This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: *.backup, *.backup-*, prisma/migrations/**, repomix-output.*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
Dockerfile.dev
next-env.d.ts
next.config.js
package.json
postcss.config.js
prisma/schema.prisma
public/firebase-messaging-sw.js
repomix.config.json
scripts/generate-thumbnails.js
server.js
src/app/(auth)/login/page.tsx
src/app/(auth)/signup/page.tsx
src/app/about/page.tsx
src/app/api/auth/[...nextauth]/route.ts
src/app/api/auth/find-email/route.ts
src/app/api/auth/find-email/send/route.ts
src/app/api/auth/register/route.ts
src/app/api/auth/reset-password/confirm/route.ts
src/app/api/auth/reset-password/route.ts
src/app/api/calls/[id]/route.ts
src/app/api/calls/route.ts
src/app/api/chat/rooms/[id]/messages/route.ts
src/app/api/chat/rooms/[id]/read/route.ts
src/app/api/chat/rooms/[id]/route.ts
src/app/api/chat/rooms/route.ts
src/app/api/comments/[id]/route.ts
src/app/api/files/[id]/download/route.ts
src/app/api/files/[id]/move/route.ts
src/app/api/files/[id]/route.ts
src/app/api/files/[id]/share/route.ts
src/app/api/files/[id]/tags/route.ts
src/app/api/files/[id]/thumbnail/route.ts
src/app/api/files/route.ts
src/app/api/files/shared/route.ts
src/app/api/files/thumbnail/[filename]/route.ts
src/app/api/files/upload/route.ts
src/app/api/folders/[id]/move/route.ts
src/app/api/folders/[id]/route.ts
src/app/api/folders/[id]/share/route.ts
src/app/api/folders/route.ts
src/app/api/posts/[id]/comments/route.ts
src/app/api/posts/[id]/route.ts
src/app/api/posts/[id]/share/route.ts
src/app/api/posts/[id]/tags/route.ts
src/app/api/posts/route.ts
src/app/api/saved-searches/[id]/route.ts
src/app/api/saved-searches/route.ts
src/app/api/search/route.ts
src/app/api/share/route.ts
src/app/api/tags/route.ts
src/app/api/users/fcm-token/route.ts
src/app/api/users/presence/route.ts
src/app/api/users/search/route.ts
src/app/chat/[id]/page.tsx
src/app/chat/page.tsx
src/app/dashboard/page.tsx
src/app/find-email/page.tsx
src/app/globals.css
src/app/layout.tsx
src/app/page.tsx
src/app/posts/[id]/page.tsx
src/app/posts/new/page.tsx
src/app/posts/page.tsx
src/app/providers.tsx
src/app/register/page.tsx
src/app/reset-password/confirm/page.tsx
src/app/reset-password/page.tsx
src/app/search/page.tsx
src/components/Breadcrumb.tsx
src/components/ConfirmDialog.tsx
src/components/FileDropZone.tsx
src/components/FileFilters.tsx
src/components/FileGridSkeleton.tsx
src/components/FilePreviewModal.tsx
src/components/FileShareModal.tsx
src/components/FolderCreateModal.tsx
src/components/LazyImage.tsx
src/components/Notificationsettings.tsx
src/components/PostShareModal.tsx
src/components/SearchBar.tsx
src/components/TagInput.tsx
src/components/Toast.tsx
src/components/UploadProgress.tsx
src/hooks/useInfiniteScroll.ts
src/hooks/useSocket.ts
src/lib/auth.ts
src/lib/db.ts
src/lib/demo-mode.ts
src/lib/email.ts
src/lib/fcm.ts
src/lib/firebase.ts
src/lib/rate-limit.ts
src/lib/sanitize.ts
src/types/next-auth.d.ts
tailwind.config.js
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="Dockerfile.dev">
FROM node:20-alpine

WORKDIR /app

COPY package*.json ./
COPY prisma ./prisma/

RUN npm install
RUN npx prisma generate

CMD ["npm", "run", "dev"]
</file>

<file path="next-env.d.ts">
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/building-your-application/configuring/typescript for more information.
</file>

<file path="postcss.config.js">
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="repomix.config.json">
{
  "output": {
    "filePath": "repomix-output.xml"
  },
  "ignore": {
    "customPatterns": [
      "*.backup",
      "*.backup-*",
      "prisma/migrations/**",
      "repomix-output.*"
    ]
  }
}
</file>

<file path="scripts/generate-thumbnails.js">
// =============================================
// ê¸°ì¡´ ì—…ë¡œë“œëœ ì´ë¯¸ì§€ íŒŒì¼ë“¤ì˜ ì¸ë„¤ì¼ ì¼ê´„ ìƒì„±
// ì‹¤í–‰: node scripts/generate-thumbnails.js
// =============================================

const { PrismaClient } = require("@prisma/client");
const sharp = require("sharp");
const { readFile, writeFile, mkdir } = require("fs/promises");
const { existsSync } = require("fs");
const { join } = require("path");

const prisma = new PrismaClient();
const STORAGE_PATH = process.env.STORAGE_PATH || "./storage";

async function generateThumbnails() {
  console.log("ğŸ“¸ ì¸ë„¤ì¼ ì¼ê´„ ìƒì„± ì‹œì‘...\n");

  const thumbnailDir = join(STORAGE_PATH, "thumbnails");
  if (!existsSync(thumbnailDir)) {
    await mkdir(thumbnailDir, { recursive: true });
    console.log("âœ… thumbnails ë””ë ‰í† ë¦¬ ìƒì„±\n");
  }

  // ì´ë¯¸ì§€ íŒŒì¼ë§Œ ì¡°íšŒ (thumbnailUrlì´ nullì¸ ê²ƒë§Œ)
  const imageFiles = await prisma.file.findMany({
    where: {
      mimeType: { startsWith: "image/" },
      thumbnailUrl: null,
    },
  });

  console.log(`ğŸ” ì²˜ë¦¬í•  ì´ë¯¸ì§€ íŒŒì¼: ${imageFiles.length}ê°œ\n`);

  let successCount = 0;
  let failCount = 0;

  for (const file of imageFiles) {
    try {
      const buffer = await readFile(file.filepath);
      const thumbnailFilename = `thumb_${file.filename.replace(/\.\w+$/, ".jpg")}`;
      const thumbnailPath = join(thumbnailDir, thumbnailFilename);

      await sharp(buffer)
        .resize(300, 300, { fit: "cover", position: "center" })
        .jpeg({ quality: 80 })
        .toFile(thumbnailPath);

      await prisma.file.update({
        where: { id: file.id },
        data: { thumbnailUrl: `/api/files/thumbnail/${thumbnailFilename}` },
      });

      console.log(`âœ… ${file.originalName} â†’ ì¸ë„¤ì¼ ìƒì„± ì™„ë£Œ`);
      successCount++;
    } catch (error) {
      console.error(`âŒ ${file.originalName} â†’ ì‹¤íŒ¨:`, error.message);
      failCount++;
    }
  }

  console.log(`\nğŸ“Š ê²°ê³¼: ì„±ê³µ ${successCount}ê°œ / ì‹¤íŒ¨ ${failCount}ê°œ`);
  await prisma.$disconnect();
}

generateThumbnails().catch((error) => {
  console.error("ì˜¤ë¥˜ ë°œìƒ:", error);
  process.exit(1);
});
</file>

<file path="src/app/about/page.tsx">
"use client";

import Link from "next/link";
import { 
  Cpu, 
  Database, 
  Layers, 
  ShieldCheck, 
  Smartphone, 
  Zap, 
  ArrowLeft,
  Server,
  Code2
} from "lucide-react";

export default function AboutPage() {
  return (
    <div className="min-h-screen bg-[#0f0c29] text-white selection:bg-purple-500/30">
      {/* ìƒë‹¨ ì¥ì‹ ë¸”ëŸ¬ */}
      <div className="fixed top-0 right-0 w-[300px] h-[300px] bg-blue-600/10 blur-[100px] -z-10" />

      <div className="max-w-4xl mx-auto px-6 py-16">
        {/* ë’¤ë¡œê°€ê¸° & í—¤ë” */}
        <Link href="/" className="inline-flex items-center gap-2 text-white/40 hover:text-white transition-colors mb-12 group">
          <ArrowLeft size={18} className="group-hover:-translate-x-1 transition-transform" />
          <span>ë©”ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°</span>
        </Link>

        <section className="mb-20">
          <h1 className="text-4xl md:text-5xl font-black mb-6 tracking-tight">
            ê¸°ìˆ ë¡œ ì‡ëŠ” <br />
            <span className="text-purple-400">ë‚˜ë§Œì˜ ë””ì§€í„¸ ìƒíƒœê³„</span>
          </h1>
          <p className="text-lg text-white/60 leading-relaxed">
            EUM(ì´ìŒ)ì€ ë‹¨ìˆœí•œ ì €ì¥ì†Œë¥¼ ë„˜ì–´, ì‚¬ìš©ìì˜ ëª¨ë“  ê¸°ê¸°ì™€ ë°ì´í„°ë¥¼ <br className="hidden md:block" />
            ê°€ì¥ ë¹ ë¥´ê³  ì•ˆì „í•œ ë°©ì‹ìœ¼ë¡œ ì—°ê²°í•˜ê¸° ìœ„í•´ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤.
          </p>
        </section>

        {/* í•µì‹¬ ê¸°ìˆ  ìŠ¤íƒ ì„¹ì…˜ */}
        <div className="grid gap-12 mb-24">
          <FeatureRow 
            icon={<Cpu size={32} />}
            title="ê³ ì„±ëŠ¥ í•˜ì´ë¸Œë¦¬ë“œ ì•„í‚¤í…ì²˜"
            desc="Next.js 14ì˜ Server Actionsì™€ API Routesë¥¼ ì ì¬ì ì†Œì— ë°°ì¹˜í•˜ì—¬, ëŒ€ìš©ëŸ‰ íŒŒì¼ ì—…ë¡œë“œ ì‹œì—ë„ ë¸Œë¼ìš°ì € ë¶€í•˜ë¥¼ ìµœì†Œí™”í•˜ê³  ì„œë²„ ìì›ì„ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬í•©ë‹ˆë‹¤."
          />
          <FeatureRow 
            icon={<ShieldCheck size={32} />}
            title="ì—”í„°í”„ë¼ì´ì¦ˆê¸‰ ë³´ì•ˆ ì‹œìŠ¤í…œ"
            desc="ì‚¬ìš©ìì˜ ë¹„ë°€ë²ˆí˜¸ëŠ” Argon2 ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ í•´ì‹±ë˜ë©°, ëª¨ë“  ë°ì´í„° ì „ì†¡ì€ SSL/TLS ì•”í˜¸í™” ë ˆì´ì–´ë¥¼ í†µê³¼í•©ë‹ˆë‹¤. ë°ì´í„°ë² ì´ìŠ¤ ìˆ˜ì¤€ì—ì„œì˜ ì ‘ê·¼ ì œì–´ë¡œ ë³´ì•ˆ ì‚¬ê³ ë¥¼ ì›ì²œ ë´‰ì‡„í•©ë‹ˆë‹¤."
          />
          <FeatureRow 
            icon={<Zap size={32} />}
            title="ì‹¤ì‹œê°„ ë°ì´í„° ë™ê¸°í™”"
            desc="Socket.ioì™€ Prismaì˜ ì‹¤ì‹œê°„ ì´ë²¤íŠ¸ë¥¼ ê²°í•©í•˜ì—¬, íŒŒì¼ ì—…ë¡œë“œë‚˜ ì±„íŒ… ë©”ì‹œì§€ ì „ì†¡ ì¦‰ì‹œ ëª¨ë“  ì—°ê²°ëœ ê¸°ê¸°ì— ìƒíƒœê°€ ë°˜ì˜ë©ë‹ˆë‹¤."
          />
        </div>

        {/* ê¸°ìˆ  ìŠ¤íƒ ê·¸ë¦¬ë“œ */}
        <div className="bg-white/5 border border-white/10 rounded-[32px] p-10">
          <h3 className="text-xl font-bold mb-8 flex items-center gap-2">
            <Code2 className="text-purple-400" />
            Built with Modern Stack
          </h3>
          <div className="grid grid-cols-2 md:grid-cols-4 gap-8">
            <StackItem icon={<Layers className="text-blue-400" />} name="Next.js 14" detail="App Router" />
            <StackItem icon={<Database className="text-emerald-400" />} name="PostgreSQL" detail="Prisma ORM" />
            <StackItem icon={<Server className="text-orange-400" />} name="Node.js" detail="Runtime" />
            <StackItem icon={<Smartphone className="text-pink-400" />} name="Firebase" detail="FCM Push" />
          </div>
        </div>

        {/* CTA */}
        <div className="mt-24 text-center">
          <p className="text-white/40 mb-6">ì¤€ë¹„ê°€ ë˜ì…¨ë‚˜ìš”?</p>
          <Link
            href="/signup"
            className="inline-flex px-10 py-4 bg-gradient-to-r from-purple-500 to-blue-600 text-white font-black rounded-2xl hover:scale-105 transition-all shadow-xl shadow-purple-500/20"
          >
            ì§€ê¸ˆ ë°”ë¡œ ê³„ì • ë§Œë“¤ê¸°
          </Link>
        </div>
      </div>
    </div>
  );
}

function FeatureRow({ icon, title, desc }: { icon: React.ReactNode, title: string, desc: string }) {
  return (
    <div className="flex flex-col md:flex-row gap-6 items-start">
      <div className="w-16 h-16 shrink-0 rounded-2xl bg-white/5 flex items-center justify-center text-purple-400 border border-white/10">
        {icon}
      </div>
      <div>
        <h3 className="text-2xl font-bold mb-3">{title}</h3>
        <p className="text-white/50 leading-relaxed">{desc}</p>
      </div>
    </div>
  );
}

function StackItem({ icon, name, detail }: { icon: React.ReactNode, name: string, detail: string }) {
  return (
    <div className="text-center md:text-left">
      <div className="mb-3 flex justify-center md:justify-start">{icon}</div>
      <p className="font-bold text-sm">{name}</p>
      <p className="text-white/30 text-xs">{detail}</p>
    </div>
  );
}
</file>

<file path="src/app/api/auth/find-email/route.ts">
// =============================================
// src/app/api/auth/find-email/route.ts
// ì´ë©”ì¼ ì°¾ê¸° API - ì´ë¦„ìœ¼ë¡œ ë§ˆìŠ¤í‚¹ëœ ì´ë©”ì¼ ë°˜í™˜
// =============================================
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";

export async function POST(request: NextRequest) {
  try {
    const { name } = await request.json();
    if (!name?.trim()) {
      return NextResponse.json({ error: "ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”" }, { status: 400 });
    }

    const user = await prisma.user.findFirst({
      where: { name: { equals: name.trim(), mode: "insensitive" } },
    });

    if (!user) {
      return NextResponse.json(
        { error: "í•´ë‹¹ ì´ë¦„ìœ¼ë¡œ ê°€ì…ëœ ê³„ì •ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ì´ë©”ì¼ ë§ˆìŠ¤í‚¹: ab***@gmail.com
    const [localPart, domain] = user.email.split("@");
    const masked =
      localPart.slice(0, 2) + "*".repeat(Math.max(3, localPart.length - 2)) + "@" + domain;

    return NextResponse.json({ maskedEmail: masked });
  } catch (error) {
    console.error("Find email error:", error);
    return NextResponse.json({ error: "ì„œë²„ ì˜¤ë¥˜" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/auth/find-email/send/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { sendEmail } from "@/lib/email";

export async function POST(request: NextRequest) {
  try {
    const { name } = await request.json();

    if (!name?.trim()) {
      return NextResponse.json({ error: "ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”" }, { status: 400 });
    }

    const user = await prisma.user.findFirst({
      where: { name: { equals: name.trim(), mode: "insensitive" } },
    });

    if (!user) {
      return NextResponse.json({ error: "ê³„ì •ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 404 });
    }

    await sendEmail({
      to: user.email,
      subject: "[ì´ìŒ] ì´ë©”ì¼ ì°¾ê¸° ì•ˆë‚´",
      html: `
        <div style="font-family: sans-serif; max-width: 480px; margin: 0 auto; padding: 40px 24px;">
          <h2 style="color: #7c3aed; margin-bottom: 8px;">ì´ìŒ (Eum)</h2>
          <p style="color: #666; margin-bottom: 24px;">ì‚¬ëŒê³¼ íŒŒì¼ì„ ì‡ë‹¤</p>
          <hr style="border: none; border-top: 1px solid #eee; margin-bottom: 24px;"/>
          <h3 style="color: #111; margin-bottom: 16px;">ì´ë©”ì¼ ì°¾ê¸°</h3>
          <p style="color: #444; margin-bottom: 8px;">ì•ˆë…•í•˜ì„¸ìš”, <strong>${user.name}</strong>ë‹˜!</p>
          <p style="color: #444; margin-bottom: 24px;">
            ìš”ì²­í•˜ì‹  ì´ìŒ ê³„ì •ì˜ ì´ë©”ì¼ ì£¼ì†Œì…ë‹ˆë‹¤:
          </p>
          <div style="background: #f5f3ff; border: 1px solid #ddd6fe; border-radius: 12px; padding: 20px; text-align: center; margin-bottom: 24px;">
            <p style="font-size: 20px; font-weight: 700; color: #7c3aed; margin: 0;">${user.email}</p>
          </div>
          <p style="color: #888; font-size: 13px;">
            ë³¸ì¸ì´ ìš”ì²­í•˜ì§€ ì•Šìœ¼ì…¨ë‹¤ë©´ ì´ ë©”ì¼ì„ ë¬´ì‹œí•´ ì£¼ì„¸ìš”.
          </p>
          <hr style="border: none; border-top: 1px solid #eee; margin: 24px 0;"/>
          <p style="color: #aaa; font-size: 12px;">Â© 2025 ì´ìŒ(Eum)</p>
        </div>
      `,
    });

    return NextResponse.json({ message: "ì´ë©”ì¼ì´ ë°œì†¡ë˜ì—ˆìŠµë‹ˆë‹¤" });
  } catch (error) {
    console.error("Send email error:", error);
    return NextResponse.json({ error: "ì´ë©”ì¼ ë°œì†¡ ì‹¤íŒ¨" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/auth/reset-password/confirm/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import bcrypt from "bcryptjs";

export async function POST(request: NextRequest) {
  try {
    const { token, password } = await request.json();

    if (!token || !password) {
      return NextResponse.json({ error: "ìœ íš¨í•˜ì§€ ì•Šì€ ìš”ì²­ì…ë‹ˆë‹¤" }, { status: 400 });
    }

    if (password.length < 8 || !/(?=.*[a-zA-Z])(?=.*\d)/.test(password)) {
      return NextResponse.json(
        { error: "ë¹„ë°€ë²ˆí˜¸ëŠ” 8ì ì´ìƒ, ì˜ë¬¸+ìˆ«ì ì¡°í•©ì´ì–´ì•¼ í•©ë‹ˆë‹¤" },
        { status: 400 }
      );
    }

    // Prisma ORMìœ¼ë¡œ í† í° ì¡°íšŒ
    const tokenRecord = await prisma.passwordResetToken.findUnique({
      where: { token },
    });

    if (!tokenRecord || tokenRecord.expiresAt < new Date()) {
      return NextResponse.json(
        { error: "ë§í¬ê°€ ë§Œë£Œëê±°ë‚˜ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë‹¤ì‹œ ìš”ì²­í•´ì£¼ì„¸ìš”." },
        { status: 400 }
      );
    }

    const hashedPassword = await bcrypt.hash(password, 12);

    // ë¹„ë°€ë²ˆí˜¸ ì—…ë°ì´íŠ¸
    await prisma.user.update({
      where: { id: tokenRecord.userId },
      data: { passwordHash: hashedPassword },
    });

    // í† í° ì‚­ì œ
    await prisma.passwordResetToken.delete({
      where: { token },
    });

    return NextResponse.json({ message: "ë¹„ë°€ë²ˆí˜¸ê°€ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤" });
  } catch (error) {
    console.error("Confirm reset error:", error);
    return NextResponse.json({ error: "ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/auth/reset-password/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { sendEmail } from "@/lib/email";
import crypto from "crypto";

export async function POST(request: NextRequest) {
  try {
    const { email } = await request.json();

    if (!email?.trim()) {
      return NextResponse.json({ error: "ì´ë©”ì¼ì„ ì…ë ¥í•˜ì„¸ìš”" }, { status: 400 });
    }

    const user = await prisma.user.findUnique({
      where: { email: email.trim().toLowerCase() },
    });

    // ë³´ì•ˆ: ì‚¬ìš©ì ì¡´ì¬ ì—¬ë¶€ ë…¸ì¶œ ì•ˆ í•¨
    if (!user) {
      return NextResponse.json({ message: "ì´ë©”ì¼ì´ ë°œì†¡ë˜ì—ˆìŠµë‹ˆë‹¤" });
    }

    // í† í° ìƒì„± (15ë¶„ ìœ íš¨)
    const token = crypto.randomBytes(32).toString("hex");
    const expiresAt = new Date(Date.now() + 15 * 60 * 1000);

    // Prisma ORMìœ¼ë¡œ í† í° ì €ì¥ (upsert)
    await prisma.passwordResetToken.upsert({
      where: { userId: user.id },
      update: { token, expiresAt },
      create: { userId: user.id, token, expiresAt },
    });

    const resetUrl = `${process.env.NEXTAUTH_URL}/reset-password/confirm?token=${token}`;

    await sendEmail({
      to: user.email,
      subject: "[ì´ìŒ] ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì • ì•ˆë‚´",
      html: `
        <div style="font-family: sans-serif; max-width: 480px; margin: 0 auto; padding: 40px 24px;">
          <h2 style="color: #7c3aed; margin-bottom: 8px;">ì´ìŒ (Eum)</h2>
          <p style="color: #666; margin-bottom: 24px;">ì‚¬ëŒê³¼ íŒŒì¼ì„ ì‡ë‹¤</p>
          <hr style="border: none; border-top: 1px solid #eee; margin-bottom: 24px;"/>
          <h3 style="color: #111; margin-bottom: 16px;">ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì •</h3>
          <p style="color: #444; margin-bottom: 8px;">ì•ˆë…•í•˜ì„¸ìš”, <strong>${user.name}</strong>ë‹˜!</p>
          <p style="color: #444; margin-bottom: 24px;">
            ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì •ì„ ìš”ì²­í•˜ì…¨ìŠµë‹ˆë‹¤.<br/>
            ì•„ë˜ ë²„íŠ¼ì„ í´ë¦­í•´ ìƒˆ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì„¤ì •í•´ì£¼ì„¸ìš”.
          </p>
          <div style="text-align: center; margin-bottom: 24px;">
            <a href="${resetUrl}"
              style="display: inline-block; background: linear-gradient(135deg, #7c3aed, #2563eb); color: white; padding: 14px 32px; border-radius: 12px; text-decoration: none; font-weight: 700; font-size: 16px;">
              ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì •í•˜ê¸°
            </a>
          </div>
          <div style="background: #fef3c7; border: 1px solid #fbbf24; border-radius: 8px; padding: 12px 16px; margin-bottom: 20px;">
            <p style="color: #92400e; font-size: 13px; margin: 0;">
              â° ì´ ë§í¬ëŠ” <strong>15ë¶„</strong> í›„ ë§Œë£Œë©ë‹ˆë‹¤.
            </p>
          </div>
          <p style="color: #888; font-size: 13px;">
            ë³¸ì¸ì´ ìš”ì²­í•˜ì§€ ì•Šìœ¼ì…¨ë‹¤ë©´ ì´ ë©”ì¼ì„ ë¬´ì‹œí•´ ì£¼ì„¸ìš”.<br/>
            ë¹„ë°€ë²ˆí˜¸ëŠ” ë³€ê²½ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
          </p>
          <hr style="border: none; border-top: 1px solid #eee; margin: 24px 0;"/>
          <p style="color: #aaa; font-size: 12px;">Â© 2025 ì´ìŒ(Eum)</p>
        </div>
      `,
    });

    return NextResponse.json({ message: "ì´ë©”ì¼ì´ ë°œì†¡ë˜ì—ˆìŠµë‹ˆë‹¤" });
  } catch (error) {
    console.error("Reset password error:", error);
    return NextResponse.json({ error: "ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/calls/[id]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// í†µí™” ìƒíƒœ ì—…ë°ì´íŠ¸ (ìˆ˜ë½/ê±°ì ˆ/ì¢…ë£Œ)
export async function PATCH(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const callId = params.id;
    const body = await request.json();
    const { action } = body; // "accept", "reject", "end"

    // í†µí™” ì¡°íšŒ
    const call = await prisma.call.findUnique({
      where: { id: callId },
      include: {
        chatRoom: true,
      },
    });

    if (!call) {
      return NextResponse.json(
        { error: "í†µí™”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ê¶Œí•œ í™•ì¸ (ë°œì‹ ì ë˜ëŠ” ìˆ˜ì‹ ìë§Œ)
    if (call.initiatorId !== session.user.id && call.receiverId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    let updatedCall;
    let systemMessage = "";

    switch (action) {
      case "accept":
        // ìˆ˜ì‹ ìë§Œ ìˆ˜ë½ ê°€ëŠ¥
        if (call.receiverId !== session.user.id) {
          return NextResponse.json(
            { error: "ìˆ˜ì‹ ìë§Œ í†µí™”ë¥¼ ìˆ˜ë½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤" },
            { status: 403 }
          );
        }

        updatedCall = await prisma.call.update({
          where: { id: callId },
          data: {
            status: "ACCEPTED",
            startedAt: new Date(),
          },
        });
        systemMessage = "í†µí™”ê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.";
        break;

      case "reject":
        // ìˆ˜ì‹ ìë§Œ ê±°ì ˆ ê°€ëŠ¥
        if (call.receiverId !== session.user.id) {
          return NextResponse.json(
            { error: "ìˆ˜ì‹ ìë§Œ í†µí™”ë¥¼ ê±°ì ˆí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤" },
            { status: 403 }
          );
        }

        updatedCall = await prisma.call.update({
          where: { id: callId },
          data: {
            status: "REJECTED",
            endedAt: new Date(),
          },
        });
        systemMessage = "í†µí™”ê°€ ê±°ì ˆë˜ì—ˆìŠµë‹ˆë‹¤.";
        break;

      case "end":
        // ë°œì‹ ì ë˜ëŠ” ìˆ˜ì‹ ì ë‘˜ ë‹¤ ì¢…ë£Œ ê°€ëŠ¥
        const endedAt = new Date();
        const duration = call.startedAt
          ? Math.floor((endedAt.getTime() - call.startedAt.getTime()) / 1000)
          : 0;

        updatedCall = await prisma.call.update({
          where: { id: callId },
          data: {
            status: "ENDED",
            endedAt,
            duration,
          },
        });

        if (duration > 0) {
          const minutes = Math.floor(duration / 60);
          const seconds = duration % 60;
          systemMessage = `í†µí™”ê°€ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. (${minutes}ë¶„ ${seconds}ì´ˆ)`;
        } else {
          systemMessage = "í†µí™”ê°€ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.";
        }
        break;

      default:
        return NextResponse.json(
          { error: "ì˜ëª»ëœ ì•¡ì…˜ì…ë‹ˆë‹¤" },
          { status: 400 }
        );
    }

    // ì‹œìŠ¤í…œ ë©”ì‹œì§€ ìƒì„±
    if (systemMessage) {
      await prisma.chatMessage.create({
        data: {
          chatRoomId: call.chatRoomId,
          senderId: session.user.id,
          type: "CALL_LOG",
          callId: call.id,
          content: systemMessage,
        },
      });
    }

    return NextResponse.json({
      message: systemMessage,
      call: updatedCall,
    });
  } catch (error) {
    console.error("Call update error:", error);
    return NextResponse.json(
      { error: "í†µí™” ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// í†µí™” ìƒì„¸ ì¡°íšŒ
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const callId = params.id;

    const call = await prisma.call.findUnique({
      where: { id: callId },
      include: {
        initiator: {
          select: {
            id: true,
            name: true,
            isOnline: true,
          },
        },
        receiver: {
          select: {
            id: true,
            name: true,
            isOnline: true,
          },
        },
        chatRoom: true,
      },
    });

    if (!call) {
      return NextResponse.json(
        { error: "í†µí™”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ê¶Œí•œ í™•ì¸
    if (call.initiatorId !== session.user.id && call.receiverId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    return NextResponse.json({ call });
  } catch (error) {
    console.error("Call fetch error:", error);
    return NextResponse.json(
      { error: "í†µí™” ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/chat/rooms/[id]/read/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// ë©”ì‹œì§€ ì½ìŒ ì²˜ë¦¬
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const chatRoomId = params.id;

    // ë©¤ë²„ì‹­ ì¡°íšŒ
    const membership = await prisma.chatRoomMember.findFirst({
      where: {
        chatRoomId,
        userId: session.user.id,
      },
    });

    if (!membership) {
      return NextResponse.json(
        { error: "ì±„íŒ…ë°©ì— ì°¸ì—¬í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // lastReadAt ì—…ë°ì´íŠ¸
    await prisma.chatRoomMember.update({
      where: {
        id: membership.id,
      },
      data: {
        lastReadAt: new Date(),
      },
    });

    return NextResponse.json({
      message: "ì½ìŒ ì²˜ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤",
    });
  } catch (error) {
    console.error("Read message error:", error);
    return NextResponse.json(
      { error: "ì½ìŒ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/chat/rooms/[id]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// ì±„íŒ…ë°© ìƒì„¸ ì¡°íšŒ
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const chatRoomId = params.id;

    // ì±„íŒ…ë°© ì¡°íšŒ
    const chatRoom = await prisma.chatRoom.findUnique({
      where: { id: chatRoomId },
      include: {
        members: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
                isOnline: true,
                lastSeenAt: true,
              },
            },
          },
        },
      },
    });

    if (!chatRoom) {
      return NextResponse.json(
        { error: "ì±„íŒ…ë°©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ì°¸ì—¬ì í™•ì¸
    const isMember = chatRoom.members.some(
      (member) => member.userId === session.user.id
    );

    if (!isMember) {
      return NextResponse.json(
        { error: "ì±„íŒ…ë°©ì— ì°¸ì—¬í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    return NextResponse.json({ chatRoom });
  } catch (error) {
    console.error("Chat room fetch error:", error);
    return NextResponse.json(
      { error: "ì±„íŒ…ë°© ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// ì±„íŒ…ë°© ë‚˜ê°€ê¸°
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const chatRoomId = params.id;

    // ë©¤ë²„ì‹­ í™•ì¸
    const membership = await prisma.chatRoomMember.findFirst({
      where: {
        chatRoomId,
        userId: session.user.id,
      },
    });

    if (!membership) {
      return NextResponse.json(
        { error: "ì±„íŒ…ë°©ì— ì°¸ì—¬í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // ë©¤ë²„ ì œê±°
    await prisma.chatRoomMember.delete({
      where: {
        id: membership.id,
      },
    });

    // ì‹œìŠ¤í…œ ë©”ì‹œì§€ ìƒì„±
    await prisma.chatMessage.create({
      data: {
        chatRoomId,
        senderId: session.user.id,
        type: "SYSTEM",
        content: `${session.user.name}ë‹˜ì´ ì±„íŒ…ë°©ì„ ë‚˜ê°”ìŠµë‹ˆë‹¤.`,
      },
    });

    // ë‚¨ì€ ë©¤ë²„ í™•ì¸
    const remainingMembers = await prisma.chatRoomMember.count({
      where: { chatRoomId },
    });

    // ë©¤ë²„ê°€ ì—†ìœ¼ë©´ ì±„íŒ…ë°© ì‚­ì œ
    if (remainingMembers === 0) {
      await prisma.chatRoom.delete({
        where: { id: chatRoomId },
      });
    }

    return NextResponse.json({
      message: "ì±„íŒ…ë°©ì„ ë‚˜ê°”ìŠµë‹ˆë‹¤",
    });
  } catch (error) {
    console.error("Chat room leave error:", error);
    return NextResponse.json(
      { error: "ì±„íŒ…ë°© ë‚˜ê°€ê¸° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/chat/rooms/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// ì±„íŒ…ë°© ëª©ë¡ ì¡°íšŒ
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    // ë‚´ê°€ ì°¸ì—¬í•œ ì±„íŒ…ë°© ëª©ë¡
    const chatRoomMembers = await prisma.chatRoomMember.findMany({
      where: {
        userId: session.user.id,
      },
      include: {
        chatRoom: {
          include: {
            members: {
              include: {
                user: {
                  select: {
                    id: true,
                    name: true,
                    email: true,
                    isOnline: true,
                    lastSeenAt: true,
                  },
                },
              },
            },
            messages: {
              orderBy: { createdAt: "desc" },
              take: 1, // ë§ˆì§€ë§‰ ë©”ì‹œì§€ë§Œ
              include: {
                sender: {
                  select: {
                    id: true,
                    name: true,
                  },
                },
              },
            },
            _count: {
              select: {
                messages: true,
              },
            },
          },
        },
      },
      orderBy: {
        chatRoom: {
          updatedAt: "desc",
        },
      },
    });

    // ì½ì§€ ì•Šì€ ë©”ì‹œì§€ ê°œìˆ˜ ê³„ì‚°
    const chatRooms = await Promise.all(
      chatRoomMembers.map(async (member) => {
        const unreadCount = await prisma.chatMessage.count({
          where: {
            chatRoomId: member.chatRoomId,
            createdAt: {
              gt: member.lastReadAt || new Date(0),
            },
            senderId: {
              not: session.user.id, // ë³¸ì¸ ë©”ì‹œì§€ ì œì™¸
            },
          },
        });

        return {
          ...member.chatRoom,
          unreadCount,
          myMembership: {
            lastReadAt: member.lastReadAt,
          },
        };
      })
    );

    return NextResponse.json({ chatRooms });
  } catch (error) {
    console.error("Chat rooms fetch error:", error);
    return NextResponse.json(
      { error: "ì±„íŒ…ë°© ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// ì±„íŒ…ë°© ìƒì„±
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { type, memberIds, name } = body;

    // ìœ íš¨ì„± ê²€ì‚¬
    if (!type || !memberIds || !Array.isArray(memberIds)) {
      return NextResponse.json(
        { error: "ì˜ëª»ëœ ìš”ì²­ì…ë‹ˆë‹¤" },
        { status: 400 }
      );
    }

    // 1:1 ì±„íŒ…ì¸ ê²½ìš° ê¸°ì¡´ ì±„íŒ…ë°© í™•ì¸
    if (type === "DIRECT") {
      if (memberIds.length !== 1) {
        return NextResponse.json(
          { error: "1:1 ì±„íŒ…ì€ ìƒëŒ€ë°© 1ëª…ë§Œ ì§€ì •í•´ì•¼ í•©ë‹ˆë‹¤" },
          { status: 400 }
        );
      }

      const otherUserId = memberIds[0];

      // ì´ë¯¸ ì¡´ì¬í•˜ëŠ” 1:1 ì±„íŒ…ë°© ì°¾ê¸°
      const existingChatRoom = await prisma.chatRoom.findFirst({
        where: {
          type: "DIRECT",
          members: {
            every: {
              userId: {
                in: [session.user.id, otherUserId],
              },
            },
          },
        },
        include: {
          members: {
            include: {
              user: {
                select: {
                  id: true,
                  name: true,
                  email: true,
                  isOnline: true,
                },
              },
            },
          },
        },
      });

      if (existingChatRoom) {
        return NextResponse.json({
          message: "ê¸°ì¡´ ì±„íŒ…ë°©ì„ ë°˜í™˜í•©ë‹ˆë‹¤",
          chatRoom: existingChatRoom,
        });
      }
    }

    // ê·¸ë£¹ ì±„íŒ…ì¸ ê²½ìš° ì´ë¦„ í•„ìˆ˜
    if (type === "GROUP" && !name) {
      return NextResponse.json(
        { error: "ê·¸ë£¹ ì±„íŒ…ë°© ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”" },
        { status: 400 }
      );
    }

    // ì±„íŒ…ë°© ìƒì„±
    const chatRoom = await prisma.chatRoom.create({
      data: {
        type,
        name: type === "GROUP" ? name : null,
        members: {
          create: [
            // ë³¸ì¸ ì¶”ê°€
            {
              userId: session.user.id,
            },
            // ë‹¤ë¥¸ ë©¤ë²„ë“¤ ì¶”ê°€
            ...memberIds.map((userId: string) => ({
              userId,
            })),
          ],
        },
      },
      include: {
        members: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
                isOnline: true,
                lastSeenAt: true,
              },
            },
          },
        },
      },
    });

    // ì‹œìŠ¤í…œ ë©”ì‹œì§€ ìƒì„± (ê·¸ë£¹ ì±„íŒ…)
    if (type === "GROUP") {
      await prisma.chatMessage.create({
        data: {
          chatRoomId: chatRoom.id,
          senderId: session.user.id,
          type: "SYSTEM",
          content: `${session.user.name}ë‹˜ì´ ì±„íŒ…ë°©ì„ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤.`,
        },
      });
    }

    return NextResponse.json(
      {
        message: "ì±„íŒ…ë°©ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤",
        chatRoom,
      },
      { status: 201 }
    );
  } catch (error) {
    console.error("Chat room create error:", error);
    return NextResponse.json(
      { error: "ì±„íŒ…ë°© ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/comments/[id]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// ëŒ“ê¸€ ì‚­ì œ
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const commentId = params.id;

    const comment = await prisma.comment.findUnique({
      where: { id: commentId },
    });

    if (!comment) {
      return NextResponse.json(
        { error: "ëŒ“ê¸€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    if (comment.userId !== session.user.id) {
      return NextResponse.json(
        { error: "ì‚­ì œ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    await prisma.comment.delete({
      where: { id: commentId },
    });

    return NextResponse.json({
      message: "ëŒ“ê¸€ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤",
    });

  } catch (error) {
    console.error("Comment delete error:", error);
    return NextResponse.json(
      { error: "ëŒ“ê¸€ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/files/[id]/download/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import { createReadStream } from "fs";
import { stat } from "fs/promises";

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const fileId = params.id;

    // íŒŒì¼ ì¡°íšŒ
    const file = await prisma.file.findUnique({
      where: { id: fileId },
    });

    if (!file) {
      return NextResponse.json(
        { error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ê¶Œí•œ í™•ì¸ (ì†Œìœ ì ë˜ëŠ” ê³µìœ ë°›ì€ ì‚¬ìš©ì)
    const isOwner = file.userId === session.user.id;
    
    if (!isOwner) {
      const sharedResource = await prisma.sharedResource.findFirst({
        where: {
          resourceType: "FILE",
          resourceId: fileId,
          sharedWithId: session.user.id,
        },
      });

      if (!sharedResource) {
        return NextResponse.json(
          { error: "íŒŒì¼ì— ì ‘ê·¼í•  ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
          { status: 403 }
        );
      }
    }

    // íŒŒì¼ ì¡´ì¬ í™•ì¸
    try {
      await stat(file.filepath);
    } catch (error) {
      return NextResponse.json(
        { error: "íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // íŒŒì¼ ìŠ¤íŠ¸ë¦¼ ì½ê¸°
    const fileStream = createReadStream(file.filepath);
    const chunks: Buffer[] = [];

    for await (const chunk of fileStream) {
      chunks.push(Buffer.from(chunk));
    }

    const buffer = Buffer.concat(chunks);

    // íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì‘ë‹µ
    return new NextResponse(buffer, {
      status: 200,
      headers: {
        "Content-Type": file.mimeType,
        "Content-Disposition": `attachment; filename="${encodeURIComponent(file.originalName)}"`,
        "Content-Length": buffer.length.toString(),
      },
    });
  } catch (error) {
    console.error("File download error:", error);
    return NextResponse.json(
      { error: "íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/files/[id]/move/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// íŒŒì¼ ì´ë™
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const fileId = params.id;
    const body = await request.json();
    const { folderId } = body; // nullì´ë©´ ë£¨íŠ¸ë¡œ ì´ë™

    // íŒŒì¼ í™•ì¸
    const file = await prisma.file.findUnique({
      where: { id: fileId },
    });

    if (!file) {
      return NextResponse.json(
        { error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    if (file.userId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // ëŒ€ìƒ í´ë” í™•ì¸ (ìˆëŠ” ê²½ìš°)
    if (folderId) {
      const targetFolder = await prisma.folder.findUnique({
        where: { id: folderId },
      });

      if (!targetFolder) {
        return NextResponse.json(
          { error: "ëŒ€ìƒ í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
          { status: 404 }
        );
      }

      if (targetFolder.userId !== session.user.id) {
        return NextResponse.json(
          { error: "ëŒ€ìƒ í´ë”ì— ëŒ€í•œ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
          { status: 403 }
        );
      }
    }

    // íŒŒì¼ ì´ë™
    const updatedFile = await prisma.file.update({
      where: { id: fileId },
      data: {
        folderId: folderId || null,
      },
    });

    return NextResponse.json({
      message: "íŒŒì¼ì´ ì´ë™ë˜ì—ˆìŠµë‹ˆë‹¤",
      file: {
        ...updatedFile,
        size: updatedFile.size.toString(),
      },
    });

  } catch (error) {
    console.error("File move error:", error);
    return NextResponse.json(
      { error: "íŒŒì¼ ì´ë™ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/files/[id]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import { unlink } from "fs/promises";
import { existsSync } from "fs";

export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const fileId = params.id;

    // íŒŒì¼ ì •ë³´ ì¡°íšŒ
    const file = await prisma.file.findUnique({
      where: { id: fileId },
    });

    if (!file) {
      return NextResponse.json(
        { error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ê¶Œí•œ í™•ì¸
    if (file.userId !== session.user.id) {
      return NextResponse.json(
        { error: "íŒŒì¼ ì‚­ì œ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // ì‹¤ì œ íŒŒì¼ ì‚­ì œ
    if (existsSync(file.filepath)) {
      await unlink(file.filepath);
    }

    // ì¸ë„¤ì¼ ì‚­ì œ (ìˆëŠ” ê²½ìš°)
    if (file.thumbnailUrl && existsSync(file.thumbnailUrl)) {
      await unlink(file.thumbnailUrl);
    }

    // DBì—ì„œ ì‚­ì œ (Cascadeë¡œ SharedResourceë„ ìë™ ì‚­ì œ)
    await prisma.file.delete({
      where: { id: fileId },
    });

    return NextResponse.json({
      message: "íŒŒì¼ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤",
    });

  } catch (error) {
    console.error("File delete error:", error);
    return NextResponse.json(
      { error: "íŒŒì¼ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/files/[id]/share/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// íŒŒì¼ ê³µìœ  ìƒì„±
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const fileId = params.id;
    const body = await request.json();
    const { sharedWithEmail, permission = "VIEW" } = body;

    if (!sharedWithEmail) {
      return NextResponse.json(
        { error: "ê³µìœ í•  ì‚¬ìš©ì ì´ë©”ì¼ì„ ì…ë ¥í•˜ì„¸ìš”" },
        { status: 400 }
      );
    }

    // íŒŒì¼ í™•ì¸
    const file = await prisma.file.findUnique({
      where: { id: fileId },
    });

    if (!file) {
      return NextResponse.json(
        { error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ì†Œìœ ì í™•ì¸
    if (file.userId !== session.user.id) {
      return NextResponse.json(
        { error: "íŒŒì¼ ì†Œìœ ìë§Œ ê³µìœ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // ê³µìœ  ëŒ€ìƒ ì‚¬ìš©ì í™•ì¸
    const sharedWithUser = await prisma.user.findUnique({
      where: { email: sharedWithEmail },
    });

    if (!sharedWithUser) {
      return NextResponse.json(
        { error: "í•´ë‹¹ ì´ë©”ì¼ì˜ ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ë³¸ì¸ì—ê²Œ ê³µìœ  ë°©ì§€
    if (sharedWithUser.id === session.user.id) {
      return NextResponse.json(
        { error: "ë³¸ì¸ì—ê²ŒëŠ” ê³µìœ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 400 }
      );
    }

    // ì´ë¯¸ ê³µìœ ëœ ê²½ìš° í™•ì¸
    const existingShare = await prisma.sharedResource.findFirst({
      where: {
        resourceType: "FILE",
        resourceId: fileId,
        sharedWithId: sharedWithUser.id,
      },
    });

    if (existingShare) {
      return NextResponse.json(
        { error: "ì´ë¯¸ ê³µìœ ëœ íŒŒì¼ì…ë‹ˆë‹¤" },
        { status: 409 }
      );
    }

    // ê³µìœ  ìƒì„±
    const share = await prisma.sharedResource.create({
      data: {
        resourceType: "FILE",
        resourceId: fileId,
        ownerId: session.user.id,
        sharedWithId: sharedWithUser.id,
        permission,
      },
      include: {
        sharedWith: {
          select: {
            id: true,
            email: true,
            name: true,
          },
        },
      },
    });

    return NextResponse.json(
      {
        message: "íŒŒì¼ì´ ê³µìœ ë˜ì—ˆìŠµë‹ˆë‹¤",
        share,
      },
      { status: 201 }
    );

  } catch (error) {
    console.error("File share error:", error);
    return NextResponse.json(
      { error: "íŒŒì¼ ê³µìœ  ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// íŒŒì¼ ê³µìœ  ëª©ë¡ ì¡°íšŒ
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const fileId = params.id;

    // íŒŒì¼ í™•ì¸ ë° ê¶Œí•œ ì²´í¬
    const file = await prisma.file.findUnique({
      where: { id: fileId },
    });

    if (!file) {
      return NextResponse.json(
        { error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    if (file.userId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // ê³µìœ  ëª©ë¡ ì¡°íšŒ
    const shares = await prisma.sharedResource.findMany({
      where: {
        resourceType: "FILE",
        resourceId: fileId,
      },
      include: {
        sharedWith: {
          select: {
            id: true,
            email: true,
            name: true,
          },
        },
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    return NextResponse.json({ shares });

  } catch (error) {
    console.error("Share list error:", error);
    return NextResponse.json(
      { error: "ê³µìœ  ëª©ë¡ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// ê³µìœ  ì‚­ì œ
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const shareId = searchParams.get("shareId");

    if (!shareId) {
      return NextResponse.json(
        { error: "ê³µìœ  IDê°€ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 400 }
      );
    }

    // ê³µìœ  í™•ì¸
    const share = await prisma.sharedResource.findUnique({
      where: { id: shareId },
    });

    if (!share) {
      return NextResponse.json(
        { error: "ê³µìœ  ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ì†Œìœ ì í™•ì¸
    if (share.ownerId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // ê³µìœ  ì‚­ì œ
    await prisma.sharedResource.delete({
      where: { id: shareId },
    });

    return NextResponse.json({
      message: "ê³µìœ ê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤",
    });

  } catch (error) {
    console.error("Share delete error:", error);
    return NextResponse.json(
      { error: "ê³µìœ  ì·¨ì†Œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/files/[id]/tags/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// íŒŒì¼ íƒœê·¸ ëª©ë¡ ì¡°íšŒ
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const file = await prisma.file.findUnique({
      where: { id: params.id },
      include: {
        fileTags: { include: { tag: true } },
      },
    });

    if (!file) {
      return NextResponse.json(
        { error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    return NextResponse.json({ tags: file.fileTags.map((ft) => ft.tag) });
  } catch (error) {
    console.error("Tag GET error:", error);
    return NextResponse.json(
      { error: "íƒœê·¸ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// íŒŒì¼ íƒœê·¸ ì¶”ê°€
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const body = await request.json();
    const { tagName } = body;

    if (!tagName || !tagName.trim()) {
      return NextResponse.json(
        { error: "íƒœê·¸ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”" },
        { status: 400 }
      );
    }

    // íŒŒì¼ í™•ì¸
    const file = await prisma.file.findUnique({ where: { id: params.id } });
    if (!file) {
      return NextResponse.json(
        { error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ì†Œìœ ì í™•ì¸
    if (file.userId !== session.user.id) {
      return NextResponse.json(
        { error: "íƒœê·¸ë¥¼ ì¶”ê°€í•  ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    const normalizedName = tagName.trim().toLowerCase();

    // íƒœê·¸ upsert (ì—†ìœ¼ë©´ ìƒì„±, ìˆìœ¼ë©´ ê¸°ì¡´ ì‚¬ìš©)
    const tag = await prisma.tag.upsert({
      where: { name: normalizedName },
      update: {},
      create: { name: normalizedName },
    });

    // ì´ë¯¸ ì—°ê²°ëëŠ”ì§€ í™•ì¸
    const existing = await prisma.fileTag.findUnique({
      where: {
        fileId_tagId: { fileId: params.id, tagId: tag.id },
      },
    });

    if (existing) {
      return NextResponse.json(
        { error: "ì´ë¯¸ ì¶”ê°€ëœ íƒœê·¸ì…ë‹ˆë‹¤" },
        { status: 400 }
      );
    }

    // íŒŒì¼-íƒœê·¸ ì—°ê²°
    await prisma.fileTag.create({
      data: { fileId: params.id, tagId: tag.id },
    });

    // íƒœê·¸ê°€ ì¶”ê°€ëœ íŒŒì¼ ì „ì²´ ë°˜í™˜ (í”„ë¡ íŠ¸ì—ì„œ ì¦‰ì‹œ ë°˜ì˜)
    const updatedFile = await prisma.file.findUnique({
      where: { id: params.id },
      include: {
        fileTags: { include: { tag: true } },
      },
    });

    // BigIntë¥¼ Stringìœ¼ë¡œ ë³€í™˜
    const serializedFile = updatedFile ? {
      ...updatedFile,
      size: updatedFile.size.toString(),
    } : null;

    return NextResponse.json(
      { message: "íƒœê·¸ê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤", tag, file: serializedFile },
      { status: 201 }
    );
  } catch (error) {
    console.error("Tag POST error:", error);
    return NextResponse.json(
      { error: "íƒœê·¸ ì¶”ê°€ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// íŒŒì¼ íƒœê·¸ ì‚­ì œ
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const body = await request.json();
    const { tagId } = body;

    if (!tagId) {
      return NextResponse.json(
        { error: "tagIdë¥¼ ì œê³µí•˜ì„¸ìš”" },
        { status: 400 }
      );
    }

    // íŒŒì¼ í™•ì¸ + ì†Œìœ ì í™•ì¸
    const file = await prisma.file.findUnique({ where: { id: params.id } });
    if (!file) {
      return NextResponse.json(
        { error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }
    if (file.userId !== session.user.id) {
      return NextResponse.json(
        { error: "íƒœê·¸ë¥¼ ì‚­ì œí•  ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // íŒŒì¼-íƒœê·¸ ì—°ê²° ì‚­ì œ
    await prisma.fileTag.delete({
      where: {
        fileId_tagId: { fileId: params.id, tagId },
      },
    });

    // ì—…ë°ì´íŠ¸ëœ íŒŒì¼ ë°˜í™˜
    const updatedFile = await prisma.file.findUnique({
      where: { id: params.id },
      include: {
        fileTags: { include: { tag: true } },
      },
    });

    // BigIntë¥¼ Stringìœ¼ë¡œ ë³€í™˜
    const serializedFile = updatedFile ? {
      ...updatedFile,
      size: updatedFile.size.toString(),
    } : null;

    return NextResponse.json({
      message: "íƒœê·¸ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤",
      file: serializedFile,
    });
  } catch (error) {
    console.error("Tag DELETE error:", error);
    return NextResponse.json(
      { error: "íƒœê·¸ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/files/[id]/thumbnail/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import sharp from "sharp";
import { existsSync } from "fs";
import { writeFile, mkdir } from "fs/promises";
import { join } from "path";

const STORAGE_PATH = process.env.STORAGE_PATH || "./storage";

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const fileId = params.id;

    // íŒŒì¼ ì •ë³´ ì¡°íšŒ
    const file = await prisma.file.findUnique({
      where: { id: fileId },
    });

    if (!file) {
      return NextResponse.json(
        { error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ê¶Œí•œ í™•ì¸
    const isOwner = file.userId === session.user.id;

    // ê³µìœ  í™•ì¸
    let isShared = false;
    if (!isOwner) {
      const shareCheck = await prisma.sharedResource.findFirst({
        where: {
          resourceType: "FILE",
          resourceId: fileId,
          sharedWithId: session.user.id,
        },
      });
      isShared = !!shareCheck;
    }

    const canView = isOwner || isShared;

    if (!canView) {
      return NextResponse.json(
        { error: "ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // ì´ë¯¸ì§€ íŒŒì¼ë§Œ ì¸ë„¤ì¼ ìƒì„±
    if (!file.mimeType.startsWith("image/")) {
      return NextResponse.json(
        { error: "ì´ë¯¸ì§€ íŒŒì¼ë§Œ ì¸ë„¤ì¼ì„ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤" },
        { status: 400 }
      );
    }

    const thumbnailDir = join(STORAGE_PATH, "thumbnails");
    const thumbnailPath = join(thumbnailDir, `${fileId}.jpg`);

    // ì¸ë„¤ì¼ì´ ì´ë¯¸ ì¡´ì¬í•˜ë©´ ë°˜í™˜
    if (existsSync(thumbnailPath)) {
      const thumbnailBuffer = await sharp(thumbnailPath).toBuffer();
      return new NextResponse(thumbnailBuffer, {
        headers: {
          "Content-Type": "image/jpeg",
          "Cache-Control": "public, max-age=31536000",
        },
      });
    }

    // ì›ë³¸ íŒŒì¼ ì¡´ì¬ í™•ì¸
    if (!existsSync(file.filepath)) {
      return NextResponse.json(
        { error: "ì›ë³¸ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ì¸ë„¤ì¼ ë””ë ‰í† ë¦¬ ìƒì„±
    if (!existsSync(thumbnailDir)) {
      await mkdir(thumbnailDir, { recursive: true });
    }

    // ì¸ë„¤ì¼ ìƒì„±
    const thumbnailBuffer = await sharp(file.filepath)
      .resize(300, 300, {
        fit: "cover",
        position: "center",
      })
      .jpeg({ quality: 80 })
      .toBuffer();

    // ì¸ë„¤ì¼ ì €ì¥
    await writeFile(thumbnailPath, thumbnailBuffer);

    // DB ì—…ë°ì´íŠ¸
    await prisma.file.update({
      where: { id: fileId },
      data: {
        thumbnailUrl: `/api/files/${fileId}/thumbnail`,
      },
    });

    return new NextResponse(thumbnailBuffer, {
      headers: {
        "Content-Type": "image/jpeg",
        "Cache-Control": "public, max-age=31536000",
      },
    });

  } catch (error) {
    console.error("Thumbnail generation error:", error);
    return NextResponse.json(
      { error: "ì¸ë„¤ì¼ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/files/thumbnail/[filename]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { readFile } from "fs/promises";
import { join } from "path";
import { existsSync } from "fs";

const STORAGE_PATH = process.env.STORAGE_PATH || "./storage";

export async function GET(
  request: NextRequest,
  { params }: { params: { filename: string } }
) {
  try {
    const thumbnailPath = join(STORAGE_PATH, "thumbnails", params.filename);

    if (!existsSync(thumbnailPath)) {
      return NextResponse.json(
        { error: "ì¸ë„¤ì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    const fileBuffer = await readFile(thumbnailPath);

    return new NextResponse(fileBuffer, {
      headers: {
        "Content-Type": "image/jpeg",
        "Cache-Control": "public, max-age=31536000, immutable",
      },
    });
  } catch (error) {
    console.error("Thumbnail serve error:", error);
    return NextResponse.json(
      { error: "ì¸ë„¤ì¼ ë¡œë”© ì‹¤íŒ¨" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/folders/[id]/move/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// í´ë” ì´ë™
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const folderId = params.id;
    const body = await request.json();
    const { parentId } = body; // nullì´ë©´ ë£¨íŠ¸ë¡œ ì´ë™

    // í´ë” í™•ì¸
    const folder = await prisma.folder.findUnique({
      where: { id: folderId },
    });

    if (!folder) {
      return NextResponse.json(
        { error: "í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    if (folder.userId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // ìê¸° ìì‹ ìœ¼ë¡œ ì´ë™ ë°©ì§€
    if (parentId === folderId) {
      return NextResponse.json(
        { error: "í´ë”ë¥¼ ìê¸° ìì‹ ìœ¼ë¡œ ì´ë™í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 400 }
      );
    }

    // ëŒ€ìƒ í´ë” í™•ì¸ (ìˆëŠ” ê²½ìš°)
    if (parentId) {
      const targetFolder = await prisma.folder.findUnique({
        where: { id: parentId },
      });

      if (!targetFolder) {
        return NextResponse.json(
          { error: "ëŒ€ìƒ í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
          { status: 404 }
        );
      }

      if (targetFolder.userId !== session.user.id) {
        return NextResponse.json(
          { error: "ëŒ€ìƒ í´ë”ì— ëŒ€í•œ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
          { status: 403 }
        );
      }

      // ìˆœí™˜ ì°¸ì¡° ë°©ì§€ (ìì‹ í´ë”ë¡œ ì´ë™ ë¶ˆê°€)
      const isDescendant = await checkIsDescendant(parentId, folderId);
      if (isDescendant) {
        return NextResponse.json(
          { error: "í•˜ìœ„ í´ë”ë¡œëŠ” ì´ë™í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
          { status: 400 }
        );
      }
    }

    // ê°™ì€ ìœ„ì¹˜ì— ê°™ì€ ì´ë¦„ì˜ í´ë”ê°€ ìˆëŠ”ì§€ í™•ì¸
    const existingFolder = await prisma.folder.findFirst({
      where: {
        userId: session.user.id,
        parentId: parentId || null,
        name: folder.name,
        id: { not: folderId },
      },
    });

    if (existingFolder) {
      return NextResponse.json(
        { error: "ëŒ€ìƒ ìœ„ì¹˜ì— ê°™ì€ ì´ë¦„ì˜ í´ë”ê°€ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤" },
        { status: 409 }
      );
    }

    // í´ë” ì´ë™
    const updatedFolder = await prisma.folder.update({
      where: { id: folderId },
      data: {
        parentId: parentId || null,
      },
      include: {
        _count: {
          select: {
            children: true,
            files: true,
          },
        },
      },
    });

    return NextResponse.json({
      message: "í´ë”ê°€ ì´ë™ë˜ì—ˆìŠµë‹ˆë‹¤",
      folder: updatedFolder,
    });

  } catch (error) {
    console.error("Folder move error:", error);
    return NextResponse.json(
      { error: "í´ë” ì´ë™ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// ìˆœí™˜ ì°¸ì¡° í™•ì¸ í—¬í¼ í•¨ìˆ˜
async function checkIsDescendant(
  targetId: string,
  ancestorId: string
): Promise<boolean> {
  let currentId: string | null = targetId;

  while (currentId) {
    if (currentId === ancestorId) {
      return true;
    }

    const folder = await prisma.folder.findUnique({
      where: { id: currentId },
      select: { parentId: true },
    });

    currentId = folder?.parentId || null;
  }

  return false;
}
</file>

<file path="src/app/api/folders/[id]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// í´ë” ìƒì„¸ ì¡°íšŒ
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const folderId = params.id;

    const folder = await prisma.folder.findUnique({
      where: { id: folderId },
      include: {
        _count: {
          select: {
            children: true,
            files: true,
          },
        },
        parent: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

    if (!folder) {
      return NextResponse.json(
        { error: "í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    if (folder.userId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    return NextResponse.json({ folder });

  } catch (error) {
    console.error("Folder fetch error:", error);
    return NextResponse.json(
      { error: "í´ë” ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// í´ë” ìˆ˜ì • (ì´ë¦„ ë³€ê²½)
export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const folderId = params.id;
    const body = await request.json();
    const { name, color, icon } = body;

    const folder = await prisma.folder.findUnique({
      where: { id: folderId },
    });

    if (!folder) {
      return NextResponse.json(
        { error: "í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    if (folder.userId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // ì´ë¦„ ë³€ê²½ ì‹œ ì¤‘ë³µ í™•ì¸
    if (name && name !== folder.name) {
      const existingFolder = await prisma.folder.findFirst({
        where: {
          userId: session.user.id,
          parentId: folder.parentId,
          name: name.trim(),
          id: { not: folderId },
        },
      });

      if (existingFolder) {
        return NextResponse.json(
          { error: "ê°™ì€ ì´ë¦„ì˜ í´ë”ê°€ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤" },
          { status: 409 }
        );
      }
    }

    // í´ë” ìˆ˜ì •
    const updatedFolder = await prisma.folder.update({
      where: { id: folderId },
      data: {
        name: name?.trim() || folder.name,
        color: color !== undefined ? color : folder.color,
        icon: icon !== undefined ? icon : folder.icon,
      },
      include: {
        _count: {
          select: {
            children: true,
            files: true,
          },
        },
      },
    });

    return NextResponse.json({
      message: "í´ë”ê°€ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤",
      folder: updatedFolder,
    });

  } catch (error) {
    console.error("Folder update error:", error);
    return NextResponse.json(
      { error: "í´ë” ìˆ˜ì • ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// í´ë” ì‚­ì œ
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const folderId = params.id;

    const folder = await prisma.folder.findUnique({
      where: { id: folderId },
      include: {
        _count: {
          select: {
            children: true,
            files: true,
          },
        },
      },
    });

    if (!folder) {
      return NextResponse.json(
        { error: "í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    if (folder.userId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // í•˜ìœ„ í´ë”ë‚˜ íŒŒì¼ì´ ìˆìœ¼ë©´ ê²½ê³ 
    if (folder._count.children > 0 || folder._count.files > 0) {
      return NextResponse.json(
        { 
          error: "í´ë”ê°€ ë¹„ì–´ìˆì§€ ì•ŠìŠµë‹ˆë‹¤",
          info: `í•˜ìœ„ í´ë” ${folder._count.children}ê°œ, íŒŒì¼ ${folder._count.files}ê°œ`
        },
        { status: 400 }
      );
    }

    // í´ë” ì‚­ì œ
    await prisma.folder.delete({
      where: { id: folderId },
    });

    return NextResponse.json({
      message: "í´ë”ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤",
    });

  } catch (error) {
    console.error("Folder delete error:", error);
    return NextResponse.json(
      { error: "í´ë” ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/folders/[id]/share/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// í´ë” ê³µìœ  ìƒì„±
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const folderId = params.id;
    const body = await request.json();
    const { sharedWithEmail, permission = "VIEW" } = body;

    if (!sharedWithEmail) {
      return NextResponse.json(
        { error: "ê³µìœ í•  ì‚¬ìš©ì ì´ë©”ì¼ì„ ì…ë ¥í•˜ì„¸ìš”" },
        { status: 400 }
      );
    }

    // í´ë” í™•ì¸
    const folder = await prisma.folder.findUnique({
      where: { id: folderId },
    });

    if (!folder) {
      return NextResponse.json(
        { error: "í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ì†Œìœ ì í™•ì¸
    if (folder.userId !== session.user.id) {
      return NextResponse.json(
        { error: "í´ë” ì†Œìœ ìë§Œ ê³µìœ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // ê³µìœ  ëŒ€ìƒ ì‚¬ìš©ì í™•ì¸
    const sharedWithUser = await prisma.user.findUnique({
      where: { email: sharedWithEmail },
    });

    if (!sharedWithUser) {
      return NextResponse.json(
        { error: "í•´ë‹¹ ì´ë©”ì¼ì˜ ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ë³¸ì¸ì—ê²Œ ê³µìœ  ë°©ì§€
    if (sharedWithUser.id === session.user.id) {
      return NextResponse.json(
        { error: "ë³¸ì¸ì—ê²ŒëŠ” ê³µìœ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 400 }
      );
    }

    // ì´ë¯¸ ê³µìœ ëœ ê²½ìš° í™•ì¸
    const existingShare = await prisma.sharedResource.findFirst({
      where: {
        resourceType: "FOLDER",
        resourceId: folderId,
        sharedWithId: sharedWithUser.id,
      },
    });

    if (existingShare) {
      return NextResponse.json(
        { error: "ì´ë¯¸ ê³µìœ ëœ í´ë”ì…ë‹ˆë‹¤" },
        { status: 409 }
      );
    }

    // ê³µìœ  ìƒì„±
    const share = await prisma.sharedResource.create({
      data: {
        resourceType: "FOLDER",
        resourceId: folderId,
        ownerId: session.user.id,
        sharedWithId: sharedWithUser.id,
        permission,
      },
    });

    // ê³µìœ  ëŒ€ìƒ ì •ë³´ ìˆ˜ë™ ì¡°íšŒ
    const shareWithUser = await prisma.user.findUnique({
      where: { id: share.sharedWithId },
      select: {
        id: true,
        email: true,
        name: true,
      },
    });

    return NextResponse.json(
      {
        message: "í´ë”ê°€ ê³µìœ ë˜ì—ˆìŠµë‹ˆë‹¤",
        share: {
          ...share,
          sharedWith: shareWithUser,
        },
      },
      { status: 201 }
    );

  } catch (error) {
    console.error("Folder share error:", error);
    return NextResponse.json(
      { error: "í´ë” ê³µìœ  ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// í´ë” ê³µìœ  ëª©ë¡ ì¡°íšŒ
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const folderId = params.id;

    // í´ë” í™•ì¸
    const folder = await prisma.folder.findUnique({
      where: { id: folderId },
    });

    if (!folder) {
      return NextResponse.json(
        { error: "í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    if (folder.userId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // ê³µìœ  ëª©ë¡ ì¡°íšŒ
    const shares = await prisma.sharedResource.findMany({
      where: {
        resourceType: "FOLDER",
        resourceId: folderId,
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    // ê° ê³µìœ ì˜ ì‚¬ìš©ì ì •ë³´ ìˆ˜ë™ ì¡°íšŒ
    const sharesWithUsers = await Promise.all(
      shares.map(async (share) => {
        const sharedWith = await prisma.user.findUnique({
          where: { id: share.sharedWithId },
          select: {
            id: true,
            email: true,
            name: true,
          },
        });

        return {
          ...share,
          sharedWith,
        };
      })
    );

    return NextResponse.json({ shares: sharesWithUsers });

  } catch (error) {
    console.error("Share list error:", error);
    return NextResponse.json(
      { error: "ê³µìœ  ëª©ë¡ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// ê³µìœ  ì‚­ì œ
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const shareId = searchParams.get("shareId");

    if (!shareId) {
      return NextResponse.json(
        { error: "ê³µìœ  IDê°€ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 400 }
      );
    }

    // ê³µìœ  í™•ì¸
    const share = await prisma.sharedResource.findUnique({
      where: { id: shareId },
    });

    if (!share) {
      return NextResponse.json(
        { error: "ê³µìœ  ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ì†Œìœ ì í™•ì¸
    if (share.ownerId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // ê³µìœ  ì‚­ì œ
    await prisma.sharedResource.delete({
      where: { id: shareId },
    });

    return NextResponse.json({
      message: "ê³µìœ ê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤",
    });

  } catch (error) {
    console.error("Share delete error:", error);
    return NextResponse.json(
      { error: "ê³µìœ  ì·¨ì†Œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/folders/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// í´ë” ëª©ë¡ ì¡°íšŒ
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const parentId = searchParams.get("parentId");

    // íŠ¹ì • í´ë”ì˜ í•˜ìœ„ í•­ëª© ì¡°íšŒ
    const folders = await prisma.folder.findMany({
      where: {
        userId: session.user.id,
        parentId: parentId || null,
      },
      orderBy: {
        name: "asc",
      },
      include: {
        _count: {
          select: {
            children: true,
            files: true,
          },
        },
      },
    });

    // íŒŒì¼ë„ í•¨ê»˜ ì¡°íšŒ
    const files = await prisma.file.findMany({
      where: {
        userId: session.user.id,
        folderId: parentId || null,
      },
      orderBy: {
        originalName: "asc",
      },
      select: {
        id: true,
        filename: true,
        originalName: true,
        size: true,
        mimeType: true,
        thumbnailUrl: true,
        createdAt: true,
        updatedAt: true,
      },
    });

    return NextResponse.json({
      folders,
      files: files.map(f => ({
        ...f,
        size: f.size.toString(),
      })),
    });

  } catch (error) {
    console.error("Folders fetch error:", error);
    return NextResponse.json(
      { error: "í´ë” ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// í´ë” ìƒì„±
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { name, parentId, color, icon } = body;

    if (!name || name.trim().length === 0) {
      return NextResponse.json(
        { error: "í´ë” ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”" },
        { status: 400 }
      );
    }

    // ë¶€ëª¨ í´ë” í™•ì¸ (ìˆëŠ” ê²½ìš°)
    if (parentId) {
      const parentFolder = await prisma.folder.findUnique({
        where: { id: parentId },
      });

      if (!parentFolder) {
        return NextResponse.json(
          { error: "ë¶€ëª¨ í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
          { status: 404 }
        );
      }

      if (parentFolder.userId !== session.user.id) {
        return NextResponse.json(
          { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
          { status: 403 }
        );
      }
    }

    // ê°™ì€ ì´ë¦„ì˜ í´ë” í™•ì¸
    const existingFolder = await prisma.folder.findFirst({
      where: {
        userId: session.user.id,
        parentId: parentId || null,
        name: name.trim(),
      },
    });

    if (existingFolder) {
      return NextResponse.json(
        { error: "ê°™ì€ ì´ë¦„ì˜ í´ë”ê°€ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤" },
        { status: 409 }
      );
    }

    // í´ë” ìƒì„±
    const folder = await prisma.folder.create({
      data: {
        name: name.trim(),
        parentId: parentId || null,
        userId: session.user.id,
        color: color || null,
        icon: icon || null,
      },
      include: {
        _count: {
          select: {
            children: true,
            files: true,
          },
        },
      },
    });

    return NextResponse.json(
      {
        message: "í´ë”ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤",
        folder,
      },
      { status: 201 }
    );

  } catch (error) {
    console.error("Folder create error:", error);
    return NextResponse.json(
      { error: "í´ë” ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/posts/[id]/comments/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// ëŒ“ê¸€ ì‘ì„±
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const postId = params.id;
    const body = await request.json();
    const { content } = body;

    if (!content || content.trim() === "") {
      return NextResponse.json(
        { error: "ëŒ“ê¸€ ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”" },
        { status: 400 }
      );
    }

    // ê²Œì‹œê¸€ ì¡´ì¬ í™•ì¸
    const post = await prisma.post.findUnique({
      where: { id: postId },
    });

    if (!post) {
      return NextResponse.json(
        { error: "ê²Œì‹œê¸€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ëŒ“ê¸€ ì‘ì„±
    const comment = await prisma.comment.create({
      data: {
        content,
        postId,
        userId: session.user.id,
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

    return NextResponse.json(
      {
        message: "ëŒ“ê¸€ì´ ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤",
        comment,
      },
      { status: 201 }
    );

  } catch (error) {
    console.error("Comment create error:", error);
    return NextResponse.json(
      { error: "ëŒ“ê¸€ ì‘ì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/posts/[id]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// ê²Œì‹œê¸€ ìƒì„¸ ì¡°íšŒ
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const postId = params.id;

    const post = await prisma.post.findUnique({
      where: { id: postId },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
        comments: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
              },
            },
          },
          orderBy: {
            createdAt: "asc",
          },
        },
      },
    });

    if (!post) {
      return NextResponse.json(
        { error: "ê²Œì‹œê¸€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ê¶Œí•œ í™•ì¸
    const isOwner = post.userId === session.user.id;
    const isPublic = post.visibility === "PUBLIC";

    // ê³µìœ  í™•ì¸
    let isShared = false;
    if (!isOwner && !isPublic && post.visibility === "SHARED") {
      const shareCheck = await prisma.sharedResource.findFirst({
        where: {
          resourceType: "POST",
          resourceId: postId,
          sharedWithId: session.user.id,
        },
      });
      isShared = !!shareCheck;
    }

    // ì ‘ê·¼ ê¶Œí•œ í™•ì¸
    const canView = isOwner || isPublic || isShared;

    console.log("=== ê²Œì‹œê¸€ ì ‘ê·¼ í™•ì¸ ===");
    console.log("ì‚¬ìš©ì ID:", session.user.id);
    console.log("ê²Œì‹œê¸€ ì†Œìœ ì:", post.userId);
    console.log("ê³µê°œ ì„¤ì •:", post.visibility);
    console.log("ì†Œìœ ì:", isOwner);
    console.log("ê³µê°œ ê¸€:", isPublic);
    console.log("ê³µìœ ë°›ìŒ:", isShared);
    console.log("ì ‘ê·¼ ê°€ëŠ¥:", canView);

    if (!canView) {
      return NextResponse.json(
        { error: "ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    return NextResponse.json({ post });

  } catch (error) {
    console.error("Post fetch error:", error);
    return NextResponse.json(
      { error: "ê²Œì‹œê¸€ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// ê²Œì‹œê¸€ ìˆ˜ì •
export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const postId = params.id;
    const body = await request.json();

    const post = await prisma.post.findUnique({
      where: { id: postId },
    });

    if (!post) {
      return NextResponse.json(
        { error: "ê²Œì‹œê¸€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    if (post.userId !== session.user.id) {
      return NextResponse.json(
        { error: "ìˆ˜ì • ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    const updatedPost = await prisma.post.update({
      where: { id: postId },
      data: {
        title: body.title,
        content: body.content,
        visibility: body.visibility,
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

    return NextResponse.json({
      message: "ê²Œì‹œê¸€ì´ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤",
      post: updatedPost,
    });

  } catch (error) {
    console.error("Post update error:", error);
    return NextResponse.json(
      { error: "ê²Œì‹œê¸€ ìˆ˜ì • ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// ê²Œì‹œê¸€ ì‚­ì œ
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const postId = params.id;

    const post = await prisma.post.findUnique({
      where: { id: postId },
    });

    if (!post) {
      return NextResponse.json(
        { error: "ê²Œì‹œê¸€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    if (post.userId !== session.user.id) {
      return NextResponse.json(
        { error: "ì‚­ì œ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    await prisma.post.delete({
      where: { id: postId },
    });

    return NextResponse.json({
      message: "ê²Œì‹œê¸€ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤",
    });

  } catch (error) {
    console.error("Post delete error:", error);
    return NextResponse.json(
      { error: "ê²Œì‹œê¸€ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/posts/[id]/share/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// ê²Œì‹œê¸€ ê³µìœ  ìƒì„±
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const postId = params.id;
    const body = await request.json();
    const { sharedWithEmail, permission = "VIEW" } = body;

    console.log("=== ê²Œì‹œê¸€ ê³µìœ  ì‹œë„ ===");
    console.log("ê²Œì‹œê¸€ ID:", postId);
    console.log("ê³µìœ  ëŒ€ìƒ:", sharedWithEmail);
    console.log("ê¶Œí•œ:", permission);

    if (!sharedWithEmail) {
      return NextResponse.json(
        { error: "ê³µìœ í•  ì‚¬ìš©ì ì´ë©”ì¼ì„ ì…ë ¥í•˜ì„¸ìš”" },
        { status: 400 }
      );
    }

    // ê²Œì‹œê¸€ í™•ì¸ (ê´€ê³„ ì—†ì´)
    const post = await prisma.post.findUnique({
      where: { id: postId },
    });

    console.log("ê²Œì‹œê¸€ ì¡´ì¬:", post ? "âœ…" : "âŒ");

    if (!post) {
      return NextResponse.json(
        { error: "ê²Œì‹œê¸€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ì†Œìœ ì í™•ì¸
    if (post.userId !== session.user.id) {
      return NextResponse.json(
        { error: "ê²Œì‹œê¸€ ì†Œìœ ìë§Œ ê³µìœ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // ê³µìœ  ëŒ€ìƒ ì‚¬ìš©ì í™•ì¸
    const sharedWithUser = await prisma.user.findUnique({
      where: { email: sharedWithEmail },
    });

    console.log("ê³µìœ  ëŒ€ìƒ ì¡´ì¬:", sharedWithUser ? "âœ…" : "âŒ");

    if (!sharedWithUser) {
      return NextResponse.json(
        { error: "í•´ë‹¹ ì´ë©”ì¼ì˜ ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ë³¸ì¸ì—ê²Œ ê³µìœ  ë°©ì§€
    if (sharedWithUser.id === session.user.id) {
      return NextResponse.json(
        { error: "ë³¸ì¸ì—ê²ŒëŠ” ê³µìœ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 400 }
      );
    }

    // ì´ë¯¸ ê³µìœ ëœ ê²½ìš° í™•ì¸
    const existingShare = await prisma.sharedResource.findFirst({
      where: {
        resourceType: "POST",
        resourceId: postId,
        sharedWithId: sharedWithUser.id,
      },
    });

    if (existingShare) {
      return NextResponse.json(
        { error: "ì´ë¯¸ ê³µìœ ëœ ê²Œì‹œê¸€ì…ë‹ˆë‹¤" },
        { status: 409 }
      );
    }

    console.log("ê³µìœ  ë°ì´í„°:", {
      resourceType: "POST",
      resourceId: postId,
      ownerId: session.user.id,
      sharedWithId: sharedWithUser.id,
      permission,
    });

    // ê³µìœ  ìƒì„± (ê´€ê³„ ì—†ì´)
    const share = await prisma.sharedResource.create({
      data: {
        resourceType: "POST",
        resourceId: postId,
        ownerId: session.user.id,
        sharedWithId: sharedWithUser.id,
        permission,
      },
    });

    console.log("âœ… ê³µìœ  ì„±ê³µ:", share.id);

    // ê³µìœ  ëŒ€ìƒ ì •ë³´ ìˆ˜ë™ ì¡°íšŒ
    const shareWithUser = await prisma.user.findUnique({
      where: { id: share.sharedWithId },
      select: {
        id: true,
        email: true,
        name: true,
      },
    });

    return NextResponse.json(
      {
        message: "ê²Œì‹œê¸€ì´ ê³µìœ ë˜ì—ˆìŠµë‹ˆë‹¤",
        share: {
          ...share,
          sharedWith: shareWithUser,
        },
      },
      { status: 201 }
    );

  } catch (error) {
    console.error("=== ê²Œì‹œê¸€ ê³µìœ  ì˜¤ë¥˜ ===");
    console.error("Error:", error);
    console.error("Message:", error.message);
    console.error("Code:", error.code);
    
    return NextResponse.json(
      { error: "ê²Œì‹œê¸€ ê³µìœ  ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// ê²Œì‹œê¸€ ê³µìœ  ëª©ë¡ ì¡°íšŒ
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const postId = params.id;

    // ê²Œì‹œê¸€ í™•ì¸
    const post = await prisma.post.findUnique({
      where: { id: postId },
    });

    if (!post) {
      return NextResponse.json(
        { error: "ê²Œì‹œê¸€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    if (post.userId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // ê³µìœ  ëª©ë¡ ì¡°íšŒ
    const shares = await prisma.sharedResource.findMany({
      where: {
        resourceType: "POST",
        resourceId: postId,
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    // ê° ê³µìœ ì˜ ì‚¬ìš©ì ì •ë³´ ìˆ˜ë™ ì¡°íšŒ
    const sharesWithUsers = await Promise.all(
      shares.map(async (share) => {
        const sharedWith = await prisma.user.findUnique({
          where: { id: share.sharedWithId },
          select: {
            id: true,
            email: true,
            name: true,
          },
        });

        return {
          ...share,
          sharedWith,
        };
      })
    );

    return NextResponse.json({ shares: sharesWithUsers });

  } catch (error) {
    console.error("Share list error:", error);
    return NextResponse.json(
      { error: "ê³µìœ  ëª©ë¡ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// ê³µìœ  ì‚­ì œ
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const shareId = searchParams.get("shareId");

    if (!shareId) {
      return NextResponse.json(
        { error: "ê³µìœ  IDê°€ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 400 }
      );
    }

    // ê³µìœ  í™•ì¸
    const share = await prisma.sharedResource.findUnique({
      where: { id: shareId },
    });

    if (!share) {
      return NextResponse.json(
        { error: "ê³µìœ  ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ì†Œìœ ì í™•ì¸
    if (share.ownerId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // ê³µìœ  ì‚­ì œ
    await prisma.sharedResource.delete({
      where: { id: shareId },
    });

    return NextResponse.json({
      message: "ê³µìœ ê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤",
    });

  } catch (error) {
    console.error("Share delete error:", error);
    return NextResponse.json(
      { error: "ê³µìœ  ì·¨ì†Œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/posts/[id]/tags/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// ê²Œì‹œê¸€ì˜ íƒœê·¸ ëª©ë¡ ì¡°íšŒ
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const postId = params.id;

    // ê²Œì‹œê¸€ í™•ì¸
    const post = await prisma.post.findUnique({
      where: { id: postId },
    });

    if (!post) {
      return NextResponse.json(
        { error: "ê²Œì‹œê¸€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // íƒœê·¸ ì¡°íšŒ
    const postTags = await prisma.postTag.findMany({
      where: { postId },
      include: {
        tag: true,
      },
    });

    return NextResponse.json({
      tags: postTags.map((pt) => pt.tag),
    });
  } catch (error) {
    console.error("Post tags fetch error:", error);
    return NextResponse.json(
      { error: "íƒœê·¸ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// ê²Œì‹œê¸€ì— íƒœê·¸ ì¶”ê°€
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const postId = params.id;
    const body = await request.json();
    const { tagName } = body;

    if (!tagName) {
      return NextResponse.json(
        { error: "íƒœê·¸ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”" },
        { status: 400 }
      );
    }

    // ê²Œì‹œê¸€ í™•ì¸
    const post = await prisma.post.findUnique({
      where: { id: postId },
    });

    if (!post) {
      return NextResponse.json(
        { error: "ê²Œì‹œê¸€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    if (post.userId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // íƒœê·¸ ì°¾ê¸° ë˜ëŠ” ìƒì„±
    let tag = await prisma.tag.findUnique({
      where: { name: tagName.trim().toLowerCase() },
    });

    if (!tag) {
      tag = await prisma.tag.create({
        data: { name: tagName.trim().toLowerCase() },
      });
    }

    // ì´ë¯¸ ì¶”ê°€ëœ íƒœê·¸ì¸ì§€ í™•ì¸
    const existingPostTag = await prisma.postTag.findUnique({
      where: {
        postId_tagId: {
          postId,
          tagId: tag.id,
        },
      },
    });

    if (existingPostTag) {
      return NextResponse.json(
        { error: "ì´ë¯¸ ì¶”ê°€ëœ íƒœê·¸ì…ë‹ˆë‹¤" },
        { status: 409 }
      );
    }

    // íƒœê·¸ ì¶”ê°€
    await prisma.postTag.create({
      data: {
        postId,
        tagId: tag.id,
      },
    });

    return NextResponse.json(
      {
        message: "íƒœê·¸ê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤",
        tag,
      },
      { status: 201 }
    );
  } catch (error) {
    console.error("Post tag add error:", error);
    return NextResponse.json(
      { error: "íƒœê·¸ ì¶”ê°€ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// ê²Œì‹œê¸€ì—ì„œ íƒœê·¸ ì œê±°
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const postId = params.id;
    const { searchParams } = new URL(request.url);
    const tagId = searchParams.get("tagId");

    if (!tagId) {
      return NextResponse.json(
        { error: "íƒœê·¸ IDê°€ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 400 }
      );
    }

    // ê²Œì‹œê¸€ í™•ì¸
    const post = await prisma.post.findUnique({
      where: { id: postId },
    });

    if (!post) {
      return NextResponse.json(
        { error: "ê²Œì‹œê¸€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    if (post.userId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // íƒœê·¸ ì œê±°
    await prisma.postTag.delete({
      where: {
        postId_tagId: {
          postId,
          tagId,
        },
      },
    });

    return NextResponse.json({
      message: "íƒœê·¸ê°€ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤",
    });
  } catch (error) {
    console.error("Post tag remove error:", error);
    return NextResponse.json(
      { error: "íƒœê·¸ ì œê±° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/posts/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import { z } from "zod";

const postSchema = z.object({
  title: z.string().min(1, "ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”").max(200),
  content: z.string().min(1, "ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”"),
  visibility: z.enum(["PRIVATE", "SHARED", "PUBLIC"]).optional(),
});

// ê²Œì‹œê¸€ ëª©ë¡ ì¡°íšŒ
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get("page") || "1");
    const limit = parseInt(searchParams.get("limit") || "20");
    const visibility = searchParams.get("visibility");
    const search = searchParams.get("search") || "";

    const skip = (page - 1) * limit;

    // 1. ë‚˜ì—ê²Œ ê³µìœ ëœ ê²Œì‹œê¸€ ID ëª©ë¡
    const sharedPosts = await prisma.sharedResource.findMany({
      where: {
        resourceType: "POST",
        sharedWithId: session.user.id,
      },
      select: {
        resourceId: true,
      },
    });

    const sharedPostIds = sharedPosts.map((sr) => sr.resourceId);

    // 2. ì¡°íšŒ ì¡°ê±´ êµ¬ì„±
    let where: any = {};
    
    if (visibility === "my") {
      // ë‚´ ê¸€ë§Œ
      where.userId = session.user.id;
    } else if (visibility === "public") {
      // ê³µê°œ ê¸€ë§Œ
      where.visibility = "PUBLIC";
    } else if (visibility === "shared") {
      // ë‚˜ì—ê²Œ ê³µìœ ëœ ê¸€ë§Œ
      where.id = { in: sharedPostIds };
    } else {
      // ì „ì²´ (ê¸°ë³¸)
      where.OR = [
        { userId: session.user.id },           // ë‚´ê°€ ì‘ì„±í•œ ê¸€
        { visibility: "PUBLIC" },              // ê³µê°œ ê¸€
        { id: { in: sharedPostIds } },         // ë‚˜ì—ê²Œ ê³µìœ ëœ ê¸€
      ];
    }

    // ê²€ìƒ‰ì–´ í•„í„°
    if (search) {
      const searchCondition = {
        OR: [
          { title: { contains: search, mode: "insensitive" } },
          { content: { contains: search, mode: "insensitive" } },
        ],
      };

      if (where.OR) {
        where.AND = [
          { OR: where.OR },
          searchCondition,
        ];
        delete where.OR;
      } else {
        where.AND = [searchCondition];
      }
    }

    const [posts, total] = await Promise.all([
      prisma.post.findMany({
        where,
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true,
            },
          },
          _count: {
            select: {
              comments: true,
            },
          },
        },
        orderBy: { createdAt: "desc" },
        skip,
        take: limit,
      }),
      prisma.post.count({ where }),
    ]);

    // 3. ê° ê²Œì‹œê¸€ì— ê³µìœ  ì •ë³´ ì¶”ê°€
    const postsWithShareInfo = await Promise.all(
      posts.map(async (post) => {
        const isShared = sharedPostIds.includes(post.id);
        let sharedBy = null;

        if (isShared && post.userId !== session.user.id) {
          // ê³µìœ ë°›ì€ ê²Œì‹œê¸€ì¸ ê²½ìš° ê³µìœ ì ì •ë³´ ì¡°íšŒ
          const shareInfo = await prisma.sharedResource.findFirst({
            where: {
              resourceType: "POST",
              resourceId: post.id,
              sharedWithId: session.user.id,
            },
            include: {
              owner: {
                select: {
                  id: true,
                  name: true,
                  email: true,
                },
              },
            },
          });

          if (shareInfo) {
            sharedBy = shareInfo.owner.name;
          }
        }

        return {
          ...post,
          isOwner: post.userId === session.user.id,
          isShared: isShared && post.userId !== session.user.id,
          sharedBy,
        };
      })
    );

    return NextResponse.json({
      posts: postsWithShareInfo,
      pagination: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    });

  } catch (error) {
    console.error("Posts fetch error:", error);
    return NextResponse.json(
      { error: "ê²Œì‹œê¸€ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// ê²Œì‹œê¸€ ìƒì„±
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const body = await request.json();
    const validation = postSchema.safeParse(body);

    if (!validation.success) {
      return NextResponse.json(
        { error: validation.error.errors[0].message },
        { status: 400 }
      );
    }

    const { title, content, visibility = "PRIVATE" } = validation.data;

    const post = await prisma.post.create({
      data: {
        title,
        content,
        visibility,
        userId: session.user.id,
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
      },
    });

    return NextResponse.json(
      {
        message: "ê²Œì‹œê¸€ì´ ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤",
        post,
      },
      { status: 201 }
    );

  } catch (error) {
    console.error("Post create error:", error);
    return NextResponse.json(
      { error: "ê²Œì‹œê¸€ ì‘ì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/saved-searches/[id]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// ì €ì¥ëœ ê²€ìƒ‰ ì‚­ì œ
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const searchId = params.id;

    const savedSearch = await prisma.savedSearch.findUnique({
      where: { id: searchId },
    });

    if (!savedSearch) {
      return NextResponse.json(
        { error: "ì €ì¥ëœ ê²€ìƒ‰ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    if (savedSearch.userId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    await prisma.savedSearch.delete({
      where: { id: searchId },
    });

    return NextResponse.json({
      message: "ì €ì¥ëœ ê²€ìƒ‰ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤",
    });
  } catch (error) {
    console.error("Saved search delete error:", error);
    return NextResponse.json(
      { error: "ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/saved-searches/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// ì €ì¥ëœ ê²€ìƒ‰ ëª©ë¡
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const savedSearches = await prisma.savedSearch.findMany({
      where: {
        userId: session.user.id,
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    return NextResponse.json({ savedSearches });
  } catch (error) {
    console.error("Saved searches fetch error:", error);
    return NextResponse.json(
      { error: "ì €ì¥ëœ ê²€ìƒ‰ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// ê²€ìƒ‰ ì €ì¥
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { name, query } = body;

    if (!name || !query) {
      return NextResponse.json(
        { error: "ì´ë¦„ê³¼ ê²€ìƒ‰ ì¡°ê±´ì„ ì…ë ¥í•˜ì„¸ìš”" },
        { status: 400 }
      );
    }

    const savedSearch = await prisma.savedSearch.create({
      data: {
        name,
        query,
        userId: session.user.id,
      },
    });

    return NextResponse.json(
      {
        message: "ê²€ìƒ‰ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤",
        savedSearch,
      },
      { status: 201 }
    );
  } catch (error) {
    console.error("Save search error:", error);
    return NextResponse.json(
      { error: "ê²€ìƒ‰ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/share/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// ê³µìœ  ëª©ë¡ ì¡°íšŒ
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    // ë‚´ê°€ ê³µìœ ë°›ì€ ëª©ë¡
    const sharedWithMe = await prisma.sharedResource.findMany({
      where: { sharedWithId: session.user.id },
      include: {
        owner: {
          select: { id: true, name: true, email: true },
        },
      },
      orderBy: { createdAt: "desc" },
    });

    // ë‚´ê°€ ê³µìœ í•œ ëª©ë¡
    const sharedByMe = await prisma.sharedResource.findMany({
      where: { ownerId: session.user.id },
      include: {
        sharedWith: {
          select: { id: true, name: true, email: true },
        },
      },
      orderBy: { createdAt: "desc" },
    });

    return NextResponse.json({ sharedWithMe, sharedByMe });
  } catch (error) {
    console.error("Share list error:", error);
    return NextResponse.json(
      { error: "ê³µìœ  ëª©ë¡ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// ê³µìœ  ìƒì„±
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const body = await request.json();
    const { resourceType, resourceId, sharedWithEmail, permission } = body;

    // í•„ìˆ˜ê°’ í™•ì¸
    if (!resourceType || !resourceId || !sharedWithEmail) {
      return NextResponse.json(
        { error: "resourceType, resourceId, sharedWithEmail ì€ í•„ìˆ˜ì…ë‹ˆë‹¤" },
        { status: 400 }
      );
    }

    // ê³µìœ  ëŒ€ìƒ ì‚¬ìš©ì ì°¾ê¸° (ì´ë©”ì¼ë¡œ)
    const sharedWithUser = await prisma.user.findUnique({
      where: { email: sharedWithEmail.trim().toLowerCase() },
    });

    if (!sharedWithUser) {
      return NextResponse.json(
        { error: "í•´ë‹¹ ì´ë©”ì¼ì˜ ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ìê¸° ìì‹ ì—ê²Œ ê³µìœ  ë°©ì§€
    if (sharedWithUser.id === session.user.id) {
      return NextResponse.json(
        { error: "ìê¸° ìì‹ ì—ê²ŒëŠ” ê³µìœ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 400 }
      );
    }

    // ë¦¬ì†ŒìŠ¤ ì¡´ì¬ + ì†Œìœ ì í™•ì¸
    if (resourceType === "FILE") {
      const file = await prisma.file.findUnique({
        where: { id: resourceId },
      });
      if (!file) {
        return NextResponse.json(
          { error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
          { status: 404 }
        );
      }
      if (file.userId !== session.user.id) {
        return NextResponse.json(
          { error: "íŒŒì¼ ì†Œìœ ìë§Œ ê³µìœ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤" },
          { status: 403 }
        );
      }
    } else if (resourceType === "FOLDER") {
      const folder = await prisma.folder.findUnique({
        where: { id: resourceId },
      });
      if (!folder) {
        return NextResponse.json(
          { error: "í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
          { status: 404 }
        );
      }
      if (folder.userId !== session.user.id) {
        return NextResponse.json(
          { error: "í´ë” ì†Œìœ ìë§Œ ê³µìœ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤" },
          { status: 403 }
        );
      }
    } else if (resourceType === "POST") {
      const post = await prisma.post.findUnique({
        where: { id: resourceId },
      });
      if (!post) {
        return NextResponse.json(
          { error: "ê²Œì‹œê¸€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
          { status: 404 }
        );
      }
      if (post.authorId !== session.user.id) {
        return NextResponse.json(
          { error: "ê²Œì‹œê¸€ ì‘ì„±ìë§Œ ê³µìœ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤" },
          { status: 403 }
        );
      }
    } else {
      return NextResponse.json(
        { error: "ì˜¬ë°”ë¥´ì§€ ì•Šì€ resourceType ì…ë‹ˆë‹¤ (FILE | FOLDER | POST)" },
        { status: 400 }
      );
    }

    // ì´ë¯¸ ê³µìœ  ì¤‘ì¸ì§€ í™•ì¸
    const existing = await prisma.sharedResource.findFirst({
      where: {
        resourceType,
        resourceId,
        sharedWithId: sharedWithUser.id,
      },
    });

    if (existing) {
      // ì´ë¯¸ ìˆìœ¼ë©´ ê¶Œí•œë§Œ ì—…ë°ì´íŠ¸
      const updated = await prisma.sharedResource.update({
        where: { id: existing.id },
        data: { permission: permission || "VIEW" },
      });
      return NextResponse.json({
        message: "ê³µìœ  ê¶Œí•œì´ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤",
        share: updated,
      });
    }

    // ìƒˆ ê³µìœ  ìƒì„±
    const share = await prisma.sharedResource.create({
      data: {
        resourceType,
        resourceId,
        ownerId: session.user.id,        // â† sharedById â†’ ownerId ìˆ˜ì •
        sharedWithId: sharedWithUser.id,
        permission: permission || "VIEW",
      },
    });

    return NextResponse.json(
      { message: "ê³µìœ ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤", share },
      { status: 201 }
    );
  } catch (error) {
    console.error("Share create error:", error);
    return NextResponse.json(
      { error: "ê³µìœ  ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/tags/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// íƒœê·¸ ëª©ë¡ ì¡°íšŒ
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const search = searchParams.get("search") || "";

    // ëª¨ë“  íƒœê·¸ ì¡°íšŒ (ì‚¬ìš© íšŸìˆ˜ í¬í•¨)
    const tags = await prisma.tag.findMany({
      where: search
        ? {
            name: {
              contains: search,
              mode: "insensitive",
            },
          }
        : {},
      include: {
        _count: {
          select: {
            fileTags: true,
            postTags: true,
          },
        },
      },
      orderBy: {
        name: "asc",
      },
    });

    return NextResponse.json({
      tags: tags.map((tag) => ({
        ...tag,
        usageCount: tag._count.fileTags + tag._count.postTags,
      })),
    });
  } catch (error) {
    console.error("Tags fetch error:", error);
    return NextResponse.json(
      { error: "íƒœê·¸ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// íƒœê·¸ ìƒì„±
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { name, color } = body;

    if (!name || name.trim().length === 0) {
      return NextResponse.json(
        { error: "íƒœê·¸ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”" },
        { status: 400 }
      );
    }

    // ì¤‘ë³µ í™•ì¸
    const existingTag = await prisma.tag.findUnique({
      where: { name: name.trim().toLowerCase() },
    });

    if (existingTag) {
      return NextResponse.json(
        { error: "ì´ë¯¸ ì¡´ì¬í•˜ëŠ” íƒœê·¸ì…ë‹ˆë‹¤", tag: existingTag },
        { status: 409 }
      );
    }

    // íƒœê·¸ ìƒì„±
    const tag = await prisma.tag.create({
      data: {
        name: name.trim().toLowerCase(),
        color: color || null,
      },
    });

    return NextResponse.json(
      {
        message: "íƒœê·¸ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤",
        tag,
      },
      { status: 201 }
    );
  } catch (error) {
    console.error("Tag create error:", error);
    return NextResponse.json(
      { error: "íƒœê·¸ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/users/fcm-token/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// FCM í† í° ë“±ë¡
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { fcmToken } = body;

    if (!fcmToken) {
      return NextResponse.json(
        { error: "FCM í† í°ì„ ì œê³µí•˜ì„¸ìš”" },
        { status: 400 }
      );
    }

    // í† í° ì €ì¥
    await prisma.user.update({
      where: { id: session.user.id },
      data: { fcmToken },
    });

    return NextResponse.json({
      message: "FCM í† í°ì´ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤",
    });
  } catch (error) {
    console.error("FCM token registration error:", error);
    return NextResponse.json(
      { error: "í† í° ë“±ë¡ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// FCM í† í° ì‚­ì œ (ë¡œê·¸ì•„ì›ƒ ì‹œ)
export async function DELETE(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    await prisma.user.update({
      where: { id: session.user.id },
      data: { fcmToken: null },
    });

    return NextResponse.json({
      message: "FCM í† í°ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤",
    });
  } catch (error) {
    console.error("FCM token deletion error:", error);
    return NextResponse.json(
      { error: "í† í° ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/users/presence/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// ì˜¨ë¼ì¸ ìƒíƒœ ì—…ë°ì´íŠ¸
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { isOnline, networkType } = body;

    await prisma.user.update({
      where: { id: session.user.id },
      data: {
        isOnline: isOnline !== undefined ? isOnline : true,
        lastSeenAt: new Date(),
        networkType: networkType || "WIFI",
      },
    });

    return NextResponse.json({
      message: "ì˜¨ë¼ì¸ ìƒíƒœê°€ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤",
    });
  } catch (error) {
    console.error("Presence update error:", error);
    return NextResponse.json(
      { error: "ìƒíƒœ ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/find-email/page.tsx">
// =============================================
// íŒŒì¼ 1: src/app/find-email/page.tsx
// ì´ë©”ì¼(ì•„ì´ë””) ì°¾ê¸° í˜ì´ì§€
// =============================================
"use client";

import { useState } from "react";
import Link from "next/link";

export default function FindEmailPage() {
  const [name, setName] = useState("");
  const [loading, setLoading] = useState(false);
  const [result, setResult] = useState<{ maskedEmail: string } | null>(null);
  const [sent, setSent] = useState(false);
  const [error, setError] = useState("");

  const handleFind = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");
    setLoading(true);
    try {
      const res = await fetch("/api/auth/find-email", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name }),
      });
      const data = await res.json();
      if (res.ok) {
        setResult(data);
      } else {
        setError(data.error || "ì´ë©”ì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤");
      }
    } catch {
      setError("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  };

  const handleSendFull = async () => {
    setLoading(true);
    try {
      const res = await fetch("/api/auth/find-email/send", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name }),
      });
      if (res.ok) setSent(true);
      else setError("ì´ë©”ì¼ ë°œì†¡ ì‹¤íŒ¨");
    } catch {
      setError("ë°œì†¡ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="eum-root">
      <div className="eum-bg"><div className="eum-blob b1"/><div className="eum-blob b2"/></div>
      <div className="eum-container">
        <Link href="/login" className="eum-back">â† ë¡œê·¸ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°</Link>

        <div className="eum-card">
          <div className="eum-icon-wrap">ğŸ“§</div>
          <h2 className="eum-title">ì´ë©”ì¼ ì°¾ê¸°</h2>
          <p className="eum-sub">ê°€ì… ì‹œ ì…ë ¥í•œ ì´ë¦„ìœ¼ë¡œ ì´ë©”ì¼ì„ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤</p>

          {!result && !sent && (
            <form onSubmit={handleFind} className="eum-form">
              {error && <div className="eum-error">âš ï¸ {error}</div>}
              <div className="eum-field">
                <label className="eum-label">ì´ë¦„</label>
                <input type="text" value={name} onChange={(e) => setName(e.target.value)}
                  placeholder="ê°€ì… ì‹œ ì…ë ¥í•œ ì´ë¦„" className="eum-input" required />
              </div>
              <button type="submit" disabled={loading} className="eum-btn">
                {loading ? "ì°¾ëŠ” ì¤‘..." : "ì´ë©”ì¼ ì°¾ê¸°"}
              </button>
            </form>
          )}

          {result && !sent && (
            <div className="eum-result">
              <p className="eum-result-label">ê°€ì…ëœ ì´ë©”ì¼</p>
              <p className="eum-result-email">{result.maskedEmail}</p>
              <p className="eum-result-desc">ì „ì²´ ì´ë©”ì¼ ì£¼ì†Œë¥¼ ë°›ìœ¼ì‹œê² ìŠµë‹ˆê¹Œ?</p>
              <button onClick={handleSendFull} disabled={loading} className="eum-btn">
                {loading ? "ë°œì†¡ ì¤‘..." : "ì´ë©”ì¼ë¡œ ì „ì²´ ì£¼ì†Œ ë°›ê¸°"}
              </button>
              <Link href="/login" className="eum-link-btn">ë¡œê·¸ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°</Link>
            </div>
          )}

          {sent && (
            <div className="eum-success">
              <div className="eum-success-icon">âœ…</div>
              <p className="eum-success-msg">ì´ë©”ì¼ì´ ë°œì†¡ë˜ì—ˆìŠµë‹ˆë‹¤!</p>
              <p className="eum-success-sub">ë°›ì€ ë©”ì¼í•¨ì„ í™•ì¸í•´ì£¼ì„¸ìš”<br/>(ìŠ¤íŒ¸í•¨ë„ í™•ì¸í•´ë³´ì„¸ìš”)</p>
              <Link href="/login" className="eum-btn" style={{display:"block",textAlign:"center",textDecoration:"none",marginTop:"16px"}}>
                ë¡œê·¸ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°
              </Link>
            </div>
          )}
        </div>
      </div>
      <style>{EUM_FIND_STYLE}</style>
    </div>
  );
}

const EUM_FIND_STYLE = `
  * { box-sizing: border-box; margin: 0; padding: 0; }
  .eum-root { min-height: 100vh; min-height: 100dvh; background: #0f0c29; display: flex; align-items: center; justify-content: center; padding: 24px 20px; position: relative; overflow: hidden; font-family: 'Pretendard','Apple SD Gothic Neo',-apple-system,sans-serif; }
  .eum-bg { position: fixed; inset: 0; pointer-events: none; z-index: 0; }
  .eum-blob { position: absolute; border-radius: 50%; filter: blur(80px); opacity: 0.25; }
  .b1 { width: 380px; height: 380px; background: #7c3aed; top: -100px; left: -100px; }
  .b2 { width: 320px; height: 320px; background: #2563eb; bottom: -80px; right: -80px; }
  .eum-container { position: relative; z-index: 1; width: 100%; max-width: 400px; display: flex; flex-direction: column; gap: 16px; }
  .eum-back { font-size: 13px; color: rgba(255,255,255,0.4); text-decoration: none; display: inline-flex; align-items: center; gap: 4px; transition: color 0.2s; }
  .eum-back:hover { color: rgba(255,255,255,0.7); }
  .eum-card { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); border-radius: 24px; padding: 36px 28px; backdrop-filter: blur(20px); box-shadow: 0 25px 50px rgba(0,0,0,0.4); }
  .eum-icon-wrap { font-size: 40px; text-align: center; margin-bottom: 16px; }
  .eum-title { font-size: 22px; font-weight: 700; color: white; text-align: center; margin-bottom: 8px; }
  .eum-sub { font-size: 14px; color: rgba(255,255,255,0.5); text-align: center; line-height: 1.6; margin-bottom: 24px; }
  .eum-form { display: flex; flex-direction: column; gap: 16px; }
  .eum-field { display: flex; flex-direction: column; gap: 7px; }
  .eum-label { font-size: 13px; font-weight: 600; color: rgba(255,255,255,0.7); }
  .eum-input { background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12); border-radius: 12px; padding: 13px 16px; color: white; font-size: 16px; transition: all 0.2s; outline: none; width: 100%; -webkit-appearance: none; }
  .eum-input::placeholder { color: rgba(255,255,255,0.25); }
  .eum-input:focus { border-color: #7c3aed; background: rgba(124,58,237,0.1); box-shadow: 0 0 0 3px rgba(124,58,237,0.2); }
  .eum-error { background: rgba(239,68,68,0.15); border: 1px solid rgba(239,68,68,0.3); color: #fca5a5; font-size: 13px; padding: 12px 14px; border-radius: 12px; }
  .eum-btn { width: 100%; padding: 14px; background: linear-gradient(135deg, #7c3aed, #2563eb); border: none; border-radius: 12px; color: white; font-size: 15px; font-weight: 700; cursor: pointer; transition: all 0.2s; min-height: 50px; box-shadow: 0 4px 20px rgba(124,58,237,0.35); -webkit-tap-highlight-color: transparent; }
  .eum-btn:disabled { opacity: 0.5; cursor: not-allowed; }
  .eum-result { text-align: center; display: flex; flex-direction: column; gap: 12px; }
  .eum-result-label { font-size: 12px; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 1px; }
  .eum-result-email { font-size: 22px; font-weight: 700; color: #a78bfa; letter-spacing: 1px; }
  .eum-result-desc { font-size: 13px; color: rgba(255,255,255,0.5); }
  .eum-link-btn { text-align: center; font-size: 13px; color: rgba(255,255,255,0.35); text-decoration: none; margin-top: 4px; display: block; }
  .eum-success { text-align: center; display: flex; flex-direction: column; align-items: center; gap: 10px; }
  .eum-success-icon { font-size: 52px; }
  .eum-success-msg { font-size: 20px; font-weight: 700; color: white; }
  .eum-success-sub { font-size: 14px; color: rgba(255,255,255,0.5); line-height: 1.7; }
  .eum-expire { font-size: 12px; color: rgba(255,165,0,0.8); }
`;
</file>

<file path="src/app/posts/[id]/page.tsx">
"use client";

import { useSession } from "next-auth/react";
import { useRouter, useParams } from "next/navigation";
import { useEffect, useState } from "react";
import Link from "next/link";
import PostShareModal from "@/components/PostShareModal";

interface Comment {
  id: string;
  content: string;
  createdAt: string;
  user: {
    id: string;
    name: string;
  };
}

interface Post {
  id: string;
  title: string;
  content: string;
  visibility: string;
  createdAt: string;
  user: {
    id: string;
    name: string;
    email: string;
  };
  comments: Comment[];
}

export default function PostDetailPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const params = useParams();
  const postId = params.id as string;

  const [post, setPost] = useState<Post | null>(null);
  const [loading, setLoading] = useState(true);
  const [comment, setComment] = useState("");
  const [submitting, setSubmitting] = useState(false);
  const [shareModalOpen, setShareModalOpen] = useState(false);

  useEffect(() => {
    if (status === "unauthenticated") {
      router.push("/login");
    }
  }, [status, router]);

  useEffect(() => {
    if (session && postId) {
      fetchPost();
    }
  }, [session, postId]);

  const fetchPost = async () => {
    try {
      const res = await fetch(`/api/posts/${postId}`);
      if (res.ok) {
        const data = await res.json();
        setPost(data.post);
      } else {
        alert("ê²Œì‹œê¸€ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤");
        router.push("/posts");
      }
    } catch (err) {
      console.error("Failed to fetch post:", err);
    } finally {
      setLoading(false);
    }
  };

  const handleCommentSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!comment.trim()) return;

    setSubmitting(true);

    try {
      const res = await fetch(`/api/posts/${postId}/comments`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ content: comment }),
      });

      if (res.ok) {
        setComment("");
        fetchPost();
      } else {
        alert("ëŒ“ê¸€ ì‘ì„± ì‹¤íŒ¨");
      }
    } catch (err) {
      alert("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setSubmitting(false);
    }
  };

  const handleDeleteComment = async (commentId: string) => {
    if (!confirm("ëŒ“ê¸€ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) return;

    try {
      const res = await fetch(`/api/comments/${commentId}`, {
        method: "DELETE",
      });

      if (res.ok) {
        fetchPost();
      } else {
        alert("ëŒ“ê¸€ ì‚­ì œ ì‹¤íŒ¨");
      }
    } catch (err) {
      alert("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    }
  };

  const handleDeletePost = async () => {
    if (!confirm("ê²Œì‹œê¸€ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) return;

    try {
      const res = await fetch(`/api/posts/${postId}`, {
        method: "DELETE",
      });

      if (res.ok) {
        alert("ê²Œì‹œê¸€ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤");
        router.push("/posts");
      } else {
        alert("ì‚­ì œ ì‹¤íŒ¨");
      }
    } catch (err) {
      alert("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    }
  };

  const getVisibilityBadge = (visibility: string) => {
    const badges = {
      PUBLIC: { text: "ê³µê°œ", color: "bg-green-100 text-green-700" },
      SHARED: { text: "ê³µìœ ", color: "bg-blue-100 text-blue-700" },
      PRIVATE: { text: "ë¹„ê³µê°œ", color: "bg-gray-100 text-gray-700" },
    };
    return badges[visibility] || badges.PRIVATE;
  };

  if (status === "loading" || loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <p className="text-gray-600">ë¡œë”© ì¤‘...</p>
      </div>
    );
  }

  if (!session || !post) return null;

  const isAuthor = post.user.id === session.user.id;
  const badge = getVisibilityBadge(post.visibility);

  return (
    <div className="min-h-screen bg-gray-50">
      {/* í—¤ë” */}
      <header className="bg-white shadow">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
          <Link href="/posts" className="text-gray-600 hover:text-gray-900">
            â† ëª©ë¡ìœ¼ë¡œ
          </Link>
        </div>
      </header>

      {/* ë©”ì¸ */}
      <main className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        {/* ê²Œì‹œê¸€ */}
        <div className="bg-white rounded-lg shadow p-6 mb-6">
          <div className="flex items-start justify-between mb-4">
            <div className="flex-1">
              <h1 className="text-2xl font-bold text-gray-900 mb-2">
                {post.title}
              </h1>
              <div className="flex items-center gap-4 text-sm text-gray-500">
                <span>{post.user.name}</span>
                <span>â€¢</span>
                <span>
                  {new Date(post.createdAt).toLocaleDateString("ko-KR")}
                </span>
                <span className={`px-2 py-1 text-xs rounded-full ${badge.color}`}>
                  {badge.text}
                </span>
              </div>
            </div>
            {isAuthor && (
              <div className="flex gap-2">
                {post.visibility === "SHARED" && (
                  <button
                    onClick={() => setShareModalOpen(true)}
                    className="px-3 py-1 text-sm text-blue-600 border border-blue-300 hover:bg-blue-50 rounded"
                  >
                    ê³µìœ  ê´€ë¦¬
                  </button>
                )}
                <button
                  onClick={handleDeletePost}
                  className="px-3 py-1 text-sm text-red-600 border border-red-300 hover:bg-red-50 rounded"
                >
                  ì‚­ì œ
                </button>
              </div>
            )}
          </div>

          {/* ê³µìœ  ì„¤ì • ì•ˆë‚´ */}
          {post.visibility === "SHARED" && (
            <div className="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-md">
              <p className="text-sm text-blue-800">
                ğŸ”— ì´ ê²Œì‹œê¸€ì€ <strong>íŠ¹ì • ì‚¬ìš©ìì—ê²Œë§Œ ê³µìœ </strong>ëœ ìƒíƒœì…ë‹ˆë‹¤.
                {isAuthor && (
                  <> "ê³µìœ  ê´€ë¦¬" ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ê³µìœ  ëŒ€ìƒì„ ê´€ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</>
                )}
              </p>
            </div>
          )}

          <div className="prose max-w-none">
            <p className="whitespace-pre-wrap text-gray-700">{post.content}</p>
          </div>
        </div>

        {/* ëŒ“ê¸€ */}
        <div className="bg-white rounded-lg shadow p-6">
          <h2 className="text-lg font-semibold text-gray-900 mb-4">
            ëŒ“ê¸€ ({post.comments.length})
          </h2>

          {/* ëŒ“ê¸€ ì‘ì„± */}
          <form onSubmit={handleCommentSubmit} className="mb-6">
            <textarea
              value={comment}
              onChange={(e) => setComment(e.target.value)}
              rows={3}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 mb-2"
              placeholder="ëŒ“ê¸€ì„ ì…ë ¥í•˜ì„¸ìš”"
            />
            <div className="flex justify-end">
              <button
                type="submit"
                disabled={submitting || !comment.trim()}
                className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:bg-gray-400"
              >
                {submitting ? "ì‘ì„± ì¤‘..." : "ëŒ“ê¸€ ì‘ì„±"}
              </button>
            </div>
          </form>

          {/* ëŒ“ê¸€ ëª©ë¡ */}
          <div className="space-y-4">
            {post.comments.length === 0 ? (
              <p className="text-center text-gray-500 py-4">
                ì²« ëŒ“ê¸€ì„ ì‘ì„±í•´ë³´ì„¸ìš”
              </p>
            ) : (
              post.comments.map((comment) => (
                <div
                  key={comment.id}
                  className="border-t pt-4 first:border-t-0 first:pt-0"
                >
                  <div className="flex items-start justify-between">
                    <div className="flex-1">
                      <div className="flex items-center gap-2 mb-2">
                        <span className="font-medium text-gray-900">
                          {comment.user.name}
                        </span>
                        <span className="text-sm text-gray-500">
                          {new Date(comment.createdAt).toLocaleDateString(
                            "ko-KR"
                          )}
                        </span>
                      </div>
                      <p className="text-gray-700">{comment.content}</p>
                    </div>
                    {comment.user.id === session.user.id && (
                      <button
                        onClick={() => handleDeleteComment(comment.id)}
                        className="text-red-600 hover:text-red-700 text-sm"
                      >
                        ì‚­ì œ
                      </button>
                    )}
                  </div>
                </div>
              ))
            )}
          </div>
        </div>
      </main>

      {/* ê³µìœ  ëª¨ë‹¬ */}
      {shareModalOpen && (
        <PostShareModal
          postId={postId}
          postTitle={post.title}
          onClose={() => setShareModalOpen(false)}
        />
      )}
    </div>
  );
}
</file>

<file path="src/app/posts/new/page.tsx">
"use client";

import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import { useState, useEffect } from "react";
import Link from "next/link";

export default function NewPostPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const [formData, setFormData] = useState({
    title: "",
    content: "",
    visibility: "PRIVATE",
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  useEffect(() => {
    if (status === "unauthenticated") {
      router.push("/login");
    }
  }, [status, router]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");
    setLoading(true);

    try {
      const res = await fetch("/api/posts", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(formData),
      });

      const data = await res.json();

      if (!res.ok) {
        setError(data.error || "ê²Œì‹œê¸€ ì‘ì„± ì‹¤íŒ¨");
        setLoading(false);
        return;
      }

      alert("ê²Œì‹œê¸€ì´ ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤!");
      router.push(`/posts/${data.post.id}`);
    } catch (err) {
      console.error("Post create error:", err);
      setError("ì‘ì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
      setLoading(false);
    }
  };

  if (status === "loading") {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <p className="text-gray-600">ë¡œë”© ì¤‘...</p>
      </div>
    );
  }

  if (!session) return null;

  return (
    <div className="min-h-screen bg-gray-50">
      {/* í—¤ë” */}
      <header className="bg-white shadow">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
          <div className="flex items-center gap-4">
            <Link href="/posts" className="text-gray-600 hover:text-gray-900">
              â† ëª©ë¡
            </Link>
            <h1 className="text-2xl font-bold text-gray-900">ê¸€ì“°ê¸°</h1>
          </div>
        </div>
      </header>

      {/* ë©”ì¸ */}
      <main className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div className="bg-white rounded-lg shadow p-6">
          {error && (
            <div className="mb-4 p-4 bg-red-50 border border-red-200 rounded-md">
              <p className="text-sm text-red-800">{error}</p>
            </div>
          )}

          <form onSubmit={handleSubmit} className="space-y-6">
            {/* ì œëª© */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                ì œëª©
              </label>
              <input
                type="text"
                value={formData.title}
                onChange={(e) =>
                  setFormData({ ...formData, title: e.target.value })
                }
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                placeholder="ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”"
                required
              />
            </div>

            {/* ê³µê°œ ì„¤ì • */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                ê³µê°œ ì„¤ì •
              </label>
              <select
                value={formData.visibility}
                onChange={(e) =>
                  setFormData({ ...formData, visibility: e.target.value })
                }
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                <option value="PRIVATE">ë¹„ê³µê°œ</option>
                <option value="SHARED">ê³µìœ </option>
                <option value="PUBLIC">ê³µê°œ</option>
              </select>
            </div>

            {/* ë‚´ìš© */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                ë‚´ìš©
              </label>
              <textarea
                value={formData.content}
                onChange={(e) =>
                  setFormData({ ...formData, content: e.target.value })
                }
                rows={15}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                placeholder="ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”"
                required
              />
            </div>

            {/* ë²„íŠ¼ */}
            <div className="flex justify-end gap-2">
              <Link
                href="/posts"
                className="px-4 py-2 text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50"
              >
                ì·¨ì†Œ
              </Link>
              <button
                type="submit"
                disabled={loading}
                className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:bg-gray-400"
              >
                {loading ? "ì‘ì„± ì¤‘..." : "ì‘ì„±í•˜ê¸°"}
              </button>
            </div>
          </form>
        </div>
      </main>
    </div>
  );
}
</file>

<file path="src/app/posts/page.tsx">
"use client";

import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import { useEffect, useState } from "react";
import Link from "next/link";
import SearchBar from "@/components/SearchBar";

interface Post {
  id: string;
  title: string;
  content: string;
  visibility: string;
  createdAt: string;
  user: {
    id: string;
    name: string;
  };
  _count: {
    comments: number;
  };
  isOwner: boolean;
  isShared: boolean;
  sharedBy?: string;
}

export default function PostsPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const [posts, setPosts] = useState<Post[]>([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState<"all" | "my" | "public" | "shared">("all");
  const [searchQuery, setSearchQuery] = useState("");

  useEffect(() => {
    if (status === "unauthenticated") {
      router.push("/login");
    }
  }, [status, router]);

  useEffect(() => {
    if (session) {
      fetchPosts();
    }
  }, [session, filter, searchQuery]);

  const fetchPosts = async () => {
    setLoading(true);
    try {
      const params = new URLSearchParams();
      if (filter !== "all") {
        params.set("visibility", filter);
      }
      if (searchQuery) {
        params.set("search", searchQuery);
      }

      const res = await fetch(`/api/posts?${params}`);
      if (res.ok) {
        const data = await res.json();
        setPosts(data.posts);
      } else {
        console.error("Failed to fetch posts");
      }
    } catch (err) {
      console.error("Failed to fetch posts:", err);
    } finally {
      setLoading(false);
    }
  };

  const getVisibilityBadge = (visibility: string) => {
    const badges = {
      PUBLIC: { text: "ê³µê°œ", color: "bg-green-100 text-green-700" },
      SHARED: { text: "ê³µìœ ", color: "bg-blue-100 text-blue-700" },
      PRIVATE: { text: "ë¹„ê³µê°œ", color: "bg-gray-100 text-gray-700" },
    };
    return badges[visibility] || badges.PRIVATE;
  };

  if (status === "loading") {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <p className="text-gray-600">ë¡œë”© ì¤‘...</p>
      </div>
    );
  }

  if (!session) return null;

  return (
    <div className="min-h-screen bg-gray-50">
      {/* í—¤ë” */}
      <header className="bg-white shadow">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4 flex justify-between items-center">
          <div className="flex items-center gap-4">
            <Link href="/dashboard" className="text-2xl">
              â˜ï¸
            </Link>
            <h1 className="text-2xl font-bold text-gray-900">ê²Œì‹œíŒ</h1>
          </div>
          <Link
            href="/posts/new"
            className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
          >
            ê¸€ì“°ê¸°
          </Link>
        </div>
      </header>

      {/* ë©”ì¸ */}
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        {/* í•„í„° */}
        <div className="flex gap-2 mb-4">
          <button
            onClick={() => setFilter("all")}
            className={`px-4 py-2 rounded-md ${
              filter === "all"
                ? "bg-blue-600 text-white"
                : "bg-white text-gray-700 border hover:bg-gray-50"
            }`}
          >
            ì „ì²´
          </button>
          <button
            onClick={() => setFilter("my")}
            className={`px-4 py-2 rounded-md ${
              filter === "my"
                ? "bg-blue-600 text-white"
                : "bg-white text-gray-700 border hover:bg-gray-50"
            }`}
          >
            ë‚´ ê¸€
          </button>
          <button
            onClick={() => setFilter("public")}
            className={`px-4 py-2 rounded-md ${
              filter === "public"
                ? "bg-green-600 text-white"
                : "bg-white text-gray-700 border hover:bg-gray-50"
            }`}
          >
            ê³µê°œ ê¸€
          </button>
          <button
            onClick={() => setFilter("shared")}
            className={`px-4 py-2 rounded-md ${
              filter === "shared"
                ? "bg-purple-600 text-white"
                : "bg-white text-gray-700 border hover:bg-gray-50"
            }`}
          >
            ê³µìœ ë°›ì€ ê¸€
          </button>
        </div>

        {/* ê²€ìƒ‰ */}
        <div className="mb-6">
          <SearchBar
            onSearch={setSearchQuery}
            placeholder="ê²Œì‹œê¸€ ê²€ìƒ‰..."
          />
        </div>

        {/* ì„¤ëª… */}
        <div className="mb-4 p-4 bg-blue-50 border border-blue-200 rounded-md">
          <p className="text-sm text-blue-800">
            <strong>ğŸ’¡ ê³µê°œ ì„¤ì • ì•ˆë‚´:</strong>
            <br />
            â€¢ <strong>ë¹„ê³µê°œ</strong>: ë‚˜ë§Œ ë³¼ ìˆ˜ ìˆìŒ
            <br />
            â€¢ <strong>ê³µìœ </strong>: íŠ¹ì • ì‚¬ìš©ìì—ê²Œë§Œ ê³µìœ  (íŒŒì¼ì²˜ëŸ¼ ì´ë©”ì¼ë¡œ ê³µìœ )
            <br />
            â€¢ <strong>ê³µê°œ</strong>: ëª¨ë“  ì‚¬ìš©ìê°€ ë³¼ ìˆ˜ ìˆìŒ
          </p>
        </div>

        {/* ê²Œì‹œê¸€ ëª©ë¡ */}
        {loading ? (
          <p className="text-center text-gray-500 py-8">ë¡œë”© ì¤‘...</p>
        ) : posts.length === 0 ? (
          <div className="bg-white rounded-lg shadow p-8 text-center">
            <p className="text-gray-500">ê²Œì‹œê¸€ì´ ì—†ìŠµë‹ˆë‹¤</p>
            <Link
              href="/posts/new"
              className="inline-block mt-4 text-blue-600 hover:text-blue-700"
            >
              ì²« ê²Œì‹œê¸€ì„ ì‘ì„±í•´ë³´ì„¸ìš”
            </Link>
          </div>
        ) : (
          <div className="space-y-4">
            {posts.map((post) => {
              const badge = getVisibilityBadge(post.visibility);
              
              return (
                <Link
                  key={post.id}
                  href={`/posts/${post.id}`}
                  className={`block bg-white rounded-lg shadow hover:shadow-md transition p-6 ${
                    post.isShared ? "border-2 border-purple-300" : ""
                  }`}
                >
                  {/* ê³µìœ ë°›ì€ ê¸€ í—¤ë” */}
                  {post.isShared && (
                    <div className="mb-3 flex items-center gap-2 text-sm text-purple-700 bg-purple-50 px-3 py-2 rounded">
                      <span>ğŸ”—</span>
                      <span><strong>{post.sharedBy}ë‹˜</strong>ì´ ê³µìœ í•œ ê¸€</span>
                    </div>
                  )}

                  <div className="flex items-start justify-between">
                    <div className="flex-1">
                      <div className="flex items-center gap-2 mb-2">
                        <h3 className="text-lg font-semibold text-gray-900">
                          {post.title}
                        </h3>
                        {post.isShared && (
                          <span className="px-2 py-1 text-xs bg-purple-100 text-purple-700 rounded">
                            ê³µìœ ë°›ìŒ
                          </span>
                        )}
                      </div>
                      <p className="text-gray-600 mb-3 line-clamp-2">
                        {post.content}
                      </p>
                      <div className="flex items-center gap-4 text-sm text-gray-500">
                        <span>{post.isShared ? post.sharedBy : post.user.name}</span>
                        <span>â€¢</span>
                        <span>
                          {new Date(post.createdAt).toLocaleDateString("ko-KR")}
                        </span>
                        <span>â€¢</span>
                        <span>ëŒ“ê¸€ {post._count.comments}</span>
                      </div>
                    </div>
                    <span className={`px-3 py-1 text-xs rounded-full ${badge.color}`}>
                      {badge.text}
                    </span>
                  </div>
                </Link>
              );
            })}
          </div>
        )}
      </main>
    </div>
  );
}
</file>

<file path="src/app/providers.tsx">
"use client";

import { SessionProvider } from "next-auth/react";
import { ReactNode } from "react";

export function Providers({ children }: { children: ReactNode }) {
  return <SessionProvider>{children}</SessionProvider>;
}
</file>

<file path="src/app/reset-password/page.tsx">
"use client";

import { useState } from "react";
import Link from "next/link";

export default function ResetPasswordPage() {
  const [email, setEmail] = useState("");
  const [loading, setLoading] = useState(false);
  const [sent, setSent] = useState(false);
  const [error, setError] = useState("");

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");
    setLoading(true);
    try {
      const res = await fetch("/api/auth/reset-password", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email }),
      });
      const data = await res.json();
      if (res.ok) setSent(true);
      else setError(data.error || "ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } catch {
      setError("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="eum-root">
      <div className="eum-bg">
        <div className="eum-blob b1" />
        <div className="eum-blob b2" />
      </div>
      <div className="eum-container">
        <Link href="/login" className="eum-back">â† ë¡œê·¸ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°</Link>
        <div className="eum-card">
          <div className="eum-icon-wrap">ğŸ”</div>
          <h2 className="eum-title">ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì •</h2>
          {!sent ? (
            <>
              <p className="eum-sub">
                ê°€ì…í•œ ì´ë©”ì¼ ì£¼ì†Œë¥¼ ì…ë ¥í•˜ë©´<br />
                ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì • ë§í¬ë¥¼ ë³´ë‚´ë“œë¦½ë‹ˆë‹¤
              </p>
              <form onSubmit={handleSubmit} className="eum-form">
                {error && <div className="eum-error">âš ï¸ {error}</div>}
                <div className="eum-field">
                  <label className="eum-label">ì´ë©”ì¼</label>
                  <input
                    type="email"
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                    placeholder="ê°€ì…í•œ ì´ë©”ì¼ ì£¼ì†Œ"
                    className="eum-input"
                    required
                  />
                </div>
                <button type="submit" disabled={loading} className="eum-btn">
                  {loading ? "ì „ì†¡ ì¤‘..." : "ì¬ì„¤ì • ë§í¬ ë°›ê¸°"}
                </button>
              </form>
            </>
          ) : (
            <div className="eum-success">
              <div className="eum-success-icon">ğŸ“¨</div>
              <p className="eum-success-msg">ë©”ì¼ì„ ë°œì†¡í–ˆìŠµë‹ˆë‹¤!</p>
              <p className="eum-success-sub">
                <strong>{email}</strong>ë¡œ ì „ì†¡ëœ<br />
                ë§í¬ë¥¼ í´ë¦­í•´ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì¬ì„¤ì •í•˜ì„¸ìš”<br />
                <span className="eum-expire">ë§í¬ëŠ” 15ë¶„ê°„ ìœ íš¨í•©ë‹ˆë‹¤</span>
              </p>
              <Link
                href="/login"
                className="eum-btn"
                style={{ display: "block", textAlign: "center", textDecoration: "none", marginTop: "16px" }}
              >
                ë¡œê·¸ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°
              </Link>
            </div>
          )}
        </div>
      </div>
      <style>{EUM_FIND_STYLE}</style>
    </div>
  );
}

const EUM_FIND_STYLE = `
  * { box-sizing: border-box; margin: 0; padding: 0; }
  .eum-root { min-height: 100vh; min-height: 100dvh; background: #0f0c29; display: flex; align-items: center; justify-content: center; padding: 24px 20px; position: relative; overflow: hidden; font-family: 'Pretendard','Apple SD Gothic Neo',-apple-system,sans-serif; }
  .eum-bg { position: fixed; inset: 0; pointer-events: none; z-index: 0; }
  .eum-blob { position: absolute; border-radius: 50%; filter: blur(80px); opacity: 0.25; }
  .b1 { width: 380px; height: 380px; background: #7c3aed; top: -100px; left: -100px; }
  .b2 { width: 320px; height: 320px; background: #2563eb; bottom: -80px; right: -80px; }
  .eum-container { position: relative; z-index: 1; width: 100%; max-width: 400px; display: flex; flex-direction: column; gap: 16px; }
  .eum-back { font-size: 13px; color: rgba(255,255,255,0.4); text-decoration: none; display: inline-flex; align-items: center; gap: 4px; transition: color 0.2s; }
  .eum-back:hover { color: rgba(255,255,255,0.7); }
  .eum-card { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); border-radius: 24px; padding: 36px 28px; backdrop-filter: blur(20px); box-shadow: 0 25px 50px rgba(0,0,0,0.4); }
  .eum-icon-wrap { font-size: 40px; text-align: center; margin-bottom: 16px; }
  .eum-title { font-size: 22px; font-weight: 700; color: white; text-align: center; margin-bottom: 8px; }
  .eum-sub { font-size: 14px; color: rgba(255,255,255,0.5); text-align: center; line-height: 1.6; margin-bottom: 24px; }
  .eum-form { display: flex; flex-direction: column; gap: 16px; }
  .eum-field { display: flex; flex-direction: column; gap: 7px; }
  .eum-label { font-size: 13px; font-weight: 600; color: rgba(255,255,255,0.7); }
  .eum-input { background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12); border-radius: 12px; padding: 13px 16px; color: white; font-size: 16px; transition: all 0.2s; outline: none; width: 100%; -webkit-appearance: none; }
  .eum-input::placeholder { color: rgba(255,255,255,0.25); }
  .eum-input:focus { border-color: #7c3aed; background: rgba(124,58,237,0.1); box-shadow: 0 0 0 3px rgba(124,58,237,0.2); }
  .eum-error { background: rgba(239,68,68,0.15); border: 1px solid rgba(239,68,68,0.3); color: #fca5a5; font-size: 13px; padding: 12px 14px; border-radius: 12px; }
  .eum-btn { width: 100%; padding: 14px; background: linear-gradient(135deg, #7c3aed, #2563eb); border: none; border-radius: 12px; color: white; font-size: 15px; font-weight: 700; cursor: pointer; transition: all 0.2s; min-height: 50px; box-shadow: 0 4px 20px rgba(124,58,237,0.35); -webkit-tap-highlight-color: transparent; }
  .eum-btn:disabled { opacity: 0.5; cursor: not-allowed; }
  .eum-success { text-align: center; display: flex; flex-direction: column; align-items: center; gap: 10px; }
  .eum-success-icon { font-size: 52px; }
  .eum-success-msg { font-size: 20px; font-weight: 700; color: white; }
  .eum-success-sub { font-size: 14px; color: rgba(255,255,255,0.5); line-height: 1.7; }
  .eum-expire { font-size: 12px; color: rgba(255,165,0,0.8); }
`;
</file>

<file path="src/app/search/page.tsx">
"use client";

import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import { useEffect, useState } from "react";
import Link from "next/link";

interface SearchResult {
  files: any[];
  posts: any[];
  total: number;
}

interface SavedSearch {
  id: string;
  name: string;
  query: string;
  filters: string;
  createdAt: string;
}

interface Tag {
  id: string;
  name: string;
}

export default function SearchPage() {
  const { data: session, status } = useSession();
  const router = useRouter();

  // ê²€ìƒ‰ ìƒíƒœ
  const [query, setQuery] = useState("");
  const [results, setResults] = useState<SearchResult>({ files: [], posts: [], total: 0 });
  const [loading, setLoading] = useState(false);
  const [hasSearched, setHasSearched] = useState(false);

  // í•„í„° ìƒíƒœ
  const [showFilters, setShowFilters] = useState(false);
  const [filterType, setFilterType] = useState<"ALL" | "FILE" | "POST">("ALL");
  const [filterMimeType, setFilterMimeType] = useState("");
  const [filterTagIds, setFilterTagIds] = useState<string[]>([]);
  const [filterDateFrom, setFilterDateFrom] = useState("");
  const [filterDateTo, setFilterDateTo] = useState("");

  // íƒœê·¸ ëª©ë¡
  const [allTags, setAllTags] = useState<Tag[]>([]);

  // ì €ì¥ëœ ê²€ìƒ‰
  const [savedSearches, setSavedSearches] = useState<SavedSearch[]>([]);
  const [showSaveModal, setShowSaveModal] = useState(false);
  const [saveSearchName, setSaveSearchName] = useState("");
  const [showSavedList, setShowSavedList] = useState(false);

  useEffect(() => {
    if (status === "unauthenticated") router.push("/login");
  }, [status, router]);

  useEffect(() => {
    if (session) {
      fetchTags();
      fetchSavedSearches();
    }
  }, [session]);

  const fetchTags = async () => {
    try {
      const res = await fetch("/api/tags");
      if (res.ok) {
        const data = await res.json();
        setAllTags(data.tags || []);
      }
    } catch {}
  };

  const fetchSavedSearches = async () => {
    try {
      const res = await fetch("/api/search/saved");
      if (res.ok) {
        const data = await res.json();
        setSavedSearches(data.savedSearches || []);
      }
    } catch {}
  };

  // í™œì„± í•„í„° ìˆ˜ ê³„ì‚°
  const activeFilterCount = [
    filterType !== "ALL",
    filterMimeType !== "",
    filterTagIds.length > 0,
    filterDateFrom !== "",
    filterDateTo !== "",
  ].filter(Boolean).length;

  const handleSearch = async (overrideQuery?: string) => {
    const searchQuery = overrideQuery ?? query;
    if (!searchQuery.trim() && filterTagIds.length === 0) {
      alert("ê²€ìƒ‰ì–´ ë˜ëŠ” íƒœê·¸ë¥¼ ì„ íƒí•˜ì„¸ìš”");
      return;
    }

    setLoading(true);
    setHasSearched(true);

    try {
      const params = new URLSearchParams();
      if (searchQuery.trim()) params.set("q", searchQuery.trim());
      if (filterType !== "ALL") params.set("type", filterType);
      if (filterMimeType) params.set("mimeType", filterMimeType);
      if (filterTagIds.length > 0) params.set("tags", filterTagIds.join(","));
      if (filterDateFrom) params.set("dateFrom", filterDateFrom);
      if (filterDateTo) params.set("dateTo", filterDateTo);

      const res = await fetch(`/api/search?${params}`);
      if (res.ok) {
        const data = await res.json();
        setResults(data);
      }
    } catch {
      alert("ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  };

  const handleResetFilters = () => {
    setFilterType("ALL");
    setFilterMimeType("");
    setFilterTagIds([]);
    setFilterDateFrom("");
    setFilterDateTo("");
  };

  const handleToggleTag = (tagId: string) => {
    setFilterTagIds((prev) =>
      prev.includes(tagId) ? prev.filter((id) => id !== tagId) : [...prev, tagId]
    );
  };

  // ê²€ìƒ‰ ì €ì¥
  const handleSaveSearch = async () => {
    if (!saveSearchName.trim()) {
      alert("ê²€ìƒ‰ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”");
      return;
    }

    try {
      const filters = JSON.stringify({
        type: filterType,
        mimeType: filterMimeType,
        tagIds: filterTagIds,
        dateFrom: filterDateFrom,
        dateTo: filterDateTo,
      });

      const res = await fetch("/api/search/saved", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name: saveSearchName.trim(), query, filters }),
      });

      if (res.ok) {
        alert("ê²€ìƒ‰ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!");
        setShowSaveModal(false);
        setSaveSearchName("");
        fetchSavedSearches();
      } else {
        alert("ì €ì¥ ì‹¤íŒ¨");
      }
    } catch {
      alert("ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    }
  };

  // ì €ì¥ëœ ê²€ìƒ‰ ë¶ˆëŸ¬ì˜¤ê¸°
  const handleLoadSavedSearch = (saved: SavedSearch) => {
    setQuery(saved.query || "");
    try {
      const filters = JSON.parse(saved.filters || "{}");
      setFilterType(filters.type || "ALL");
      setFilterMimeType(filters.mimeType || "");
      setFilterTagIds(filters.tagIds || []);
      setFilterDateFrom(filters.dateFrom || "");
      setFilterDateTo(filters.dateTo || "");
    } catch {}
    setShowSavedList(false);
    setShowFilters(true);
  };

  // ì €ì¥ëœ ê²€ìƒ‰ ì‚­ì œ
  const handleDeleteSavedSearch = async (id: string) => {
    if (!confirm("ì €ì¥ëœ ê²€ìƒ‰ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) return;
    try {
      const res = await fetch(`/api/search/saved/${id}`, { method: "DELETE" });
      if (res.ok) fetchSavedSearches();
    } catch {}
  };

  if (status === "loading") {
    return <div className="min-h-screen flex items-center justify-center">ë¡œë”© ì¤‘...</div>;
  }
  if (!session) return null;

  return (
    <div className="min-h-screen bg-gray-50">
      {/* í—¤ë” */}
      <header className="bg-white shadow">
        <div className="max-w-4xl mx-auto px-4 py-4 flex justify-between items-center">
          <h1 className="text-xl font-bold">ğŸ” ê²€ìƒ‰</h1>
          <Link href="/dashboard" className="text-sm text-blue-600 hover:text-blue-700">
            â† ëŒ€ì‹œë³´ë“œ
          </Link>
        </div>
      </header>

      <main className="max-w-4xl mx-auto px-4 py-6">

        {/* ê²€ìƒ‰ì°½ */}
        <div className="bg-white shadow rounded-lg p-5 mb-4">
          <div className="flex gap-2 mb-3">
            <input
              type="text"
              value={query}
              onChange={(e) => setQuery(e.target.value)}
              onKeyDown={(e) => e.key === "Enter" && handleSearch()}
              placeholder="íŒŒì¼ëª…, ê²Œì‹œê¸€ ì œëª©ìœ¼ë¡œ ê²€ìƒ‰..."
              className="flex-1 px-4 py-2.5 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm"
            />
            <button
              onClick={() => handleSearch()}
              disabled={loading}
              className="px-5 py-2.5 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:bg-gray-400 text-sm font-medium"
            >
              {loading ? "ê²€ìƒ‰ ì¤‘..." : "ê²€ìƒ‰"}
            </button>
          </div>

          {/* í•„í„° í† ê¸€ ë²„íŠ¼ í–‰ */}
          <div className="flex items-center gap-2">
            <button
              onClick={() => setShowFilters(!showFilters)}
              className={`flex items-center gap-1.5 px-3 py-1.5 rounded-md text-sm border transition ${
                showFilters
                  ? "bg-blue-50 border-blue-300 text-blue-700"
                  : "bg-gray-50 border-gray-300 text-gray-600 hover:bg-gray-100"
              }`}
            >
              <span>âš™ï¸ í•„í„°</span>
              {activeFilterCount > 0 && (
                <span className="bg-blue-600 text-white text-xs rounded-full w-4 h-4 flex items-center justify-center">
                  {activeFilterCount}
                </span>
              )}
            </button>

            {activeFilterCount > 0 && (
              <button
                onClick={handleResetFilters}
                className="px-3 py-1.5 text-xs text-red-500 hover:text-red-700 border border-red-200 rounded-md hover:bg-red-50"
              >
                í•„í„° ì´ˆê¸°í™”
              </button>
            )}

            <div className="ml-auto flex gap-2">
              {hasSearched && (
                <button
                  onClick={() => setShowSaveModal(true)}
                  className="px-3 py-1.5 text-xs text-green-600 border border-green-300 rounded-md hover:bg-green-50"
                >
                  ğŸ’¾ ê²€ìƒ‰ ì €ì¥
                </button>
              )}
              {savedSearches.length > 0 && (
                <button
                  onClick={() => setShowSavedList(!showSavedList)}
                  className="px-3 py-1.5 text-xs text-purple-600 border border-purple-300 rounded-md hover:bg-purple-50"
                >
                  ğŸ“‹ ì €ì¥ëœ ê²€ìƒ‰ ({savedSearches.length})
                </button>
              )}
            </div>
          </div>

          {/* í•„í„° íŒ¨ë„ */}
          {showFilters && (
            <div className="mt-4 pt-4 border-t space-y-4">

              {/* ê²€ìƒ‰ ëŒ€ìƒ */}
              <div>
                <p className="text-xs font-semibold text-gray-500 uppercase mb-2">ê²€ìƒ‰ ëŒ€ìƒ</p>
                <div className="flex gap-2">
                  {(["ALL", "FILE", "POST"] as const).map((type) => (
                    <button
                      key={type}
                      onClick={() => setFilterType(type)}
                      className={`px-3 py-1.5 text-sm rounded-full border transition ${
                        filterType === type
                          ? "bg-blue-600 text-white border-blue-600"
                          : "bg-white text-gray-600 border-gray-300 hover:bg-gray-50"
                      }`}
                    >
                      {type === "ALL" ? "ì „ì²´" : type === "FILE" ? "ğŸ“„ íŒŒì¼ë§Œ" : "ğŸ“ ê²Œì‹œê¸€ë§Œ"}
                    </button>
                  ))}
                </div>
              </div>

              {/* íŒŒì¼ íƒ€ì… í•„í„° (íŒŒì¼ ê²€ìƒ‰ ì‹œë§Œ) */}
              {(filterType === "ALL" || filterType === "FILE") && (
                <div>
                  <p className="text-xs font-semibold text-gray-500 uppercase mb-2">íŒŒì¼ íƒ€ì…</p>
                  <div className="flex flex-wrap gap-2">
                    {[
                      { label: "ì „ì²´", value: "" },
                      { label: "ğŸ–¼ï¸ ì´ë¯¸ì§€", value: "image" },
                      { label: "ğŸ“¹ ë™ì˜ìƒ", value: "video" },
                      { label: "ğŸ“„ PDF", value: "pdf" },
                      { label: "ğŸ“Š ë¬¸ì„œ", value: "document" },
                      { label: "ğŸ—œï¸ ì••ì¶•", value: "zip" },
                    ].map((opt) => (
                      <button
                        key={opt.value}
                        onClick={() => setFilterMimeType(opt.value)}
                        className={`px-3 py-1.5 text-sm rounded-full border transition ${
                          filterMimeType === opt.value
                            ? "bg-green-600 text-white border-green-600"
                            : "bg-white text-gray-600 border-gray-300 hover:bg-gray-50"
                        }`}
                      >
                        {opt.label}
                      </button>
                    ))}
                  </div>
                </div>
              )}

              {/* íƒœê·¸ í•„í„° */}
              {allTags.length > 0 && (
                <div>
                  <p className="text-xs font-semibold text-gray-500 uppercase mb-2">
                    íƒœê·¸ í•„í„°
                    {filterTagIds.length > 0 && (
                      <span className="ml-2 text-blue-600 normal-case font-normal">
                        {filterTagIds.length}ê°œ ì„ íƒë¨
                      </span>
                    )}
                  </p>
                  <div className="flex flex-wrap gap-2 max-h-24 overflow-y-auto">
                    {allTags.map((tag) => (
                      <button
                        key={tag.id}
                        onClick={() => handleToggleTag(tag.id)}
                        className={`px-3 py-1 text-sm rounded-full border transition ${
                          filterTagIds.includes(tag.id)
                            ? "bg-orange-500 text-white border-orange-500"
                            : "bg-white text-gray-600 border-gray-300 hover:bg-gray-50"
                        }`}
                      >
                        ğŸ·ï¸ {tag.name}
                      </button>
                    ))}
                  </div>
                </div>
              )}

              {/* ë‚ ì§œ í•„í„° */}
              <div>
                <p className="text-xs font-semibold text-gray-500 uppercase mb-2">ì—…ë¡œë“œ ë‚ ì§œ</p>
                <div className="flex items-center gap-2">
                  <input
                    type="date"
                    value={filterDateFrom}
                    onChange={(e) => setFilterDateFrom(e.target.value)}
                    className="px-3 py-1.5 border border-gray-300 rounded-md text-sm"
                  />
                  <span className="text-gray-400 text-sm">~</span>
                  <input
                    type="date"
                    value={filterDateTo}
                    onChange={(e) => setFilterDateTo(e.target.value)}
                    className="px-3 py-1.5 border border-gray-300 rounded-md text-sm"
                  />
                  {(filterDateFrom || filterDateTo) && (
                    <button
                      onClick={() => { setFilterDateFrom(""); setFilterDateTo(""); }}
                      className="text-xs text-red-400 hover:text-red-600"
                    >
                      âœ•
                    </button>
                  )}
                </div>
              </div>

              {/* í•„í„° ì ìš© ë²„íŠ¼ */}
              <button
                onClick={() => handleSearch()}
                className="w-full py-2 bg-blue-600 text-white rounded-md text-sm font-medium hover:bg-blue-700"
              >
                ğŸ” í•„í„° ì ìš©í•´ì„œ ê²€ìƒ‰
              </button>
            </div>
          )}

          {/* ì €ì¥ëœ ê²€ìƒ‰ ëª©ë¡ */}
          {showSavedList && savedSearches.length > 0 && (
            <div className="mt-4 pt-4 border-t">
              <p className="text-xs font-semibold text-gray-500 uppercase mb-2">ì €ì¥ëœ ê²€ìƒ‰</p>
              <div className="space-y-2 max-h-48 overflow-y-auto">
                {savedSearches.map((saved) => (
                  <div key={saved.id} className="flex items-center justify-between p-2.5 bg-gray-50 rounded-md">
                    <button
                      onClick={() => handleLoadSavedSearch(saved)}
                      className="flex-1 text-left"
                    >
                      <p className="text-sm font-medium text-blue-600 hover:text-blue-800">
                        {saved.name}
                      </p>
                      {saved.query && (
                        <p className="text-xs text-gray-400">"{saved.query}"</p>
                      )}
                    </button>
                    <button
                      onClick={() => handleDeleteSavedSearch(saved.id)}
                      className="ml-2 text-xs text-red-400 hover:text-red-600"
                    >
                      ì‚­ì œ
                    </button>
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>

        {/* ê²€ìƒ‰ ê²°ê³¼ */}
        {hasSearched && !loading && (
          <div className="bg-white shadow rounded-lg p-5">
            {results.total === 0 ? (
              <div className="text-center py-8">
                <p className="text-gray-500 text-lg mb-2">ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤</p>
                <p className="text-gray-400 text-sm">ë‹¤ë¥¸ ê²€ìƒ‰ì–´ë‚˜ í•„í„°ë¥¼ ì‚¬ìš©í•´ë³´ì„¸ìš”</p>
              </div>
            ) : (
              <>
                <div className="flex items-center justify-between mb-4">
                  <h2 className="font-semibold">
                    ê²€ìƒ‰ ê²°ê³¼{" "}
                    <span className="text-blue-600">({results.total}ê°œ)</span>
                  </h2>
                  {/* ê²°ê³¼ ìš”ì•½ */}
                  <div className="flex gap-2 text-xs text-gray-500">
                    {results.files.length > 0 && <span>ğŸ“„ íŒŒì¼ {results.files.length}ê°œ</span>}
                    {results.posts.length > 0 && <span>ğŸ“ ê²Œì‹œê¸€ {results.posts.length}ê°œ</span>}
                  </div>
                </div>

                {/* íŒŒì¼ ê²°ê³¼ */}
                {results.files.length > 0 && (
                  <div className="mb-5">
                    <h3 className="text-sm font-semibold text-gray-600 mb-2 flex items-center gap-1">
                      ğŸ“„ íŒŒì¼ ({results.files.length})
                    </h3>
                    <div className="space-y-2">
                      {results.files.map((file: any) => (
                        <div
                          key={file.id}
                          className="flex items-center gap-3 p-3 border rounded-md hover:bg-gray-50 cursor-pointer"
                          onClick={() => router.push("/dashboard")}
                        >
                          {/* ì¸ë„¤ì¼ */}
                          <div className="w-10 h-10 rounded bg-gray-100 flex-shrink-0 overflow-hidden">
                            {file.thumbnailUrl ? (
                              <img src={file.thumbnailUrl} alt="" className="w-full h-full object-cover" />
                            ) : (
                              <div className="w-full h-full flex items-center justify-center text-lg">
                                {file.mimeType?.startsWith("image/") ? "ğŸ–¼ï¸" :
                                 file.mimeType?.startsWith("video/") ? "ğŸ¥" :
                                 file.mimeType === "application/pdf" ? "ğŸ“•" : "ğŸ“„"}
                              </div>
                            )}
                          </div>
                          <div className="flex-1 min-w-0">
                            <p className="font-medium text-sm truncate">{file.originalName}</p>
                            <div className="flex items-center gap-2 mt-0.5">
                              <span className="text-xs text-gray-400">
                                {(parseInt(file.size) / 1024 / 1024).toFixed(2)} MB
                              </span>
                              <span className="text-xs text-gray-300">â€¢</span>
                              <span className="text-xs text-gray-400">
                                {new Date(file.createdAt).toLocaleDateString("ko-KR")}
                              </span>
                              {/* íƒœê·¸ í‘œì‹œ */}
                              {file.fileTags?.map((ft: any) => (
                                <span key={ft.tag.id} className="px-1.5 py-0.5 text-xs bg-blue-100 text-blue-600 rounded-full">
                                  {ft.tag.name}
                                </span>
                              ))}
                            </div>
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}

                {/* ê²Œì‹œê¸€ ê²°ê³¼ */}
                {results.posts.length > 0 && (
                  <div>
                    <h3 className="text-sm font-semibold text-gray-600 mb-2 flex items-center gap-1">
                      ğŸ“ ê²Œì‹œê¸€ ({results.posts.length})
                    </h3>
                    <div className="space-y-2">
                      {results.posts.map((post: any) => (
                        <Link
                          key={post.id}
                          href={`/posts/${post.id}`}
                          className="block p-3 border rounded-md hover:bg-gray-50"
                        >
                          <div className="flex items-start justify-between">
                            <div className="flex-1 min-w-0">
                              <p className="font-medium text-sm">{post.title}</p>
                              <p className="text-xs text-gray-500 mt-0.5 line-clamp-1">
                                {post.content}
                              </p>
                            </div>
                            <span className={`ml-2 px-2 py-0.5 text-xs rounded-full flex-shrink-0 ${
                              post.visibility === "PUBLIC"
                                ? "bg-green-100 text-green-700"
                                : post.visibility === "SHARED"
                                ? "bg-blue-100 text-blue-700"
                                : "bg-gray-100 text-gray-600"
                            }`}>
                              {post.visibility === "PUBLIC" ? "ê³µê°œ" :
                               post.visibility === "SHARED" ? "ê³µìœ " : "ë¹„ê³µê°œ"}
                            </span>
                          </div>
                          <div className="flex items-center gap-2 mt-1">
                            <span className="text-xs text-gray-400">
                              {new Date(post.createdAt).toLocaleDateString("ko-KR")}
                            </span>
                            {post.postTags?.map((pt: any) => (
                              <span key={pt.tag.id} className="px-1.5 py-0.5 text-xs bg-orange-100 text-orange-600 rounded-full">
                                {pt.tag.name}
                              </span>
                            ))}
                          </div>
                        </Link>
                      ))}
                    </div>
                  </div>
                )}
              </>
            )}
          </div>
        )}
      </main>

      {/* ê²€ìƒ‰ ì €ì¥ ëª¨ë‹¬ */}
      {showSaveModal && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 p-4" onClick={() => setShowSaveModal(false)}>
          <div className="bg-white rounded-lg shadow-xl max-w-sm w-full p-5" onClick={(e) => e.stopPropagation()}>
            <h3 className="text-base font-semibold mb-3">ğŸ’¾ ê²€ìƒ‰ ì €ì¥</h3>
            <input
              type="text"
              value={saveSearchName}
              onChange={(e) => setSaveSearchName(e.target.value)}
              onKeyDown={(e) => e.key === "Enter" && handleSaveSearch()}
              placeholder="ì €ì¥í•  ê²€ìƒ‰ ì´ë¦„ (ì˜ˆ: íƒœêµ­ì—¬í–‰ ì´ë¯¸ì§€)"
              className="w-full px-3 py-2 border rounded-md text-sm mb-3"
              autoFocus
            />
            <div className="text-xs text-gray-500 mb-4 space-y-0.5">
              {query && <p>ê²€ìƒ‰ì–´: "{query}"</p>}
              {filterType !== "ALL" && <p>ëŒ€ìƒ: {filterType}</p>}
              {filterMimeType && <p>íƒ€ì…: {filterMimeType}</p>}
              {filterTagIds.length > 0 && <p>íƒœê·¸: {filterTagIds.length}ê°œ</p>}
              {(filterDateFrom || filterDateTo) && <p>ë‚ ì§œ: {filterDateFrom} ~ {filterDateTo}</p>}
            </div>
            <div className="flex justify-end gap-2">
              <button onClick={() => setShowSaveModal(false)} className="px-3 py-1.5 text-sm text-gray-600 hover:bg-gray-100 rounded-md">ì·¨ì†Œ</button>
              <button onClick={handleSaveSearch} className="px-3 py-1.5 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700">ì €ì¥</button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/Breadcrumb.tsx">
"use client";

interface BreadcrumbItem {
  id: string | null;
  name: string;
}

interface BreadcrumbProps {
  path: BreadcrumbItem[];
  onNavigate: (folderId: string | null) => void;
}

export default function Breadcrumb({ path, onNavigate }: BreadcrumbProps) {
  return (
    <div className="flex items-center gap-2 text-sm text-gray-600 mb-4">
      {path.map((item, index) => (
        <div key={item.id || "root"} className="flex items-center gap-2">
          <button
            onClick={() => onNavigate(item.id)}
            className={`hover:text-blue-600 ${
              index === path.length - 1
                ? "font-semibold text-gray-900"
                : "text-gray-600"
            }`}
          >
            {item.name}
          </button>
          {index < path.length - 1 && (
            <span className="text-gray-400">/</span>
          )}
        </div>
      ))}
    </div>
  );
}
</file>

<file path="src/components/ConfirmDialog.tsx">
"use client";

import { useEffect, useRef } from "react";

interface ConfirmDialogProps {
  isOpen: boolean;
  title: string;
  message: string;
  confirmLabel?: string;
  cancelLabel?: string;
  variant?: "danger" | "default";
  onConfirm: () => void;
  onCancel: () => void;
}

export function ConfirmDialog({
  isOpen,
  title,
  message,
  confirmLabel = "í™•ì¸",
  cancelLabel = "ì·¨ì†Œ",
  variant = "default",
  onConfirm,
  onCancel,
}: ConfirmDialogProps) {
  const confirmBtnRef = useRef<HTMLButtonElement>(null);

  // ì—´ë¦´ ë•Œ í™•ì¸ ë²„íŠ¼ì— í¬ì»¤ìŠ¤
  useEffect(() => {
    if (isOpen) {
      setTimeout(() => confirmBtnRef.current?.focus(), 50);
    }
  }, [isOpen]);

  // ESC í‚¤ë¡œ ë‹«ê¸°
  useEffect(() => {
    if (!isOpen) return;
    const handle = (e: KeyboardEvent) => {
      if (e.key === "Escape") onCancel();
    };
    window.addEventListener("keydown", handle);
    return () => window.removeEventListener("keydown", handle);
  }, [isOpen, onCancel]);

  if (!isOpen) return null;

  return (
    <div
      className="fixed inset-0 z-[200] flex items-center justify-center p-4 bg-black/50 backdrop-blur-sm"
      onClick={onCancel}
    >
      <div
        className="bg-white rounded-2xl shadow-2xl w-full max-w-sm p-6 animate-in zoom-in-95 duration-150"
        onClick={(e) => e.stopPropagation()}
      >
        <h3 className="font-bold text-gray-900 text-base mb-2">{title}</h3>
        <p className="text-sm text-gray-500 mb-6">{message}</p>
        <div className="flex gap-3">
          <button
            onClick={onCancel}
            className="flex-1 py-2.5 rounded-xl border border-gray-200 text-gray-600 text-sm font-medium hover:bg-gray-50 transition"
          >
            {cancelLabel}
          </button>
          <button
            ref={confirmBtnRef}
            onClick={onConfirm}
            className={`flex-1 py-2.5 rounded-xl text-white text-sm font-bold transition ${
              variant === "danger"
                ? "bg-red-500 hover:bg-red-600"
                : "bg-blue-600 hover:bg-blue-700"
            }`}
          >
            {confirmLabel}
          </button>
        </div>
      </div>
    </div>
  );
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Hook â€” ì–´ë””ì„œë“  ê°„ë‹¨í•˜ê²Œ ì‚¬ìš©
//
// ì‚¬ìš©ë²•:
//   const { confirmDialog, openConfirm } = useConfirm();
//
//   openConfirm({
//     title: "ì‚­ì œ í™•ì¸",
//     message: "ì •ë§ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
//     variant: "danger",
//     onConfirm: () => handleDelete(id),
//   });
//
//   return <>{confirmDialog}</>
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
import { useState, useCallback } from "react";

interface OpenConfirmOptions {
  title: string;
  message: string;
  confirmLabel?: string;
  variant?: "danger" | "default";
  onConfirm: () => void;
}

export function useConfirm() {
  const [state, setState] = useState<{
    isOpen: boolean;
    title: string;
    message: string;
    confirmLabel: string;
    variant: "danger" | "default";
    onConfirm: () => void;
  }>({
    isOpen: false,
    title: "",
    message: "",
    confirmLabel: "í™•ì¸",
    variant: "default",
    onConfirm: () => {},
  });

  const openConfirm = useCallback((opts: OpenConfirmOptions) => {
    setState({
      isOpen: true,
      title: opts.title,
      message: opts.message,
      confirmLabel: opts.confirmLabel || "í™•ì¸",
      variant: opts.variant || "default",
      onConfirm: opts.onConfirm,
    });
  }, []);

  const handleConfirm = useCallback(() => {
    state.onConfirm();
    setState((s) => ({ ...s, isOpen: false }));
  }, [state]);

  const handleCancel = useCallback(() => {
    setState((s) => ({ ...s, isOpen: false }));
  }, []);

  const confirmDialog = (
    <ConfirmDialog
      isOpen={state.isOpen}
      title={state.title}
      message={state.message}
      confirmLabel={state.confirmLabel}
      variant={state.variant}
      onConfirm={handleConfirm}
      onCancel={handleCancel}
    />
  );

  return { confirmDialog, openConfirm };
}
</file>

<file path="src/components/FileDropZone.tsx">
"use client";

import { useState, DragEvent } from "react";

interface FileDropZoneProps {
  onFileSelect: (file: File) => void;
  uploading: boolean;
}

export default function FileDropZone({ onFileSelect, uploading }: FileDropZoneProps) {
  const [isDragging, setIsDragging] = useState(false);

  const handleDragEnter = (e: DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(true);
  };

  const handleDragLeave = (e: DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);
  };

  const handleDragOver = (e: DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
  };

  const handleDrop = (e: DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);

    const files = Array.from(e.dataTransfer.files);
    if (files.length > 0) {
      onFileSelect(files[0]);
    }
  };

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (files && files.length > 0) {
      onFileSelect(files[0]);
    }
  };

  return (
    <div
      className={`relative border-2 border-dashed rounded-lg p-8 text-center transition ${
        isDragging
          ? "border-blue-500 bg-blue-50"
          : "border-gray-300 bg-gray-50 hover:border-gray-400"
      } ${uploading ? "opacity-50 pointer-events-none" : ""}`}
      onDragEnter={handleDragEnter}
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
    >
      <input
        type="file"
        onChange={handleFileChange}
        disabled={uploading}
        className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
      />

      <div className="pointer-events-none">
        <div className="text-4xl mb-4">
          {uploading ? "â³" : "ğŸ“¤"}
        </div>
        <p className="text-lg font-medium text-gray-700 mb-2">
          {uploading ? "ì—…ë¡œë“œ ì¤‘..." : "íŒŒì¼ì„ ë“œë˜ê·¸í•˜ê±°ë‚˜ í´ë¦­í•˜ì„¸ìš”"}
        </p>
        <p className="text-sm text-gray-500">
          ì´ë¯¸ì§€, ë™ì˜ìƒ, ë¬¸ì„œ (ìµœëŒ€ 2GB)
        </p>
      </div>
    </div>
  );
}
</file>

<file path="src/components/FileFilters.tsx">
"use client";

interface FileFiltersProps {
  fileType: string;
  onFileTypeChange: (type: string) => void;
  sortBy: string;
  onSortByChange: (sort: string) => void;
}

export default function FileFilters({
  fileType,
  onFileTypeChange,
  sortBy,
  onSortByChange,
}: FileFiltersProps) {
  return (
    <div className="flex flex-wrap gap-4 items-center">
      {/* íŒŒì¼ íƒ€ì… í•„í„° */}
      <div>
        <label className="text-sm text-gray-600 mr-2">íƒ€ì…:</label>
        <select
          value={fileType}
          onChange={(e) => onFileTypeChange(e.target.value)}
          className="px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
        >
          <option value="">ì „ì²´</option>
          <option value="image">ì´ë¯¸ì§€</option>
          <option value="video">ë™ì˜ìƒ</option>
          <option value="document">ë¬¸ì„œ</option>
        </select>
      </div>

      {/* ì •ë ¬ */}
      <div>
        <label className="text-sm text-gray-600 mr-2">ì •ë ¬:</label>
        <select
          value={sortBy}
          onChange={(e) => onSortByChange(e.target.value)}
          className="px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
        >
          <option value="createdAt-desc">ìµœì‹ ìˆœ</option>
          <option value="createdAt-asc">ì˜¤ë˜ëœìˆœ</option>
          <option value="originalName-asc">ì´ë¦„ (ê°€ë‚˜ë‹¤ìˆœ)</option>
          <option value="originalName-desc">ì´ë¦„ (ì—­ìˆœ)</option>
          <option value="size-desc">í¬ê¸° (í° ìˆœ)</option>
          <option value="size-asc">í¬ê¸° (ì‘ì€ ìˆœ)</option>
        </select>
      </div>
    </div>
  );
}
</file>

<file path="src/components/FileGridSkeleton.tsx">
export default function FileGridSkeleton({ count = 8 }: { count?: number }) {
  return (
    <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
      {Array.from({ length: count }).map((_, i) => (
        <div key={i} className="border rounded-lg overflow-hidden animate-pulse">
          <div className="aspect-square bg-gray-200" />
          <div className="p-3 space-y-2">
            <div className="h-4 bg-gray-200 rounded w-3/4" />
            <div className="h-3 bg-gray-200 rounded w-1/2" />
          </div>
        </div>
      ))}
    </div>
  );
}
</file>

<file path="src/components/FilePreviewModal.tsx">
"use client";

import { useEffect } from "react";

interface FilePreviewModalProps {
  file: {
    id: string;
    originalName: string;
    mimeType: string;
    size: string;
  } | null;
  onClose: () => void;
}

export default function FilePreviewModal({ file, onClose }: FilePreviewModalProps) {
  // ESC í‚¤ë¡œ ë‹«ê¸°
  useEffect(() => {
    const handleEsc = (e: KeyboardEvent) => {
      if (e.key === "Escape") onClose();
    };
    window.addEventListener("keydown", handleEsc);
    return () => window.removeEventListener("keydown", handleEsc);
  }, [onClose]);

  if (!file) return null;

  const isImage = file.mimeType.startsWith("image/");
  const isVideo = file.mimeType.startsWith("video/");
  const isPdf = file.mimeType.includes("pdf");

  const formatFileSize = (bytes: string) => {
    const size = parseInt(bytes);
    if (size < 1024) return `${size} B`;
    if (size < 1024 * 1024) return `${(size / 1024).toFixed(2)} KB`;
    if (size < 1024 * 1024 * 1024) return `${(size / (1024 * 1024)).toFixed(2)} MB`;
    return `${(size / (1024 * 1024 * 1024)).toFixed(2)} GB`;
  };

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-75 p-4"
      onClick={onClose}
    >
      <div
        className="relative bg-white rounded-lg shadow-xl max-w-4xl w-full max-h-[90vh] overflow-hidden"
        onClick={(e) => e.stopPropagation()}
      >
        {/* í—¤ë” */}
        <div className="flex items-center justify-between p-4 border-b">
          <div>
            <h3 className="text-lg font-semibold text-gray-900">
              {file.originalName}
            </h3>
            <p className="text-sm text-gray-500">
              {formatFileSize(file.size)} â€¢ {file.mimeType}
            </p>
          </div>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-gray-600 text-2xl font-bold"
          >
            Ã—
          </button>
        </div>

        {/* ë¯¸ë¦¬ë³´ê¸° ì˜ì—­ */}
        <div className="p-4 flex items-center justify-center bg-gray-100 min-h-[400px] max-h-[60vh] overflow-auto">
          {isImage && (
            <img
              src={`/api/files/${file.id}/download`}
              alt={file.originalName}
              className="max-w-full max-h-full object-contain"
            />
          )}

          {isVideo && (
            <video
              controls
              className="max-w-full max-h-full"
              src={`/api/files/${file.id}/download`}
            >
              ë¹„ë””ì˜¤ë¥¼ ì¬ìƒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
            </video>
          )}

          {isPdf && (
            <iframe
              src={`/api/files/${file.id}/download`}
              className="w-full h-[60vh]"
              title={file.originalName}
            />
          )}

          {!isImage && !isVideo && !isPdf && (
            <div className="text-center text-gray-500">
              <p className="text-4xl mb-4">ğŸ“„</p>
              <p>ë¯¸ë¦¬ë³´ê¸°ë¥¼ ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤</p>
              <p className="text-sm mt-2">ë‹¤ìš´ë¡œë“œí•˜ì—¬ í™•ì¸í•˜ì„¸ìš”</p>
            </div>
          )}
        </div>

        {/* í‘¸í„° */}
        <div className="flex items-center justify-end gap-2 p-4 border-t bg-gray-50">
          <a
            href={`/api/files/${file.id}/download`}
            download={file.originalName}
            className="px-4 py-2 text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 rounded-md"
          >
            ë‹¤ìš´ë¡œë“œ
          </a>
          <button
            onClick={onClose}
            className="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 hover:bg-gray-50 rounded-md"
          >
            ë‹«ê¸°
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/FileShareModal.tsx">
"use client";

import { useState, useEffect } from "react";

interface Share {
  id: string;
  sharedWith: {
    id: string;
    email: string;
    name: string;
  };
  permission: string;
  createdAt: string;
}

interface FileShareModalProps {
  fileId: string | null;
  fileName: string;
  onClose: () => void;
}

export default function FileShareModal({ fileId, fileName, onClose }: FileShareModalProps) {
  const [email, setEmail] = useState("");
  const [permission, setPermission] = useState("VIEW");
  const [shares, setShares] = useState<Share[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  // ê³µìœ  ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸°
  useEffect(() => {
    if (fileId) {
      fetchShares();
    }
  }, [fileId]);

  const fetchShares = async () => {
    if (!fileId) return;

    try {
      const res = await fetch(`/api/files/${fileId}/share`);
      if (res.ok) {
        const data = await res.json();
        setShares(data.shares);
      }
    } catch (err) {
      console.error("Failed to fetch shares:", err);
    }
  };

  // ê³µìœ  ì¶”ê°€
  const handleShare = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!fileId || !email) return;

    setLoading(true);
    setError("");

    try {
      const res = await fetch(`/api/files/${fileId}/share`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ sharedWithEmail: email, permission }),
      });

      const data = await res.json();

      if (!res.ok) {
        setError(data.error || "ê³µìœ  ì‹¤íŒ¨");
        setLoading(false);
        return;
      }

      alert("íŒŒì¼ì´ ê³µìœ ë˜ì—ˆìŠµë‹ˆë‹¤!");
      setEmail("");
      fetchShares();
    } catch (err) {
      setError("ê³µìœ  ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  };

  // ê³µìœ  ì‚­ì œ
  const handleDeleteShare = async (shareId: string) => {
    if (!fileId || !confirm("ê³µìœ ë¥¼ ì·¨ì†Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) return;

    try {
      const res = await fetch(`/api/files/${fileId}/share?shareId=${shareId}`, {
        method: "DELETE",
      });

      if (res.ok) {
        alert("ê³µìœ ê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤");
        fetchShares();
      } else {
        alert("ê³µìœ  ì·¨ì†Œ ì‹¤íŒ¨");
      }
    } catch (err) {
      alert("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    }
  };

  if (!fileId) return null;

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 p-4"
      onClick={onClose}
    >
      <div
        className="bg-white rounded-lg shadow-xl max-w-2xl w-full max-h-[80vh] overflow-hidden"
        onClick={(e) => e.stopPropagation()}
      >
        {/* í—¤ë” */}
        <div className="flex items-center justify-between p-6 border-b">
          <h3 className="text-lg font-semibold text-gray-900">
            íŒŒì¼ ê³µìœ : {fileName}
          </h3>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-gray-600 text-2xl"
          >
            Ã—
          </button>
        </div>

        {/* ë³¸ë¬¸ */}
        <div className="p-6 overflow-y-auto max-h-[60vh]">
          {/* ê³µìœ  ì¶”ê°€ í¼ */}
          <form onSubmit={handleShare} className="mb-6">
            <label className="block text-sm font-medium text-gray-700 mb-2">
              ê³µìœ í•  ì‚¬ìš©ì ì´ë©”ì¼
            </label>

            {error && (
              <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-md">
                <p className="text-sm text-red-800">{error}</p>
              </div>
            )}

            <div className="flex gap-2 mb-4">
              <input
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                placeholder="user@example.com"
                className="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                required
              />
              <select
                value={permission}
                onChange={(e) => setPermission(e.target.value)}
                className="px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                <option value="VIEW">ë³´ê¸°</option>
                <option value="EDIT">í¸ì§‘</option>
              </select>
            </div>

            <button
              type="submit"
              disabled={loading}
              className="w-full px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:bg-gray-400"
            >
              {loading ? "ê³µìœ  ì¤‘..." : "ê³µìœ í•˜ê¸°"}
            </button>
          </form>

          {/* ê³µìœ  ëª©ë¡ */}
          <div>
            <h4 className="text-sm font-semibold text-gray-900 mb-3">
              ê³µìœ  ì¤‘ì¸ ì‚¬ìš©ì ({shares.length})
            </h4>

            {shares.length === 0 ? (
              <p className="text-sm text-gray-500 text-center py-4">
                ì•„ì§ ê³µìœ ëœ ì‚¬ìš©ìê°€ ì—†ìŠµë‹ˆë‹¤
              </p>
            ) : (
              <div className="space-y-2">
                {shares.map((share) => (
                  <div
                    key={share.id}
                    className="flex items-center justify-between p-3 bg-gray-50 rounded-md"
                  >
                    <div>
                      <p className="text-sm font-medium text-gray-900">
                        {share.sharedWith.name}
                      </p>
                      <p className="text-xs text-gray-500">
                        {share.sharedWith.email}
                      </p>
                    </div>
                    <div className="flex items-center gap-2">
                      <span className="px-2 py-1 text-xs bg-blue-100 text-blue-700 rounded">
                        {share.permission === "VIEW" ? "ë³´ê¸°" : "í¸ì§‘"}
                      </span>
                      <button
                        onClick={() => handleDeleteShare(share.id)}
                        className="text-red-600 hover:text-red-800 text-sm"
                      >
                        ì·¨ì†Œ
                      </button>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>

        {/* í‘¸í„° */}
        <div className="flex justify-end p-6 border-t">
          <button
            onClick={onClose}
            className="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50"
          >
            ë‹«ê¸°
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/FolderCreateModal.tsx">
"use client";

import { useState } from "react";

interface FolderCreateModalProps {
  parentId: string | null;
  onClose: () => void;
  onSuccess: () => void;
}

export default function FolderCreateModal({ 
  parentId, 
  onClose, 
  onSuccess 
}: FolderCreateModalProps) {
  const [name, setName] = useState("");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!name.trim()) {
      setError("í´ë” ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”");
      return;
    }

    setLoading(true);
    setError("");

    try {
      const res = await fetch("/api/folders", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ 
          name: name.trim(),
          parentId 
        }),
      });

      const data = await res.json();

      if (!res.ok) {
        setError(data.error || "í´ë” ìƒì„± ì‹¤íŒ¨");
        setLoading(false);
        return;
      }

      alert("í´ë”ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!");
      onSuccess();
      onClose();

    } catch (err) {
      setError("í´ë” ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 p-4"
      onClick={onClose}
    >
      <div
        className="bg-white rounded-lg shadow-xl max-w-md w-full p-6"
        onClick={(e) => e.stopPropagation()}
      >
        <h3 className="text-lg font-semibold text-gray-900 mb-4">
          ìƒˆ í´ë” ë§Œë“¤ê¸°
        </h3>

        <form onSubmit={handleSubmit}>
          {error && (
            <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-md">
              <p className="text-sm text-red-800">{error}</p>
            </div>
          )}

          <div className="mb-4">
            <label className="block text-sm font-medium text-gray-700 mb-2">
              í´ë” ì´ë¦„
            </label>
            <input
              type="text"
              value={name}
              onChange={(e) => setName(e.target.value)}
              placeholder="ìƒˆ í´ë”"
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              autoFocus
            />
          </div>

          <div className="flex justify-end gap-2">
            <button
              type="button"
              onClick={onClose}
              className="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50"
            >
              ì·¨ì†Œ
            </button>
            <button
              type="submit"
              disabled={loading}
              className="px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700 disabled:bg-gray-400"
            >
              {loading ? "ìƒì„± ì¤‘..." : "ìƒì„±"}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}
</file>

<file path="src/components/LazyImage.tsx">
"use client";

import { useState, useEffect, useRef } from "react";

interface LazyImageProps {
  src: string;
  alt: string;
  className?: string;
}

export default function LazyImage({ src, alt, className = "" }: LazyImageProps) {
  const [isLoaded, setIsLoaded] = useState(false);
  const [isInView, setIsInView] = useState(false);
  const imgRef = useRef<HTMLImageElement>(null);

  useEffect(() => {
    if (!imgRef.current) return;

    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsInView(true);
          observer.disconnect();
        }
      },
      { rootMargin: "50px" }
    );

    observer.observe(imgRef.current);

    return () => observer.disconnect();
  }, []);

  return (
    <div className={`relative ${className}`} ref={imgRef}>
      {!isLoaded && (
        <div className="absolute inset-0 bg-gray-200 animate-pulse" />
      )}
      {isInView && (
        <img
          src={src}
          alt={alt}
          className={`${className} ${isLoaded ? "opacity-100" : "opacity-0"} transition-opacity duration-300`}
          onLoad={() => setIsLoaded(true)}
          onError={(e) => {
            e.currentTarget.style.display = "none";
          }}
        />
      )}
    </div>
  );
}
</file>

<file path="src/components/Notificationsettings.tsx">
"use client";

import { useState, useEffect } from "react";
import { registerFCMToken, unregisterFCMToken } from "@/lib/firebase";

export default function NotificationSettings() {
  const [notificationsEnabled, setNotificationsEnabled] = useState(false);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    // ì•Œë¦¼ ê¶Œí•œ ìƒíƒœ í™•ì¸
    if ("Notification" in window) {
      setNotificationsEnabled(Notification.permission === "granted");
    }
  }, []);

  const handleToggle = async () => {
    if (notificationsEnabled) {
      // ì•Œë¦¼ ë¹„í™œì„±í™”
      setLoading(true);
      await unregisterFCMToken();
      setNotificationsEnabled(false);
      setLoading(false);
    } else {
      // ì•Œë¦¼ í™œì„±í™”
      setLoading(true);
      const success = await registerFCMToken();
      setNotificationsEnabled(success);
      setLoading(false);

      if (!success) {
        alert("ì•Œë¦¼ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”");
      }
    }
  };

  return (
    <div className="bg-white shadow rounded-lg p-6">
      <h3 className="text-lg font-semibold mb-4">ğŸ“¬ ì•Œë¦¼ ì„¤ì •</h3>
      
      <div className="flex items-center justify-between">
        <div>
          <p className="font-medium">í‘¸ì‹œ ì•Œë¦¼</p>
          <p className="text-sm text-gray-500">
            ìƒˆ ë©”ì‹œì§€ì™€ í†µí™” ìš”ì²­ì„ ì•Œë¦¼ìœ¼ë¡œ ë°›ìŠµë‹ˆë‹¤
          </p>
        </div>
        
        <button
          onClick={handleToggle}
          disabled={loading}
          className={`relative inline-flex h-8 w-14 items-center rounded-full transition ${
            notificationsEnabled ? "bg-blue-600" : "bg-gray-300"
          } ${loading ? "opacity-50 cursor-not-allowed" : "cursor-pointer"}`}
        >
          <span
            className={`inline-block h-6 w-6 transform rounded-full bg-white transition ${
              notificationsEnabled ? "translate-x-7" : "translate-x-1"
            }`}
          />
        </button>
      </div>

      {notificationsEnabled && (
        <div className="mt-4 p-3 bg-green-50 border border-green-200 rounded-md">
          <p className="text-sm text-green-800">
            âœ… ì•Œë¦¼ì´ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ì•±ì„ ë‹«ì•„ë„ ìƒˆ ë©”ì‹œì§€ ì•Œë¦¼ì„ ë°›ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
          </p>
        </div>
      )}

      {!notificationsEnabled && "Notification" in window && (
        <div className="mt-4 p-3 bg-yellow-50 border border-yellow-200 rounded-md">
          <p className="text-sm text-yellow-800">
            âš ï¸ ì•Œë¦¼ì´ ë¹„í™œì„±í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ì•±ì„ ë‹«ìœ¼ë©´ ë©”ì‹œì§€ ì•Œë¦¼ì„ ë°›ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
          </p>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/PostShareModal.tsx">
"use client";

import { useState, useEffect } from "react";

interface Share {
  id: string;
  sharedWith: {
    id: string;
    email: string;
    name: string;
  };
  permission: string;
  createdAt: string;
}

interface PostShareModalProps {
  postId: string | null;
  postTitle: string;
  onClose: () => void;
}

export default function PostShareModal({ postId, postTitle, onClose }: PostShareModalProps) {
  const [email, setEmail] = useState("");
  const [permission, setPermission] = useState("VIEW");
  const [shares, setShares] = useState<Share[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  // ê³µìœ  ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸°
  useEffect(() => {
    if (postId) {
      fetchShares();
    }
  }, [postId]);

  const fetchShares = async () => {
    if (!postId) return;

    try {
      const res = await fetch(`/api/posts/${postId}/share`);
      if (res.ok) {
        const data = await res.json();
        setShares(data.shares);
      }
    } catch (err) {
      console.error("Failed to fetch shares:", err);
    }
  };

  // ê³µìœ  ì¶”ê°€
  const handleShare = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!postId || !email) return;

    setLoading(true);
    setError("");

    try {
      const res = await fetch(`/api/posts/${postId}/share`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ sharedWithEmail: email, permission }),
      });

      const data = await res.json();

      if (!res.ok) {
        setError(data.error || "ê³µìœ  ì‹¤íŒ¨");
        setLoading(false);
        return;
      }

      alert("ê²Œì‹œê¸€ì´ ê³µìœ ë˜ì—ˆìŠµë‹ˆë‹¤!");
      setEmail("");
      fetchShares();
    } catch (err) {
      setError("ê³µìœ  ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  };

  // ê³µìœ  ì‚­ì œ
  const handleDeleteShare = async (shareId: string) => {
    if (!postId || !confirm("ê³µìœ ë¥¼ ì·¨ì†Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) return;

    try {
      const res = await fetch(`/api/posts/${postId}/share?shareId=${shareId}`, {
        method: "DELETE",
      });

      if (res.ok) {
        alert("ê³µìœ ê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤");
        fetchShares();
      } else {
        alert("ê³µìœ  ì·¨ì†Œ ì‹¤íŒ¨");
      }
    } catch (err) {
      alert("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    }
  };

  if (!postId) return null;

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 p-4"
      onClick={onClose}
    >
      <div
        className="bg-white rounded-lg shadow-xl max-w-2xl w-full max-h-[80vh] overflow-hidden"
        onClick={(e) => e.stopPropagation()}
      >
        {/* í—¤ë” */}
        <div className="flex items-center justify-between p-6 border-b">
          <h3 className="text-lg font-semibold text-gray-900">
            ê²Œì‹œê¸€ ê³µìœ : {postTitle}
          </h3>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-gray-600 text-2xl"
          >
            Ã—
          </button>
        </div>

        {/* ë³¸ë¬¸ */}
        <div className="p-6 overflow-y-auto max-h-[60vh]">
          {/* ì•ˆë‚´ ë©”ì‹œì§€ */}
          <div className="mb-6 p-4 bg-blue-50 border border-blue-200 rounded-md">
            <p className="text-sm text-blue-800">
              ğŸ’¡ ì´ë©”ì¼ì„ ì…ë ¥í•˜ì—¬ íŠ¹ì • ì‚¬ìš©ìì—ê²Œë§Œ ê²Œì‹œê¸€ì„ ê³µìœ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
              <br />
              ê³µìœ ë°›ì€ ì‚¬ìš©ìëŠ” ìì‹ ì˜ ê²Œì‹œíŒì—ì„œ ì´ ê¸€ì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
            </p>
          </div>

          {/* ê³µìœ  ì¶”ê°€ í¼ */}
          <form onSubmit={handleShare} className="mb-6">
            <label className="block text-sm font-medium text-gray-700 mb-2">
              ê³µìœ í•  ì‚¬ìš©ì ì´ë©”ì¼
            </label>

            {error && (
              <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-md">
                <p className="text-sm text-red-800">{error}</p>
              </div>
            )}

            <div className="flex gap-2 mb-4">
              <input
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                placeholder="user@example.com"
                className="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                required
              />
              <select
                value={permission}
                onChange={(e) => setPermission(e.target.value)}
                className="px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                <option value="VIEW">ë³´ê¸°</option>
                <option value="EDIT">í¸ì§‘</option>
              </select>
            </div>

            <button
              type="submit"
              disabled={loading}
              className="w-full px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:bg-gray-400"
            >
              {loading ? "ê³µìœ  ì¤‘..." : "ê³µìœ í•˜ê¸°"}
            </button>
          </form>

          {/* ê³µìœ  ëª©ë¡ */}
          <div>
            <h4 className="text-sm font-semibold text-gray-900 mb-3">
              ê³µìœ  ì¤‘ì¸ ì‚¬ìš©ì ({shares.length})
            </h4>

            {shares.length === 0 ? (
              <p className="text-sm text-gray-500 text-center py-4">
                ì•„ì§ ê³µìœ ëœ ì‚¬ìš©ìê°€ ì—†ìŠµë‹ˆë‹¤
              </p>
            ) : (
              <div className="space-y-2">
                {shares.map((share) => (
                  <div
                    key={share.id}
                    className="flex items-center justify-between p-3 bg-gray-50 rounded-md"
                  >
                    <div>
                      <p className="text-sm font-medium text-gray-900">
                        {share.sharedWith.name}
                      </p>
                      <p className="text-xs text-gray-500">
                        {share.sharedWith.email}
                      </p>
                    </div>
                    <div className="flex items-center gap-2">
                      <span className="px-2 py-1 text-xs bg-blue-100 text-blue-700 rounded">
                        {share.permission === "VIEW" ? "ë³´ê¸°" : "í¸ì§‘"}
                      </span>
                      <button
                        onClick={() => handleDeleteShare(share.id)}
                        className="text-red-600 hover:text-red-800 text-sm"
                      >
                        ì·¨ì†Œ
                      </button>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>

        {/* í‘¸í„° */}
        <div className="flex justify-end p-6 border-t">
          <button
            onClick={onClose}
            className="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50"
          >
            ë‹«ê¸°
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/SearchBar.tsx">
"use client";

import { useState } from "react";

interface SearchBarProps {
  onSearch: (query: string) => void;
  placeholder?: string;
}

export default function SearchBar({ onSearch, placeholder = "ê²€ìƒ‰..." }: SearchBarProps) {
  const [query, setQuery] = useState("");

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    onSearch(query);
  };

  return (
    <form onSubmit={handleSubmit} className="flex gap-2">
      <input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder={placeholder}
        className="flex-1 px-4 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
      />
      <button
        type="submit"
        className="px-6 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
      >
        ê²€ìƒ‰
      </button>
      {query && (
        <button
          type="button"
          onClick={() => {
            setQuery("");
            onSearch("");
          }}
          className="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300"
        >
          ì´ˆê¸°í™”
        </button>
      )}
    </form>
  );
}
</file>

<file path="src/components/TagInput.tsx">
"use client";

import { useState, useEffect } from "react";

interface Tag {
  id: string;
  name: string;
  color?: string;
}

interface TagInputProps {
  resourceId: string;
  resourceType: "file" | "post";
  onTagsChange?: () => void;
}

export default function TagInput({
  resourceId,
  resourceType,
  onTagsChange,
}: TagInputProps) {
  const [tags, setTags] = useState<Tag[]>([]);
  const [allTags, setAllTags] = useState<Tag[]>([]);
  const [inputValue, setInputValue] = useState("");
  const [suggestions, setSuggestions] = useState<Tag[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    fetchTags();
    fetchAllTags();
  }, [resourceId]);

  // í˜„ì¬ íƒœê·¸ ì¡°íšŒ
  const fetchTags = async () => {
    try {
      const res = await fetch(`/api/${resourceType}s/${resourceId}/tags`);
      if (res.ok) {
        const data = await res.json();
        setTags(data.tags || []);
      }
    } catch (err) {
      console.error("Failed to fetch tags:", err);
    }
  };

  // ì „ì²´ íƒœê·¸ ëª©ë¡ ì¡°íšŒ
  const fetchAllTags = async () => {
    try {
      const res = await fetch("/api/tags");
      if (res.ok) {
        const data = await res.json();
        setAllTags(data.tags || []);
      }
    } catch (err) {
      console.error("Failed to fetch all tags:", err);
    }
  };

  // íƒœê·¸ ì¶”ê°€
  const handleAddTag = async (tagName: string) => {
    if (!tagName.trim()) return;

    setLoading(true);
    try {
      const res = await fetch(`/api/${resourceType}s/${resourceId}/tags`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ tagName: tagName.trim() }),
      });

      if (res.ok) {
        await fetchTags();
        setInputValue("");
        setSuggestions([]);
        onTagsChange?.();
      } else {
        const data = await res.json();
        alert(data.error || "íƒœê·¸ ì¶”ê°€ ì‹¤íŒ¨");
      }
    } catch (err) {
      alert("íƒœê·¸ ì¶”ê°€ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  };

  // íƒœê·¸ ì œê±°
  const handleRemoveTag = async (tagId: string) => {
    setLoading(true);
    try {
      const res = await fetch(
        `/api/${resourceType}s/${resourceId}/tags?tagId=${tagId}`,
        { method: "DELETE" }
      );

      if (res.ok) {
        await fetchTags();
        onTagsChange?.();
      } else {
        alert("íƒœê·¸ ì œê±° ì‹¤íŒ¨");
      }
    } catch (err) {
      alert("íƒœê·¸ ì œê±° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  };

  // ì…ë ¥ê°’ ë³€ê²½ ì‹œ ìë™ì™„ì„±
  const handleInputChange = (value: string) => {
    setInputValue(value);

    if (value.trim()) {
      const filtered = allTags.filter(
        (tag) =>
          tag.name.toLowerCase().includes(value.toLowerCase()) &&
          !tags.some((t) => t.id === tag.id)
      );
      setSuggestions(filtered.slice(0, 5));
    } else {
      setSuggestions([]);
    }
  };

  // Enterë¡œ íƒœê·¸ ì¶”ê°€
  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === "Enter") {
      e.preventDefault();
      handleAddTag(inputValue);
    }
  };

  return (
    <div className="space-y-3">
      {/* í˜„ì¬ íƒœê·¸ */}
      <div className="flex flex-wrap gap-2">
        {tags.map((tag) => (
          <span
            key={tag.id}
            className="inline-flex items-center gap-1 px-3 py-1 bg-blue-100 text-blue-800 text-sm rounded-full"
          >
            #{tag.name}
            <button
              onClick={() => handleRemoveTag(tag.id)}
              disabled={loading}
              className="hover:text-blue-900 disabled:opacity-50"
            >
              Ã—
            </button>
          </span>
        ))}
      </div>

      {/* íƒœê·¸ ì…ë ¥ */}
      <div className="relative">
        <input
          type="text"
          value={inputValue}
          onChange={(e) => handleInputChange(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder="íƒœê·¸ ì…ë ¥ í›„ Enter"
          className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
          disabled={loading}
        />

        {/* ìë™ì™„ì„± */}
        {suggestions.length > 0 && (
          <div className="absolute z-10 w-full mt-1 bg-white border border-gray-300 rounded-md shadow-lg">
            {suggestions.map((tag) => (
              <button
                key={tag.id}
                onClick={() => {
                  handleAddTag(tag.name);
                }}
                className="w-full px-3 py-2 text-left hover:bg-gray-100 text-sm"
              >
                #{tag.name}
              </button>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/components/Toast.tsx">
"use client";

import { useEffect, useState, useCallback } from "react";
import { createPortal } from "react-dom";

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// íƒ€ì…
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export type ToastType = "success" | "error" | "info" | "warning";

interface Toast {
  id: string;
  message: string;
  type: ToastType;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ì „ì—­ Toast ì´ë²¤íŠ¸ (ì–´ë””ì„œë“  í˜¸ì¶œ ê°€ëŠ¥)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
type ToastListener = (toast: Omit<Toast, "id">) => void;
let listener: ToastListener | null = null;

export const toast = {
  success: (message: string) => listener?.({ message, type: "success" }),
  error: (message: string) => listener?.({ message, type: "error" }),
  info: (message: string) => listener?.({ message, type: "info" }),
  warning: (message: string) => listener?.({ message, type: "warning" }),
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ToastContainer â€” layout.tsxì— ì¶”ê°€
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function ToastContainer() {
  const [toasts, setToasts] = useState<Toast[]>([]);
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  const addToast = useCallback((t: Omit<Toast, "id">) => {
    const id = Math.random().toString(36).slice(2);
    setToasts((prev) => [...prev, { ...t, id }]);
    setTimeout(() => {
      setToasts((prev) => prev.filter((toast) => toast.id !== id));
    }, 3500);
  }, []);

  useEffect(() => {
    listener = addToast;
    return () => {
      listener = null;
    };
  }, [addToast]);

  if (!mounted) return null;

  const icons: Record<ToastType, string> = {
    success: "âœ“",
    error: "âœ•",
    info: "â„¹",
    warning: "âš ",
  };

  const colors: Record<ToastType, string> = {
    success: "bg-green-500",
    error: "bg-red-500",
    info: "bg-blue-500",
    warning: "bg-yellow-500",
  };

  return createPortal(
    <div className="fixed top-4 right-4 z-[9999] flex flex-col gap-2 pointer-events-none">
      {toasts.map((t) => (
        <div
          key={t.id}
          className={`
            flex items-center gap-3 px-4 py-3 rounded-xl shadow-lg text-white
            text-sm font-medium max-w-xs pointer-events-auto
            animate-in slide-in-from-right duration-300
            ${colors[t.type]}
          `}
        >
          <span className="text-base font-bold">{icons[t.type]}</span>
          <span>{t.message}</span>
        </div>
      ))}
    </div>,
    document.body
  );
}
</file>

<file path="src/components/UploadProgress.tsx">
"use client";

interface UploadProgressProps {
  fileName: string;
  progress: number;
  onCancel?: () => void;
}

export default function UploadProgress({ fileName, progress, onCancel }: UploadProgressProps) {
  return (
    <div className="bg-white border border-gray-200 rounded-lg p-4 shadow-sm">
      <div className="flex items-center justify-between mb-2">
        <div className="flex-1 mr-4">
          <p className="text-sm font-medium text-gray-900 truncate">{fileName}</p>
          <p className="text-xs text-gray-500">{progress}% ì™„ë£Œ</p>
        </div>
        {onCancel && (
          <button
            onClick={onCancel}
            className="text-gray-400 hover:text-gray-600"
          >
            âœ•
          </button>
        )}
      </div>
      <div className="w-full bg-gray-200 rounded-full h-2">
        <div
          className="bg-blue-600 h-2 rounded-full transition-all duration-300"
          style={{ width: `${progress}%` }}
        />
      </div>
    </div>
  );
}
</file>

<file path="src/hooks/useInfiniteScroll.ts">
import { useEffect, useRef, useState } from "react";

interface UseInfiniteScrollProps {
  fetchMore: () => Promise<void>;
  hasMore: boolean;
  loading: boolean;
}

export function useInfiniteScroll({ fetchMore, hasMore, loading }: UseInfiniteScrollProps) {
  const observerRef = useRef<HTMLDivElement>(null);
  const [isFetching, setIsFetching] = useState(false);

  useEffect(() => {
    if (!observerRef.current || loading || !hasMore) return;

    const observer = new IntersectionObserver(
      async ([entry]) => {
        if (entry.isIntersecting && !isFetching) {
          setIsFetching(true);
          await fetchMore();
          setIsFetching(false);
        }
      },
      { rootMargin: "100px" }
    );

    observer.observe(observerRef.current);

    return () => observer.disconnect();
  }, [fetchMore, hasMore, loading, isFetching]);

  return observerRef;
}
</file>

<file path="src/lib/db.ts">
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
  });

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;

export default prisma;
</file>

<file path="src/lib/demo-mode.ts">
/**
 * ë°ëª¨ ëª¨ë“œ ì„¤ì •
 * ì•±ìŠ¤í† ì–´ ì‹¬ì‚¬ìš© ë°ëª¨ ê³„ì • ë° ìƒ˜í”Œ ë°ì´í„°
 */

export const DEMO_MODE = process.env.NEXT_PUBLIC_DEMO_MODE === 'true';

// ì‹¬ì‚¬ê´€ìš© ë°ëª¨ ê³„ì •
export const DEMO_USERS = [
  {
    id: 'demo-reviewer-001',
    email: 'reviewer@appstore.com',
    password: 'Demo2024!Review',
    name: 'App Store Reviewer',
    role: 'USER' as const,
  },
  {
    id: 'demo-user-001',
    email: 'testuser@demo.com',
    password: 'Demo2024!Test',
    name: 'Test User',
    role: 'USER' as const,
  },
];

// ë°ëª¨ ìœ ì €ì¸ì§€ í™•ì¸
export function isDemoUser(email: string): boolean {
  return DEMO_USERS.some((user) => user.email === email);
}

// ë°ëª¨ ê³„ì • ì •ë³´ ê°€ì ¸ì˜¤ê¸°
export function getDemoUser(email: string) {
  return DEMO_USERS.find((user) => user.email === email);
}
</file>

<file path="src/lib/email.ts">
import nodemailer from "nodemailer";

interface EmailOptions {
  to: string;
  subject: string;
  html: string;
}

export async function sendEmail({ to, subject, html }: EmailOptions) {
  const transporter = nodemailer.createTransport({
    service: "gmail",
    auth: {
      user: process.env.EMAIL_USER,
      pass: process.env.EMAIL_PASS,
    },
  });

  await transporter.sendMail({
    from: `"ì´ìŒ (Eum)" <${process.env.EMAIL_USER}>`,
    to,
    subject,
    html,
  });
}
</file>

<file path="src/lib/rate-limit.ts">
import { NextRequest } from "next/server";

interface RateLimitStore {
  [key: string]: {
    count: number;
    resetTime: number;
  };
}

const store: RateLimitStore = {};

export function rateLimit(
  limit: number = 100, // ìš”ì²­ íšŸìˆ˜
  windowMs: number = 60 * 1000 // ì‹œê°„ ìœˆë„ìš° (1ë¶„)
) {
  return async (request: NextRequest): Promise<{ success: boolean; remaining: number }> => {
    // IP ì£¼ì†Œ ë˜ëŠ” ì‚¬ìš©ì IDë¡œ ì‹ë³„
    const identifier = request.headers.get("x-forwarded-for") || 
                      request.headers.get("x-real-ip") || 
                      "unknown";
    
    const now = Date.now();
    const record = store[identifier];

    // ì²« ìš”ì²­ì´ê±°ë‚˜ ìœˆë„ìš°ê°€ ë§Œë£Œëœ ê²½ìš°
    if (!record || now > record.resetTime) {
      store[identifier] = {
        count: 1,
        resetTime: now + windowMs,
      };
      return { success: true, remaining: limit - 1 };
    }

    // ì œí•œ ì´ˆê³¼
    if (record.count >= limit) {
      return { success: false, remaining: 0 };
    }

    // ì¹´ìš´íŠ¸ ì¦ê°€
    record.count++;
    return { success: true, remaining: limit - record.count };
  };
}

// ì£¼ê¸°ì ìœ¼ë¡œ ë§Œë£Œëœ í•­ëª© ì •ë¦¬
setInterval(() => {
  const now = Date.now();
  for (const key in store) {
    if (store[key].resetTime < now) {
      delete store[key];
    }
  }
}, 60 * 1000); // 1ë¶„ë§ˆë‹¤
</file>

<file path="src/lib/sanitize.ts">
/**
 * XSS ë°©ì§€ë¥¼ ìœ„í•œ HTML ì´ìŠ¤ì¼€ì´í”„
 */
export function escapeHtml(text: string): string {
  const map: { [key: string]: string } = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;',
  };
  
  return text.replace(/[&<>"']/g, (char) => map[char]);
}

/**
 * íŒŒì¼ëª… sanitize (ê²½ë¡œ ì¡°ì‘ ë°©ì§€)
 */
export function sanitizeFilename(filename: string): string {
  // ìœ„í—˜í•œ ë¬¸ì ì œê±°
  return filename
    .replace(/[\/\\]/g, '_')      // ìŠ¬ë˜ì‹œ ì œê±°
    .replace(/\.\./g, '_')         // ìƒìœ„ ë””ë ‰í† ë¦¬ ì ‘ê·¼ ë°©ì§€
    .replace(/[<>:"|?*]/g, '_')    // íŒŒì¼ì‹œìŠ¤í…œ ì˜ˆì•½ ë¬¸ì
    .slice(0, 255);                // ê¸¸ì´ ì œí•œ
}

/**
 * URL íŒŒë¼ë¯¸í„° ê²€ì¦
 */
export function validateUrlParam(param: string, type: 'id' | 'email' | 'string'): boolean {
  switch (type) {
    case 'id':
      // CUID í˜•ì‹ ê²€ì¦
      return /^c[a-z0-9]{24}$/.test(param);
    case 'email':
      return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(param);
    case 'string':
      return param.length > 0 && param.length <= 1000;
    default:
      return false;
  }
}
</file>

<file path="src/types/next-auth.d.ts">
import { DefaultSession } from "next-auth";

declare module "next-auth" {
  interface Session {
    user: {
      id: string;
      role: string;
    } & DefaultSession["user"];
  }

  interface User {
    id: string;
    email: string;
    name: string;
    role: string;
  }
}

declare module "next-auth/jwt" {
  interface JWT {
    id: string;
    role: string;
  }
}
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#f0f9ff',
          100: '#e0f2fe',
          500: '#0ea5e9',
          600: '#0284c7',
          700: '#0369a1',
        },
      },
    },
  },
  plugins: [],
}
</file>

<file path=".gitignore">
node_modules/
.next/
.env
.env.local
.env.production
storage/
*.log

# repomix
#repomix-output.xml
#repomix-output.txt

# ë°±ì—… íŒŒì¼
*.backup
*.backup-*
</file>

<file path="public/firebase-messaging-sw.js">
// Firebase Cloud Messaging Service Worker
importScripts('https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js');
importScripts('https://www.gstatic.com/firebasejs/9.0.0/firebase-messaging-compat.js');

// âœ… ì…ë ¥í•˜ì‹  Firebase ì„¤ì •ê°’ ì ìš©
const firebaseConfig = {
  apiKey: "AIzaSyDX5C589FJTRt7eSEEyBTYOhy3zOt61rww",
  authDomain: "personal-cloud-ca830.firebaseapp.com",
  projectId: "personal-cloud-ca830",
  storageBucket: "personal-cloud-ca830.firebasestorage.app",
  messagingSenderId: "531266228781",
  appId: "1:531266228781:web:7d2debc260ee30b1285ea4"
};

firebase.initializeApp(firebaseConfig);
const messaging = firebase.messaging();

// ë°±ê·¸ë¼ìš´ë“œ ë©”ì‹œì§€ ìˆ˜ì‹ 
messaging.onBackgroundMessage((payload) => {
  console.log('[sw.js] ë°±ê·¸ë¼ìš´ë“œ ë©”ì‹œì§€:', payload);

  const notificationTitle = payload.notification?.title || 'ìƒˆ ë©”ì‹œì§€';
  const notificationOptions = {
    body: payload.notification?.body || '',
    icon: '/icon-192x192.png',
    badge: '/badge-72x72.png',
    data: payload.data,
    // ë™ì¼ ì±„íŒ…ë°© ì•Œë¦¼ì€ í•˜ë‚˜ë¡œ ë¬¶ì–´ ì‚¬ìš©ì í”¼ë¡œë„ë¥¼ ì¤„ì„
    tag: payload.data?.chatRoomId || 'default',
    renotify: true,
    vibrate: [200, 100, 200],
  };

  // í†µí™” ì•Œë¦¼(incoming_call) ë˜ëŠ” í˜¸ì¶œ ìš”ì²­(call_request) ì²˜ë¦¬
  if (payload.data?.type === 'incoming_call' || payload.data?.type === 'call_request') {
    notificationOptions.requireInteraction = true; // ì‚¬ìš©ìê°€ ì‘ë‹µí•  ë•Œê¹Œì§€ ìœ ì§€
    notificationOptions.actions = [
      { action: 'accept', title: 'âœ… ìˆ˜ë½' },
      { action: 'reject', title: 'âŒ ê±°ì ˆ' },
    ];
    notificationOptions.vibrate = [500, 100, 500, 100, 500];
  }

  self.registration.showNotification(notificationTitle, notificationOptions);
});

// ì•Œë¦¼ í´ë¦­ ì²˜ë¦¬
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  const data = event.notification.data;

  // 1. í†µí™” ìˆ˜ë½/ê±°ì ˆ ì•¡ì…˜ ë²„íŠ¼ ì²˜ë¦¬
  if (event.action === 'accept') {
    const callUrl = `/call/${data.callId}?action=accept`;
    event.waitUntil(focusOrOpenWindow(callUrl));
    return;
  } 
  
  if (event.action === 'reject') {
    if (data.callId) {
      event.waitUntil(
        fetch('/api/calls/reject', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ callId: data.callId }),
        })
      );
    }
    return;
  }

  // 2. ì¼ë°˜ ì•Œë¦¼ í´ë¦­ ì‹œ ì´ë™ ê²½ë¡œ ì„¤ì •
  let targetUrl = '/chat';
  if (data?.chatRoomId) {
    targetUrl = `/chat/${data.chatRoomId}`;
  } else if (data?.callId) {
    targetUrl = `/call/${data.callId}`;
  }

  event.waitUntil(focusOrOpenWindow(targetUrl));
});

/**
 * ì¤‘ë³µ íƒ­ ë°©ì§€: ì´ë¯¸ ì—´ë¦° ì°½ì´ ìˆìœ¼ë©´ í¬ì»¤ìŠ¤, ì—†ìœ¼ë©´ ìƒˆ ì°½
 */
async function focusOrOpenWindow(url) {
  const windowClients = await clients.matchAll({ type: 'window', includeUncontrolled: true });
  
  for (let client of windowClients) {
    // ìƒëŒ€ ê²½ë¡œ í¬í•¨ ì—¬ë¶€ í™•ì¸
    if (client.url.includes(url) && 'focus' in client) {
      return client.focus();
    }
  }
  
  if (clients.openWindow) {
    return clients.openWindow(url);
  }
}
</file>

<file path="src/app/api/auth/register/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { hash } from "bcryptjs"; // âœ… bcrypt â†’ bcryptjs
import { z } from "zod";
import { prisma } from "@/lib/db";
import { DEMO_MODE } from "@/lib/demo-mode";

const signupSchema = z.object({
  email: z.string().email("ìœ íš¨í•œ ì´ë©”ì¼ì„ ì…ë ¥í•˜ì„¸ìš”"),
  password: z.string().min(8, "ë¹„ë°€ë²ˆí˜¸ëŠ” ìµœì†Œ 8ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤"),
  name: z.string().min(2, "ì´ë¦„ì€ ìµœì†Œ 2ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤"),
  marketingConsent: z.boolean().optional(),
});

export async function POST(request: NextRequest) {
  try {
    if (DEMO_MODE) {
      return NextResponse.json(
        {
          error: "ë°ëª¨ ëª¨ë“œì—ì„œëŠ” íšŒì›ê°€ì…ì´ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.",
          demoAccount: "reviewer@appstore.com / Demo2024!Review",
        },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validation = signupSchema.safeParse(body);

    if (!validation.success) {
      return NextResponse.json(
        { error: validation.error.errors[0].message },
        { status: 400 }
      );
    }

    const { email, password, name } = validation.data;

    const existingUser = await prisma.user.findUnique({ where: { email } });
    if (existingUser) {
      return NextResponse.json(
        { error: "ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ ì´ë©”ì¼ì…ë‹ˆë‹¤" },
        { status: 409 }
      );
    }

    const passwordHash = await hash(password, 12);

    const user = await prisma.user.create({
      data: {
        email,
        passwordHash,
        name,
        role: "USER",
        emailVerified: false,
      },
      select: {
        id: true,
        email: true,
        name: true,
        createdAt: true,
      },
    });

    return NextResponse.json(
      { message: "íšŒì›ê°€ì…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤", user },
      { status: 201 }
    );
  } catch (error) {
    console.error("Signup error:", error);
    return NextResponse.json({ error: "ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/files/shared/route.ts">
export const dynamic = 'force-dynamic';

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    // ê³µìœ ë°›ì€ íŒŒì¼ ì¡°íšŒ
    const sharedResources = await prisma.sharedResource.findMany({
      where: {
        resourceType: "FILE",
        sharedWithId: session.user.id,
      },
      include: {
        file: {
          select: {
            id: true,
            filename: true,
            originalName: true,
            size: true,
            mimeType: true,
            thumbnailUrl: true,
            createdAt: true,
            user: {
              select: {
                name: true,
                email: true,
              },
            },
          },
        },
        owner: {
          select: {
            name: true,
            email: true,
          },
        },
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    // íŒŒì¼ ì •ë³´ ë³€í™˜
    const files = sharedResources.map((share) => ({
      id: share.file?.id,
      filename: share.file?.filename,
      originalName: share.file?.originalName,
      size: share.file?.size.toString(),
      mimeType: share.file?.mimeType,
      thumbnailUrl: share.file?.thumbnailUrl,
      createdAt: share.file?.createdAt,
      sharedBy: share.owner.name,
      sharedByEmail: share.owner.email,
      permission: share.permission,
      sharedAt: share.createdAt,
    }));

    return NextResponse.json({ files });

  } catch (error) {
    console.error("Shared files fetch error:", error);
    return NextResponse.json(
      { error: "ê³µìœ  íŒŒì¼ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/files/upload/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import { writeFile, mkdir } from "fs/promises";
import { existsSync } from "fs";
import { join } from "path";
import crypto from "crypto";
import sharp from "sharp";

const STORAGE_PATH = process.env.STORAGE_PATH || "./storage";
const MAX_FILE_SIZE = parseInt(process.env.NEXT_PUBLIC_MAX_FILE_SIZE || "52428800"); // 50MB

export async function POST(request: NextRequest) {
  try {
    // 1. ì„¸ì…˜ í™•ì¸
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const formData = await request.formData();
    const file = formData.get("file") as File;
    const folderId = formData.get("folderId") as string | null;

    // 2. íŒŒì¼ ìœ íš¨ì„± ê²€ì‚¬
    if (!file) {
      return NextResponse.json({ error: "íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”" }, { status: 400 });
    }

    if (file.size > MAX_FILE_SIZE) {
      return NextResponse.json(
        { error: `íŒŒì¼ í¬ê¸°ëŠ” ${MAX_FILE_SIZE / (1024 * 1024)}MBë¥¼ ì´ˆê³¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤` },
        { status: 400 }
      );
    }

    // 3. íŒŒì¼ í•´ì‹œ ìƒì„± (ì¤‘ë³µ ì²´í¬ìš©)
    const bytes = await file.arrayBuffer();
    const buffer = Buffer.from(bytes);
    const fileHash = crypto.createHash("sha256").update(buffer).digest("hex");

    /**
     * 4. ì‹œìŠ¤í…œ ì „ì²´ ì¤‘ë³µ í™•ì¸ (Hash ê¸°ë°˜)
     * DBì˜ hash í•„ë“œì— @unique ì œì•½ì¡°ê±´ì´ ìˆìœ¼ë¯€ë¡œ, 
     * ë‹¤ë¥¸ ìœ ì €ê°€ ì˜¬ë¦° íŒŒì¼ì´ë¼ë„ í•´ì‹œê°€ ê°™ìœ¼ë©´ create ì‹œ ì—ëŸ¬ê°€ ë°œìƒí•©ë‹ˆë‹¤.
     */
    const existingFile = await prisma.file.findFirst({
      where: { hash: fileHash },
    });

    if (existingFile) {
      const isMine = existingFile.userId === session.user.id;
      return NextResponse.json(
        { 
          error: isMine 
            ? "ì´ë¯¸ ë‚´ ë³´ê´€í•¨ì— ë™ì¼í•œ íŒŒì¼ì´ ì¡´ì¬í•©ë‹ˆë‹¤." 
            : "ì´ë¯¸ ì‹œìŠ¤í…œì— ë“±ë¡ëœ ë™ì¼í•œ ë‚´ìš©ì˜ íŒŒì¼ì…ë‹ˆë‹¤.",
          existingFile: { id: existingFile.id, originalName: existingFile.originalName } 
        },
        { status: 409 } // Conflict
      );
    }

    // 5. ê³ ìœ  íŒŒì¼ëª… ë° ê²½ë¡œ ì„¤ì •
    const fileExtension = file.name.split(".").pop() || "bin";
    const uniqueFilename = `${crypto.randomUUID()}.${fileExtension}`;

    const uploadDir = join(STORAGE_PATH, "files");
    const thumbnailDir = join(STORAGE_PATH, "thumbnails");
    
    if (!existsSync(uploadDir)) await mkdir(uploadDir, { recursive: true });
    if (!existsSync(thumbnailDir)) await mkdir(thumbnailDir, { recursive: true });

    // 6. ë¬¼ë¦¬ íŒŒì¼ ì €ì¥
    const filepath = join(uploadDir, uniqueFilename);
    await writeFile(filepath, buffer);

    // 7. ì¸ë„¤ì¼ ìƒì„± (ì´ë¯¸ì§€ì¸ ê²½ìš°ë§Œ)
    let thumbnailUrl: string | null = null;
    if (file.type.startsWith("image/")) {
      try {
        const thumbnailFilename = `thumb_${uniqueFilename.replace(/\.\w+$/, ".jpg")}`;
        const thumbnailPath = join(thumbnailDir, thumbnailFilename);
        
        await sharp(buffer)
          .resize(300, 300, { fit: "cover", position: "center" })
          .jpeg({ quality: 80 })
          .toFile(thumbnailPath);
        
        thumbnailUrl = `/api/files/thumbnail/${thumbnailFilename}`;
      } catch (err) {
        console.error("Thumbnail generation failed:", err);
        // ì¸ë„¤ì¼ ì‹¤íŒ¨ëŠ” íŒŒì¼ ì—…ë¡œë“œ ìì²´ë¥¼ ì¤‘ë‹¨ì‹œí‚¤ì§€ ì•ŠìŒ
      }
    }

    /**
     * 8. DB ì €ì¥ ë° ìµœì¢… ì¤‘ë³µ ì—ëŸ¬ í•¸ë“¤ë§
     * findFirst ì´í›„ create ì§ì „ì— ë‹¤ë¥¸ ìš”ì²­ì´ ë“¤ì–´ì˜¬ ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ 
     * Prismaì˜ P2002(Unique ì œì•½ ìœ„ë°˜) ì—ëŸ¬ë¥¼ Catchí•©ë‹ˆë‹¤.
     */
    try {
      const savedFile = await prisma.file.create({
        data: {
          filename: uniqueFilename,
          originalName: file.name,
          filepath: filepath,
          size: BigInt(file.size),
          mimeType: file.type,
          hash: fileHash,
          thumbnailUrl,
          userId: session.user.id,
          folderId: folderId || null,
        },
      });

      return NextResponse.json(
        {
          message: "íŒŒì¼ì´ ì—…ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤",
          file: {
            id: savedFile.id,
            filename: savedFile.filename,
            originalName: savedFile.originalName,
            size: savedFile.size.toString(),
            mimeType: savedFile.mimeType,
            thumbnailUrl: savedFile.thumbnailUrl,
            createdAt: savedFile.createdAt,
          },
        },
        { status: 201 }
      );
    } catch (dbError: any) {
      if (dbError.code === "P2002") {
        return NextResponse.json(
          { error: "ì´ë¯¸ ì¡´ì¬í•˜ëŠ” íŒŒì¼ì…ë‹ˆë‹¤(ì¤‘ë³µ ë°ì´í„°)." },
          { status: 409 }
        );
      }
      throw dbError; // ë‹¤ë¥¸ DB ì˜¤ë¥˜ëŠ” ì™¸ë¶€ catch ë¸”ë¡ì—ì„œ ì²˜ë¦¬
    }

  } catch (error) {
    console.error("File upload error:", error);
    return NextResponse.json(
      { error: "íŒŒì¼ ì—…ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/search/route.ts">
export const dynamic = 'force-dynamic';

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const q = searchParams.get("q") || "";
    const type = searchParams.get("type") || "ALL";       // ALL | FILE | POST
    const mimeType = searchParams.get("mimeType") || "";   // image | video | pdf | document | zip
    const tagsParam = searchParams.get("tags") || "";       // "tagId1,tagId2"
    const dateFrom = searchParams.get("dateFrom") || "";
    const dateTo = searchParams.get("dateTo") || "";

    const tagIds = tagsParam ? tagsParam.split(",").filter(Boolean) : [];

    let files: any[] = [];
    let posts: any[] = [];

    // ===== íŒŒì¼ ê²€ìƒ‰ =====
    if (type === "ALL" || type === "FILE") {
      const fileWhere: any = {
        userId: session.user.id,
      };

      // í‚¤ì›Œë“œ
      if (q.trim()) {
        fileWhere.originalName = {
          contains: q.trim(),
          mode: "insensitive",
        };
      }

      // MIME íƒ€ì… í•„í„°
      if (mimeType) {
        const mimeMap: Record<string, any> = {
          image: { startsWith: "image/" },
          video: { startsWith: "video/" },
          pdf: { equals: "application/pdf" },
          document: {
            in: [
              "application/msword",
              "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
              "application/vnd.ms-excel",
              "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
              "application/vnd.ms-powerpoint",
              "application/vnd.openxmlformats-officedocument.presentationml.presentation",
              "text/plain",
            ],
          },
          zip: {
            in: [
              "application/zip",
              "application/x-rar-compressed",
              "application/x-7z-compressed",
            ],
          },
        };

        if (mimeMap[mimeType]) {
          fileWhere.mimeType = mimeMap[mimeType];
        }
      }

      // ë‚ ì§œ í•„í„°
      if (dateFrom || dateTo) {
        fileWhere.createdAt = {};
        if (dateFrom) fileWhere.createdAt.gte = new Date(dateFrom);
        if (dateTo) {
          const to = new Date(dateTo);
          to.setHours(23, 59, 59, 999);
          fileWhere.createdAt.lte = to;
        }
      }

      // íƒœê·¸ í•„í„°
      if (tagIds.length > 0) {
        fileWhere.fileTags = {
          some: {
            tagId: { in: tagIds },
          },
        };
      }

      files = await prisma.file.findMany({
        where: fileWhere,
        include: {
          fileTags: {
            include: { tag: true },
          },
        },
        orderBy: { createdAt: "desc" },
        take: 50,
      });

      // BigInt ì§ë ¬í™”
      files = files.map(file => ({
        ...file,
        size: file.size.toString(),
      }));
    }

    // ===== ê²Œì‹œê¸€ ê²€ìƒ‰ =====
    if (type === "ALL" || type === "POST") {
      // ë¨¼ì € ê³µìœ ë°›ì€ ê²Œì‹œê¸€ ID ëª©ë¡ ì¡°íšŒ
      const sharedPostIds = await prisma.sharedResource.findMany({
        where: {
          resourceType: "POST",
          sharedWithId: session.user.id,
        },
        select: { resourceId: true },
      });

      const postWhere: any = {
        OR: [
          { userId: session.user.id },
          { visibility: "PUBLIC" },
          {
            visibility: "SHARED",
            id: { in: sharedPostIds.map(sr => sr.resourceId) },
          },
        ],
      };

      // í‚¤ì›Œë“œ
      if (q.trim()) {
        postWhere.AND = [
          {
            OR: [
              { title: { contains: q.trim(), mode: "insensitive" } },
              { content: { contains: q.trim(), mode: "insensitive" } },
            ],
          },
        ];
      }

      // ë‚ ì§œ í•„í„°
      if (dateFrom || dateTo) {
        const dateFilter: any = {};
        if (dateFrom) dateFilter.gte = new Date(dateFrom);
        if (dateTo) {
          const to = new Date(dateTo);
          to.setHours(23, 59, 59, 999);
          dateFilter.lte = to;
        }

        if (postWhere.AND) {
          postWhere.AND.push({ createdAt: dateFilter });
        } else {
          postWhere.AND = [{ createdAt: dateFilter }];
        }
      }

      // íƒœê·¸ í•„í„°
      if (tagIds.length > 0) {
        const tagFilter = {
          postTags: { some: { tagId: { in: tagIds } } },
        };
        if (postWhere.AND) {
          postWhere.AND.push(tagFilter);
        } else {
          postWhere.AND = [tagFilter];
        }
      }

      posts = await prisma.post.findMany({
        where: postWhere,
        include: {
          user: { select: { id: true, name: true } },
          postTags: { include: { tag: true } },
          _count: { select: { comments: true } },
        },
        orderBy: { createdAt: "desc" },
        take: 50,
      });
    }

    return NextResponse.json({
      files,
      posts,
      total: files.length + posts.length,
      query: q,
      filters: { type, mimeType, tagIds, dateFrom, dateTo },
    });
  } catch (error) {
    console.error("Search error:", error);
    return NextResponse.json(
      { error: "ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/users/search/route.ts">
export const dynamic = 'force-dynamic';

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// ì‚¬ìš©ì ê²€ìƒ‰ (ì´ë©”ì¼ ê¸°ë°˜)
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const query = searchParams.get("q") || "";

    if (!query.trim()) {
      return NextResponse.json(
        { error: "ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”" },
        { status: 400 }
      );
    }

    // ì´ë©”ì¼ ë˜ëŠ” ì´ë¦„ìœ¼ë¡œ ê²€ìƒ‰ (ë³¸ì¸ ì œì™¸)
    const users = await prisma.user.findMany({
      where: {
        AND: [
          {
            OR: [
              { email: { contains: query, mode: "insensitive" } },
              { name: { contains: query, mode: "insensitive" } },
            ],
          },
          {
            id: { not: session.user.id }, // ë³¸ì¸ ì œì™¸
          },
        ],
      },
      select: {
        id: true,
        email: true,
        name: true,
        isOnline: true,
        lastSeenAt: true,
      },
      take: 20,
    });

    return NextResponse.json({ users });
  } catch (error) {
    console.error("User search error:", error);
    return NextResponse.json(
      { error: "ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/page.tsx">
"use client";

import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import { useEffect } from "react";
import Link from "next/link";
import { 
  Cloud, 
  ShieldCheck, 
  Zap, 
  Share2, 
  ArrowRight, 
  CheckCircle2,
  Lock,
  Globe
} from "lucide-react";

export default function HomePage() {
  const { data: session, status } = useSession();
  const router = useRouter();

  useEffect(() => {
    if (status === "authenticated") {
      router.push("/dashboard");
    }
  }, [status, router]);

  if (status === "loading") {
    return (
      <div className="min-h-screen bg-[#0f0c29] flex items-center justify-center">
        <div className="w-12 h-12 border-4 border-purple-500/20 border-t-purple-500 rounded-full animate-spin" />
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-[#0f0c29] text-white selection:bg-purple-500/30 overflow-x-hidden">
      {/* ë°°ê²½ ì¥ì‹ (Blobs) */}
      <div className="fixed top-0 left-0 w-full h-full overflow-hidden -z-10 pointer-events-none">
        <div className="absolute top-[-10%] left-[-10%] w-[50%] h-[50%] bg-purple-600/20 blur-[120px] rounded-full" />
        <div className="absolute bottom-[-10%] right-[-10%] w-[50%] h-[50%] bg-blue-600/20 blur-[120px] rounded-full" />
      </div>

      <div className="max-w-6xl mx-auto px-6 py-20 relative">
        {/* ìƒë‹¨ ë„¤ë¹„ê²Œì´ì…˜ ìŠ¤íƒ€ì¼ í—¤ë” */}
        <nav className="flex justify-between items-center mb-24">
          <div className="flex items-center gap-2">
            <div className="w-10 h-10 bg-gradient-to-br from-purple-500 to-blue-600 rounded-xl flex items-center justify-center shadow-lg shadow-purple-500/20">
              <Cloud size={24} fill="currentColor" />
            </div>
            <span className="text-xl font-black tracking-tighter italic">EUM CLOUD</span>
          </div>
          <div className="flex gap-4">
            <Link href="/login" className="px-5 py-2 text-sm font-bold text-white/70 hover:text-white transition-colors">
              ë¡œê·¸ì¸
            </Link>
            <Link href="/register" className="px-5 py-2 text-sm font-bold bg-white/10 hover:bg-white/20 rounded-full border border-white/10 transition-all">
              ì‹œì‘í•˜ê¸°
            </Link>
          </div>
        </nav>

        {/* íˆì–´ë¡œ ì„¹ì…˜ */}
        <div className="text-center mb-32">
          <div className="inline-flex items-center gap-2 px-4 py-2 rounded-full bg-white/5 border border-white/10 text-purple-400 text-xs font-bold mb-8 animate-fade-in">
            <span className="relative flex h-2 w-2">
              <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-purple-400 opacity-75"></span>
              <span className="relative inline-flex rounded-full h-2 w-2 bg-purple-500"></span>
            </span>
            NEXT-GEN PERSONAL CLOUD
          </div>
          <h1 className="text-5xl md:text-7xl font-black mb-8 leading-[1.1] tracking-tight">
            ë°ì´í„°ì˜ ì—°ê²°, <br />
            <span className="bg-clip-text text-transparent bg-gradient-to-r from-purple-400 via-blue-400 to-emerald-400">
              ê·¸ ì´ìƒì˜ ê°€ì¹˜ ì´ìŒ
            </span>
          </h1>
          <p className="text-lg md:text-xl text-white/50 max-w-2xl mx-auto mb-12 leading-relaxed">
            ë‚˜ë§Œì˜ í¼ìŠ¤ë„ ìŠ¤í† ë¦¬ì§€ë¥¼ ë„˜ì–´ ì‹¤ì‹œê°„ ë¯¸ë””ì–´ ìŠ¤íŠ¸ë¦¬ë°ê³¼ <br className="hidden md:block" /> 
            ê°•ë ¥í•œ í˜‘ì—… ë„êµ¬ë¥¼ í•˜ë‚˜ì˜ ìƒíƒœê³„ì—ì„œ ê²½í—˜í•˜ì„¸ìš”.
          </p>
          <div className="flex flex-col sm:flex-row items-center justify-center gap-4">
            <Link
              href="/register"
              className="group w-full sm:w-auto px-8 py-4 bg-white text-black font-black rounded-2xl hover:bg-purple-50 transition-all flex items-center justify-center gap-2"
            >
              ë¬´ë£Œë¡œ ì‹œì‘í•˜ê¸°
              <ArrowRight size={20} className="group-hover:translate-x-1 transition-transform" />
            </Link>
            <Link
              href="/about"
              className="w-full sm:w-auto px-8 py-4 bg-white/5 text-white font-bold rounded-2xl border border-white/10 hover:bg-white/10 transition-all"
            >
              ê¸°ëŠ¥ ë‘˜ëŸ¬ë³´ê¸°
            </Link>
          </div>
        </div>

        {/* ê¸°ëŠ¥ ì¹´ë“œ ì„¹ì…˜ */}
        <div className="grid md:grid-cols-3 gap-6 mb-32">
          {[
            { icon: <ShieldCheck className="text-purple-400" />, title: "ê°•ë ¥í•œ ë³´ì•ˆ", desc: "ì—”ë“œ íˆ¬ ì—”ë“œ ì•”í˜¸í™”ë¡œ ì˜¤ì§ ë‹¹ì‹ ë§Œì´ ë°ì´í„°ì— ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤." },
            { icon: <Zap className="text-blue-400" />, title: "ì´ˆê³ ì† ìŠ¤íŠ¸ë¦¬ë°", desc: "ì–´ë””ì„œë“  ëŠê¹€ ì—†ëŠ” ê³ í™”ì§ˆ ë¯¸ë””ì–´ ì¬ìƒ í™˜ê²½ì„ ì œê³µí•©ë‹ˆë‹¤." },
            { icon: <Share2 className="text-emerald-400" />, title: "ìŠ¤ë§ˆíŠ¸ ê³µìœ ", desc: "ê°€ì¡±, ì¹œêµ¬ì™€ í´ë¦­ í•œ ë²ˆìœ¼ë¡œ ì•ˆì „í•˜ê²Œ í´ë”ë¥¼ ê³µìœ í•˜ì„¸ìš”." }
          ].map((feature, i) => (
            <div key={i} className="group p-8 rounded-[32px] bg-white/5 border border-white/10 hover:border-purple-500/50 transition-all hover:-translate-y-2">
              <div className="w-12 h-12 rounded-2xl bg-white/5 flex items-center justify-center mb-6 group-hover:scale-110 transition-transform">
                {feature.icon}
              </div>
              <h3 className="text-xl font-bold mb-3">{feature.title}</h3>
              <p className="text-white/40 leading-relaxed text-sm">
                {feature.desc}
              </p>
            </div>
          ))}
        </div>

        {/* í•˜ë‹¨ ì‹œìŠ¤í…œ ìƒíƒœ ë³´ë“œ */}
        <div className="relative p-10 rounded-[40px] bg-gradient-to-b from-white/10 to-transparent border border-white/10 overflow-hidden">
          <div className="absolute top-0 right-0 p-8 opacity-10">
            <Globe size={120} />
          </div>
          <div className="relative z-10">
            <div className="flex items-center gap-3 mb-8">
              <CheckCircle2 className="text-emerald-400" />
              <h3 className="text-xl font-bold italic tracking-tight">SYSTEM OPERATIONAL</h3>
            </div>
            <div className="grid grid-cols-2 md:grid-cols-4 gap-8">
              <StatusItem label="Platform" value="Next.js 14" />
              <StatusItem label="Database" value="PostgreSQL" />
              <StatusItem label="Security" value="AES-256" />
              <StatusItem label="Auth" value="NextAuth.js" />
            </div>
          </div>
        </div>
        
        <footer className="mt-24 text-center text-white/20 text-xs font-medium tracking-widest uppercase">
          &copy; 2026 EUM PERSONAL CLOUD SERVICE. ALL RIGHTS RESERVED.
        </footer>
      </div>
    </div>
  );
}

function StatusItem({ label, value }: { label: string, value: string }) {
  return (
    <div>
      <p className="text-white/30 text-[10px] font-bold uppercase tracking-widest mb-1">{label}</p>
      <p className="text-white font-mono text-sm">{value}</p>
    </div>
  );
}
</file>

<file path="src/app/register/page.tsx">
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import Link from "next/link";
import { 
  Mail, 
  Lock, 
  User, 
  Eye, 
  EyeOff, 
  Cloud, 
  AlertCircle, 
  Loader2, 
  CheckCircle2, 
  ChevronRight,
  ShieldCheck,
  FileText
} from "lucide-react";

interface PrivacyConsent {
  terms: boolean;
  privacy: boolean;
  age: boolean;
  marketing: boolean;
}

export default function RegisterPage() {
  const router = useRouter();

  // ì…ë ¥ ìƒíƒœ
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [passwordConfirm, setPasswordConfirm] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const [showPasswordConfirm, setShowPasswordConfirm] = useState(false);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  // ê°œì¸ì •ë³´ ë™ì˜ ìƒíƒœ
  const [showPrivacyModal, setShowPrivacyModal] = useState(false);
  const [showFullText, setShowFullText] = useState<"terms" | "privacy" | null>(null);
  const [consent, setConsent] = useState<PrivacyConsent>({
    terms: false, privacy: false, age: false, marketing: false,
  });
  const [consentDone, setConsentDone] = useState(false);

  // ìœ íš¨ì„± ê²€ì‚¬ ë¡œì§
  const passwordRules = {
    length: password.length >= 8,
    combo: /(?=.*[a-zA-Z])(?=.*\d)/.test(password),
  };
  const passwordMatch = password === passwordConfirm && passwordConfirm.length > 0;
  const emailValid = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  const allRequiredConsent = consent.terms && consent.privacy && consent.age;

  const handleAllConsent = (checked: boolean) => {
    setConsent({ terms: checked, privacy: checked, age: checked, marketing: checked });
  };

  const handleConsentSubmit = () => {
    if (!allRequiredConsent) return;
    setConsentDone(true);
    setShowPrivacyModal(false);
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");

    if (!consentDone) {
      setShowPrivacyModal(true);
      return;
    }

    if (!passwordRules.length || !passwordRules.combo || !passwordMatch) {
      setError("ì…ë ¥í•˜ì‹  ì •ë³´ë¥¼ ë‹¤ì‹œ í™•ì¸í•´ì£¼ì„¸ìš”.");
      return;
    }

    setLoading(true);
    try {
      // ğŸ’¡ ì˜¤ë¥˜ í•´ê²° í¬ì¸íŠ¸: API ê²½ë¡œê°€ /api/auth/register ì¸ì§€ /api/register ì¸ì§€ í™•ì¸ í•„ìš”
      // í˜„ì¬ í”„ë¡œì íŠ¸ êµ¬ì¡°ì— ë§ì¶° ì—”ë“œí¬ì¸íŠ¸ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.
      const res = await fetch("/api/auth/register", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ 
          name, 
          email, 
          password, 
          marketingConsent: consent.marketing 
        }),
      });

      const data = await res.json();

      if (res.ok) {
        // ì„±ê³µ ì‹œ ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ ì´ë™í•˜ë©° ì„±ê³µ ë©”ì‹œì§€ ì „ë‹¬
        router.push("/login?signup=success");
      } else {
        setError(data.error || "ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ ì´ë©”ì¼ì´ê±°ë‚˜ ê°€ì… ì •ë³´ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.");
      }
    } catch (err) {
      setError("ì„œë²„ì™€ì˜ í†µì‹  ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-[#0f0c29] text-white flex items-center justify-center p-6 relative overflow-hidden font-sans">
      {/* ë°°ê²½ ì¥ì‹ */}
      <div className="absolute top-[-10%] left-[-10%] w-[40%] h-[40%] bg-purple-600/20 blur-[100px] rounded-full -z-10" />
      <div className="absolute bottom-[-10%] right-[-10%] w-[40%] h-[40%] bg-blue-600/20 blur-[100px] rounded-full -z-10" />

      <div className="max-w-md w-full relative z-10">
        {/* ë¡œê³  ì˜ì—­ */}
        <div className="text-center mb-8 flex flex-col items-center">
          <Link href="/" className="inline-flex items-center gap-3 group">
            <div className="w-12 h-12 bg-gradient-to-br from-purple-500 to-blue-600 rounded-2xl flex items-center justify-center shadow-xl group-hover:scale-110 transition-transform">
              <Cloud size={28} fill="currentColor" />
            </div>
            <div className="text-left">
              <h1 className="text-3xl font-black tracking-tighter italic leading-none">EUM</h1>
              <p className="text-[10px] text-white/40 uppercase tracking-[0.2em] font-bold mt-1">Personal Cloud</p>
            </div>
          </Link>
        </div>

        {/* íšŒì›ê°€ì… ì¹´ë“œ */}
        <div className="bg-white/5 border border-white/10 p-8 rounded-[40px] backdrop-blur-2xl shadow-2xl">
          <div className="mb-6">
            <h2 className="text-2xl font-bold mb-1">íšŒì›ê°€ì…</h2>
            <p className="text-white/50 text-sm">ì´ìŒì˜ ìƒˆ ê°€ì¡±ì´ ë˜ì–´ì£¼ì„¸ìš” âœ¨</p>
          </div>

          {error && (
            <div className="mb-6 flex items-center gap-2 bg-red-500/10 border border-red-500/20 text-red-400 p-4 rounded-2xl text-sm">
              <AlertCircle size={18} />
              <p>{error}</p>
            </div>
          )}

          <form onSubmit={handleSubmit} className="space-y-4">
            {/* ì´ë¦„ ì…ë ¥ */}
            <div className="space-y-1.5">
              <label className="text-xs font-bold text-white/40 ml-1 uppercase tracking-wider">Name</label>
              <div className="relative group">
                <div className="absolute inset-y-0 left-4 flex items-center text-white/20 group-focus-within:text-purple-400 transition-colors">
                  <User size={18} />
                </div>
                <input
                  type="text"
                  value={name}
                  onChange={(e) => setName(e.target.value)}
                  placeholder="í™ê¸¸ë™"
                  className="w-full bg-white/5 border border-white/10 rounded-2xl py-3.5 pl-12 pr-4 outline-none focus:border-purple-500/50 focus:bg-white/10 transition-all"
                  required
                />
              </div>
            </div>

            {/* ì´ë©”ì¼ ì…ë ¥ */}
            <div className="space-y-1.5">
              <label className="text-xs font-bold text-white/40 ml-1 uppercase tracking-wider">Email</label>
              <div className="relative group">
                <div className="absolute inset-y-0 left-4 flex items-center text-white/20 group-focus-within:text-purple-400 transition-colors">
                  <Mail size={18} />
                </div>
                <input
                  type="email"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  placeholder="example@email.com"
                  className={`w-full bg-white/5 border border-white/10 rounded-2xl py-3.5 pl-12 pr-4 outline-none focus:border-purple-500/50 focus:bg-white/10 transition-all ${email && !emailValid ? "border-red-500/50" : emailValid ? "border-emerald-500/50" : ""}`}
                  required
                />
              </div>
            </div>

            {/* ë¹„ë°€ë²ˆí˜¸ ì…ë ¥ */}
            <div className="space-y-1.5">
              <label className="text-xs font-bold text-white/40 ml-1 uppercase tracking-wider">Password</label>
              <div className="relative group">
                <div className="absolute inset-y-0 left-4 flex items-center text-white/20 group-focus-within:text-purple-400 transition-colors">
                  <Lock size={18} />
                </div>
                <input
                  type={showPassword ? "text" : "password"}
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  placeholder="8ì ì´ìƒ, ì˜ë¬¸+ìˆ«ì"
                  className="w-full bg-white/5 border border-white/10 rounded-2xl py-3.5 pl-12 pr-12 outline-none focus:border-purple-500/50 focus:bg-white/10 transition-all"
                  required
                />
                <button
                  type="button"
                  onClick={() => setShowPassword(!showPassword)}
                  className="absolute inset-y-0 right-4 flex items-center text-white/20 hover:text-white"
                >
                  {showPassword ? <EyeOff size={18} /> : <Eye size={18} />}
                </button>
              </div>
              {/* ë¹„ë°€ë²ˆí˜¸ ê·œì¹™ ì²´í¬ í‘œì‹œ */}
              {password && (
                <div className="flex gap-3 px-1 mt-1">
                  <div className={`flex items-center gap-1 text-[11px] ${passwordRules.length ? "text-emerald-400" : "text-white/20"}`}>
                    <CheckCircle2 size={12} /> 8ì ì´ìƒ
                  </div>
                  <div className={`flex items-center gap-1 text-[11px] ${passwordRules.combo ? "text-emerald-400" : "text-white/20"}`}>
                    <CheckCircle2 size={12} /> ì˜ë¬¸+ìˆ«ì
                  </div>
                </div>
              )}
            </div>

            {/* ë¹„ë°€ë²ˆí˜¸ í™•ì¸ */}
            <div className="space-y-1.5">
              <label className="text-xs font-bold text-white/40 ml-1 uppercase tracking-wider">Confirm Password</label>
              <div className="relative group">
                <div className="absolute inset-y-0 left-4 flex items-center text-white/20 group-focus-within:text-purple-400 transition-colors">
                  <Lock size={18} />
                </div>
                <input
                  type={showPasswordConfirm ? "text" : "password"}
                  value={passwordConfirm}
                  onChange={(e) => setPasswordConfirm(e.target.value)}
                  placeholder="ë¹„ë°€ë²ˆí˜¸ ì¬ì…ë ¥"
                  className={`w-full bg-white/5 border border-white/10 rounded-2xl py-3.5 pl-12 pr-12 outline-none focus:border-purple-500/50 focus:bg-white/10 transition-all ${passwordConfirm && !passwordMatch ? "border-red-500/50" : passwordMatch ? "border-emerald-500/50" : ""}`}
                  required
                />
                <button
                  type="button"
                  onClick={() => setShowPasswordConfirm(!showPasswordConfirm)}
                  className="absolute inset-y-0 right-4 flex items-center text-white/20 hover:text-white"
                >
                  {showPasswordConfirm ? <EyeOff size={18} /> : <Eye size={18} />}
                </button>
              </div>
            </div>

            {/* ì•½ê´€ ë™ì˜ ì„¹ì…˜ */}
            <div className="pt-2">
              {consentDone ? (
                <button 
                  type="button" 
                  onClick={() => setShowPrivacyModal(true)}
                  className="w-full bg-emerald-500/10 border border-emerald-500/30 rounded-2xl p-3 flex items-center justify-between group"
                >
                  <div className="flex items-center gap-2 text-emerald-400 text-sm font-medium">
                    <ShieldCheck size={18} />
                    <span>ì•½ê´€ ë™ì˜ ì™„ë£Œ</span>
                  </div>
                  <span className="text-[10px] text-white/20 group-hover:text-white/40">ë³€ê²½í•˜ê¸°</span>
                </button>
              ) : (
                <button
                  type="button"
                  onClick={() => setShowPrivacyModal(true)}
                  className="w-full bg-white/5 border border-dashed border-white/20 rounded-2xl p-3 text-white/40 text-sm hover:bg-white/10 hover:border-white/40 transition-all flex items-center justify-center gap-2"
                >
                  <FileText size={18} />
                  ê°œì¸ì •ë³´ ìˆ˜ì§‘ ë™ì˜ (í•„ìˆ˜)
                </button>
              )}
            </div>

            <button
              type="submit"
              disabled={loading || !consentDone}
              className="w-full py-4 bg-gradient-to-r from-purple-500 to-blue-600 text-white font-bold rounded-2xl hover:opacity-90 active:scale-[0.98] transition-all flex items-center justify-center gap-2 shadow-xl shadow-purple-500/20 disabled:opacity-30 mt-4"
            >
              {loading ? <Loader2 size={20} className="animate-spin" /> : <>íšŒì›ê°€ì… <ChevronRight size={20} /></>}
            </button>
          </form>

          <div className="mt-6 text-center">
            <p className="text-white/40 text-sm">
              ì´ë¯¸ ê³„ì •ì´ ìˆìœ¼ì‹ ê°€ìš”?{" "}
              <Link href="/login" className="text-white font-bold hover:text-purple-400 underline underline-offset-4">
                ë¡œê·¸ì¸
              </Link>
            </p>
          </div>
        </div>
      </div>

      {/* ë™ì˜ ëª¨ë‹¬ (ìƒëµ: ê¸°ì¡´ ë¡œì§ê³¼ ë™ì¼í•˜ë‚˜ ë””ìì¸ì„ EUM ìŠ¤íƒ€ì¼ë¡œ ì¡°ì •) */}
      {showPrivacyModal && (
        <div className="fixed inset-0 z-[100] flex items-end sm:items-center justify-center p-0 sm:p-4 bg-black/80 backdrop-blur-sm animate-in fade-in duration-200">
          <div className="bg-[#1a1735] w-full max-w-lg rounded-t-[32px] sm:rounded-[32px] p-8 border border-white/10 shadow-2xl overflow-y-auto max-h-[90vh]">
            <h3 className="text-xl font-bold mb-2">ì„œë¹„ìŠ¤ ì´ìš© ë™ì˜</h3>
            <p className="text-white/40 text-sm mb-6">ì›í™œí•œ ì„œë¹„ìŠ¤ ì œê³µì„ ìœ„í•´ í•„ìˆ˜ í•­ëª©ì— ë™ì˜ê°€ í•„ìš”í•©ë‹ˆë‹¤.</p>
            
            <div className="space-y-1">
              <label className="flex items-center gap-3 p-4 bg-white/5 rounded-2xl cursor-pointer hover:bg-white/10 transition-colors mb-4">
                <input 
                  type="checkbox" 
                  className="w-5 h-5 rounded-lg accent-purple-500"
                  checked={consent.terms && consent.privacy && consent.age && consent.marketing}
                  onChange={(e) => handleAllConsent(e.target.checked)}
                />
                <span className="font-bold">ì „ì²´ ë™ì˜í•˜ê¸°</span>
              </label>
              
              <div className="space-y-1 px-1">
                {[
                  { key: "terms", label: "[í•„ìˆ˜] ì„œë¹„ìŠ¤ ì´ìš©ì•½ê´€", type: "terms" },
                  { key: "privacy", label: "[í•„ìˆ˜] ê°œì¸ì •ë³´ ì²˜ë¦¬ë°©ì¹¨", type: "privacy" },
                  { key: "age", label: "[í•„ìˆ˜] ë§Œ 14ì„¸ ì´ìƒì…ë‹ˆë‹¤", type: null },
                  { key: "marketing", label: "[ì„ íƒ] ë§ˆì¼€íŒ… ì •ë³´ ìˆ˜ì‹ ", type: null },
                ].map((item) => (
                  <div key={item.key} className="flex items-center justify-between py-3 border-b border-white/5 last:border-0">
                    <label className="flex items-center gap-3 cursor-pointer">
                      <input 
                        type="checkbox" 
                        className="w-4 h-4 rounded accent-purple-500"
                        checked={consent[item.key as keyof PrivacyConsent]}
                        onChange={(e) => setConsent({ ...consent, [item.key]: e.target.checked })}
                      />
                      <span className={`text-sm ${item.key === 'marketing' ? 'text-white/40' : 'text-white/70'}`}>{item.label}</span>
                    </label>
                    {item.type && (
                      <button 
                        onClick={() => setShowFullText(item.type as "terms" | "privacy")}
                        className="text-[11px] text-white/30 underline"
                      >ì „ë¬¸ë³´ê¸°</button>
                    )}
                  </div>
                ))}
              </div>
            </div>

            <div className="mt-8 flex gap-3">
              <button 
                onClick={() => setShowPrivacyModal(false)}
                className="flex-1 py-4 bg-white/5 rounded-2xl font-bold hover:bg-white/10 transition-colors"
              >ì·¨ì†Œ</button>
              <button 
                onClick={handleConsentSubmit}
                disabled={!allRequiredConsent}
                className="flex-[2] py-4 bg-gradient-to-r from-purple-500 to-blue-600 rounded-2xl font-bold disabled:opacity-30"
              >ë™ì˜í•˜ê³  ê³„ì†í•˜ê¸°</button>
            </div>
          </div>
        </div>
      )}

      {/* ì•½ê´€ ì „ë¬¸ ëª¨ë‹¬ (ê¸°ì¡´ ë¡œì§ ìœ ì§€) */}
      {showFullText && (
        <div className="fixed inset-0 z-[110] flex items-center justify-center p-4 bg-black/90">
          <div className="bg-[#1a1735] w-full max-w-2xl rounded-[32px] p-8 border border-white/10 flex flex-col max-h-[80vh]">
            <h4 className="text-lg font-bold mb-4">{showFullText === "terms" ? "ì´ìš©ì•½ê´€" : "ê°œì¸ì •ë³´ ì²˜ë¦¬ë°©ì¹¨"}</h4>
            <div className="flex-1 overflow-y-auto bg-black/20 rounded-2xl p-6 text-sm text-white/60 leading-relaxed whitespace-pre-wrap">
              {showFullText === "terms" ? TERMS_TEXT : PRIVACY_TEXT}
            </div>
            <button 
              onClick={() => setShowFullText(null)}
              className="mt-6 w-full py-4 bg-white/10 rounded-2xl font-bold"
            >í™•ì¸</button>
          </div>
        </div>
      )}
    </div>
  );
}

// ì•½ê´€ í…ìŠ¤íŠ¸ ë°ì´í„° (ìƒëµ - ê¸°ì¡´ ë°ì´í„° ì‚¬ìš©)
const TERMS_TEXT = `...`;
const PRIVACY_TEXT = `...`;
</file>

<file path="src/app/reset-password/confirm/page.tsx">
"use client";

import { useState, useEffect, Suspense } from "react";
import { useSearchParams, useRouter } from "next/navigation";
import Link from "next/link";

function ResetPasswordContent() {
  const searchParams = useSearchParams();
  const router = useRouter();
  const token = searchParams.get("token");

  const [password, setPassword] = useState("");
  const [confirm, setConfirm] = useState("");
  const [loading, setLoading] = useState(false);
  const [done, setDone] = useState(false);
  const [error, setError] = useState("");

  useEffect(() => {
    if (!token) {
      setError("ìœ íš¨í•˜ì§€ ì•Šì€ ë§í¬ì…ë‹ˆë‹¤");
    }
  }, [token]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");

    if (password !== confirm) {
      setError("ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤");
      return;
    }
    if (password.length < 8 || !/(?=.*[a-zA-Z])(?=.*\d)/.test(password)) {
      setError("ë¹„ë°€ë²ˆí˜¸ëŠ” 8ì ì´ìƒ, ì˜ë¬¸+ìˆ«ì ì¡°í•©ì´ì–´ì•¼ í•©ë‹ˆë‹¤");
      return;
    }

    setLoading(true);
    try {
      const res = await fetch("/api/auth/reset-password/confirm", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ token, password }),
      });
      const data = await res.json();
      if (res.ok) {
        setDone(true);
        setTimeout(() => router.push("/login"), 3000);
      } else {
        setError(data.error || "ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
      }
    } catch {
      setError("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="eum-card">
      <div className="eum-icon-wrap">ğŸ”‘</div>
      <h2 className="eum-title">ìƒˆ ë¹„ë°€ë²ˆí˜¸ ì„¤ì •</h2>

      {done ? (
        <div className="eum-success">
          <div className="eum-success-icon">âœ…</div>
          <p className="eum-success-msg">ë¹„ë°€ë²ˆí˜¸ê°€ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤!</p>
          <p className="eum-success-sub">3ì´ˆ í›„ ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ ì´ë™í•©ë‹ˆë‹¤</p>
          <Link
            href="/login"
            className="eum-btn"
            style={{
              display: "block",
              textAlign: "center",
              textDecoration: "none",
              marginTop: "16px",
            }}
          >
            ë¡œê·¸ì¸í•˜ëŸ¬ ê°€ê¸°
          </Link>
        </div>
      ) : (
        <>
          <p className="eum-sub">ìƒˆë¡œ ì‚¬ìš©í•  ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”</p>
          <form onSubmit={handleSubmit} className="eum-form">
            {error && <div className="eum-error">âš ï¸ {error}</div>}
            <div className="eum-field">
              <label className="eum-label">ìƒˆ ë¹„ë°€ë²ˆí˜¸</label>
              <input
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                placeholder="8ì ì´ìƒ, ì˜ë¬¸+ìˆ«ì"
                className="eum-input"
                required
              />
            </div>
            <div className="eum-field">
              <label className="eum-label">ë¹„ë°€ë²ˆí˜¸ í™•ì¸</label>
              <input
                type="password"
                value={confirm}
                onChange={(e) => setConfirm(e.target.value)}
                placeholder="ë¹„ë°€ë²ˆí˜¸ë¥¼ ë‹¤ì‹œ ì…ë ¥í•˜ì„¸ìš”"
                className="eum-input"
                required
              />
              {confirm && (
                <span
                  style={{
                    fontSize: "12px",
                    marginTop: "4px",
                    color: password === confirm ? "#4ade80" : "#f87171",
                  }}
                >
                  {password === confirm ? "âœ… ì¼ì¹˜í•©ë‹ˆë‹¤" : "âŒ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤"}
                </span>
              )}
            </div>
            <button
              type="submit"
              disabled={loading || !token}
              className="eum-btn"
            >
              {loading ? "ë³€ê²½ ì¤‘..." : "ë¹„ë°€ë²ˆí˜¸ ë³€ê²½í•˜ê¸°"}
            </button>
          </form>
        </>
      )}
    </div>
  );
}

export default function ResetPasswordConfirmPage() {
  return (
    <div className="eum-root">
      <div className="eum-bg">
        <div className="eum-blob b1" />
        <div className="eum-blob b2" />
      </div>
      <div className="eum-container">
        <Suspense fallback={<div className="eum-card" style={{ color: 'white', textAlign: 'center' }}>ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>}>
          <ResetPasswordContent />
        </Suspense>
      </div>
      <style>{EUM_FIND_STYLE}</style>
    </div>
  );
}

const EUM_FIND_STYLE = `
  * { box-sizing: border-box; margin: 0; padding: 0; }
  .eum-root { min-height: 100vh; min-height: 100dvh; background: #0f0c29; display: flex; align-items: center; justify-content: center; padding: 24px 20px; position: relative; overflow: hidden; font-family: 'Pretendard','Apple SD Gothic Neo',-apple-system,sans-serif; }
  .eum-bg { position: fixed; inset: 0; pointer-events: none; z-index: 0; }
  .eum-blob { position: absolute; border-radius: 50%; filter: blur(80px); opacity: 0.25; }
  .b1 { width: 380px; height: 380px; background: #7c3aed; top: -100px; left: -100px; }
  .b2 { width: 320px; height: 320px; background: #2563eb; bottom: -80px; right: -80px; }
  .eum-container { position: relative; z-index: 1; width: 100%; max-width: 400px; }
  .eum-card { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); border-radius: 24px; padding: 36px 28px; backdrop-filter: blur(20px); box-shadow: 0 25px 50px rgba(0,0,0,0.4); }
  .eum-icon-wrap { font-size: 40px; text-align: center; margin-bottom: 16px; }
  .eum-title { font-size: 22px; font-weight: 700; color: white; text-align: center; margin-bottom: 8px; }
  .eum-sub { font-size: 14px; color: rgba(255,255,255,0.5); text-align: center; line-height: 1.6; margin-bottom: 24px; }
  .eum-form { display: flex; flex-direction: column; gap: 16px; }
  .eum-field { display: flex; flex-direction: column; gap: 7px; }
  .eum-label { font-size: 13px; font-weight: 600; color: rgba(255,255,255,0.7); }
  .eum-input { background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12); border-radius: 12px; padding: 13px 16px; color: white; font-size: 16px; transition: all 0.2s; outline: none; width: 100%; -webkit-appearance: none; }
  .eum-input::placeholder { color: rgba(255,255,255,0.25); }
  .eum-input:focus { border-color: #7c3aed; background: rgba(124,58,237,0.1); box-shadow: 0 0 0 3px rgba(124,58,237,0.2); }
  .eum-error { background: rgba(239,68,68,0.15); border: 1px solid rgba(239,68,68,0.3); color: #fca5a5; font-size: 13px; padding: 12px 14px; border-radius: 12px; }
  .eum-btn { width: 100%; padding: 14px; background: linear-gradient(135deg, #7c3aed, #2563eb); border: none; border-radius: 12px; color: white; font-size: 15px; font-weight: 700; cursor: pointer; transition: all 0.2s; min-height: 50px; box-shadow: 0 4px 20px rgba(124,58,237,0.35); -webkit-tap-highlight-color: transparent; }
  .eum-btn:disabled { opacity: 0.5; cursor: not-allowed; }
  .eum-success { text-align: center; display: flex; flex-direction: column; align-items: center; gap: 10px; }
  .eum-success-icon { font-size: 52px; }
  .eum-success-msg { font-size: 20px; font-weight: 700; color: white; }
  .eum-success-sub { font-size: 14px; color: rgba(255,255,255,0.5); line-height: 1.7; }
`;
</file>

<file path="src/lib/auth.ts">
import NextAuth, { AuthOptions } from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";
import { compare } from "bcryptjs"; // âœ… bcrypt â†’ bcryptjs
import { prisma } from "@/lib/db";

export const authOptions: AuthOptions = {
  providers: [
    CredentialsProvider({
      name: "Credentials",
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" },
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) {
          return null;
        }

        const user = await prisma.user.findUnique({
          where: { email: credentials.email },
        });

        if (!user) return null;

        const isPasswordValid = await compare(
          credentials.password,
          user.passwordHash
        );

        if (!isPasswordValid) return null;

        return {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role,
        };
      },
    }),
  ],
  session: {
    strategy: "jwt",
    maxAge: 30 * 24 * 60 * 60, // 30ì¼
  },
  pages: {
    signIn: "/login",
    signOut: "/",
    error: "/login",
  },
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.id = user.id;
        token.role = user.role;
      }
      return token;
    },
    async session({ session, token }) {
      if (session.user) {
        session.user.id = token.id as string;
        session.user.role = token.role as string;
      }
      return session;
    },
  },
  secret: process.env.NEXTAUTH_SECRET,
};

const handler = NextAuth(authOptions);
export { handler as GET, handler as POST };
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/app/api/auth/[...nextauth]/route": ["./src/lib/auth"],
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="next.config.js">
/** @type {import('next').NextConfig} */
const path = require('path');

const nextConfig = {
  output: 'standalone',

  typescript: {
    ignoreBuildErrors: true,
  },

  experimental: {
    serverActions: {
      bodySizeLimit: '50mb',
    },
  },

  webpack: (config) => {
    config.resolve.alias = {
      ...config.resolve.alias,
      [path.resolve(__dirname, 'src/app/api/auth/[...nextauth]/route')]:
        path.resolve(__dirname, 'src/lib/auth'),
    };
    return config;
  },

  images: {
    remotePatterns: [
      {
        protocol: 'http',
        hostname: 'localhost',
      },
      {
        protocol: 'https',
        hostname: '**.up.railway.app',
      },
      {
        protocol: 'https',
        hostname: '**.mooo.com',
      },
    ],
  },

  swcMinify: true,
  compress: true,
}

module.exports = nextConfig
</file>

<file path="prisma/schema.prisma">
// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  USER
  ADMIN
}

enum ResourceType {
  FILE
  FOLDER
  POST
  CHATROOM
}

enum Permission {
  VIEW
  EDIT
  ADMIN
}

enum Visibility {
  PRIVATE
  SHARED
  PUBLIC
}

enum ChatRoomType {
  DIRECT
  GROUP
}

enum MessageType {
  TEXT
  FILE
  CALL_LOG
  SYSTEM
}

enum CallStatus {
  PENDING
  ACCEPTED
  REJECTED
  MISSED
  ENDED
}

enum CallType {
  VOICE
  VIDEO
}

enum NetworkType {
  WIFI
  CELLULAR
  OFFLINE
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  passwordHash  String    @map("password_hash")
  name          String
  role          Role      @default(USER)
  emailVerified Boolean   @default(false) @map("email_verified")
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")
  
  isOnline      Boolean   @default(false) @map("is_online")
  lastSeenAt    DateTime? @map("last_seen_at")
  fcmToken      String?   @map("fcm_token")
  networkType   NetworkType @default(OFFLINE) @map("network_type")
  
  files                File[]
  folders              Folder[]
  posts                Post[]
  comments             Comment[]
  sharedResources      SharedResource[] @relation("SharedWith")
  ownedSharedResources SharedResource[] @relation("Owner")
  savedSearches        SavedSearch[]
  
  chatRoomMembers      ChatRoomMember[]
  sentMessages         ChatMessage[]
  callsInitiated       Call[] @relation("CallInitiator")
  callsReceived        Call[] @relation("CallReceiver")
  
  passwordResetTokens PasswordResetToken[]

  @@map("users")
}

model ChatRoom {
  id        String       @id @default(cuid())
  name      String?      
  type      ChatRoomType @default(DIRECT)
  createdAt DateTime     @default(now()) @map("created_at")
  updatedAt DateTime     @updatedAt @map("updated_at")
  
  members   ChatRoomMember[]
  messages  ChatMessage[]
  calls     Call[]
  
  @@map("chat_rooms")
}

model ChatRoomMember {
  id         String   @id @default(cuid())
  chatRoomId String   @map("chat_room_id")
  userId     String   @map("user_id")
  joinedAt   DateTime @default(now()) @map("joined_at")
  lastReadAt DateTime? @map("last_read_at")
  
  chatRoom   ChatRoom @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([chatRoomId, userId])
  @@index([chatRoomId])
  @@index([userId])
  @@map("chat_room_members")
}

model ChatMessage {
  id         String      @id @default(cuid())
  chatRoomId String      @map("chat_room_id")
  senderId   String      @map("sender_id")
  type       MessageType @default(TEXT)
  content    String?     
  fileId     String?     @map("file_id")
  callId     String?     @map("call_id")
  createdAt  DateTime    @default(now()) @map("created_at")
  
  chatRoom   ChatRoom    @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)
  sender     User        @relation(fields: [senderId], references: [id], onDelete: Cascade)
  
  // âœ… ì¶”ê°€ë¨: Fileê³¼ì˜ ê´€ê³„
  file       File?       @relation(fields: [fileId], references: [id], onDelete: SetNull)

  @@index([chatRoomId])
  @@index([senderId])
  @@index([createdAt])
  @@map("chat_messages")
}

model Call {
  id           String     @id @default(cuid())
  chatRoomId   String     @map("chat_room_id")
  initiatorId  String     @map("initiator_id")
  receiverId   String     @map("receiver_id")
  type         CallType   @default(VOICE)
  status       CallStatus @default(PENDING)
  startedAt    DateTime?  @map("started_at")
  endedAt      DateTime?  @map("ended_at")
  duration     Int?
  createdAt    DateTime   @default(now()) @map("created_at")
  
  chatRoom     ChatRoom   @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)
  initiator    User       @relation("CallInitiator", fields: [initiatorId], references: [id], onDelete: Cascade)
  receiver     User       @relation("CallReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  
  @@index([chatRoomId])
  @@index([initiatorId])
  @@index([receiverId])
  @@index([status])
  @@map("calls")
}

model Folder {
  id        String   @id @default(cuid())
  name      String
  parentId  String?  @map("parent_id")
  userId    String   @map("user_id")
  color     String?
  icon      String?
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  parent    Folder?  @relation("FolderHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children  Folder[] @relation("FolderHierarchy")
  files     File[]
  
  @@index([userId])
  @@index([parentId])
  @@map("folders")
}

model File {
  id              String    @id @default(cuid())
  filename        String
  originalName    String    @map("original_name")
  filepath        String
  size            BigInt
  mimeType        String    @map("mime_type")
  hash            String?   @unique
  thumbnailUrl    String?   @map("thumbnail_url")
  transcodeStatus String?   @default("PENDING") @map("transcode_status")
  transcodeJobId  String?   @map("transcode_job_id")
  transcodedPaths Json?     @map("transcoded_paths")
  userId          String    @map("user_id")
  folderId        String?   @map("folder_id")
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  folder          Folder?   @relation(fields: [folderId], references: [id], onDelete: SetNull)
  fileTags        FileTag[]
  
  // âœ… ì¶”ê°€ë¨: ChatMessageì™€ì˜ ì—­ê´€ê³„
  chatMessages    ChatMessage[]

  @@index([userId])
  @@index([folderId])
  @@map("files")
}

model Tag {
  id        String   @id @default(cuid())
  name      String   @unique
  color     String?
  createdAt DateTime @default(now()) @map("created_at")
  
  fileTags  FileTag[]
  postTags  PostTag[]
  
  @@map("tags")
}

model FileTag {
  id        String   @id @default(cuid())
  fileId    String   @map("file_id")
  tagId     String   @map("tag_id")
  createdAt DateTime @default(now()) @map("created_at")
  
  file      File     @relation(fields: [fileId], references: [id], onDelete: Cascade)
  tag       Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)
  
  @@unique([fileId, tagId])
  @@index([fileId])
  @@index([tagId])
  @@map("file_tags")
}

model PostTag {
  id        String   @id @default(cuid())
  postId    String   @map("post_id")
  tagId     String   @map("tag_id")
  createdAt DateTime @default(now()) @map("created_at")
  
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  tag       Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)
  
  @@unique([postId, tagId])
  @@index([postId])
  @@index([tagId])
  @@map("post_tags")
}

model SavedSearch {
  id        String   @id @default(cuid())
  name      String
  query     Json
  userId    String   @map("user_id")
  createdAt DateTime @default(now()) @map("created_at")
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@map("saved_searches")
}

model Post {
  id         String     @id @default(cuid())
  title      String
  content    String
  visibility Visibility @default(PRIVATE)
  userId     String     @map("user_id")
  createdAt  DateTime   @default(now()) @map("created_at")
  updatedAt  DateTime   @updatedAt @map("updated_at")
  
  user            User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  comments        Comment[]
  postTags        PostTag[]
  
  @@index([userId])
  @@map("posts")
}

model Comment {
  id        String   @id @default(cuid())
  content   String
  postId    String   @map("post_id")
  userId    String   @map("user_id")
  createdAt DateTime @default(now()) @map("created_at")
  
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([postId])
  @@index([userId])
  @@map("comments")
}

model SharedResource {
  id           String       @id @default(cuid())
  resourceType ResourceType
  resourceId   String       @map("resource_id")
  ownerId      String       @map("owner_id")
  sharedWithId String       @map("shared_with_id")
  permission   Permission   @default(VIEW)
  createdAt    DateTime     @default(now()) @map("created_at")
  
  owner        User         @relation("Owner", fields: [ownerId], references: [id], onDelete: Cascade)
  sharedWith   User         @relation("SharedWith", fields: [sharedWithId], references: [id], onDelete: Cascade)
  
  @@unique([resourceType, resourceId, sharedWithId])
  @@index([ownerId])
  @@index([sharedWithId])
  @@index([resourceType, resourceId])
  @@map("shared_resources")
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  userId    String   @unique
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("password_reset_tokens")
}
</file>

<file path="src/app/api/files/route.ts">
export const dynamic = 'force-dynamic';

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get("page") || "1");
    const limit = parseInt(searchParams.get("limit") || "20");
    const sortBy = searchParams.get("sortBy") || "createdAt";
    const sortOrder = (searchParams.get("sortOrder") || "desc") as "asc" | "desc";
    
    // [ì¶”ê°€] í´ë” ê²©ë¦¬ í•µì‹¬ íŒŒë¼ë¯¸í„°
    const folderId = searchParams.get("folderId"); // "null" ë˜ëŠ” "uuid"

    // ê²€ìƒ‰ & í•„í„°
    const search = searchParams.get("search") || "";
    const fileType = searchParams.get("fileType") || "";
    const startDate = searchParams.get("startDate");
    const endDate = searchParams.get("endDate");
    const filter = searchParams.get("filter") || "all"; // all, mine, shared

    const skip = (page - 1) * limit;

    /**
     * ==========================================
     * 1. ë‚´ íŒŒì¼ ì¡°ê±´ ì„¤ì • (folderId í•„í„°ë§ ì¶”ê°€)
     * ==========================================
     */
    const myFilesWhere: any = {
      userId: session.user.id,
    };

    // [í•µì‹¬ ìˆ˜ì •] í´ë” ê²©ë¦¬ ë¡œì§ ì£¼ì…
    // folderIdê°€ "null" ë¬¸ìì—´ë¡œ ì˜¤ë©´ ë¶€ëª¨ê°€ ì—†ëŠ”(í™ˆ) íŒŒì¼ë§Œ, IDê°€ ì˜¤ë©´ í•´ë‹¹ í´ë” íŒŒì¼ë§Œ.
    if (folderId === "null" || !folderId) {
      myFilesWhere.folderId = null;
    } else {
      myFilesWhere.folderId = folderId;
    }

    // ê²€ìƒ‰ì–´ í•„í„°
    if (search) {
      myFilesWhere.OR = [
        { originalName: { contains: search, mode: "insensitive" } },
        { filename: { contains: search, mode: "insensitive" } },
      ];
    }

    // íŒŒì¼ íƒ€ì… í•„í„°
    if (fileType) {
      if (fileType === "image") {
        myFilesWhere.mimeType = { startsWith: "image/" };
      } else if (fileType === "video") {
        myFilesWhere.mimeType = { startsWith: "video/" };
      } else if (fileType === "document") {
        myFilesWhere.OR = [
          { mimeType: { contains: "pdf" } },
          { mimeType: { contains: "document" } },
          { mimeType: { contains: "word" } },
        ];
      }
    }

    // ë‚ ì§œ ë²”ìœ„ í•„í„°
    if (startDate || endDate) {
      myFilesWhere.createdAt = {};
      if (startDate) myFilesWhere.createdAt.gte = new Date(startDate);
      if (endDate) myFilesWhere.createdAt.lte = new Date(endDate);
    }

    /**
     * ==========================================
     * 2. ê³µìœ ë°›ì€ íŒŒì¼ ì¡°íšŒ (ê³µìœ ëŠ” í´ë” ê²©ë¦¬ì—ì„œ ì œì™¸í•˜ê±°ë‚˜ ë³„ë„ ì²˜ë¦¬)
     * ==========================================
     */
    const sharedResources = await prisma.sharedResource.findMany({
      where: {
        resourceType: "FILE",
        sharedWithId: session.user.id,
      },
    });

    const sharedFileIds = sharedResources.map((sr) => sr.resourceId);

    // ê³µìœ ë°›ì€ íŒŒì¼ ìƒì„¸ ì •ë³´ (ê³µìœ ë°›ì€ íŒŒì¼ì€ í´ë” ê²½ë¡œì™€ ìƒê´€ì—†ì´ ë³´ì—¬ì£¼ëŠ” ê²ƒì´ ì¼ë°˜ì )
    const sharedFilesData = sharedFileIds.length > 0 
      ? await prisma.file.findMany({
          where: { id: { in: sharedFileIds } },
          include: { 
            user: { 
              select: { id: true, name: true, email: true } 
            },
            fileTags: {
              include: { tag: true }
            }
          }
        })
      : [];

    const sharedFilesWithMeta = sharedFilesData.map((file) => {
      const shareInfo = sharedResources.find((sr) => sr.resourceId === file.id);
      return {
        ...file,
        size: file.size.toString(),
        isShared: true,
        isOwner: false,
        sharedBy: file.user?.name,
        sharedByEmail: file.user?.email,
        sharedAt: shareInfo?.createdAt,
        permission: shareInfo?.permission,
      };
    });

    /**
     * ==========================================
     * 3. í•„í„° ë° í˜ì´ì§€ë„¤ì´ì…˜ ì²˜ë¦¬
     * ==========================================
     */
    let myFiles: any[] = [];
    let totalMyFiles = 0;

    if (filter === "all" || filter === "mine") {
      [myFiles, totalMyFiles] = await Promise.all([
        prisma.file.findMany({
          where: myFilesWhere,
          orderBy: { [sortBy]: sortOrder },
          // filterê°€ "all"ì¼ ë•ŒëŠ” ë‚˜ì¤‘ì— ë©”ëª¨ë¦¬ì—ì„œ í•©ì¹˜ë¯€ë¡œ skip/takeë¥¼ ì—¬ê¸°ì„œ í•˜ì§€ ì•ŠìŒ
          skip: filter === "mine" ? skip : undefined,
          take: filter === "mine" ? limit : undefined,
          include: {
            fileTags: {
              include: { tag: true }
            }
          }
        }),
        prisma.file.count({ where: myFilesWhere }),
      ]);
    }

    const myFilesWithMeta = myFiles.map((file) => ({
      ...file,
      size: file.size.toString(),
      isShared: false,
      isOwner: true,
    }));

    /**
     * ==========================================
     * 4. ìµœì¢… ë°ì´í„° ì¡°í•© ë° ì •ë ¬
     * ==========================================
     */
    let resultFiles: any[] = [];
    let finalTotal = 0;

    if (filter === "all") {
      // ë‚´ íŒŒì¼(í˜„ì¬ í´ë” ë‚´) + ê³µìœ ë°›ì€ íŒŒì¼ ì „ì²´
      const combined = [...myFilesWithMeta, ...sharedFilesWithMeta];
      
      // ì •ë ¬ ë¡œì§
      combined.sort((a: any, b: any) => {
        const aVal = a[sortBy];
        const bVal = b[sortBy];
        return sortOrder === "desc" 
          ? (aVal > bVal ? -1 : 1) 
          : (aVal > bVal ? 1 : -1);
      });

      finalTotal = combined.length;
      resultFiles = combined.slice(skip, skip + limit);
    } else if (filter === "mine") {
      resultFiles = myFilesWithMeta;
      finalTotal = totalMyFiles;
    } else {
      // shared í•„í„°
      sharedFilesWithMeta.sort((a: any, b: any) => {
        const aVal = a[sortBy];
        const bVal = b[sortBy];
        return sortOrder === "desc" ? (aVal > bVal ? -1 : 1) : (aVal > bVal ? 1 : -1);
      });
      finalTotal = sharedFilesWithMeta.length;
      resultFiles = sharedFilesWithMeta.slice(skip, skip + limit);
    }

    return NextResponse.json({
      files: resultFiles,
      pagination: {
        total: finalTotal,
        page,
        limit,
        totalPages: Math.ceil(finalTotal / limit),
      },
      stats: {
        myFiles: totalMyFiles,
        sharedFiles: sharedFilesWithMeta.length,
      },
    });

  } catch (error) {
    console.error("Files fetch error:", error);
    return NextResponse.json(
      { error: "íŒŒì¼ ëª©ë¡ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/chat/page.tsx">
"use client";

import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import { useEffect, useState, useCallback } from "react";
import Link from "next/link";
import { useSocket } from "@/hooks/useSocket";
import { toast } from "@/components/Toast";

interface ChatRoom {
  id: string;
  name: string | null;
  type: "DIRECT" | "GROUP";
  members: any[];
  messages: any[];
  unreadCount: number;
  updatedAt: string;
}

export default function ChatPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const { socket, isConnected } = useSocket();

  const [chatRooms, setChatRooms] = useState<ChatRoom[]>([]);
  const [loading, setLoading] = useState(true);
  const [showNewChatModal, setShowNewChatModal] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [searchResults, setSearchResults] = useState<any[]>([]);
  const [isSearching, setIsSearching] = useState(false);
  const [isCreating, setIsCreating] = useState(false);

  useEffect(() => {
    if (status === "unauthenticated") router.push("/login");
  }, [status, router]);

  const fetchChatRooms = useCallback(async () => {
    try {
      const res = await fetch("/api/chat/rooms");
      if (res.ok) {
        const data = await res.json();
        setChatRooms(data.chatRooms || []);
      }
    } catch (err) {
      console.error("ì±„íŒ…ë°© ëª©ë¡ ë¡œë“œ ì‹¤íŒ¨:", err);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    if (session) fetchChatRooms();
  }, [session, fetchChatRooms]);

  // âœ… ì‹¤ì‹œê°„: ë‹¤ë¥¸ ì±„íŒ…ë°©ì—ì„œ ìƒˆ ë©”ì‹œì§€ ì˜¤ë©´ ëª©ë¡ ìˆœì„œ/ë¯¸ë¦¬ë³´ê¸° ê°±ì‹ 
  useEffect(() => {
    if (!socket) return;

    const handleNewMessage = (data: any) => {
      setChatRooms((prev) => {
        const roomIndex = prev.findIndex((r) => r.id === data.chatRoomId);
        if (roomIndex === -1) return prev;

        const updated = [...prev];
        const room = { ...updated[roomIndex] };

        // ë§ˆì§€ë§‰ ë©”ì‹œì§€ ì—…ë°ì´íŠ¸
        room.messages = [data];
        room.updatedAt = data.createdAt || new Date().toISOString();

        // ë‚´ê°€ ë³´ë‚¸ ë©”ì‹œì§€ê°€ ì•„ë‹ˆë©´ unread ì¦ê°€
        if (data.senderId !== session?.user?.id) {
          room.unreadCount = (room.unreadCount || 0) + 1;
        }

        // í•´ë‹¹ ë°©ì„ ë§¨ ìœ„ë¡œ ì˜¬ë¦¬ê¸°
        updated.splice(roomIndex, 1);
        return [room, ...updated];
      });
    };

    socket.on("message:receive", handleNewMessage);
    socket.on("message:new", handleNewMessage);

    return () => {
      socket.off("message:receive", handleNewMessage);
      socket.off("message:new", handleNewMessage);
    };
  }, [socket, session?.user?.id]);

  const searchUsers = async () => {
    if (!searchQuery.trim()) return;
    setIsSearching(true);
    try {
      const res = await fetch(
        `/api/users/search?q=${encodeURIComponent(searchQuery)}`
      );
      if (res.ok) {
        const data = await res.json();
        setSearchResults(data.users || []);
        if ((data.users || []).length === 0) {
          toast.info("ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤");
        }
      }
    } catch {
      toast.error("ì‚¬ìš©ì ê²€ìƒ‰ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
    } finally {
      setIsSearching(false);
    }
  };

  const createChatRoom = async (otherUserId: string) => {
    setIsCreating(true);
    try {
      const res = await fetch("/api/chat/rooms", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ type: "DIRECT", memberIds: [otherUserId] }),
      });

      if (res.ok) {
        const data = await res.json();
        router.push(`/chat/${data.chatRoom.id}`);
      } else {
        // âœ… alert() â†’ toast.error()
        toast.error("ì±„íŒ…ë°© ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
      }
    } catch {
      toast.error("ì±„íŒ…ë°© ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setIsCreating(false);
    }
  };

  const closeModal = () => {
    setShowNewChatModal(false);
    setSearchResults([]);
    setSearchQuery("");
  };

  const getChatRoomName = (chatRoom: ChatRoom) => {
    if (chatRoom.type === "GROUP") return chatRoom.name || "ê·¸ë£¹ ì±„íŒ…";
    const other = chatRoom.members.find(
      (m) => m.user.id !== session?.user?.id
    );
    return other?.user.name || "ì•Œ ìˆ˜ ì—†ìŒ";
  };

  const getChatRoomInitial = (chatRoom: ChatRoom) => {
    return getChatRoomName(chatRoom)[0]?.toUpperCase() || "?";
  };

  const getLastMessage = (chatRoom: ChatRoom) => {
    if (!chatRoom.messages?.length) return "ë©”ì‹œì§€ê°€ ì—†ìŠµë‹ˆë‹¤";
    const last = chatRoom.messages[0];
    if (last.type === "FILE") return "ğŸ“ íŒŒì¼";
    if (last.type === "CALL_LOG") return "ğŸ“ í†µí™”";
    return last.content || "ë©”ì‹œì§€ê°€ ì—†ìŠµë‹ˆë‹¤";
  };

  const formatDate = (dateStr: string) => {
    const date = new Date(dateStr);
    if (isNaN(date.getTime())) return "";
    const now = new Date();
    const isToday = date.toDateString() === now.toDateString();
    if (isToday) {
      return date.toLocaleTimeString("ko-KR", {
        hour: "2-digit",
        minute: "2-digit",
      });
    }
    return date.toLocaleDateString("ko-KR", { month: "short", day: "numeric" });
  };

  if (status === "loading") {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="text-gray-400">ë¡œë”© ì¤‘...</div>
      </div>
    );
  }

  if (!session) return null;

  return (
    <div className="min-h-screen bg-gray-50">
      {/* â”€â”€ í—¤ë” â”€â”€ */}
      <header className="bg-white border-b sticky top-0 z-10">
        <div className="max-w-2xl mx-auto px-4 py-4 flex justify-between items-center">
          <div className="flex items-center gap-3">
            <h1 className="text-xl font-bold text-gray-900">ğŸ’¬ ì±„íŒ…</h1>
            {/* âœ… isConnected ì´ì œ ì‹¤ì œë¡œ ì‘ë™ */}
            <span
              className={`w-2 h-2 rounded-full ${
                isConnected ? "bg-green-500" : "bg-gray-300"
              }`}
              title={isConnected ? "ì—°ê²°ë¨" : "ì—°ê²° ì¤‘..."}
            />
          </div>
          <div className="flex items-center gap-2">
            <Link
              href="/dashboard"
              className="text-sm text-gray-500 hover:text-gray-700"
            >
              â† ëŒ€ì‹œë³´ë“œ
            </Link>
            <button
              onClick={() => setShowNewChatModal(true)}
              className="px-3 py-1.5 bg-blue-600 text-white text-sm rounded-lg hover:bg-blue-700 font-medium"
            >
              + ìƒˆ ì±„íŒ…
            </button>
          </div>
        </div>
      </header>

      {/* â”€â”€ ì±„íŒ…ë°© ëª©ë¡ â”€â”€ */}
      <main className="max-w-2xl mx-auto px-4 py-4">
        {loading ? (
          // ìŠ¤ì¼ˆë ˆí†¤ UI
          <div className="space-y-1">
            {[1, 2, 3].map((i) => (
              <div
                key={i}
                className="bg-white rounded-xl p-4 flex gap-3 animate-pulse"
              >
                <div className="w-12 h-12 rounded-full bg-gray-200 flex-shrink-0" />
                <div className="flex-1 space-y-2 py-1">
                  <div className="h-4 bg-gray-200 rounded w-1/3" />
                  <div className="h-3 bg-gray-100 rounded w-2/3" />
                </div>
              </div>
            ))}
          </div>
        ) : chatRooms.length === 0 ? (
          <div className="text-center py-16">
            <p className="text-4xl mb-4">ğŸ’¬</p>
            <p className="text-gray-500 mb-4">ì•„ì§ ëŒ€í™”ê°€ ì—†ì–´ìš”</p>
            <button
              onClick={() => setShowNewChatModal(true)}
              className="px-4 py-2 bg-blue-600 text-white rounded-lg text-sm font-medium"
            >
              ì²« ì±„íŒ… ì‹œì‘í•˜ê¸°
            </button>
          </div>
        ) : (
          <div className="space-y-1">
            {chatRooms.map((chatRoom) => (
              <Link
                key={chatRoom.id}
                href={`/chat/${chatRoom.id}`}
                className="flex items-center gap-3 bg-white hover:bg-gray-50 rounded-xl p-4 transition"
              >
                {/* ì•„ë°”íƒ€ */}
                <div className="w-12 h-12 rounded-full bg-blue-100 flex items-center justify-center text-blue-600 font-bold text-lg flex-shrink-0">
                  {getChatRoomInitial(chatRoom)}
                </div>

                {/* ë‚´ìš© */}
                <div className="flex-1 min-w-0">
                  <div className="flex items-center justify-between mb-0.5">
                    <span className="font-semibold text-gray-900 text-sm">
                      {getChatRoomName(chatRoom)}
                    </span>
                    <span className="text-xs text-gray-400 flex-shrink-0 ml-2">
                      {formatDate(chatRoom.updatedAt)}
                    </span>
                  </div>
                  <div className="flex items-center justify-between">
                    <p className="text-sm text-gray-500 truncate">
                      {getLastMessage(chatRoom)}
                    </p>
                    {chatRoom.unreadCount > 0 && (
                      <span className="ml-2 min-w-[20px] h-5 px-1.5 bg-blue-600 text-white text-xs rounded-full flex items-center justify-center flex-shrink-0">
                        {chatRoom.unreadCount > 99 ? "99+" : chatRoom.unreadCount}
                      </span>
                    )}
                  </div>
                </div>
              </Link>
            ))}
          </div>
        )}
      </main>

      {/* â”€â”€ ìƒˆ ì±„íŒ… ëª¨ë‹¬ â”€â”€ */}
      {showNewChatModal && (
        <div
          className="fixed inset-0 z-50 flex items-end sm:items-center justify-center bg-black/50 backdrop-blur-sm p-4"
          onClick={closeModal}
        >
          <div
            className="bg-white rounded-2xl shadow-2xl w-full max-w-md p-6"
            onClick={(e) => e.stopPropagation()}
          >
            <h3 className="text-lg font-bold mb-4 text-gray-900">
              ìƒˆ ì±„íŒ… ì‹œì‘
            </h3>

            <div className="flex gap-2 mb-4">
              <input
                type="text"
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                onKeyDown={(e) => e.key === "Enter" && searchUsers()}
                placeholder="ì´ë¦„ ë˜ëŠ” ì´ë©”ì¼ë¡œ ê²€ìƒ‰"
                className="flex-1 px-4 py-2.5 border border-gray-200 rounded-xl outline-none focus:border-blue-500 text-gray-900 bg-gray-50 text-sm"
                autoFocus
              />
              <button
                onClick={searchUsers}
                disabled={isSearching}
                className="px-4 py-2.5 bg-blue-600 text-white rounded-xl font-medium text-sm disabled:opacity-50"
              >
                {isSearching ? "..." : "ê²€ìƒ‰"}
              </button>
            </div>

            {searchResults.length > 0 && (
              <div className="space-y-2 max-h-60 overflow-y-auto mb-4">
                {searchResults.map((user) => (
                  <button
                    key={user.id}
                    onClick={() => createChatRoom(user.id)}
                    disabled={isCreating}
                    className="w-full p-3 text-left border border-gray-100 rounded-xl hover:bg-blue-50 hover:border-blue-200 transition disabled:opacity-50"
                  >
                    <div className="flex items-center gap-3">
                      <div className="w-9 h-9 rounded-full bg-blue-100 flex items-center justify-center text-blue-600 font-bold text-sm flex-shrink-0">
                        {user.name?.[0]?.toUpperCase() || "?"}
                      </div>
                      <div className="flex-1 min-w-0">
                        <p className="font-medium text-gray-900 text-sm">
                          {user.name}
                        </p>
                        <p className="text-xs text-gray-500 truncate">
                          {user.email}
                        </p>
                      </div>
                      {user.isOnline && (
                        <span className="w-2 h-2 bg-green-500 rounded-full flex-shrink-0" />
                      )}
                    </div>
                  </button>
                ))}
              </div>
            )}

            <div className="flex justify-end">
              <button
                onClick={closeModal}
                className="px-4 py-2 text-gray-500 hover:bg-gray-100 rounded-xl text-sm font-medium"
              >
                ë‹«ê¸°
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

@import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');

:root {
  --eum-purple: #7c3aed;
  --eum-blue: #2563eb;
  --eum-dark: #0f0c29;
  --eum-glass: rgba(255, 255, 255, 0.06);
  --eum-border: rgba(255, 255, 255, 0.12);
}

* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

body {
  font-family: 'Pretendard', -apple-system, sans-serif;
  background-color: var(--eum-dark);
  color: #ffffff;
  overflow-x: hidden;
}

/* ì„¸ë ¨ëœ ìŠ¤í¬ë¡¤ë°” ì»¤ìŠ¤í…€ */
::-webkit-scrollbar {
  width: 6px;
}
::-webkit-scrollbar-track {
  background: var(--eum-dark);
}
::-webkit-scrollbar-thumb {
  background: rgba(124, 58, 237, 0.3);
  border-radius: 10px;
}
::-webkit-scrollbar-thumb:hover {
  background: var(--eum-purple);
}

/* ì „ì—­ ê·¸ë¼ë°ì´ì…˜ í…ìŠ¤íŠ¸ í´ë˜ìŠ¤ */
.text-eum-gradient {
  background: linear-gradient(135deg, #a78bfa, #60a5fa);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

/* Glassmorphism ê¸°ë³¸ í´ë˜ìŠ¤ */
.eum-glass-effect {
  background: var(--eum-glass);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  border: 1px solid var(--eum-border);
}
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from "next";
import { Providers } from "./providers";
import { ToastContainer } from "@/components/Toast";
import "./globals.css";

export const metadata: Metadata = {
  title: "ì´ìŒ (Eum)",
  description: "ì‚¬ëŒê³¼ íŒŒì¼ì„ ì‡ë‹¤",
};

export default function RootLayout({ children }) {
  return (
    <html lang="ko">
      <head>
        <link
          rel="stylesheet"
          href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css"
        />
      </head>
      <body>
        <Providers>{children}</Providers>
        {/* âœ… ì „ì—­ Toast â€” ëª¨ë“  í˜ì´ì§€ì—ì„œ toast.error() ë“± ì‚¬ìš© ê°€ëŠ¥ */}
        <ToastContainer />
      </body>
    </html>
  );
}
</file>

<file path="src/lib/firebase.ts">
import { initializeApp, getApps, getApp } from "firebase/app";
import { getMessaging, getToken, onMessage, Messaging } from "firebase/messaging";

const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
};

// Firebase ì•± ì´ˆê¸°í™” (ì„œë²„ ì‚¬ì´ë“œ ì—ëŸ¬ ë°©ì§€)
const app = getApps().length === 0 ? initializeApp(firebaseConfig) : getApp();

let messaging: Messaging | null = null;

/**
 * ë©”ì‹œì§• ê°ì²´ ì´ˆê¸°í™”
 */
export const getFirebaseMessaging = () => {
  if (typeof window !== "undefined" && "serviceWorker" in navigator) {
    if (!messaging) {
      try {
        messaging = getMessaging(app);
      } catch (error) {
        console.error("Firebase Messaging ì´ˆê¸°í™” ì‹¤íŒ¨:", error);
      }
    }
  }
  return messaging;
};

/**
 * FCM í† í° ìš”ì²­
 */
export async function requestNotificationPermission(): Promise<string | null> {
  try {
    if (typeof window === "undefined") return null;

    const permission = await Notification.requestPermission();
    if (permission !== "granted") {
      console.warn("âš ï¸ ì•Œë¦¼ ê¶Œí•œì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤.");
      return null;
    }

    const messaging = getFirebaseMessaging();
    if (!messaging) return null;

    // 1. ì„œë¹„ìŠ¤ ì›Œì»¤ ë“±ë¡ ë° 'ì¤€ë¹„' ìƒíƒœ ëŒ€ê¸°
    // ê²½ë¡œê°€ ì •í™•íˆ /firebase-messaging-sw.js ì¸ì§€ í™•ì¸í•˜ì„¸ìš”.
    const registration = await navigator.serviceWorker.register("/firebase-messaging-sw.js");
    
    // ì„œë¹„ìŠ¤ ì›Œì»¤ê°€ í™œì„±í™”ë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ëŠ” ë¡œì§ ì¶”ê°€ (ì¤‘ìš”)
    while (registration.active?.state !== 'activated') {
      await new Promise(resolve => setTimeout(resolve, 100)); // 100msì”© ëŒ€ê¸°
      if (registration.installing?.state === 'redundant') break; 
    }

    console.log("âœ… ì„œë¹„ìŠ¤ ì›Œì»¤ í™œì„±í™” í™•ì¸ë¨");

    // 2. í† í° ê°€ì ¸ì˜¤ê¸° (registration ê°ì²´ë¥¼ ì§ì ‘ ì „ë‹¬)
    const token = await getToken(messaging, {
      vapidKey: process.env.NEXT_PUBLIC_FIREBASE_VAPID_KEY,
      serviceWorkerRegistration: registration,
    });

    if (token) {
      console.log("âœ… FCM í† í° ìƒì„± ì„±ê³µ:", token);
      return token;
    } 
    
    return null;
  } catch (error) {
    console.error("âŒ FCM í† í° ìš”ì²­ ì‹¤íŒ¨:", error);
    return null;
  }
}

/**
 * í¬ê·¸ë¼ìš´ë“œ ë©”ì‹œì§€ ìˆ˜ì‹  ë¦¬ìŠ¤ë„ˆ (ì•±ì„ ì¼œë†“ê³  ìˆì„ ë•Œ)
 */
export function onForegroundMessage(callback: (payload: any) => void) {
  const messaging = getFirebaseMessaging();
  if (!messaging) return () => {};

  // ë¸Œë¼ìš°ì € íƒ­ì´ í™œì„±í™”ëœ ìƒíƒœì—ì„œ í‘¸ì‹œê°€ ì˜¤ë©´ ì´ ë¡œì§ì´ ì‹¤í–‰ë©ë‹ˆë‹¤.
  return onMessage(messaging, (payload) => {
    console.log("ğŸ“¬ í¬ê·¸ë¼ìš´ë“œ ë©”ì‹œì§€ ìˆ˜ì‹ :", payload);
    callback(payload);
  });
}

/**
 * FCM í† í° ì„œë²„ ë“±ë¡
 */
export async function registerFCMToken() {
  const token = await requestNotificationPermission();
  
  if (token) {
    try {
      const res = await fetch("/api/users/fcm-token", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ fcmToken: token }),
      });

      if (res.ok) {
        console.log("âœ… FCM í† í° ì„œë²„ ë“±ë¡ ì„±ê³µ");
        return true;
      }
    } catch (error) {
      console.error("FCM í† í° ì„œë²„ ì „ì†¡ ì˜¤ë¥˜:", error);
    }
  }
  return false;
}

/**
 * FCM í† í° ì‚­ì œ
 */
export async function unregisterFCMToken() {
  try {
    const res = await fetch("/api/users/fcm-token", {
      method: "DELETE",
    });
    return res.ok;
  } catch (error) {
    console.error("FCM í† í° ì‚­ì œ ì˜¤ë¥˜:", error);
    return false;
  }
}
</file>

<file path="src/app/(auth)/login/page.tsx">
"use client";

import { useState, Suspense } from "react";
import { signIn } from "next-auth/react";
import { useRouter, useSearchParams } from "next/navigation";
import Link from "next/link";
import { 
  Mail, 
  Lock, 
  Eye, 
  EyeOff, 
  Cloud, 
  AlertCircle, 
  Loader2,
  ChevronRight,
  Search
} from "lucide-react";

function LoginForm() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  const isSignupSuccess = searchParams.get("signup") === "success";

  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");
    setLoading(true);

    try {
      const result = await signIn("credentials", {
        email,
        password,
        redirect: false,
      });

      if (result?.error) {
        setError("ì´ë©”ì¼ ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.");
      } else {
        router.push("/dashboard");
        router.refresh();
      }
    } catch (err) {
      setError("ë¡œê·¸ì¸ ì¤‘ ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-[#0f0c29] text-white flex items-center justify-center p-6 relative overflow-hidden">
      {/* ë°°ê²½ ì¥ì‹ */}
      <div className="absolute top-[-10%] left-[-10%] w-[40%] h-[40%] bg-purple-600/20 blur-[100px] rounded-full -z-10" />
      <div className="absolute bottom-[-10%] right-[-10%] w-[40%] h-[40%] bg-blue-600/20 blur-[100px] rounded-full -z-10" />

      <div className="max-w-md w-full">
        {/* ë¡œê³  */}
        <div className="text-center mb-10 flex flex-col items-center">
          <Link href="/" className="inline-flex items-center gap-3 mb-4 group">
            <div className="w-12 h-12 bg-gradient-to-br from-purple-500 to-blue-600 rounded-2xl flex items-center justify-center shadow-xl group-hover:scale-110 transition-transform">
              <Cloud size={28} fill="currentColor" />
            </div>
            <div className="text-left">
              <h1 className="text-3xl font-black tracking-tighter italic leading-none">EUM</h1>
              <p className="text-[10px] text-white/40 uppercase tracking-[0.2em] font-bold mt-1">Personal Cloud</p>
            </div>
          </Link>
        </div>

        {/* ì¹´ë“œ */}
        <div className="bg-white/5 border border-white/10 p-8 rounded-[40px] backdrop-blur-2xl shadow-2xl relative">
          <div className="mb-8">
            <h2 className="text-2xl font-bold mb-2">ë¡œê·¸ì¸</h2>
            <p className="text-white/50 text-sm">ì´ìŒì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤ ğŸ‘‹</p>
          </div>

          {isSignupSuccess && !error && (
            <div className="mb-6 flex items-center gap-2 bg-emerald-500/10 border border-emerald-500/20 text-emerald-400 p-4 rounded-2xl text-sm animate-fade-in">
              <AlertCircle size={18} />
              <p>íšŒì›ê°€ì… ì™„ë£Œ! ìƒì„±í•œ ê³„ì •ìœ¼ë¡œ ë¡œê·¸ì¸í•˜ì„¸ìš”.</p>
            </div>
          )}

          {error && (
            <div className="mb-6 flex items-center gap-2 bg-red-500/10 border border-red-500/20 text-red-400 p-4 rounded-2xl text-sm">
              <AlertCircle size={18} />
              <p>{error}</p>
            </div>
          )}

          <form onSubmit={handleLogin} className="space-y-4">
            <div className="space-y-2">
              <label className="text-xs font-bold text-white/40 ml-1 uppercase tracking-wider">Email</label>
              <div className="relative group">
                <div className="absolute inset-y-0 left-4 flex items-center pointer-events-none text-white/20 group-focus-within:text-purple-400 transition-colors">
                  <Mail size={18} />
                </div>
                <input
                  type="email"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  placeholder="example@email.com"
                  className="w-full bg-white/5 border border-white/10 rounded-2xl py-4 pl-12 pr-4 outline-none focus:border-purple-500/50 focus:bg-white/10 transition-all placeholder:text-white/10"
                  required
                />
              </div>
            </div>

            <div className="space-y-2">
              <label className="text-xs font-bold text-white/40 ml-1 uppercase tracking-wider">Password</label>
              <div className="relative group">
                <div className="absolute inset-y-0 left-4 flex items-center pointer-events-none text-white/20 group-focus-within:text-purple-400 transition-colors">
                  <Lock size={18} />
                </div>
                <input
                  type={showPassword ? "text" : "password"}
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  placeholder="ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”"
                  className="w-full bg-white/5 border border-white/10 rounded-2xl py-4 pl-12 pr-12 outline-none focus:border-purple-500/50 focus:bg-white/10 transition-all placeholder:text-white/10"
                  required
                />
                <button
                  type="button"
                  onClick={() => setShowPassword(!showPassword)}
                  className="absolute inset-y-0 right-4 flex items-center text-white/20 hover:text-white transition-colors"
                >
                  {showPassword ? <EyeOff size={18} /> : <Eye size={18} />}
                </button>
              </div>
            </div>

            <div className="flex justify-end gap-3 px-1">
              <Link href="/find-email" className="text-xs text-white/30 hover:text-purple-400 transition-colors flex items-center gap-1">
                <Search size={12} />
                ì´ë©”ì¼ ì°¾ê¸°
              </Link>
              <span className="text-white/10 text-xs">|</span>
              <Link href="/reset-password" className="text-xs text-white/30 hover:text-purple-400 transition-colors">
                ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì •
              </Link>
            </div>

            <button
              type="submit"
              disabled={loading}
              className="w-full py-4 bg-gradient-to-r from-purple-500 to-blue-600 text-white font-bold rounded-2xl hover:opacity-90 active:scale-[0.98] transition-all flex items-center justify-center gap-2 shadow-xl shadow-purple-500/20 disabled:opacity-50 mt-2"
            >
              {loading ? (
                <Loader2 size={20} className="animate-spin" />
              ) : (
                <>
                  ë¡œê·¸ì¸
                  <ChevronRight size={20} />
                </>
              )}
            </button>
          </form>

          <div className="mt-8 pt-8 border-t border-white/5 text-center">
            <p className="text-white/40 text-sm">
              ì•„ì§ ê³„ì •ì´ ì—†ìœ¼ì‹ ê°€ìš”?{" "}
              <Link href="/register" className="text-white font-bold hover:text-purple-400 transition-colors underline underline-offset-4">
                íšŒì›ê°€ì…
              </Link>
            </p>
          </div>
        </div>
        
        <p className="text-center mt-10 text-white/10 text-[10px] font-medium tracking-[0.3em] uppercase">
          Â© 2026 EUM Cloud Service
        </p>
      </div>
    </div>
  );
}

export default function LoginPage() {
  return (
    <Suspense fallback={
      <div className="min-h-screen bg-[#0f0c29] flex items-center justify-center">
        <Loader2 size={40} className="animate-spin text-purple-500" />
      </div>
    }>
      <LoginForm />
    </Suspense>
  );
}
</file>

<file path="src/app/(auth)/signup/page.tsx">
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import Link from "next/link";

export default function SignupPage() {
  const router = useRouter();
  const [formData, setFormData] = useState({
    name: "",
    email: "",
    password: "",
  });
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");
    setLoading(true);

    try {
      const res = await fetch("/api/auth/signup", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(formData),
      });

      const data = await res.json();

      if (!res.ok) {
        setError(data.error || "íšŒì›ê°€ì…ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
        setLoading(false);
        return;
      }

      // ì„±ê³µ ì‹œ ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ ì´ë™
      alert("íšŒì›ê°€ì…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤! ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”.");
      router.push("/login");
    } catch (err) {
      setError("ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
            â˜ï¸ Personal Cloud
          </h2>
          <p className="mt-2 text-center text-sm text-gray-600">
            ìƒˆ ê³„ì • ë§Œë“¤ê¸°
          </p>
        </div>

        <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
          {error && (
            <div className="rounded-md bg-red-50 p-4">
              <p className="text-sm text-red-800">{error}</p>
            </div>
          )}

          <div className="rounded-md shadow-sm -space-y-px">
            <div>
              <label htmlFor="name" className="sr-only">ì´ë¦„</label>
              <input
                id="name"
                name="name"
                type="text"
                required
                value={formData.name}
                onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-t-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
                placeholder="ì´ë¦„"
              />
            </div>
            <div>
              <label htmlFor="email" className="sr-only">ì´ë©”ì¼</label>
              <input
                id="email"
                name="email"
                type="email"
                required
                value={formData.email}
                onChange={(e) => setFormData({ ...formData, email: e.target.value })}
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
                placeholder="ì´ë©”ì¼ ì£¼ì†Œ"
              />
            </div>
            <div>
              <label htmlFor="password" className="sr-only">ë¹„ë°€ë²ˆí˜¸</label>
              <input
                id="password"
                name="password"
                type="password"
                required
                value={formData.password}
                onChange={(e) => setFormData({ ...formData, password: e.target.value })}
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-b-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
                placeholder="ë¹„ë°€ë²ˆí˜¸ (ìµœì†Œ 8ì)"
              />
            </div>
          </div>

          <div>
            <button
              type="submit"
              disabled={loading}
              className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:bg-gray-400"
            >
              {loading ? "ì²˜ë¦¬ ì¤‘..." : "íšŒì›ê°€ì…"}
            </button>
          </div>

          <div className="text-center">
            <p className="text-sm text-gray-600">
              ì´ë¯¸ ê³„ì •ì´ ìˆìœ¼ì‹ ê°€ìš”?{" "}
              <Link href="/login" className="font-medium text-blue-600 hover:text-blue-500">
                ë¡œê·¸ì¸
              </Link>
            </p>
          </div>
        </form>
      </div>
    </div>
  );
}
</file>

<file path="src/app/api/auth/[...nextauth]/route.ts">
import NextAuth from "next-auth";
import { authOptions } from "@/lib/auth";

const handler = NextAuth(authOptions);

// authOptionsëŠ” ì ˆëŒ€ ì—¬ê¸°ì„œ exportí•˜ì§€ ì•ŠìŒ!
// ë‹¤ë¥¸ íŒŒì¼ë“¤ì€ @/lib/auth ì—ì„œ ì§ì ‘ importí•´ì•¼ í•¨
export { handler as GET, handler as POST };
</file>

<file path="src/app/api/calls/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { prisma } from "@/lib/db";
import { sendCallNotification } from "@/lib/fcm";

// í†µí™” ìš”ì²­ ìƒì„±
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { chatRoomId, receiverId, callType } = body;

    // ìœ íš¨ì„± ê²€ì‚¬
    if (!chatRoomId || !receiverId || !callType) {
      return NextResponse.json(
        { error: "í•„ìˆ˜ ì •ë³´ê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤" },
        { status: 400 }
      );
    }

    // ì±„íŒ…ë°© ë©¤ë²„ì‹­ í™•ì¸
    const membership = await prisma.chatRoomMember.findFirst({
      where: {
        chatRoomId,
        userId: session.user.id,
      },
    });

    if (!membership) {
      return NextResponse.json(
        { error: "ì±„íŒ…ë°©ì— ì°¸ì—¬í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // ìˆ˜ì‹ ì ì •ë³´ ì¡°íšŒ
    const receiver = await prisma.user.findUnique({
      where: { id: receiverId },
      select: {
        id: true,
        name: true,
        fcmToken: true,
        isOnline: true,
      },
    });

    if (!receiver) {
      return NextResponse.json(
        { error: "ìˆ˜ì‹ ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // í†µí™” ê¸°ë¡ ìƒì„±
    const call = await prisma.call.create({
      data: {
        chatRoomId,
        initiatorId: session.user.id,
        receiverId,
        type: callType,
        status: "PENDING",
      },
    });

    // ========== FCM í‘¸ì‹œ ì•Œë¦¼ ì „ì†¡ ==========
    if (receiver.fcmToken) {
      try {
        // ìˆ˜ì •ëœ fcm.tsì˜ sendCallNotification í˜¸ì¶œ
        const pushResult = await sendCallNotification(
          receiver.fcmToken,
          session.user.name || "ì‚¬ìš©ì",
          callType,
          call.id,
          chatRoomId
        );
        
        if (pushResult.success) {
          console.log(`âœ… í†µí™” í‘¸ì‹œ ì„±ê³µ: ${receiver.name} (Status: ${receiver.isOnline ? 'Online' : 'Offline'})`);
        } else {
          console.error(`âŒ í†µí™” í‘¸ì‹œ ì „ì†¡ ì‹¤íŒ¨: ${pushResult.error}`);
        }
      } catch (error) {
        console.error(`âŒ í†µí™” í‘¸ì‹œ ì˜ˆì™¸ ë°œìƒ (${receiver.name}):`, error);
      }
    } else {
      console.warn(`âš ï¸ FCM í† í° ì—†ìŒ: ${receiver.name}`);
    }

    return NextResponse.json(
      {
        message: "í†µí™” ìš”ì²­ì´ ì „ì†¡ë˜ì—ˆìŠµë‹ˆë‹¤",
        call,
      },
      { status: 201 }
    );
  } catch (error) {
    console.error("Call request error:", error);
    return NextResponse.json(
      { error: "í†µí™” ìš”ì²­ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// í™œì„± í†µí™” ì¡°íšŒ
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const activeCalls = await prisma.call.findMany({
      where: {
        OR: [
          { initiatorId: session.user.id },
          { receiverId: session.user.id },
        ],
        status: { in: ["PENDING", "ACCEPTED"] },
      },
      include: {
        initiator: { select: { id: true, name: true } },
        receiver: { select: { id: true, name: true } },
      },
      orderBy: { createdAt: "desc" },
    });

    return NextResponse.json({ calls: activeCalls });
  } catch (error) {
    console.error("Active calls fetch error:", error);
    return NextResponse.json(
      { error: "í†µí™” ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/dashboard/page.tsx">
"use client";

import { useSession, signOut } from "next-auth/react";
import { useRouter, usePathname } from "next/navigation";
import { useEffect, useState, useCallback, useMemo } from "react";
import Link from "next/link";
import { toast } from "@/components/Toast";
import { useConfirm } from "@/components/ConfirmDialog";

interface Folder {
  id: string;
  name: string;
  userId: string;
  _count: { files: number };
}

interface Tag { id: string; name: string; color: string | null; }

interface FileItem {
  id: string;
  filename: string;
  originalName: string;
  size: string;
  mimeType: string;
  thumbnailUrl: string | null;
  createdAt: string;
  folderId: string | null;
  userId: string;
  fileTags?: { tag: Tag }[];
}

interface BreadcrumbItem { id: string | null; name: string; }

export default function DashboardPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const pathname = usePathname();
  // âœ… confirm() ëŒ€ì²´
  const { confirmDialog, openConfirm } = useConfirm();

  const [currentFolderId, setCurrentFolderId] = useState<string | null>(null);
  const [folders, setFolders] = useState<Folder[]>([]);
  const [files, setFiles] = useState<FileItem[]>([]);
  const [breadcrumb, setBreadcrumb] = useState<BreadcrumbItem[]>([{ id: null, name: "í™ˆ" }]);
  const [loading, setLoading] = useState(true);
  const [searchQuery, setSearchQuery] = useState("");

  const [showFolderModal, setShowFolderModal] = useState(false);
  const [showFileDetail, setShowFileDetail] = useState(false);
  const [showShareModal, setShowShareModal] = useState(false);
  const [selectedFile, setSelectedFile] = useState<FileItem | null>(null);
  const [selectedFolder, setSelectedFolder] = useState<Folder | null>(null);
  const [shareType, setShareType] = useState<"FILE" | "FOLDER">("FILE");

  const [newFolderName, setNewFolderName] = useState("");
  const [shareEmail, setShareEmail] = useState("");
  const [sharePermission, setSharePermission] = useState<"VIEW" | "EDIT">("VIEW");
  const [newTagName, setNewTagName] = useState("");
  const [isSharing, setIsSharing] = useState(false);

  const [uploading, setUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);

  const fetchData = useCallback(async () => {
    setLoading(true);
    try {
      const folderUrl = currentFolderId ? `/api/folders?parentId=${currentFolderId}` : `/api/folders`;
      const fileUrl = currentFolderId ? `/api/files?folderId=${currentFolderId}` : `/api/files?folderId=null`;
      const [fRes, fileRes] = await Promise.all([fetch(folderUrl), fetch(fileUrl)]);
      if (fRes.ok) setFolders((await fRes.json()).folders || []);
      if (fileRes.ok) setFiles((await fileRes.json()).files || []);
    } catch (err) {
      console.error(err);
      toast.error("ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  }, [currentFolderId]);

  useEffect(() => {
    if (status === "unauthenticated") router.push("/login");
    if (session) fetchData();
  }, [status, session, fetchData, router]);

  const displayedFiles = useMemo(
    () => files.filter((f) => f.originalName.toLowerCase().includes(searchQuery.toLowerCase())),
    [files, searchQuery]
  );

  const handleFolderClick = (f: Folder) => {
    setCurrentFolderId(f.id);
    setBreadcrumb([...breadcrumb, { id: f.id, name: f.name }]);
  };

  const handleBreadcrumbClick = (idx: number) => {
    const next = breadcrumb.slice(0, idx + 1);
    setBreadcrumb(next);
    setCurrentFolderId(next[next.length - 1].id);
  };

  const handleCreateFolder = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newFolderName.trim()) return;
    const res = await fetch("/api/folders", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ name: newFolderName, parentId: currentFolderId }),
    });
    if (res.ok) {
      setNewFolderName("");
      setShowFolderModal(false);
      fetchData();
      // âœ… alert() â†’ toast
      toast.success("í´ë”ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤");
    } else {
      toast.error("í´ë” ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
    }
  };

  const handleFileUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;
    setUploading(true);
    const fd = new FormData();
    fd.append("file", file);
    if (currentFolderId) fd.append("folderId", currentFolderId);

    const xhr = new XMLHttpRequest();
    xhr.upload.onprogress = (ev) => setUploadProgress((ev.loaded / ev.total) * 100);
    xhr.onload = () => {
      fetchData();
      setUploading(false);
      setUploadProgress(0);
      if (xhr.status >= 200 && xhr.status < 300) {
        toast.success("íŒŒì¼ì´ ì—…ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤");
      } else {
        toast.error("ì—…ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
      }
    };
    xhr.onerror = () => {
      setUploading(false);
      toast.error("ì—…ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    };
    xhr.open("POST", "/api/files/upload");
    xhr.send(fd);
    // input ì´ˆê¸°í™” (ê°™ì€ íŒŒì¼ ì¬ì—…ë¡œë“œ ê°€ëŠ¥í•˜ë„ë¡)
    e.target.value = "";
  };

  const handleDeleteFolder = (id: string) => {
    // âœ… confirm() â†’ ConfirmDialog
    openConfirm({
      title: "í´ë” ì‚­ì œ",
      message: "í´ë”ë¥¼ ì‚­ì œí•˜ë©´ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
      confirmLabel: "ì‚­ì œ",
      variant: "danger",
      onConfirm: async () => {
        const res = await fetch(`/api/folders/${id}`, { method: "DELETE" });
        if (res.ok) {
          fetchData();
          toast.success("í´ë”ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤");
        } else {
          toast.error("ì‚­ì œ ê¶Œí•œì´ ì—†ê±°ë‚˜ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
        }
      },
    });
  };

  const handleDeleteFile = (id: string) => {
    // âœ… confirm() â†’ ConfirmDialog
    openConfirm({
      title: "íŒŒì¼ ì‚­ì œ",
      message: "íŒŒì¼ì„ ì‚­ì œí•˜ë©´ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
      confirmLabel: "ì‚­ì œ",
      variant: "danger",
      onConfirm: async () => {
        const res = await fetch(`/api/files/${id}`, { method: "DELETE" });
        if (res.ok) {
          setShowFileDetail(false);
          fetchData();
          toast.success("íŒŒì¼ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤");
        } else {
          toast.error("íŒŒì¼ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
        }
      },
    });
  };

  const handleAddTag = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!selectedFile || !newTagName.trim()) return;
    const res = await fetch(`/api/files/${selectedFile.id}/tags`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ tagName: newTagName }),
    });
    if (res.ok) {
      const tagData = await res.json();
      setSelectedFile({ ...selectedFile, fileTags: [...(selectedFile.fileTags || []), { tag: tagData }] });
      setNewTagName("");
      fetchData();
    } else {
      toast.error("íƒœê·¸ ì¶”ê°€ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
    }
  };

  const handleShare = async (e: React.FormEvent) => {
    e.preventDefault();
    const resourceId = shareType === "FILE" ? selectedFile?.id : selectedFolder?.id;
    if (!resourceId) return;
    setIsSharing(true);
    try {
      const res = await fetch("/api/share", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          resourceType: shareType,
          resourceId,
          sharedWithEmail: shareEmail,
          permission: sharePermission,
        }),
      });
      if (res.ok) {
        toast.success("ê³µìœ ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤");
        setShowShareModal(false);
        setShareEmail("");
      } else {
        const data = await res.json();
        toast.error(data.error || "ê³µìœ ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
      }
    } catch {
      toast.error("ê³µìœ  ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setIsSharing(false);
    }
  };

  if (status === "loading") {
    return <div className="h-screen flex items-center justify-center font-bold">ë¡œë”© ì¤‘...</div>;
  }
  if (!session) return null;

  return (
    <div className="min-h-screen bg-[#F8F9FA] flex flex-col text-slate-900 pb-20 md:pb-0">
      {/* ConfirmDialog ë Œë”ë§ */}
      {confirmDialog}

      {/* í—¤ë” */}
      <header className="bg-white border-b sticky top-0 z-40 px-6 h-16 flex items-center justify-between shadow-sm">
        <div className="flex items-center gap-6">
          <h1 className="text-xl font-black text-blue-600">ì´ìŒ</h1>
          <nav className="flex items-center gap-4 text-xs font-bold text-slate-400">
            <Link href="/dashboard" className={pathname === "/dashboard" ? "text-blue-600" : ""}>íŒŒì¼</Link>
            <Link href="/posts" className={pathname === "/posts" ? "text-blue-600" : ""}>ê²Œì‹œíŒ</Link>
            <Link href="/chat" className={pathname === "/chat" ? "text-blue-600" : ""}>ì±„íŒ…</Link>
          </nav>
        </div>
        <div className="flex items-center gap-4">
          <span className="text-[12px] font-black text-slate-600 bg-slate-100 px-3 py-1.5 rounded-full">
            {session.user?.name}ë‹˜
          </span>
          <button
            onClick={() => signOut()}
            className="text-[11px] font-black bg-slate-900 text-white px-3 py-2 rounded-lg"
          >
            ë¡œê·¸ì•„ì›ƒ
          </button>
        </div>
      </header>

      {/* ëª¨ë°”ì¼ í•˜ë‹¨ë°” */}
      <div className="md:hidden fixed bottom-0 left-0 right-0 bg-white border-t px-12 py-3 z-50 flex justify-between items-center shadow-lg">
        <Link href="/dashboard" className="text-xl">ğŸ“</Link>
        <button
          onClick={() => setShowFolderModal(true)}
          className="w-12 h-12 bg-blue-600 text-white rounded-full flex items-center justify-center text-2xl -mt-10 border-4 border-white shadow-xl"
        >+</button>
        <Link href="/chat" className="text-xl opacity-30">ğŸ’¬</Link>
      </div>

      {/* ê²½ë¡œ ì•ˆë‚´ */}
      <div className="bg-white border-b py-2.5 px-6 text-[10px] font-black text-slate-300">
        {breadcrumb.map((c, i) => (
          <span key={i}>
            {i > 0 && <span className="mx-2">/</span>}
            <button
              onClick={() => handleBreadcrumbClick(i)}
              className={i === breadcrumb.length - 1 ? "text-slate-800" : "hover:text-slate-600"}
            >
              {c.name}
            </button>
          </span>
        ))}
      </div>

      <main className="max-w-7xl w-full mx-auto p-4 md:p-10 flex-1">
        {/* ê²€ìƒ‰ & ì•¡ì…˜ */}
        <div className="mb-8 flex flex-wrap gap-4">
          <input
            type="text"
            placeholder="íŒŒì¼ ê²€ìƒ‰..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="flex-1 min-w-[200px] bg-white border rounded-xl py-3 px-4 text-sm outline-none shadow-sm focus:border-blue-500"
          />
          <button
            onClick={() => setShowFolderModal(true)}
            className="bg-white border px-5 py-3 rounded-xl font-bold text-sm"
          >
            ğŸ“ ìƒˆ í´ë”
          </button>
          <label className="bg-blue-600 text-white px-5 py-3 rounded-xl font-bold text-sm cursor-pointer shadow-lg shadow-blue-500/20">
            ğŸ“¤ ì—…ë¡œë“œ
            <input type="file" onChange={handleFileUpload} className="hidden" />
          </label>
        </div>

        {/* ì—…ë¡œë“œ ì§„í–‰ë°” */}
        {uploading && (
          <div className="mb-8 p-4 bg-blue-50 rounded-xl border border-blue-100">
            <div className="flex justify-between text-[10px] font-black text-blue-600 mb-1">
              <span>íŒŒì¼ ì „ì†¡ ì¤‘...</span>
              <span>{uploadProgress.toFixed(0)}%</span>
            </div>
            <div className="w-full bg-blue-100 h-1.5 rounded-full overflow-hidden">
              <div className="bg-blue-600 h-full transition-all" style={{ width: `${uploadProgress}%` }} />
            </div>
          </div>
        )}

        {/* í´ë” ì„¹ì…˜ */}
        {!searchQuery && folders.length > 0 && (
          <div className="mb-10">
            <h2 className="text-[11px] font-black text-slate-300 uppercase mb-4 px-1">í´ë”</h2>
            <div className="grid grid-cols-1 sm:grid-cols-3 lg:grid-cols-4 gap-4">
              {folders.map((f) => (
                <div
                  key={f.id}
                  className="group bg-white border p-4 rounded-2xl flex items-center justify-between hover:border-blue-500 transition-all shadow-sm"
                >
                  <div
                    className="flex items-center gap-3 truncate cursor-pointer flex-1"
                    onClick={() => handleFolderClick(f)}
                  >
                    <span className="text-2xl">ğŸ“‚</span>
                    <div className="truncate">
                      <p className="text-sm font-bold truncate">{f.name}</p>
                      <p className="text-[10px] font-bold text-slate-400">{f._count.files} items</p>
                    </div>
                  </div>
                  <div className="flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                    <button
                      onClick={() => { setSelectedFolder(f); setShareType("FOLDER"); setShowShareModal(true); }}
                      className="p-1.5 hover:bg-slate-50 rounded-lg"
                      title="ê³µìœ "
                    >ğŸ”—</button>
                    {f.userId === session.user?.id && (
                      <button
                        onClick={() => handleDeleteFolder(f.id)}
                        className="p-1.5 hover:bg-red-50 text-red-500 rounded-lg"
                        title="ì‚­ì œ"
                      >ğŸ—‘ï¸</button>
                    )}
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}

        {/* íŒŒì¼ ì„¹ì…˜ */}
        <div>
          <h2 className="text-[11px] font-black text-slate-300 uppercase mb-4 px-1">íŒŒì¼</h2>
          {loading ? (
            <div className="grid grid-cols-2 xs:grid-cols-3 md:grid-cols-5 lg:grid-cols-7 gap-6">
              {[...Array(7)].map((_, i) => (
                <div key={i} className="animate-pulse">
                  <div className="aspect-square bg-gray-200 rounded-[2rem]" />
                  <div className="h-3 bg-gray-200 rounded mt-2 mx-2" />
                </div>
              ))}
            </div>
          ) : displayedFiles.length === 0 ? (
            <div className="text-center py-16 text-slate-300">
              <p className="text-4xl mb-3">ğŸ“‚</p>
              <p className="font-bold text-sm">
                {searchQuery ? "ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤" : "íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤"}
              </p>
            </div>
          ) : (
            <div className="grid grid-cols-2 xs:grid-cols-3 md:grid-cols-5 lg:grid-cols-7 gap-6">
              {displayedFiles.map((file) => (
                <div
                  key={file.id}
                  className="group cursor-pointer"
                  onClick={() => { setSelectedFile(file); setShowFileDetail(true); }}
                >
                  <div className="aspect-square bg-white border rounded-[2rem] flex items-center justify-center overflow-hidden group-hover:shadow-xl transition-all relative">
                    {file.thumbnailUrl ? (
                      <img src={file.thumbnailUrl} className="w-full h-full object-cover" alt={file.originalName} />
                    ) : (
                      <span className="text-4xl">ğŸ“„</span>
                    )}
                    {file.userId !== session.user?.id && (
                      <span className="absolute top-2 right-2 bg-blue-600 text-white text-[8px] px-1.5 py-0.5 rounded-full">
                        SHARED
                      </span>
                    )}
                  </div>
                  <p className="mt-2 text-[10px] font-bold text-center truncate px-2">{file.originalName}</p>
                  <div className="flex flex-wrap justify-center gap-1 mt-1">
                    {file.fileTags?.map((ft) => (
                      <span key={ft.tag.id} className="text-[8px] bg-slate-100 text-slate-500 px-1.5 py-0.5 rounded">
                        #{ft.tag.name}
                      </span>
                    ))}
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      </main>

      {/* ëª¨ë‹¬: í´ë” ìƒì„± */}
      {showFolderModal && (
        <div className="fixed inset-0 z-[100] bg-black/50 flex items-center justify-center p-4">
          <form
            onSubmit={handleCreateFolder}
            className="bg-white p-6 rounded-[2rem] w-full max-w-xs shadow-2xl animate-in fade-in zoom-in duration-200"
          >
            <h3 className="font-black mb-4">ìƒˆ í´ë” ìƒì„±</h3>
            <input
              type="text"
              value={newFolderName}
              onChange={(e) => setNewFolderName(e.target.value)}
              autoFocus
              className="w-full border-2 rounded-xl p-3 mb-6 outline-none focus:border-blue-500 font-bold"
              placeholder="í´ë” ì´ë¦„ ì…ë ¥"
            />
            <div className="flex gap-2">
              <button
                type="button"
                onClick={() => setShowFolderModal(false)}
                className="flex-1 font-bold text-slate-400"
              >
                ì·¨ì†Œ
              </button>
              <button
                type="submit"
                className="flex-[2] py-3 bg-blue-600 text-white rounded-xl font-bold shadow-lg"
              >
                í´ë” ë§Œë“¤ê¸°
              </button>
            </div>
          </form>
        </div>
      )}

      {/* ëª¨ë‹¬: íŒŒì¼ ìƒì„¸ */}
      {showFileDetail && selectedFile && (
        <div
          className="fixed inset-0 z-[100] bg-black/60 backdrop-blur-sm flex items-center justify-center p-4"
          onClick={() => setShowFileDetail(false)}
        >
          <div
            className="bg-white w-full max-w-md rounded-[2.5rem] overflow-hidden shadow-2xl"
            onClick={(e) => e.stopPropagation()}
          >
            <div className="aspect-video bg-slate-50 flex items-center justify-center relative border-b">
              {selectedFile.thumbnailUrl ? (
                <img src={selectedFile.thumbnailUrl} className="h-full object-contain" alt={selectedFile.originalName} />
              ) : (
                <span className="text-8xl">ğŸ“„</span>
              )}
              <button
                onClick={() => setShowFileDetail(false)}
                className="absolute top-4 right-4 bg-white/80 w-8 h-8 rounded-full font-black"
              >
                âœ•
              </button>
            </div>
            <div className="p-8">
              <h3 className="text-lg font-black break-all mb-4">{selectedFile.originalName}</h3>
              <div className="mb-6">
                <p className="text-[10px] font-black text-slate-400 uppercase mb-2">íƒœê·¸</p>
                <div className="flex flex-wrap gap-2 mb-3">
                  {selectedFile.fileTags?.map((ft) => (
                    <span key={ft.tag.id} className="text-xs bg-blue-50 text-blue-600 px-2.5 py-1 rounded-lg font-bold">
                      #{ft.tag.name}
                    </span>
                  ))}
                </div>
                <form onSubmit={handleAddTag} className="flex gap-2">
                  <input
                    type="text"
                    value={newTagName}
                    onChange={(e) => setNewTagName(e.target.value)}
                    placeholder="ìƒˆ íƒœê·¸..."
                    className="flex-1 bg-slate-50 border rounded-xl px-3 py-2 text-xs outline-none"
                  />
                  <button type="submit" className="bg-slate-900 text-white px-4 py-2 rounded-xl text-xs font-bold">
                    ì¶”ê°€
                  </button>
                </form>
              </div>
              <div className="flex gap-2 mb-2">
                <button
                  onClick={() => { setShowFileDetail(false); setShareType("FILE"); setShowShareModal(true); }}
                  className="flex-1 py-4 bg-slate-100 rounded-2xl text-xs font-black"
                >
                  ğŸ”— ê³µìœ 
                </button>
                <button
                  onClick={() => handleDeleteFile(selectedFile.id)}
                  className="flex-1 py-4 bg-red-50 text-red-500 rounded-2xl text-xs font-black"
                >
                  ğŸ—‘ï¸ ì‚­ì œ
                </button>
              </div>
              <button
                onClick={() => window.open(`/api/files/${selectedFile.id}/download`)}
                className="w-full py-4 bg-blue-600 text-white rounded-2xl text-sm font-black shadow-lg"
              >
                ğŸ“¥ ë‹¤ìš´ë¡œë“œ
              </button>
            </div>
          </div>
        </div>
      )}

      {/* ëª¨ë‹¬: ê³µìœ  */}
      {showShareModal && (
        <div
          className="fixed inset-0 z-[110] bg-black/50 flex items-center justify-center p-4"
          onClick={() => setShowShareModal(false)}
        >
          <div
            className="bg-white p-8 rounded-[2.5rem] w-full max-w-sm"
            onClick={(e) => e.stopPropagation()}
          >
            <h3 className="font-black text-lg mb-6">í•­ëª© ê³µìœ </h3>
            <form onSubmit={handleShare} className="space-y-4">
              <input
                type="email"
                value={shareEmail}
                onChange={(e) => setShareEmail(e.target.value)}
                required
                className="w-full border-2 rounded-xl p-3 text-sm outline-none focus:border-blue-500"
                placeholder="ìƒëŒ€ë°© ì´ë©”ì¼"
              />
              <select
                value={sharePermission}
                onChange={(e) => setSharePermission(e.target.value as "VIEW" | "EDIT")}
                className="w-full border-2 rounded-xl p-3 text-sm font-bold"
              >
                <option value="VIEW">ì½ê¸° ê°€ëŠ¥</option>
                <option value="EDIT">í¸ì§‘ ê°€ëŠ¥</option>
              </select>
              <div className="flex gap-2 pt-2">
                <button
                  type="button"
                  onClick={() => setShowShareModal(false)}
                  className="flex-1 font-bold text-slate-400 text-sm"
                >
                  ì·¨ì†Œ
                </button>
                <button
                  type="submit"
                  disabled={isSharing}
                  className="flex-[2] py-3 bg-blue-600 text-white rounded-xl font-bold shadow-lg disabled:opacity-50"
                >
                  {isSharing ? "ê³µìœ  ì¤‘..." : "ë³´ë‚´ê¸°"}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="package.json">
{
  "name": "personal-cloud",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "node server.js",
    "build": "next build",
    "start": "cross-env NODE_ENV=production node --max-old-space-size=512 server.js",
    "lint": "next lint",
    "db:generate": "prisma generate",
    "db:migrate": "prisma migrate dev",
    "db:push": "prisma db push",
    "db:studio": "prisma studio",
    "ai:update": "npx repomix && git add . && git commit -m \"Update code and AI context\" && git push origin master"
  },
  "dependencies": {
    "@prisma/client": "^5.22.0",
    "bcryptjs": "^3.0.3",
    "date-fns": "^4.1.0",
    "firebase": "^12.9.0",
    "firebase-admin": "^13.6.1",
    "lucide-react": "^0.575.0",
    "next": "14.2.35",
    "next-auth": "^4.24.10",
    "nodemailer": "^7.0.13",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "sharp": "^0.33.5",
    "socket.io": "^4.8.3",
    "socket.io-client": "^4.8.3",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@types/bcrypt": "^5.0.2",
    "@types/bcryptjs": "^2.4.6",
    "@types/multer": "^1.4.12",
    "@types/node": "^20",
    "@types/nodemailer": "^7.0.9",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "autoprefixer": "^10.4.20",
    "cross-env": "^10.1.0",
    "eslint": "^8",
    "eslint-config-next": "14.2.18",
    "postcss": "^8",
    "prisma": "^5.22.0",
    "tailwindcss": "^3.4.1",
    "typescript": "^5"
  }
}
</file>

<file path="server.js">
const { createServer } = require("http");
const { parse } = require("url");
const next = require("next");
const { Server } = require("socket.io");

const dev = process.env.NODE_ENV !== "production";
const hostname = dev ? "localhost" : "0.0.0.0";
const port = process.env.PORT || 3000;

const app = next({ dev, hostname, port });
const handle = app.getRequestHandler();

app.prepare().then(() => {
  const httpServer = createServer(async (req, res) => {
    const parsedUrl = parse(req.url, true);
    await handle(req, res, parsedUrl);
  });

  const io = new Server(httpServer, {
    cors: {
      // âœ… ì™€ì¼ë“œì¹´ë“œ(*) ëŒ€ì‹  ì‹¤ì œ ë„ë©”ì¸ìœ¼ë¡œ ì œí•œ
      origin: process.env.NEXTAUTH_URL || "http://localhost:3000",
      methods: ["GET", "POST"],
    },
    transports: ["websocket", "polling"],
    pingTimeout: 60000,
    pingInterval: 25000,
  });

  // âœ… API routeì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ì „ì—­ ë“±ë¡
  global.io = io;

  // userId â†’ socketId ë§¤í•‘
  const onlineUsers = new Map();

  io.on("connection", (socket) => {
    const userId = socket.handshake.auth.userId;

    if (!userId) {
      console.warn("âš ï¸ userId ì—†ëŠ” ì†Œì¼“ ì—°ê²° ê±°ë¶€");
      socket.disconnect();
      return;
    }

    socket.userId = userId;
    onlineUsers.set(userId, socket.id);
    console.log(`âœ… ì†Œì¼“ ì—°ê²°: ${userId} (${socket.id}) | ì˜¨ë¼ì¸: ${onlineUsers.size}ëª…`);

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ì±„íŒ…
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    socket.on("chat:join", (chatRoomId) => {
      socket.join(`chat:${chatRoomId}`);
      console.log(`ğŸ“¥ ë°© ì…ì¥: chat:${chatRoomId} (${userId})`);
    });

    socket.on("chat:leave", (chatRoomId) => {
      socket.leave(`chat:${chatRoomId}`);
    });

    // í´ë¼ì´ì–¸íŠ¸ê°€ ì§ì ‘ emití•  ë•Œ â€” API routeì˜ global.ioì™€ ë™ì¼í•œ ì´ë²¤íŠ¸ëª… ì‚¬ìš©
    socket.on("message:send", (data) => {
      // âœ… "message:receive"ë¡œ í†µì¼ (ì´ì „: message:receive ì™€ message:new í˜¼ìš©)
      socket.to(`chat:${data.chatRoomId}`).emit("message:receive", data);
    });

    socket.on("typing:start", (data) => {
      socket.to(`chat:${data.chatRoomId}`).emit("typing:update", {
        userId: data.userId || userId,
        isTyping: true,
      });
    });

    socket.on("typing:stop", (data) => {
      socket.to(`chat:${data.chatRoomId}`).emit("typing:update", {
        userId: data.userId || userId,
        isTyping: false,
      });
    });

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // WebRTC ì‹œê·¸ë„ë§
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    // 1) ë°œì‹ ì â†’ ìˆ˜ì‹ ì: í†µí™” ìš”ì²­ + Offer
    socket.on("call:start", (data) => {
      const { receiverId, offer, callType, chatRoomId } = data;
      const receiverSocketId = onlineUsers.get(receiverId);

      console.log(`ğŸ“ call:start | ${userId} â†’ ${receiverId} (${callType})`);

      if (!receiverSocketId) {
        // âœ… ìˆ˜ì‹ ìê°€ ì˜¤í”„ë¼ì¸ì´ë©´ ë°œì‹ ìì—ê²Œ ì•Œë¦¼
        socket.emit("call:user-offline", {
          message: "ìƒëŒ€ë°©ì´ ì˜¤í”„ë¼ì¸ ìƒíƒœì…ë‹ˆë‹¤.",
        });
        return;
      }

      io.to(receiverSocketId).emit("call:incoming", {
        callerId: userId,
        offer,
        // âœ… callType ì „ë‹¬ â€” ìˆ˜ì‹ ìê°€ VIDEOì¸ì§€ VOICEì¸ì§€ ì•Œ ìˆ˜ ìˆìŒ
        callType: callType || "VOICE",
        chatRoomId,
      });
    });

    // 2) ìˆ˜ì‹ ì â†’ ë°œì‹ ì: í†µí™” ìˆ˜ë½ + Answer
    socket.on("call:accept", (data) => {
      const { callerId, answer } = data;
      const callerSocketId = onlineUsers.get(callerId);

      console.log(`âœ… call:accept | ${userId} â†’ ${callerId}`);

      if (callerSocketId) {
        io.to(callerSocketId).emit("call:accepted", { answer });
      }
    });

    // 3) ìˆ˜ì‹ ì â†’ ë°œì‹ ì: í†µí™” ê±°ì ˆ
    socket.on("call:reject", (data) => {
      const callerSocketId = onlineUsers.get(data.callerId);

      console.log(`âŒ call:reject | ${userId} â†’ ${data.callerId}`);

      if (callerSocketId) {
        io.to(callerSocketId).emit("call:rejected");
      }
    });

    // 4) í†µí™” ì¢…ë£Œ
    socket.on("call:end", (data) => {
      const otherSocketId = onlineUsers.get(data.otherUserId);

      console.log(`ğŸ“µ call:end | ${userId} â†’ ${data.otherUserId}`);

      if (otherSocketId) {
        io.to(otherSocketId).emit("call:ended");
      }
    });

    // 5) ICE Candidate ì¤‘ê³„
    socket.on("call:ice-candidate", (data) => {
      const { otherUserId, candidate } = data;
      const otherSocketId = onlineUsers.get(otherUserId);

      if (otherSocketId && candidate) {
        io.to(otherSocketId).emit("call:ice-candidate", { candidate });
      }
    });

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ì—°ê²° í•´ì œ
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    socket.on("disconnect", (reason) => {
      onlineUsers.delete(userId);
      console.log(`âŒ ì†Œì¼“ í•´ì œ: ${userId} | ì´ìœ : ${reason} | ì˜¨ë¼ì¸: ${onlineUsers.size}ëª…`);

      // âœ… í†µí™” ì¤‘ì´ì—ˆë‹¤ë©´ ìƒëŒ€ë°©ì—ê²Œ í†µí™” ì¢…ë£Œ ì•Œë¦¼
      // (í˜„ì¬ëŠ” ë‹¨ìˆœ broadcast â€” ì¶”í›„ í†µí™” ìƒíƒœ Mapìœ¼ë¡œ ì •êµí™” ê°€ëŠ¥)
    });
  });

  httpServer.listen(port, hostname, () => {
    console.log(`ğŸš€ ì„œë²„ ì‹œì‘: http://${hostname}:${port}`);
  });
});
</file>

<file path="src/lib/fcm.ts">
import * as admin from "firebase-admin";

/**
 * Firebase Admin SDK ì´ˆê¸°í™” (ì‹±ê¸€í†¤ íŒ¨í„´)
 */
function initFirebase() {
  if (admin.apps.length > 0) return true;

  const serviceAccountVar = process.env.FIREBASE_SERVICE_ACCOUNT_KEY;
  if (!serviceAccountVar) {
    console.warn("âš ï¸ FIREBASE_SERVICE_ACCOUNT_KEY ë¯¸ì„¤ì •");
    return false;
  }

  try {
    let configStr = serviceAccountVar.trim();
    if (configStr.startsWith("'") && configStr.endsWith("'")) configStr = configStr.slice(1, -1);
    if (configStr.startsWith('"') && configStr.endsWith('"')) configStr = configStr.slice(1, -1);

    const serviceAccount = JSON.parse(configStr);
    if (serviceAccount.private_key) {
      serviceAccount.private_key = serviceAccount.private_key.replace(/\\n/g, '\n');
    }

    admin.initializeApp({
      credential: admin.credential.cert(serviceAccount),
    });
    console.log("âœ… Firebase Admin ì´ˆê¸°í™” ì„±ê³µ!");
    return true;
  } catch (error: any) {
    console.error("âŒ Firebase ì´ˆê¸°í™” ì—ëŸ¬:", error.message);
    return false;
  }
}

/**
 * í•µì‹¬ í‘¸ì‹œ ì „ì†¡ ë¡œì§
 */
export async function sendPushNotification(
  fcmToken: string,
  payload: { title: string; body: string; data?: Record<string, string> }
) {
  if (!initFirebase()) return { success: false, error: "Initialization failed" };

  try {
    const message: admin.messaging.Message = {
      token: fcmToken,
      notification: {
        title: payload.title,
        body: payload.body,
      },
      data: payload.data || {},
      webpush: {
        headers: { Urgency: "high" },
        notification: {
          icon: "/icon-192x192.png",
          badge: "/badge-72x72.png",
          requireInteraction: payload.data?.type === "call_request",
        },
        fcmOptions: {
          link: payload.data?.click_action || "/chat",
        },
      },
      android: { 
        priority: "high",
        notification: {
          sound: "default",
          clickAction: "FLUTTER_NOTIFICATION_CLICK"
        }
      },
      apns: { 
        payload: { 
          aps: { 
            sound: "default", 
            badge: 1,
            contentAvailable: true 
          } 
        } 
      },
    };

    const response = await admin.messaging().send(message);
    return { success: true, messageId: response };
  } catch (error: any) {
    console.error("FCM Send Error:", error);
    return { success: false, error: error.code || error.message };
  }
}

/**
 * í†µí™” ìš”ì²­ ì•Œë¦¼ ì „ì†¡ (ì¶”ê°€ëœ ë¶€ë¶„)
 */
export async function sendCallNotification(
  token: string, 
  senderName: string, 
  callType: string, 
  callId: string, 
  chatRoomId: string
) {
  const isVideo = callType === "VIDEO";
  return sendPushNotification(token, {
    title: `ğŸ“ ${senderName}ë‹˜ìœ¼ë¡œë¶€í„° í†µí™” ìš”ì²­`,
    body: `${isVideo ? "ì˜ìƒ í†µí™”" : "ìŒì„± í†µí™”"} ìš”ì²­ì´ ì™”ìŠµë‹ˆë‹¤.`,
    data: {
      type: "call_request",
      callId,
      chatRoomId,
      callType,
      click_action: `/chat/${chatRoomId}?callId=${callId}`
    },
  });
}

/**
 * ì±„íŒ… ë©”ì‹œì§€ ì•Œë¦¼ ì „ì†¡
 */
export async function sendChatMessageNotification(token: string, senderName: string, content: string, chatRoomId: string) {
  return sendPushNotification(token, {
    title: senderName,
    body: content || "ìƒˆ ë©”ì‹œì§€ê°€ ë„ì°©í–ˆìŠµë‹ˆë‹¤.",
    data: { 
      type: "chat_message", 
      chatRoomId, 
      click_action: `/chat/${chatRoomId}` 
    },
  });
}

/**
 * íŒŒì¼ ê³µìœ  ì•Œë¦¼ ì „ì†¡
 */
export async function sendFileSharedNotification(token: string, senderName: string, fileName: string, chatRoomId: string) {
  return sendPushNotification(token, {
    title: `ğŸ“ ${senderName}ë‹˜ì˜ íŒŒì¼ ê³µìœ `,
    body: fileName,
    data: { 
      type: "file_shared", 
      chatRoomId, 
      click_action: `/chat/${chatRoomId}` 
    },
  });
}

export { admin };
</file>

<file path="src/app/api/chat/rooms/[id]/messages/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { prisma } from "@/lib/db";
import { sendChatMessageNotification, sendFileSharedNotification } from "@/lib/fcm";

// BigInt ì§ë ¬í™” ìœ í‹¸
function serialize(data: any) {
  return JSON.parse(
    JSON.stringify(data, (key, value) =>
      typeof value === "bigint" ? value.toString() : value
    )
  );
}

// â”€â”€â”€ GET: ë©”ì‹œì§€ ëª©ë¡ ì¡°íšŒ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const chatRoomId = params.id;
    const { searchParams } = new URL(request.url);
    const limit = parseInt(searchParams.get("limit") || "50");
    const before = searchParams.get("before");

    // ë©¤ë²„ì‹­ í™•ì¸
    const membership = await prisma.chatRoomMember.findFirst({
      where: { chatRoomId, userId: session.user.id },
    });

    if (!membership) {
      return NextResponse.json(
        { error: "ì±„íŒ…ë°©ì— ì°¸ì—¬í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    const messages = await prisma.chatMessage.findMany({
      where: {
        chatRoomId,
        ...(before && { createdAt: { lt: new Date(before) } }),
      },
      include: {
        sender: { select: { id: true, name: true, email: true } },
        file: { select: { id: true, originalName: true, size: true, mimeType: true } },
      },
      orderBy: { createdAt: "desc" },
      take: limit,
    });

    return NextResponse.json(serialize({ messages: messages.reverse() }));
  } catch (error) {
    console.error("GET Messages Error:", error);
    return NextResponse.json({ error: "ë©”ì‹œì§€ ì¡°íšŒ ì‹¤íŒ¨" }, { status: 500 });
  }
}

// â”€â”€â”€ POST: ë©”ì‹œì§€ ì „ì†¡ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const chatRoomId = params.id;
    const { type, content, fileId, callId } = await request.json();

    // ë©”ì‹œì§€ ìƒì„±
    const message = await prisma.chatMessage.create({
      data: {
        chatRoomId,
        senderId: session.user.id,
        type,
        content:
          type === "TEXT" || type === "CALL_LOG" || type === "SYSTEM"
            ? content
            : null,
        fileId: type === "FILE" ? fileId : null,
        callId: callId || null,
      },
      include: {
        sender: { select: { id: true, name: true, email: true } },
        file: true,
      },
    });

    const serializedMessage = serialize(message);

    // âœ… ì´ë²¤íŠ¸ëª… í†µì¼: "message:new" â†’ "message:receive"
    // (í´ë¼ì´ì–¸íŠ¸ useSocket.tsì˜ listen ì´ë²¤íŠ¸ì™€ ì¼ì¹˜)
    const io = (global as any).io;
    if (io) {
      io.to(`chat:${chatRoomId}`).emit("message:receive", serializedMessage);
      console.log(`ğŸ“¡ ì†Œì¼“ ë¸Œë¡œë“œìºìŠ¤íŠ¸: chat:${chatRoomId}`);
    } else {
      console.warn("âš ï¸ global.io ì—†ìŒ â€” ì†Œì¼“ ì„œë²„ ìƒíƒœ í™•ì¸ í•„ìš”");
    }

    // ì±„íŒ…ë°© ë©¤ë²„ ì¡°íšŒ (íŒŒì¼ ê¶Œí•œ + FCMìš©)
    const members = await prisma.chatRoomMember.findMany({
      where: { chatRoomId },
      include: { user: { select: { id: true, name: true, fcmToken: true } } },
    });

    // íŒŒì¼ ê³µìœ  ì‹œ ë©¤ë²„ë“¤ì—ê²Œ ê¶Œí•œ ë¶€ì—¬
    if (type === "FILE" && fileId) {
      for (const member of members) {
        if (member.userId !== session.user.id) {
          await prisma.filePermission.upsert({
            where: {
              resourceType_resourceId_sharedWithId: {
                resourceType: "FILE",
                resourceId: fileId,
                sharedWithId: member.userId,
              },
            },
            update: {},
            create: {
              resourceType: "FILE",
              resourceId: fileId,
              ownerId: session.user.id,
              sharedWithId: member.userId,
              permission: "VIEW",
            },
          });
        }
      }
    }

    // ì±„íŒ…ë°© updatedAt ê°±ì‹ 
    await prisma.chatRoom.update({
      where: { id: chatRoomId },
      data: { updatedAt: new Date() },
    });

    // FCM í‘¸ì‹œ ì•Œë¦¼ (ë‚˜ ì œì™¸í•œ ë©¤ë²„ë“¤)
    for (const member of members) {
      if (member.userId !== session.user.id && member.user.fcmToken) {
        try {
          if (type === "TEXT") {
            await sendChatMessageNotification(
              member.user.fcmToken,
              session.user.name || "ì‚¬ìš©ì",
              content,
              chatRoomId
            );
          } else if (type === "FILE" && message.file) {
            await sendFileSharedNotification(
              member.user.fcmToken,
              session.user.name || "ì‚¬ìš©ì",
              (message.file as any).originalName,
              chatRoomId
            );
          }
        } catch (error) {
          console.error(`âŒ FCM ì‹¤íŒ¨ (${member.user.name}):`, error);
        }
      }
    }

    return NextResponse.json({ data: serializedMessage }, { status: 201 });
  } catch (error) {
    console.error("POST Message Error:", error);
    return NextResponse.json({ error: "ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨" }, { status: 500 });
  }
}
</file>

<file path="src/hooks/useSocket.ts">
"use client";

import { useEffect, useRef, useState, useCallback } from "react";
import { io, Socket } from "socket.io-client";
import { useSession } from "next-auth/react";
import { toast } from "@/components/Toast";

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ì‹±ê¸€í„´ ì†Œì¼“ (ì „ì—­ 1ê°œë§Œ ìœ ì§€)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let globalSocket: Socket | null = null;
let globalUserId: string | null = null;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ICE ì„œë²„ ì„¤ì •
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const ICE_SERVERS: RTCIceServer[] = [
  { urls: "stun:stun.l.google.com:19302" },
  { urls: "stun:stun1.l.google.com:19302" },
  {
    urls: "turn:openrelay.metered.ca:80",
    username: "openrelayproject",
    credential: "openrelayproject",
  },
  {
    urls: "turn:openrelay.metered.ca:443",
    username: "openrelayproject",
    credential: "openrelayproject",
  },
];

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// useSocket â€” ì‹±ê¸€í„´ ì†Œì¼“ ì—°ê²°
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function useSocket() {
  const { data: session } = useSession();
  const socketRef = useRef<Socket | null>(null);
  const [isConnected, setIsConnected] = useState(false);

  useEffect(() => {
    if (!session?.user?.id) return;

    // ì´ë¯¸ ê°™ì€ ìœ ì €ì˜ ì†Œì¼“ì´ ìˆìœ¼ë©´ ì¬ì‚¬ìš©
    if (globalSocket && globalUserId === session.user.id) {
      socketRef.current = globalSocket;
      setIsConnected(globalSocket.connected);
      return;
    }

    // ê¸°ì¡´ ì†Œì¼“ ì •ë¦¬
    if (globalSocket) {
      globalSocket.disconnect();
    }

    const socketUrl =
      typeof window !== "undefined"
        ? window.location.origin
        : "https://eum-app-production.up.railway.app";

    const socket = io(socketUrl, {
      auth: { userId: session.user.id },
      transports: ["websocket", "polling"],
      reconnection: true,
      reconnectionAttempts: 10,
      reconnectionDelay: 1000,
    });

    globalSocket = socket;
    globalUserId = session.user.id;
    socketRef.current = socket;

    socket.on("connect", () => {
      console.log("âœ… ì†Œì¼“ ì—°ê²°:", socket.id);
      setIsConnected(true);
    });

    socket.on("disconnect", (reason) => {
      console.log("âŒ ì†Œì¼“ í•´ì œ:", reason);
      setIsConnected(false);
    });

    socket.on("connect_error", (err) => {
      console.error("âŒ ì†Œì¼“ ì—°ê²° ì—ëŸ¬:", err.message);
      setIsConnected(false);
    });

    return () => {
      // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ì†Œì¼“ì€ ìœ ì§€ (ì‹±ê¸€í„´)
    };
  }, [session?.user?.id]);

  return { socket: socketRef.current, isConnected };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// useChatRoom â€” ì±„íŒ… + WebRTC
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function useChatRoom(chatRoomId: string | null) {
  const { socket, isConnected } = useSocket();

  const [socketMessages, setSocketMessages] = useState<any[]>([]);
  const [typingUsers, setTypingUsers] = useState<Set<string>>(new Set());

  // WebRTC ìƒíƒœ
  const [incomingCall, setIncomingCall] = useState<any>(null);
  const [localStream, setLocalStream] = useState<MediaStream | null>(null);
  const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);
  const [callStatus, setCallStatus] = useState<
    "idle" | "calling" | "incoming" | "connected" | "ended"
  >("idle");

  const peerConnectionRef = useRef<RTCPeerConnection | null>(null);
  const localStreamRef = useRef<MediaStream | null>(null);

  // âœ… ICE Candidate ë²„í¼ â€” setRemoteDescription ì „ì— ë„ì°©í•œ candidate ì €ì¥
  const iceCandidateBufferRef = useRef<RTCIceCandidateInit[]>([]);
  const remoteDescSetRef = useRef(false);
  const currentCallTargetRef = useRef<string | null>(null);

  // â”€â”€â”€ ì±„íŒ…ë°© ì…ì¥ (ì¬ì—°ê²° ì‹œì—ë„ ìë™ ì¬ì…ì¥) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  useEffect(() => {
    if (!socket || !chatRoomId) return;

    const joinRoom = () => {
      socket.emit("chat:join", chatRoomId);
      console.log("ğŸ“¥ ì±„íŒ…ë°© ì…ì¥:", chatRoomId);
    };

    if (socket.connected) joinRoom();

    // âœ… í•µì‹¬: ì†Œì¼“ ì¬ì—°ê²° ì‹œ ìë™ìœ¼ë¡œ ì±„íŒ…ë°© ì¬ì…ì¥
    socket.on("connect", joinRoom);

    return () => {
      socket.off("connect", joinRoom);
    };
  }, [socket, chatRoomId]);

  // â”€â”€â”€ ë©”ì‹œì§€ & íƒ€ì´í•‘ ì´ë²¤íŠ¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  useEffect(() => {
    if (!socket) return;

    const handleMessage = (data: any) => {
      setSocketMessages((prev) =>
        prev.some((m) => m.id === data.id) ? prev : [...prev, data]
      );
    };

    const handleTyping = ({ userId, isTyping }: any) => {
      setTypingUsers((prev) => {
        const next = new Set(prev);
        if (isTyping) next.add(userId);
        else next.delete(userId);
        return next;
      });
    };

    // âœ… API routeì˜ "message:new" + server.jsì˜ "message:receive" ë‘˜ ë‹¤ ìˆ˜ì‹ 
    socket.on("message:receive", handleMessage);
    socket.on("message:new", handleMessage);
    socket.on("typing:update", handleTyping);

    return () => {
      socket.off("message:receive", handleMessage);
      socket.off("message:new", handleMessage);
      socket.off("typing:update", handleTyping);
    };
  }, [socket]);

  // â”€â”€â”€ WebRTC ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  useEffect(() => {
    if (!socket) return;

    const handleIncoming = (data: any) => {
      console.log("ğŸ“ í†µí™” ìš”ì²­ ìˆ˜ì‹ :", data);
      setIncomingCall(data);
      setCallStatus("incoming");
    };

    const handleAccepted = async ({ answer }: any) => {
      console.log("âœ… Answer ìˆ˜ì‹ , RemoteDescription ì„¤ì • ì¤‘...");
      const pc = peerConnectionRef.current;
      if (!pc) return;
      try {
        await pc.setRemoteDescription(new RTCSessionDescription(answer));
        // âœ… Answer ì„¤ì • ì™„ë£Œ í›„ ë²„í¼ëœ ICE candidates ì ìš©
        await flushIceCandidates();
        setCallStatus("connected");
      } catch (e) {
        console.error("Answer ì„¤ì • ì‹¤íŒ¨:", e);
      }
    };

    const handleRejected = () => {
      toast.info("ìƒëŒ€ë°©ì´ í†µí™”ë¥¼ ê±°ì ˆí–ˆìŠµë‹ˆë‹¤");
      setCallStatus("idle");
      cleanupCall();
    };

    // âœ… ìˆ˜ì‹ : ìƒëŒ€ë°© ì˜¤í”„ë¼ì¸
    const handleUserOffline = () => {
      toast.error("ìƒëŒ€ë°©ì´ ì˜¤í”„ë¼ì¸ ìƒíƒœì…ë‹ˆë‹¤");
      setCallStatus("idle");
      cleanupCall();
    };

    const handleEnded = () => {
      console.log("ğŸ“´ í†µí™” ì¢…ë£Œë¨");
      setCallStatus("ended");
      cleanupCall();
      setTimeout(() => setCallStatus("idle"), 1500);
    };

    // âœ… í•µì‹¬: remoteDescription ì„¤ì • ì—¬ë¶€ì— ë”°ë¼ ë²„í¼ ë˜ëŠ” ì¦‰ì‹œ ì ìš©
    const handleIceCandidate = async ({ candidate }: any) => {
      if (!candidate) return;
      const pc = peerConnectionRef.current;
      if (!pc) return;

      if (remoteDescSetRef.current) {
        try {
          await pc.addIceCandidate(new RTCIceCandidate(candidate));
          console.log("ğŸ§Š ICE Candidate ì¦‰ì‹œ ì ìš©:", candidate.type);
        } catch (e) {
          console.error("ICE Candidate ì ìš© ì‹¤íŒ¨:", e);
        }
      } else {
        console.log("ğŸ“¦ ICE Candidate ë²„í¼ë§:", candidate.type);
        iceCandidateBufferRef.current.push(candidate);
      }
    };

    socket.on("call:incoming", handleIncoming);
    socket.on("call:accepted", handleAccepted);
    socket.on("call:rejected", handleRejected);
    socket.on("call:ended", handleEnded);
    socket.on("call:ice-candidate", handleIceCandidate);
    socket.on("call:user-offline", handleUserOffline);

    return () => {
      socket.off("call:incoming", handleIncoming);
      socket.off("call:accepted", handleAccepted);
      socket.off("call:rejected", handleRejected);
      socket.off("call:ended", handleEnded);
      socket.off("call:ice-candidate", handleIceCandidate);
      socket.off("call:user-offline", handleUserOffline);
    };
  }, [socket]);

  // â”€â”€â”€ ë²„í¼ëœ ICE Candidates ì¼ê´„ ì ìš© â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const flushIceCandidates = useCallback(async () => {
    const pc = peerConnectionRef.current;
    if (!pc) return;
    console.log(`ğŸ§Š ë²„í¼ ICE ì ìš©: ${iceCandidateBufferRef.current.length}ê°œ`);
    for (const candidate of iceCandidateBufferRef.current) {
      try {
        await pc.addIceCandidate(new RTCIceCandidate(candidate));
      } catch (e) {
        console.error("ë²„í¼ ICE ì ìš© ì‹¤íŒ¨:", e);
      }
    }
    iceCandidateBufferRef.current = [];
    remoteDescSetRef.current = true;
  }, []);

  // â”€â”€â”€ PeerConnection ìƒì„± â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const createPeerConnection = useCallback(
    (targetUserId: string) => {
      if (peerConnectionRef.current) {
        peerConnectionRef.current.close();
      }
      iceCandidateBufferRef.current = [];
      remoteDescSetRef.current = false;

      const pc = new RTCPeerConnection({
        iceServers: ICE_SERVERS,
        iceCandidatePoolSize: 10,
      });

      // âœ… ICE Candidate ìƒì„± â†’ ìƒëŒ€ë°©ì—ê²Œ ì „ë‹¬
      pc.onicecandidate = (event) => {
        if (event.candidate && socket) {
          console.log("ğŸ“¡ ICE Candidate ì „ì†¡:", event.candidate.type);
          socket.emit("call:ice-candidate", {
            otherUserId: targetUserId,
            candidate: event.candidate.toJSON(),
          });
        }
      };

      pc.oniceconnectionstatechange = () => {
        console.log("ğŸ”— ICE ìƒíƒœ:", pc.iceConnectionState);
        if (
          pc.iceConnectionState === "connected" ||
          pc.iceConnectionState === "completed"
        ) {
          setCallStatus("connected");
        } else if (
          pc.iceConnectionState === "failed" ||
          pc.iceConnectionState === "disconnected"
        ) {
          console.warn("âš ï¸ ICE ì—°ê²° ì‹¤íŒ¨ â€” TURN ì„œë²„ í™•ì¸ í•„ìš”");
          cleanupCall();
          setCallStatus("idle");
        }
      };

      pc.ontrack = (event) => {
        console.log("ğŸµ ì›ê²© íŠ¸ë™ ìˆ˜ì‹ :", event.track.kind);
        setRemoteStream(event.streams[0]);
      };

      peerConnectionRef.current = pc;
      return pc;
    },
    [socket]
  );

  // â”€â”€â”€ ì •ë¦¬ í•¨ìˆ˜ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const cleanupCall = useCallback(() => {
    if (localStreamRef.current) {
      localStreamRef.current.getTracks().forEach((t) => t.stop());
      localStreamRef.current = null;
    }
    if (peerConnectionRef.current) {
      peerConnectionRef.current.close();
      peerConnectionRef.current = null;
    }
    iceCandidateBufferRef.current = [];
    remoteDescSetRef.current = false;
    currentCallTargetRef.current = null;
    setLocalStream(null);
    setRemoteStream(null);
    setIncomingCall(null);
  }, []);

  // â”€â”€â”€ í†µí™” ê±¸ê¸° â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // âœ… ë²„ê·¸ ìˆ˜ì •: callTypeì„ ì²« ë²ˆì§¸ ì¸ìë¡œ ë°›ìŒ (ê¸°ì¡´: otherUserIdë§Œ ë°›ì•„ì„œ "VOICE"ê°€ receiverIdë¡œ ì „ì†¡ë˜ë˜ ë²„ê·¸)
  const initiateCall = useCallback(
    async (callType: "VOICE" | "VIDEO", otherUserId: string) => {
      if (!socket || callStatus !== "idle") return;

      try {
        setCallStatus("calling");
        currentCallTargetRef.current = otherUserId;

        // âœ… ìŒì„±í†µí™”ë©´ ì¹´ë©”ë¼ ìš”ì²­ ì•ˆ í•¨ (ê¸°ì¡´: í•­ìƒ video:true)
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: true,
          video: callType === "VIDEO",
        });

        localStreamRef.current = stream;
        setLocalStream(stream);

        const pc = createPeerConnection(otherUserId);
        stream.getTracks().forEach((track) => pc.addTrack(track, stream));

        const offer = await pc.createOffer({
          offerToReceiveAudio: true,
          offerToReceiveVideo: callType === "VIDEO",
        });
        await pc.setLocalDescription(offer);

        console.log("ğŸ“¤ Offer ì „ì†¡:", callType, "â†’", otherUserId);
        socket.emit("call:start", {
          receiverId: otherUserId,
          chatRoomId,
          callType,
          offer: pc.localDescription,
        });
      } catch (error) {
        console.error("í†µí™” ì‹œì‘ ì‹¤íŒ¨:", error);
        setCallStatus("idle");
        cleanupCall();
      }
    },
    [socket, callStatus, chatRoomId, createPeerConnection, cleanupCall]
  );

  // â”€â”€â”€ í†µí™” ìˆ˜ë½ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const acceptCall = useCallback(async () => {
    if (!incomingCall || !socket) return;

    try {
      setCallStatus("connected");
      currentCallTargetRef.current = incomingCall.callerId;

      const stream = await navigator.mediaDevices.getUserMedia({
        audio: true,
        video: incomingCall.callType === "VIDEO",
      });

      localStreamRef.current = stream;
      setLocalStream(stream);

      const pc = createPeerConnection(incomingCall.callerId);
      stream.getTracks().forEach((track) => pc.addTrack(track, stream));

      await pc.setRemoteDescription(
        new RTCSessionDescription(incomingCall.offer)
      );

      // âœ… setRemoteDescription ì™„ë£Œ í›„ ë²„í¼ëœ ICE ì ìš©
      await flushIceCandidates();

      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);

      console.log("ğŸ“¤ Answer ì „ì†¡");
      socket.emit("call:accept", {
        callerId: incomingCall.callerId,
        answer: pc.localDescription,
      });

      setIncomingCall(null);
    } catch (error) {
      console.error("í†µí™” ìˆ˜ë½ ì‹¤íŒ¨:", error);
      setCallStatus("idle");
      cleanupCall();
    }
  }, [incomingCall, socket, createPeerConnection, flushIceCandidates, cleanupCall]);

  // â”€â”€â”€ í†µí™” ê±°ì ˆ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const rejectCall = useCallback(() => {
    if (!incomingCall || !socket) return;
    socket.emit("call:reject", { callerId: incomingCall.callerId });
    setIncomingCall(null);
    setCallStatus("idle");
  }, [incomingCall, socket]);

  // â”€â”€â”€ í†µí™” ì¢…ë£Œ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const endCall = useCallback(
    (otherUserId?: string) => {
      const targetId = otherUserId || currentCallTargetRef.current;
      if (targetId && socket) {
        socket.emit("call:end", { otherUserId: targetId });
      }
      setCallStatus("idle");
      cleanupCall();
    },
    [socket, cleanupCall]
  );

  // â”€â”€â”€ ìŒì†Œê±° í† ê¸€ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const toggleMute = useCallback(() => {
    const stream = localStreamRef.current;
    if (!stream) return false;
    const track = stream.getAudioTracks()[0];
    if (!track) return false;
    track.enabled = !track.enabled;
    return !track.enabled;
  }, []);

  return {
    socketMessages,
    typingUsers,
    socket,
    isConnected,
    incomingCall,
    localStream,
    remoteStream,
    callStatus,
    initiateCall,
    acceptCall,
    rejectCall,
    endCall,
    toggleMute,
  };
}
</file>

<file path="src/app/chat/[id]/page.tsx">
"use client";

import { useSession } from "next-auth/react";
import { useParams, useRouter } from "next/navigation";
import { useEffect, useState, useRef, useCallback } from "react";
import { useChatRoom } from "@/hooks/useSocket";
import { useInfiniteScroll } from "@/hooks/useInfiniteScroll";
import { toast } from "@/components/Toast";

const MESSAGE_LIMIT = 30; // í•œ ë²ˆì— ë¶ˆëŸ¬ì˜¬ ë©”ì‹œì§€ ìˆ˜

export default function ChatRoomPage() {
  const { data: session } = useSession();
  const params = useParams();
  const router = useRouter();
  const chatRoomId = params.id as string;

  const [allMessages, setAllMessages] = useState<any[]>([]);
  const [input, setInput] = useState("");
  const [isSending, setIsSending] = useState(false);
  const [chatRoom, setChatRoom] = useState<any>(null);
  const [audioMuted, setAudioMuted] = useState(false);

  // âœ… í˜ì´ì§€ë„¤ì´ì…˜ ìƒíƒœ
  const [hasMore, setHasMore] = useState(true);
  const [isLoadingMore, setIsLoadingMore] = useState(false);
  const [isInitialLoading, setIsInitialLoading] = useState(true);
  const oldestMessageDateRef = useRef<string | null>(null);

  // ìŠ¤í¬ë¡¤ ìœ„ì¹˜ ë³´ì¡´ìš©
  const scrollContainerRef = useRef<HTMLDivElement>(null);
  const bottomRef = useRef<HTMLDivElement>(null);
  const shouldScrollToBottomRef = useRef(true);

  const localVideoRef = useRef<HTMLVideoElement>(null);
  const remoteVideoRef = useRef<HTMLVideoElement>(null);

  const {
    socketMessages,
    typingUsers,
    socket,
    incomingCall,
    localStream,
    remoteStream,
    callStatus,
    initiateCall,
    acceptCall,
    rejectCall,
    endCall,
    toggleMute,
  } = useChatRoom(chatRoomId);

  // â”€â”€â”€ ì´ˆê¸° ë©”ì‹œì§€ ë¡œë“œ (ìµœê·¼ 30ê°œ) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  useEffect(() => {
    if (!chatRoomId) return;

    Promise.all([
      fetch(`/api/chat/rooms/${chatRoomId}/messages?limit=${MESSAGE_LIMIT}`),
      fetch(`/api/chat/rooms/${chatRoomId}`),
    ])
      .then(async ([msgRes, roomRes]) => {
        if (msgRes.ok) {
          const data = await msgRes.json();
          const messages = data.messages || [];
          setAllMessages(messages);
          if (messages.length > 0) {
            oldestMessageDateRef.current = messages[0].createdAt;
          }
          setHasMore(messages.length === MESSAGE_LIMIT);
        }
        if (roomRes.ok) {
          const data = await roomRes.json();
          setChatRoom(data.chatRoom);
        }
      })
      .catch((err) => console.error("ì´ˆê¸° ë¡œë“œ ì‹¤íŒ¨:", err))
      .finally(() => setIsInitialLoading(false));

    // âœ… ì±„íŒ…ë°© ì…ì¥ ì‹œ ì½ìŒ ì²˜ë¦¬ â€” ì•ˆ ì½ì€ ë°°ì§€ ì¦‰ì‹œ ì œê±°
    fetch(`/api/chat/rooms/${chatRoomId}/read`, { method: "POST" }).catch(
      () => {}
    );
  }, [chatRoomId]);

  // â”€â”€â”€ ì´ì „ ë©”ì‹œì§€ ë” ë¶ˆëŸ¬ì˜¤ê¸° â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const fetchMoreMessages = useCallback(async () => {
    if (!oldestMessageDateRef.current || isLoadingMore) return;

    setIsLoadingMore(true);

    // ìŠ¤í¬ë¡¤ ìœ„ì¹˜ ë³´ì¡´: ë¡œë“œ ì „ í˜„ì¬ ìŠ¤í¬ë¡¤ ë†’ì´ ê¸°ë¡
    const container = scrollContainerRef.current;
    const prevScrollHeight = container?.scrollHeight || 0;

    try {
      const res = await fetch(
        `/api/chat/rooms/${chatRoomId}/messages?limit=${MESSAGE_LIMIT}&before=${encodeURIComponent(
          oldestMessageDateRef.current
        )}`
      );

      if (res.ok) {
        const data = await res.json();
        const olderMessages = data.messages || [];

        if (olderMessages.length === 0) {
          setHasMore(false);
          return;
        }

        setAllMessages((prev) => [...olderMessages, ...prev]);
        setHasMore(olderMessages.length === MESSAGE_LIMIT);

        if (olderMessages.length > 0) {
          oldestMessageDateRef.current = olderMessages[0].createdAt;
        }

        // âœ… ìŠ¤í¬ë¡¤ ìœ„ì¹˜ ë³´ì¡´: ìƒˆ ë©”ì‹œì§€ ë†’ì´ë§Œí¼ ì•„ë˜ë¡œ ë³´ì •
        requestAnimationFrame(() => {
          if (container) {
            const newScrollHeight = container.scrollHeight;
            container.scrollTop = newScrollHeight - prevScrollHeight;
          }
        });
      }
    } catch (err) {
      console.error("ì´ì „ ë©”ì‹œì§€ ë¡œë“œ ì‹¤íŒ¨:", err);
    } finally {
      setIsLoadingMore(false);
    }
  }, [chatRoomId, isLoadingMore]);

  // âœ… useInfiniteScroll â€” ìŠ¤í¬ë¡¤ ë§¨ ìœ„ì— ë‹¿ìœ¼ë©´ fetchMoreMessages ì‹¤í–‰
  const topObserverRef = useInfiniteScroll({
    fetchMore: fetchMoreMessages,
    hasMore,
    loading: isLoadingMore,
  });

  // â”€â”€â”€ ì‹¤ì‹œê°„ ë©”ì‹œì§€ ì¶”ê°€ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  useEffect(() => {
    if (socketMessages.length === 0) return;
    const newMsg = socketMessages[socketMessages.length - 1];
    setAllMessages((prev) =>
      prev.some((m) => m.id === newMsg.id) ? prev : [...prev, newMsg]
    );
    shouldScrollToBottomRef.current = true;

    // âœ… ìƒˆ ë©”ì‹œì§€ ë„ì°© ì‹œì—ë„ ì½ìŒ ì²˜ë¦¬ (ì±„íŒ…ë°© ì—´ë ¤ìˆìœ¼ë©´)
    fetch(`/api/chat/rooms/${chatRoomId}/read`, { method: "POST" }).catch(
      () => {}
    );
  }, [socketMessages, chatRoomId]);

  // â”€â”€â”€ ìë™ ìŠ¤í¬ë¡¤ (ìƒˆ ë©”ì‹œì§€ / ì´ˆê¸° ë¡œë“œ ì‹œë§Œ) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  useEffect(() => {
    if (shouldScrollToBottomRef.current) {
      bottomRef.current?.scrollIntoView({ behavior: "smooth" });
      shouldScrollToBottomRef.current = false;
    }
  }, [allMessages]);

  // ì´ˆê¸° ë¡œë“œ ì™„ë£Œ ì‹œ ë§¨ ì•„ë˜ë¡œ
  useEffect(() => {
    if (!isInitialLoading) {
      shouldScrollToBottomRef.current = true;
      bottomRef.current?.scrollIntoView();
    }
  }, [isInitialLoading]);

  // â”€â”€â”€ ë¹„ë””ì˜¤ ìŠ¤íŠ¸ë¦¼ ì—°ê²° â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  useEffect(() => {
    if (localStream && localVideoRef.current)
      localVideoRef.current.srcObject = localStream;
  }, [localStream]);

  useEffect(() => {
    if (remoteStream && remoteVideoRef.current)
      remoteVideoRef.current.srcObject = remoteStream;
  }, [remoteStream]);

  // â”€â”€â”€ ë©”ì‹œì§€ ì „ì†¡ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const onSend = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!input.trim() || !session?.user?.id || isSending) return;

    const content = input;
    setInput("");
    setIsSending(true);
    socket?.emit("typing:stop", { chatRoomId });
    shouldScrollToBottomRef.current = true;

    try {
      const res = await fetch(`/api/chat/rooms/${chatRoomId}/messages`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ type: "TEXT", content }),
      });

      const result = await res.json();

      if (result.data) {
        setAllMessages((prev) =>
          prev.some((m) => m.id === result.data.id)
            ? prev
            : [...prev, result.data]
        );
        socket?.emit("message:send", { chatRoomId, ...result.data });
      } else {
        toast.error("ë©”ì‹œì§€ ì „ì†¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
        setInput(content); // ì‹¤íŒ¨ ì‹œ ì…ë ¥ ë³µì›
      }
    } catch {
      toast.error("ë©”ì‹œì§€ ì „ì†¡ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
      setInput(content);
    } finally {
      setIsSending(false);
    }
  };

  // â”€â”€â”€ ìœ í‹¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const formatTime = (dateStr: any) => {
    if (!dateStr) return "";
    const date = new Date(dateStr);
    return isNaN(date.getTime())
      ? ""
      : date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
  };

  const getOtherMember = () =>
    chatRoom?.members?.find((m: any) => m.user.id !== session?.user?.id);

  // â”€â”€â”€ í†µí™” í•¸ë“¤ëŸ¬ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const handleVoiceCall = () => {
    const other = getOtherMember();
    if (!other) return;
    initiateCall("VOICE", other.user.id);
  };

  const handleEndCall = () => {
    endCall(getOtherMember()?.user?.id);
  };

  const handleToggleMute = () => {
    setAudioMuted(toggleMute());
  };

  const isInCall =
    callStatus === "calling" ||
    callStatus === "connected" ||
    callStatus === "incoming";

  const callStatusLabel: Record<string, string> = {
    calling: "ì—°ê²° ì¤‘...",
    incoming: "ì „í™” ì˜´",
    connected: "í†µí™” ì¤‘",
  };

  return (
    <div className="flex flex-col h-screen bg-[#F8F9FA] text-black overflow-hidden">

      {/* â”€â”€ í—¤ë” â”€â”€ */}
      <div className="p-4 border-b flex gap-3 items-center bg-white sticky top-0 z-20 shadow-sm justify-between">
        <div className="flex items-center gap-3">
          <button
            onClick={() => router.back()}
            className="hover:bg-gray-100 p-1 rounded-full"
          >
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <path d="m15 18-6-6 6-6" />
            </svg>
          </button>
          <div>
            <p className="font-bold text-base">
              {getOtherMember()?.user?.name || "ëŒ€í™”ë°©"}
            </p>
            {isInCall && (
              <p className="text-xs text-green-500 font-medium animate-pulse">
                {callStatusLabel[callStatus]}
              </p>
            )}
          </div>
        </div>

        {callStatus === "idle" && (
          <button
            onClick={handleVoiceCall}
            className="w-10 h-10 rounded-full bg-green-500 flex items-center justify-center text-white shadow-md active:scale-90 transition-transform"
          >
            ğŸ“
          </button>
        )}
      </div>

      {/* â”€â”€ ë©”ì‹œì§€ ì˜ì—­ â”€â”€ */}
      <div
        ref={scrollContainerRef}
        className="flex-1 overflow-y-auto px-4 py-2 pb-28"
      >
        {/* âœ… ìƒë‹¨ ê°ì§€ íŠ¸ë¦¬ê±° â€” ì—¬ê¸° ë‹¿ìœ¼ë©´ ì´ì „ ë©”ì‹œì§€ ë¡œë“œ */}
        <div ref={topObserverRef} className="h-1" />

        {/* ì´ì „ ë©”ì‹œì§€ ë¡œë”© ì¸ë””ì¼€ì´í„° */}
        {isLoadingMore && (
          <div className="flex justify-center py-3">
            <div className="flex gap-1">
              {[0, 1, 2].map((i) => (
                <div
                  key={i}
                  className="w-2 h-2 bg-gray-300 rounded-full animate-bounce"
                  style={{ animationDelay: `${i * 0.15}s` }}
                />
              ))}
            </div>
          </div>
        )}

        {/* ë” ì´ìƒ ë©”ì‹œì§€ ì—†ìŒ */}
        {!hasMore && allMessages.length > 0 && (
          <p className="text-center text-xs text-gray-400 py-3">
            â€” ëŒ€í™” ì‹œì‘ â€”
          </p>
        )}

        {/* ì´ˆê¸° ë¡œë”© ìŠ¤ì¼ˆë ˆí†¤ */}
        {isInitialLoading ? (
          <div className="space-y-4 mt-4">
            {[1, 2, 3, 4].map((i) => (
              <div
                key={i}
                className={`flex ${i % 2 === 0 ? "justify-end" : "justify-start"}`}
              >
                <div
                  className={`h-10 rounded-2xl animate-pulse bg-gray-200 ${
                    i % 2 === 0 ? "w-40" : "w-52"
                  }`}
                />
              </div>
            ))}
          </div>
        ) : (
          <div className="space-y-4 mt-2">
            {allMessages.map((msg, idx) => {
              const senderId = msg.sender?.id || msg.senderId || msg.userId;
              const isMe = senderId === session?.user?.id;
              const senderName = msg.sender?.name || "ìƒëŒ€ë°©";

              // ë‚ ì§œ êµ¬ë¶„ì„ 
              const showDateDivider =
                idx === 0 ||
                new Date(msg.createdAt).toDateString() !==
                  new Date(allMessages[idx - 1]?.createdAt).toDateString();

              return (
                <div key={msg.id || idx}>
                  {/* ë‚ ì§œ êµ¬ë¶„ì„  */}
                  {showDateDivider && (
                    <div className="flex items-center gap-2 my-4">
                      <div className="flex-1 h-px bg-gray-200" />
                      <span className="text-xs text-gray-400 px-2">
                        {new Date(msg.createdAt).toLocaleDateString("ko-KR", {
                          year: "numeric",
                          month: "long",
                          day: "numeric",
                        })}
                      </span>
                      <div className="flex-1 h-px bg-gray-200" />
                    </div>
                  )}

                  <div className={`flex ${isMe ? "justify-end" : "justify-start"}`}>
                    <div className={`flex flex-col ${isMe ? "items-end" : "items-start"}`}>
                      {!isMe && (
                        <span className="text-[10px] text-gray-400 mb-1 ml-1">
                          {senderName}
                        </span>
                      )}
                      <div
                        className={`p-3 px-4 rounded-2xl max-w-[80vw] sm:max-w-[60%] text-[14px] shadow-sm ${
                          isMe
                            ? "bg-blue-600 text-white rounded-tr-none"
                            : "bg-white border border-gray-200 text-black rounded-tl-none"
                        }`}
                      >
                        {msg.type === "FILE" && msg.file ? (
                          <a
                            href={msg.file.url}
                            target="_blank"
                            rel="noopener noreferrer"
                            className="underline"
                          >
                            ğŸ“ {msg.file.originalName || msg.file.name}
                          </a>
                        ) : (
                          <p className="whitespace-pre-wrap break-words">
                            {msg.content}
                          </p>
                        )}
                        <div
                          className={`text-[9px] mt-1 opacity-60 ${
                            isMe ? "text-right" : "text-left"
                          }`}
                        >
                          {formatTime(msg.createdAt)}
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              );
            })}
          </div>
        )}

        {typingUsers.size > 0 && (
          <div className="flex justify-start mt-4">
            <div className="bg-white border border-gray-200 rounded-2xl rounded-tl-none px-4 py-3 shadow-sm">
              <div className="flex gap-1 items-center">
                {[0, 1, 2].map((i) => (
                  <div
                    key={i}
                    className="w-2 h-2 bg-gray-400 rounded-full animate-bounce"
                    style={{ animationDelay: `${i * 0.15}s` }}
                  />
                ))}
              </div>
            </div>
          </div>
        )}

        <div ref={bottomRef} />
      </div>

      {/* â”€â”€ ì…ë ¥ì°½ â”€â”€ */}
      <div className="fixed bottom-0 left-0 right-0 p-3 bg-white border-t border-gray-200 z-30">
        <form
          onSubmit={onSend}
          className="flex items-center gap-2 max-w-2xl mx-auto"
        >
          <input
            value={input}
            onChange={(e) => {
              setInput(e.target.value);
              socket?.emit(
                e.target.value.length > 0 ? "typing:start" : "typing:stop",
                { chatRoomId }
              );
            }}
            className="flex-1 border border-gray-300 rounded-full px-5 py-3 text-black bg-gray-100 outline-none focus:bg-white text-[15px]"
            placeholder="ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”..."
          />
          <button
            type="submit"
            disabled={!input.trim() || isSending}
            className="bg-blue-600 text-white w-12 h-12 flex items-center justify-center rounded-full disabled:bg-gray-300 transition-all active:scale-95 shadow-lg shadow-blue-500/20"
          >
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round">
              <path d="m22 2-7 20-4-9-9-4Z" />
              <path d="M22 2 11 13" />
            </svg>
          </button>
        </form>
      </div>

      {/* â”€â”€ í†µí™” ëª¨ë‹¬ â”€â”€ */}
      {isInCall && (
        <div className="fixed inset-0 z-[100] bg-black/95 flex flex-col items-center justify-center p-6 backdrop-blur-md">
          <div className="text-white text-center mb-10">
            <div className="w-24 h-24 bg-blue-600 rounded-full mx-auto mb-4 flex items-center justify-center text-3xl font-bold border-4 border-white/20 animate-pulse">
              {getOtherMember()?.user?.name?.charAt(0)?.toUpperCase() || "?"}
            </div>
            <h2 className="text-2xl font-bold">{callStatusLabel[callStatus]}</h2>
            <p className="text-white/50 text-sm mt-2">
              {getOtherMember()?.user?.name}
            </p>
          </div>

          <div className="relative w-full max-w-sm aspect-[3/4] bg-gray-900 rounded-[2rem] overflow-hidden mb-12 shadow-2xl border border-white/10">
            <video ref={remoteVideoRef} autoPlay playsInline className="w-full h-full object-cover" />
            <div className="absolute top-4 right-4 w-24 aspect-[3/4] bg-black rounded-xl overflow-hidden border-2 border-white/20 shadow-lg">
              <video ref={localVideoRef} autoPlay playsInline muted className="w-full h-full object-cover" />
            </div>
          </div>

          <div className="flex gap-6 items-center">
            {callStatus === "incoming" && (
              <>
                <button
                  onClick={rejectCall}
                  className="w-16 h-16 bg-red-500 rounded-full text-white text-2xl shadow-xl active:scale-90 transition-transform flex items-center justify-center"
                >
                  âœ•
                </button>
                <button
                  onClick={acceptCall}
                  className="w-16 h-16 bg-green-500 rounded-full text-white text-2xl shadow-xl active:scale-90 transition-transform flex items-center justify-center"
                >
                  âœ“
                </button>
              </>
            )}

            {(callStatus === "calling" || callStatus === "connected") && (
              <>
                <button
                  onClick={handleToggleMute}
                  className={`w-14 h-14 rounded-full flex items-center justify-center text-white text-xl transition-all ${
                    audioMuted ? "bg-red-500" : "bg-white/20 hover:bg-white/30"
                  }`}
                >
                  {audioMuted ? "ğŸ”‡" : "ğŸ¤"}
                </button>
                <button
                  onClick={handleEndCall}
                  className="w-20 h-20 bg-red-500 rounded-full flex items-center justify-center shadow-2xl shadow-red-500/40 active:scale-95 transition-all"
                >
                  <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="currentColor" className="text-white rotate-[135deg]">
                    <path d="M6.62 10.79a15.05 15.05 0 006.59 6.59l2.2-2.2a1 1 0 011.01-.24c1.12.37 2.33.57 3.58.57a1 1 0 011 1V20a1 1 0 01-1 1C10.29 21 3 13.71 3 4a1 1 0 011-1h3.5a1 1 0 011 1c0 1.25.2 2.46.57 3.58a1 1 0 01-.25 1.01l-2.2 2.2z" />
                  </svg>
                </button>
              </>
            )}
          </div>
        </div>
      )}
    </div>
  );
}
</file>

</files>

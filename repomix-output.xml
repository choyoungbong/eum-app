This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/**/*, prisma/schema.prisma, package.json, tsconfig.json, next.config.*, middleware.*
- Files matching these patterns are excluded: *.backup, *.backup-*, prisma/migrations/**, repomix-output.*, node_modules/**, storage/**, logs/**, .git/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
next.config.js
package.json
prisma/schema.prisma
src/__tests__/lib/api-response.test.ts
src/__tests__/lib/cache.test.ts
src/__tests__/lib/components/ErrorBoundary.test.tsx
src/__tests__/lib/components/MentionTextarea.test.tsx
src/__tests__/lib/validators.test.ts
src/app/(auth)/login/page.tsx
src/app/(auth)/signup/page.tsx
src/app/about/page.tsx
src/app/activity-log/page.tsx
src/app/admin/page.tsx
src/app/admin/stats/page.tsx
src/app/api/activity-logs/route.ts
src/app/api/admin/notices/route.ts
src/app/api/admin/stats/route.ts
src/app/api/admin/users/[id]/ban/route.ts
src/app/api/admin/users/[id]/route.ts
src/app/api/admin/users/route.ts
src/app/api/auth/[...nextauth]/route.ts
src/app/api/auth/2fa/disable/route.ts
src/app/api/auth/2fa/setup/route.ts
src/app/api/auth/find-email/route.ts
src/app/api/auth/find-email/send/route.ts
src/app/api/auth/register/route.ts
src/app/api/auth/reset-password/confirm/route.ts
src/app/api/auth/reset-password/route.ts
src/app/api/auth/verify-email/confirm/route.ts
src/app/api/auth/verify-email/route.ts
src/app/api/calls/[id]/route.ts
src/app/api/calls/route.ts
src/app/api/chat/rooms/[id]/messages/route.ts
src/app/api/chat/rooms/[id]/read/route.ts
src/app/api/chat/rooms/[id]/route.ts
src/app/api/chat/rooms/route.ts
src/app/api/comments/[id]/route.ts
src/app/api/errors/report/route.ts
src/app/api/files/[id]/download/route.ts
src/app/api/files/[id]/encrypt/route.ts
src/app/api/files/[id]/favorite/route.ts
src/app/api/files/[id]/move/route.ts
src/app/api/files/[id]/public-link/route.ts
src/app/api/files/[id]/restore/route.ts
src/app/api/files/[id]/route.ts
src/app/api/files/[id]/share/route.ts
src/app/api/files/[id]/tags/route.ts
src/app/api/files/[id]/thumbnail/route.ts
src/app/api/files/[id]/versions/[versionId]/rollback/route.ts
src/app/api/files/[id]/versions/route.ts
src/app/api/files/route.ts
src/app/api/files/shared/route.ts
src/app/api/files/thumbnail/[filename]/route.ts
src/app/api/files/trash/route.ts
src/app/api/files/upload/route.ts
src/app/api/folders/[id]/download/route.ts
src/app/api/folders/[id]/move/route.ts
src/app/api/folders/[id]/route.ts
src/app/api/folders/[id]/share/route.ts
src/app/api/folders/route.ts
src/app/api/health/route.ts
src/app/api/link-preview/route.ts
src/app/api/notifications/[id]/route.ts
src/app/api/notifications/preferences/route.ts
src/app/api/notifications/route.ts
src/app/api/posts/[id]/bookmark/route.ts
src/app/api/posts/[id]/comments/route.ts
src/app/api/posts/[id]/like/route.ts
src/app/api/posts/[id]/route.ts
src/app/api/posts/[id]/share/route.ts
src/app/api/posts/[id]/tags/route.ts
src/app/api/posts/bookmarks/route.ts
src/app/api/posts/route.ts
src/app/api/saved-searches/[id]/route.ts
src/app/api/saved-searches/route.ts
src/app/api/search/route.ts
src/app/api/share/[token]/route.ts
src/app/api/share/route.ts
src/app/api/tags/route.ts
src/app/api/users/[id]/follow/route.ts
src/app/api/users/[id]/followers/route.ts
src/app/api/users/[id]/public/route.ts
src/app/api/users/fcm-token/route.ts
src/app/api/users/me/api-keys/[keyId]/route.ts
src/app/api/users/me/api-keys/route.ts
src/app/api/users/me/avatar/route.ts
src/app/api/users/me/export/route.ts
src/app/api/users/me/onboarding/route.ts
src/app/api/users/me/route.ts
src/app/api/users/me/sessions/route.ts
src/app/api/users/mention-search/route.ts
src/app/api/users/presence/route.ts
src/app/api/users/search/route.ts
src/app/banned/page.tsx
src/app/chat/[id]/page.tsx
src/app/chat/page.tsx
src/app/dashboard/page.tsx
src/app/error.tsx
src/app/find-email/page.tsx
src/app/global-error.tsx
src/app/globals.css
src/app/layout.tsx
src/app/not-found.tsx
src/app/notifications/page.tsx
src/app/notifications/settings/page.tsx
src/app/offline/page.tsx
src/app/page.tsx
src/app/posts/[id]/page.tsx
src/app/posts/new/page.tsx
src/app/posts/page.tsx
src/app/profile/page.tsx
src/app/providers.tsx
src/app/register/page.tsx
src/app/reset-password/confirm/page.tsx
src/app/reset-password/page.tsx
src/app/search/page.tsx
src/app/settings/2fa/page.tsx
src/app/settings/api-keys/page.tsx
src/app/settings/sessions/page.tsx
src/app/share/[token]/page.tsx
src/app/shared/page.tsx
src/app/trash/page.tsx
src/app/users/[id]/page.tsx
src/app/users/search/page.tsx
src/components/Breadcrumb.tsx
src/components/ConfirmDialog.tsx
src/components/DragDropUpload.tsx
src/components/ErrorBoundary.tsx
src/components/FileDropZone.tsx
src/components/FileEncryptButton.tsx
src/components/FileFavoritePin.tsx
src/components/FileFilters.tsx
src/components/FileGridSkeleton.tsx
src/components/FilePreviewModal.tsx
src/components/FileShareModal.tsx
src/components/FileVersionHistory.tsx
src/components/FolderCreateModal.tsx
src/components/KeyboardShortcuts.tsx
src/components/LazyImage.tsx
src/components/LikeBookmarkButtons.tsx
src/components/LinkPreviewCard.tsx
src/components/MentionTextarea.tsx
src/components/MessageBubble.tsx
src/components/MobileBottomNav.tsx
src/components/Notificationsettings.tsx
src/components/OnboardingTour.tsx
src/components/PostShareModal.tsx
src/components/ProfileImageUpload.tsx
src/components/PWAInstaller.tsx
src/components/SearchBar.tsx
src/components/SoundToggle.tsx
src/components/StorageQuotaBar.tsx
src/components/SystemNoticeBanner.tsx
src/components/TagInput.tsx
src/components/ThemeToggle.tsx
src/components/Toast.tsx
src/components/TypingIndicator.tsx
src/components/UploadProgress.tsx
src/components/UploadProgressOverlay.tsx
src/hooks/useInfiniteScroll.ts
src/hooks/useSocket.ts
src/lib/activity-log.ts
src/lib/api-key-auth.ts
src/lib/api-response.ts
src/lib/auth.ts
src/lib/cache.ts
src/lib/client-utils.ts
src/lib/db.ts
src/lib/demo-mode.ts
src/lib/email-templates.ts
src/lib/email.ts
src/lib/emit-notification.ts
src/lib/fcm.ts
src/lib/firebase.ts
src/lib/image-optimizer.ts
src/lib/logger.ts
src/lib/notification-prefs.ts
src/lib/notification.ts
src/lib/optimized-queries.ts
src/lib/rate-limit.ts
src/lib/request-logger.ts
src/lib/sanitize.ts
src/lib/socket-client.ts
src/lib/socket-server.ts
src/lib/sound.ts
src/lib/storage-guard.ts
src/lib/validators.ts
src/lib/webrtc.ts
src/middleware.ts
src/pages/api/socket/io.ts
src/types/next-auth.d.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/app/(auth)/login/page.tsx">
"use client";

import React, { useState, Suspense } from "react";
import { useSearchParams, useRouter } from "next/navigation";
import Link from "next/link";
import { Loader2 } from "lucide-react"; // 로딩 아이콘용

function LoginForm() {
  const searchParams = useSearchParams();
  const router = useRouter();
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");
  const [isLoading, setIsLoading] = useState(false);

  // searchParams가 null일 경우를 대비한 안전한 접근
  const isSignupSuccess = searchParams?.get("signup") === "success";

  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");
    setIsLoading(true);

    try {
      const res = await fetch("/api/auth/login", {
        method: "POST",
        body: JSON.stringify({ email, password }),
        headers: { "Content-Type": "application/json" },
      });

      if (res.ok) {
        router.push("/dashboard");
        router.refresh();
      } else {
        const data = await res.json();
        setError(data.message || "로그인에 실패했습니다.");
      }
    } catch (err) {
      setError("서버 연결에 실패했습니다.");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="w-full max-w-md mx-auto bg-white dark:bg-zinc-900 border dark:border-zinc-800 rounded-xl shadow-sm overflow-hidden">
      <div className="p-6">
        <div className="space-y-1 mb-6">
          <h2 className="text-2xl font-bold tracking-tight dark:text-white">로그인</h2>
          <p className="text-sm text-gray-500 dark:text-zinc-400">계정에 접속하여 서비스를 이용하세요.</p>
        </div>

        <form onSubmit={handleLogin} className="space-y-4">
          {isSignupSuccess && (
            <div className="p-3 rounded-lg bg-green-50 border border-green-200 dark:bg-green-900/20 dark:border-green-900">
              <p className="text-sm text-green-600 dark:text-green-400">
                회원가입이 완료되었습니다. 로그인해 주세요.
              </p>
            </div>
          )}
          
          {error && (
            <div className="p-3 rounded-lg bg-red-50 border border-red-200 dark:bg-red-900/20 dark:border-red-900">
              <p className="text-sm text-red-600 dark:text-red-400">{error}</p>
            </div>
          )}

          <div className="space-y-2">
            <label className="text-sm font-medium dark:text-zinc-200">이메일</label>
            <input 
              type="email" 
              placeholder="name@example.com" 
              className="w-full px-3 py-2 bg-white dark:bg-zinc-800 border dark:border-zinc-700 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 dark:text-white"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required 
            />
          </div>

          <div className="space-y-2">
            <label className="text-sm font-medium dark:text-zinc-200">비밀번호</label>
            <input 
              type="password" 
              className="w-full px-3 py-2 bg-white dark:bg-zinc-800 border dark:border-zinc-700 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 dark:text-white"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required 
            />
          </div>

          <button 
            type="submit" 
            disabled={isLoading}
            className="w-full flex items-center justify-center py-2 px-4 bg-blue-600 hover:bg-blue-700 disabled:bg-blue-400 text-white rounded-md font-medium transition-colors"
          >
            {isLoading ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : "로그인"}
          </button>
        </form>
      </div>
      
      <div className="px-6 py-4 bg-gray-50 dark:bg-zinc-800/50 border-t dark:border-zinc-800 text-center">
        <p className="text-sm text-gray-500 dark:text-zinc-400">
          계정이 없으신가요?{" "}
          <Link href="/signup" className="text-blue-600 dark:text-blue-400 hover:underline">
            회원가입
          </Link>
        </p>
      </div>
    </div>
  );
}

export default function LoginPage() {
  return (
    <div className="min-h-screen flex items-center justify-center p-4 bg-gray-50 dark:bg-zinc-950">
      <Suspense fallback={<div className="dark:text-white">로딩 중...</div>}>
        <LoginForm />
      </Suspense>
    </div>
  );
}
</file>

<file path="src/app/about/page.tsx">
"use client";

import Link from "next/link";
import { 
  Cpu, 
  Database, 
  Layers, 
  ShieldCheck, 
  Smartphone, 
  Zap, 
  ArrowLeft,
  Server,
  Code2
} from "lucide-react";

export default function AboutPage() {
  return (
    <div className="min-h-screen bg-[#0f0c29] text-white selection:bg-purple-500/30">
      {/* 상단 장식 블러 */}
      <div className="fixed top-0 right-0 w-[300px] h-[300px] bg-blue-600/10 blur-[100px] -z-10" />

      <div className="max-w-4xl mx-auto px-6 py-16">
        {/* 뒤로가기 & 헤더 */}
        <Link href="/" className="inline-flex items-center gap-2 text-white/40 hover:text-white transition-colors mb-12 group">
          <ArrowLeft size={18} className="group-hover:-translate-x-1 transition-transform" />
          <span>메인으로 돌아가기</span>
        </Link>

        <section className="mb-20">
          <h1 className="text-4xl md:text-5xl font-black mb-6 tracking-tight">
            기술로 잇는 <br />
            <span className="text-purple-400">나만의 디지털 생태계</span>
          </h1>
          <p className="text-lg text-white/60 leading-relaxed">
            EUM(이음)은 단순한 저장소를 넘어, 사용자의 모든 기기와 데이터를 <br className="hidden md:block" />
            가장 빠르고 안전한 방식으로 연결하기 위해 설계되었습니다.
          </p>
        </section>

        {/* 핵심 기술 스택 섹션 */}
        <div className="grid gap-12 mb-24">
          <FeatureRow 
            icon={<Cpu size={32} />}
            title="고성능 하이브리드 아키텍처"
            desc="Next.js 14의 Server Actions와 API Routes를 적재적소에 배치하여, 대용량 파일 업로드 시에도 브라우저 부하를 최소화하고 서버 자원을 효율적으로 관리합니다."
          />
          <FeatureRow 
            icon={<ShieldCheck size={32} />}
            title="엔터프라이즈급 보안 시스템"
            desc="사용자의 비밀번호는 Argon2 알고리즘으로 해싱되며, 모든 데이터 전송은 SSL/TLS 암호화 레이어를 통과합니다. 데이터베이스 수준에서의 접근 제어로 보안 사고를 원천 봉쇄합니다."
          />
          <FeatureRow 
            icon={<Zap size={32} />}
            title="실시간 데이터 동기화"
            desc="Socket.io와 Prisma의 실시간 이벤트를 결합하여, 파일 업로드나 채팅 메시지 전송 즉시 모든 연결된 기기에 상태가 반영됩니다."
          />
        </div>

        {/* 기술 스택 그리드 */}
        <div className="bg-white/5 border border-white/10 rounded-[32px] p-10">
          <h3 className="text-xl font-bold mb-8 flex items-center gap-2">
            <Code2 className="text-purple-400" />
            Built with Modern Stack
          </h3>
          <div className="grid grid-cols-2 md:grid-cols-4 gap-8">
            <StackItem icon={<Layers className="text-blue-400" />} name="Next.js 14" detail="App Router" />
            <StackItem icon={<Database className="text-emerald-400" />} name="PostgreSQL" detail="Prisma ORM" />
            <StackItem icon={<Server className="text-orange-400" />} name="Node.js" detail="Runtime" />
            <StackItem icon={<Smartphone className="text-pink-400" />} name="Firebase" detail="FCM Push" />
          </div>
        </div>

        {/* CTA */}
        <div className="mt-24 text-center">
          <p className="text-white/40 mb-6">준비가 되셨나요?</p>
          <Link
            href="/signup"
            className="inline-flex px-10 py-4 bg-gradient-to-r from-purple-500 to-blue-600 text-white font-black rounded-2xl hover:scale-105 transition-all shadow-xl shadow-purple-500/20"
          >
            지금 바로 계정 만들기
          </Link>
        </div>
      </div>
    </div>
  );
}

function FeatureRow({ icon, title, desc }: { icon: React.ReactNode, title: string, desc: string }) {
  return (
    <div className="flex flex-col md:flex-row gap-6 items-start">
      <div className="w-16 h-16 shrink-0 rounded-2xl bg-white/5 flex items-center justify-center text-purple-400 border border-white/10">
        {icon}
      </div>
      <div>
        <h3 className="text-2xl font-bold mb-3">{title}</h3>
        <p className="text-white/50 leading-relaxed">{desc}</p>
      </div>
    </div>
  );
}

function StackItem({ icon, name, detail }: { icon: React.ReactNode, name: string, detail: string }) {
  return (
    <div className="text-center md:text-left">
      <div className="mb-3 flex justify-center md:justify-start">{icon}</div>
      <p className="font-bold text-sm">{name}</p>
      <p className="text-white/30 text-xs">{detail}</p>
    </div>
  );
}
</file>

<file path="src/app/api/auth/[...nextauth]/route.ts">
import NextAuth from "next-auth";
import { authOptions } from "@/lib/auth";

const handler = NextAuth(authOptions);

// authOptions는 절대 여기서 export하지 않음!
// 다른 파일들은 @/lib/auth 에서 직접 import해야 함
export { handler as GET, handler as POST };
</file>

<file path="src/app/api/auth/find-email/route.ts">
// =============================================
// src/app/api/auth/find-email/route.ts
// 이메일 찾기 API - 이름으로 마스킹된 이메일 반환
// =============================================
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";

export async function POST(request: NextRequest) {
  try {
    const { name } = await request.json();
    if (!name?.trim()) {
      return NextResponse.json({ error: "이름을 입력하세요" }, { status: 400 });
    }

    const user = await prisma.user.findFirst({
      where: { name: { equals: name.trim(), mode: "insensitive" } },
    });

    if (!user) {
      return NextResponse.json(
        { error: "해당 이름으로 가입된 계정을 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    // 이메일 마스킹: ab***@gmail.com
    const [localPart, domain] = user.email.split("@");
    const masked =
      localPart.slice(0, 2) + "*".repeat(Math.max(3, localPart.length - 2)) + "@" + domain;

    return NextResponse.json({ maskedEmail: masked });
  } catch (error) {
    console.error("Find email error:", error);
    return NextResponse.json({ error: "서버 오류" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/auth/find-email/send/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { sendEmail } from "@/lib/email";

export async function POST(request: NextRequest) {
  try {
    const { name } = await request.json();

    if (!name?.trim()) {
      return NextResponse.json({ error: "이름을 입력하세요" }, { status: 400 });
    }

    const user = await prisma.user.findFirst({
      where: { name: { equals: name.trim(), mode: "insensitive" } },
    });

    if (!user) {
      return NextResponse.json({ error: "계정을 찾을 수 없습니다" }, { status: 404 });
    }

    await sendEmail({
      to: user.email,
      subject: "[이음] 이메일 찾기 안내",
      html: `
        <div style="font-family: sans-serif; max-width: 480px; margin: 0 auto; padding: 40px 24px;">
          <h2 style="color: #7c3aed; margin-bottom: 8px;">이음 (Eum)</h2>
          <p style="color: #666; margin-bottom: 24px;">사람과 파일을 잇다</p>
          <hr style="border: none; border-top: 1px solid #eee; margin-bottom: 24px;"/>
          <h3 style="color: #111; margin-bottom: 16px;">이메일 찾기</h3>
          <p style="color: #444; margin-bottom: 8px;">안녕하세요, <strong>${user.name}</strong>님!</p>
          <p style="color: #444; margin-bottom: 24px;">
            요청하신 이음 계정의 이메일 주소입니다:
          </p>
          <div style="background: #f5f3ff; border: 1px solid #ddd6fe; border-radius: 12px; padding: 20px; text-align: center; margin-bottom: 24px;">
            <p style="font-size: 20px; font-weight: 700; color: #7c3aed; margin: 0;">${user.email}</p>
          </div>
          <p style="color: #888; font-size: 13px;">
            본인이 요청하지 않으셨다면 이 메일을 무시해 주세요.
          </p>
          <hr style="border: none; border-top: 1px solid #eee; margin: 24px 0;"/>
          <p style="color: #aaa; font-size: 12px;">© 2025 이음(Eum)</p>
        </div>
      `,
    });

    return NextResponse.json({ message: "이메일이 발송되었습니다" });
  } catch (error) {
    console.error("Send email error:", error);
    return NextResponse.json({ error: "이메일 발송 실패" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/auth/register/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { hash } from "bcryptjs"; // ✅ bcrypt → bcryptjs
import { z } from "zod";
import { prisma } from "@/lib/db";
import { DEMO_MODE } from "@/lib/demo-mode";

const signupSchema = z.object({
  email: z.string().email("유효한 이메일을 입력하세요"),
  password: z.string().min(8, "비밀번호는 최소 8자 이상이어야 합니다"),
  name: z.string().min(2, "이름은 최소 2자 이상이어야 합니다"),
  marketingConsent: z.boolean().optional(),
});

export async function POST(request: NextRequest) {
  try {
    if (DEMO_MODE) {
      return NextResponse.json(
        {
          error: "데모 모드에서는 회원가입이 불가능합니다.",
          demoAccount: "reviewer@appstore.com / Demo2024!Review",
        },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validation = signupSchema.safeParse(body);

    if (!validation.success) {
      return NextResponse.json(
        { error: validation.error.errors[0].message },
        { status: 400 }
      );
    }

    const { email, password, name } = validation.data;

    const existingUser = await prisma.user.findUnique({ where: { email } });
    if (existingUser) {
      return NextResponse.json(
        { error: "이미 사용 중인 이메일입니다" },
        { status: 409 }
      );
    }

    const passwordHash = await hash(password, 12);

    const user = await prisma.user.create({
      data: {
        email,
        passwordHash,
        name,
        role: "USER",
        emailVerified: false,
      },
      select: {
        id: true,
        email: true,
        name: true,
        createdAt: true,
      },
    });

    return NextResponse.json(
      { message: "회원가입이 완료되었습니다", user },
      { status: 201 }
    );
  } catch (error) {
    console.error("Signup error:", error);
    return NextResponse.json({ error: "서버 오류가 발생했습니다" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/auth/reset-password/confirm/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import bcrypt from "bcryptjs";

export async function POST(request: NextRequest) {
  try {
    const { token, password } = await request.json();

    if (!token || !password) {
      return NextResponse.json({ error: "유효하지 않은 요청입니다" }, { status: 400 });
    }

    if (password.length < 8 || !/(?=.*[a-zA-Z])(?=.*\d)/.test(password)) {
      return NextResponse.json(
        { error: "비밀번호는 8자 이상, 영문+숫자 조합이어야 합니다" },
        { status: 400 }
      );
    }

    // Prisma ORM으로 토큰 조회
    const tokenRecord = await prisma.passwordResetToken.findUnique({
      where: { token },
    });

    if (!tokenRecord || tokenRecord.expiresAt < new Date()) {
      return NextResponse.json(
        { error: "링크가 만료됐거나 유효하지 않습니다. 다시 요청해주세요." },
        { status: 400 }
      );
    }

    const hashedPassword = await bcrypt.hash(password, 12);

    // 비밀번호 업데이트
    await prisma.user.update({
      where: { id: tokenRecord.userId },
      data: { passwordHash: hashedPassword },
    });

    // 토큰 삭제
    await prisma.passwordResetToken.delete({
      where: { token },
    });

    return NextResponse.json({ message: "비밀번호가 변경되었습니다" });
  } catch (error) {
    console.error("Confirm reset error:", error);
    return NextResponse.json({ error: "오류가 발생했습니다" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/auth/reset-password/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { sendEmail } from "@/lib/email";
import crypto from "crypto";

export async function POST(request: NextRequest) {
  try {
    const { email } = await request.json();

    if (!email?.trim()) {
      return NextResponse.json({ error: "이메일을 입력하세요" }, { status: 400 });
    }

    const user = await prisma.user.findUnique({
      where: { email: email.trim().toLowerCase() },
    });

    // 보안: 사용자 존재 여부 노출 안 함
    if (!user) {
      return NextResponse.json({ message: "이메일이 발송되었습니다" });
    }

    // 토큰 생성 (15분 유효)
    const token = crypto.randomBytes(32).toString("hex");
    const expiresAt = new Date(Date.now() + 15 * 60 * 1000);

    // Prisma ORM으로 토큰 저장 (upsert)
    await prisma.passwordResetToken.upsert({
      where: { userId: user.id },
      update: { token, expiresAt },
      create: { userId: user.id, token, expiresAt },
    });

    const resetUrl = `${process.env.NEXTAUTH_URL}/reset-password/confirm?token=${token}`;

    await sendEmail({
      to: user.email,
      subject: "[이음] 비밀번호 재설정 안내",
      html: `
        <div style="font-family: sans-serif; max-width: 480px; margin: 0 auto; padding: 40px 24px;">
          <h2 style="color: #7c3aed; margin-bottom: 8px;">이음 (Eum)</h2>
          <p style="color: #666; margin-bottom: 24px;">사람과 파일을 잇다</p>
          <hr style="border: none; border-top: 1px solid #eee; margin-bottom: 24px;"/>
          <h3 style="color: #111; margin-bottom: 16px;">비밀번호 재설정</h3>
          <p style="color: #444; margin-bottom: 8px;">안녕하세요, <strong>${user.name}</strong>님!</p>
          <p style="color: #444; margin-bottom: 24px;">
            비밀번호 재설정을 요청하셨습니다.<br/>
            아래 버튼을 클릭해 새 비밀번호를 설정해주세요.
          </p>
          <div style="text-align: center; margin-bottom: 24px;">
            <a href="${resetUrl}"
              style="display: inline-block; background: linear-gradient(135deg, #7c3aed, #2563eb); color: white; padding: 14px 32px; border-radius: 12px; text-decoration: none; font-weight: 700; font-size: 16px;">
              비밀번호 재설정하기
            </a>
          </div>
          <div style="background: #fef3c7; border: 1px solid #fbbf24; border-radius: 8px; padding: 12px 16px; margin-bottom: 20px;">
            <p style="color: #92400e; font-size: 13px; margin: 0;">
              ⏰ 이 링크는 <strong>15분</strong> 후 만료됩니다.
            </p>
          </div>
          <p style="color: #888; font-size: 13px;">
            본인이 요청하지 않으셨다면 이 메일을 무시해 주세요.<br/>
            비밀번호는 변경되지 않습니다.
          </p>
          <hr style="border: none; border-top: 1px solid #eee; margin: 24px 0;"/>
          <p style="color: #aaa; font-size: 12px;">© 2025 이음(Eum)</p>
        </div>
      `,
    });

    return NextResponse.json({ message: "이메일이 발송되었습니다" });
  } catch (error) {
    console.error("Reset password error:", error);
    return NextResponse.json({ error: "오류가 발생했습니다" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/calls/[id]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// 통화 상태 업데이트 (수락/거절/종료)
export async function PATCH(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const callId = params.id;
    const body = await request.json();
    const { action } = body; // "accept", "reject", "end"

    // 통화 조회
    const call = await prisma.call.findUnique({
      where: { id: callId },
      include: {
        chatRoom: true,
      },
    });

    if (!call) {
      return NextResponse.json(
        { error: "통화를 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    // 권한 확인 (발신자 또는 수신자만)
    if (call.initiatorId !== session.user.id && call.receiverId !== session.user.id) {
      return NextResponse.json(
        { error: "권한이 없습니다" },
        { status: 403 }
      );
    }

    let updatedCall;
    let systemMessage = "";

    switch (action) {
      case "accept":
        // 수신자만 수락 가능
        if (call.receiverId !== session.user.id) {
          return NextResponse.json(
            { error: "수신자만 통화를 수락할 수 있습니다" },
            { status: 403 }
          );
        }

        updatedCall = await prisma.call.update({
          where: { id: callId },
          data: {
            status: "ACCEPTED",
            startedAt: new Date(),
          },
        });
        systemMessage = "통화가 시작되었습니다.";
        break;

      case "reject":
        // 수신자만 거절 가능
        if (call.receiverId !== session.user.id) {
          return NextResponse.json(
            { error: "수신자만 통화를 거절할 수 있습니다" },
            { status: 403 }
          );
        }

        updatedCall = await prisma.call.update({
          where: { id: callId },
          data: {
            status: "REJECTED",
            endedAt: new Date(),
          },
        });
        systemMessage = "통화가 거절되었습니다.";
        break;

      case "end":
        // 발신자 또는 수신자 둘 다 종료 가능
        const endedAt = new Date();
        const duration = call.startedAt
          ? Math.floor((endedAt.getTime() - call.startedAt.getTime()) / 1000)
          : 0;

        updatedCall = await prisma.call.update({
          where: { id: callId },
          data: {
            status: "ENDED",
            endedAt,
            duration,
          },
        });

        if (duration > 0) {
          const minutes = Math.floor(duration / 60);
          const seconds = duration % 60;
          systemMessage = `통화가 종료되었습니다. (${minutes}분 ${seconds}초)`;
        } else {
          systemMessage = "통화가 종료되었습니다.";
        }
        break;

      default:
        return NextResponse.json(
          { error: "잘못된 액션입니다" },
          { status: 400 }
        );
    }

    // 시스템 메시지 생성
    if (systemMessage) {
      await prisma.chatMessage.create({
        data: {
          chatRoomId: call.chatRoomId,
          senderId: session.user.id,
          type: "CALL_LOG",
          callId: call.id,
          content: systemMessage,
        },
      });
    }

    return NextResponse.json({
      message: systemMessage,
      call: updatedCall,
    });
  } catch (error) {
    console.error("Call update error:", error);
    return NextResponse.json(
      { error: "통화 업데이트 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}

// 통화 상세 조회
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const callId = params.id;

    const call = await prisma.call.findUnique({
      where: { id: callId },
      include: {
        initiator: {
          select: {
            id: true,
            name: true,
            isOnline: true,
          },
        },
        receiver: {
          select: {
            id: true,
            name: true,
            isOnline: true,
          },
        },
        chatRoom: true,
      },
    });

    if (!call) {
      return NextResponse.json(
        { error: "통화를 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    // 권한 확인
    if (call.initiatorId !== session.user.id && call.receiverId !== session.user.id) {
      return NextResponse.json(
        { error: "권한이 없습니다" },
        { status: 403 }
      );
    }

    return NextResponse.json({ call });
  } catch (error) {
    console.error("Call fetch error:", error);
    return NextResponse.json(
      { error: "통화 조회 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/calls/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { prisma } from "@/lib/db";
import { sendCallNotification } from "@/lib/fcm";

// 통화 요청 생성
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { chatRoomId, receiverId, callType } = body;

    // 유효성 검사
    if (!chatRoomId || !receiverId || !callType) {
      return NextResponse.json(
        { error: "필수 정보가 누락되었습니다" },
        { status: 400 }
      );
    }

    // 채팅방 멤버십 확인
    const membership = await prisma.chatRoomMember.findFirst({
      where: {
        chatRoomId,
        userId: session.user.id,
      },
    });

    if (!membership) {
      return NextResponse.json(
        { error: "채팅방에 참여하지 않았습니다" },
        { status: 403 }
      );
    }

    // 수신자 정보 조회
    const receiver = await prisma.user.findUnique({
      where: { id: receiverId },
      select: {
        id: true,
        name: true,
        fcmToken: true,
        isOnline: true,
      },
    });

    if (!receiver) {
      return NextResponse.json(
        { error: "수신자를 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    // 통화 기록 생성
    const call = await prisma.call.create({
      data: {
        chatRoomId,
        initiatorId: session.user.id,
        receiverId,
        type: callType,
        status: "PENDING",
      },
    });

    // ========== FCM 푸시 알림 전송 ==========
    if (receiver.fcmToken) {
      try {
        // 수정된 fcm.ts의 sendCallNotification 호출
        const pushResult = await sendCallNotification(
          receiver.fcmToken,
          session.user.name || "사용자",
          callType,
          call.id,
          chatRoomId
        );
        
        if (pushResult.success) {
          console.log(`✅ 통화 푸시 성공: ${receiver.name} (Status: ${receiver.isOnline ? 'Online' : 'Offline'})`);
        } else {
          console.error(`❌ 통화 푸시 전송 실패: ${pushResult.error}`);
        }
      } catch (error) {
        console.error(`❌ 통화 푸시 예외 발생 (${receiver.name}):`, error);
      }
    } else {
      console.warn(`⚠️ FCM 토큰 없음: ${receiver.name}`);
    }

    return NextResponse.json(
      {
        message: "통화 요청이 전송되었습니다",
        call,
      },
      { status: 201 }
    );
  } catch (error) {
    console.error("Call request error:", error);
    return NextResponse.json(
      { error: "통화 요청 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}

// 활성 통화 조회
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const activeCalls = await prisma.call.findMany({
      where: {
        OR: [
          { initiatorId: session.user.id },
          { receiverId: session.user.id },
        ],
        status: { in: ["PENDING", "ACCEPTED"] },
      },
      include: {
        initiator: { select: { id: true, name: true } },
        receiver: { select: { id: true, name: true } },
      },
      orderBy: { createdAt: "desc" },
    });

    return NextResponse.json({ calls: activeCalls });
  } catch (error) {
    console.error("Active calls fetch error:", error);
    return NextResponse.json(
      { error: "통화 조회 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/chat/rooms/[id]/read/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// 메시지 읽음 처리
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const chatRoomId = params.id;

    // 멤버십 조회
    const membership = await prisma.chatRoomMember.findFirst({
      where: {
        chatRoomId,
        userId: session.user.id,
      },
    });

    if (!membership) {
      return NextResponse.json(
        { error: "채팅방에 참여하지 않았습니다" },
        { status: 403 }
      );
    }

    // lastReadAt 업데이트
    await prisma.chatRoomMember.update({
      where: {
        id: membership.id,
      },
      data: {
        lastReadAt: new Date(),
      },
    });

    return NextResponse.json({
      message: "읽음 처리되었습니다",
    });
  } catch (error) {
    console.error("Read message error:", error);
    return NextResponse.json(
      { error: "읽음 처리 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/chat/rooms/[id]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// 채팅방 상세 조회
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const chatRoomId = params.id;

    // 채팅방 조회
    const chatRoom = await prisma.chatRoom.findUnique({
      where: { id: chatRoomId },
      include: {
        members: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
                isOnline: true,
                lastSeenAt: true,
              },
            },
          },
        },
      },
    });

    if (!chatRoom) {
      return NextResponse.json(
        { error: "채팅방을 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    // 참여자 확인
    const isMember = chatRoom.members.some(
      (member: any) => member.userId === session.user.id
    );

    if (!isMember) {
      return NextResponse.json(
        { error: "채팅방에 참여하지 않았습니다" },
        { status: 403 }
      );
    }

    return NextResponse.json({ chatRoom });
  } catch (error) {
    console.error("Chat room fetch error:", error);
    return NextResponse.json(
      { error: "채팅방 조회 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}

// 채팅방 나가기
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const chatRoomId = params.id;

    // 멤버십 확인
    const membership = await prisma.chatRoomMember.findFirst({
      where: {
        chatRoomId,
        userId: session.user.id,
      },
    });

    if (!membership) {
      return NextResponse.json(
        { error: "채팅방에 참여하지 않았습니다" },
        { status: 403 }
      );
    }

    // 멤버 제거
    await prisma.chatRoomMember.delete({
      where: {
        id: membership.id,
      },
    });

    // 시스템 메시지 생성
    await prisma.chatMessage.create({
      data: {
        chatRoomId,
        senderId: session.user.id,
        type: "SYSTEM",
        content: `${session.user.name}님이 채팅방을 나갔습니다.`,
      },
    });

    // 남은 멤버 확인
    const remainingMembers = await prisma.chatRoomMember.count({
      where: { chatRoomId },
    });

    // 멤버가 없으면 채팅방 삭제
    if (remainingMembers === 0) {
      await prisma.chatRoom.delete({
        where: { id: chatRoomId },
      });
    }

    return NextResponse.json({
      message: "채팅방을 나갔습니다",
    });
  } catch (error) {
    console.error("Chat room leave error:", error);
    return NextResponse.json(
      { error: "채팅방 나가기 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/chat/rooms/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// 채팅방 목록 조회
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    // 내가 참여한 채팅방 목록
    const chatRoomMembers = await prisma.chatRoomMember.findMany({
      where: {
        userId: session.user.id,
      },
      include: {
        chatRoom: {
          include: {
            members: {
              include: {
                user: {
                  select: {
                    id: true,
                    name: true,
                    email: true,
                    isOnline: true,
                    lastSeenAt: true,
                  },
                },
              },
            },
            messages: {
              orderBy: { createdAt: "desc" },
              take: 1, // 마지막 메시지만
              include: {
                sender: {
                  select: {
                    id: true,
                    name: true,
                  },
                },
              },
            },
            _count: {
              select: {
                messages: true,
              },
            },
          },
        },
      },
      orderBy: {
        chatRoom: {
          updatedAt: "desc",
        },
      },
    });

    // 읽지 않은 메시지 개수 계산
    const chatRooms = await Promise.all(
      chatRoomMembers.map(async (member: any) => {
        const unreadCount = await prisma.chatMessage.count({
          where: {
            chatRoomId: member.chatRoomId,
            createdAt: {
              gt: member.lastReadAt || new Date(0),
            },
            senderId: {
              not: session.user.id, // 본인 메시지 제외
            },
          },
        });

        return {
          ...member.chatRoom,
          unreadCount,
          myMembership: {
            lastReadAt: member.lastReadAt,
          },
        };
      })
    );

    return NextResponse.json({ chatRooms });
  } catch (error) {
    console.error("Chat rooms fetch error:", error);
    return NextResponse.json(
      { error: "채팅방 조회 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}

// 채팅방 생성
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { type, memberIds, name } = body;

    // 유효성 검사
    if (!type || !memberIds || !Array.isArray(memberIds)) {
      return NextResponse.json(
        { error: "잘못된 요청입니다" },
        { status: 400 }
      );
    }

    // 1:1 채팅인 경우 기존 채팅방 확인
    if (type === "DIRECT") {
      if (memberIds.length !== 1) {
        return NextResponse.json(
          { error: "1:1 채팅은 상대방 1명만 지정해야 합니다" },
          { status: 400 }
        );
      }

      const otherUserId = memberIds[0];

      // 이미 존재하는 1:1 채팅방 찾기
      const existingChatRoom = await prisma.chatRoom.findFirst({
        where: {
          type: "DIRECT",
          members: {
            every: {
              userId: {
                in: [session.user.id, otherUserId],
              },
            },
          },
        },
        include: {
          members: {
            include: {
              user: {
                select: {
                  id: true,
                  name: true,
                  email: true,
                  isOnline: true,
                },
              },
            },
          },
        },
      });

      if (existingChatRoom) {
        return NextResponse.json({
          message: "기존 채팅방을 반환합니다",
          chatRoom: existingChatRoom,
        });
      }
    }

    // 그룹 채팅인 경우 이름 필수
    if (type === "GROUP" && !name) {
      return NextResponse.json(
        { error: "그룹 채팅방 이름을 입력하세요" },
        { status: 400 }
      );
    }

    // 채팅방 생성
    const chatRoom = await prisma.chatRoom.create({
      data: {
        type,
        name: type === "GROUP" ? name : null,
        members: {
          create: [
            // 본인 추가
            {
              userId: session.user.id,
            },
            // 다른 멤버들 추가
            ...memberIds.map((userId: string) => ({
              userId,
            })),
          ],
        },
      },
      include: {
        members: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
                isOnline: true,
                lastSeenAt: true,
              },
            },
          },
        },
      },
    });

    // 시스템 메시지 생성 (그룹 채팅)
    if (type === "GROUP") {
      await prisma.chatMessage.create({
        data: {
          chatRoomId: chatRoom.id,
          senderId: session.user.id,
          type: "SYSTEM",
          content: `${session.user.name}님이 채팅방을 만들었습니다.`,
        },
      });
    }

    return NextResponse.json(
      {
        message: "채팅방이 생성되었습니다",
        chatRoom,
      },
      { status: 201 }
    );
  } catch (error) {
    console.error("Chat room create error:", error);
    return NextResponse.json(
      { error: "채팅방 생성 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/comments/[id]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// 댓글 삭제
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const commentId = params.id;

    const comment = await prisma.comment.findUnique({
      where: { id: commentId },
    });

    if (!comment) {
      return NextResponse.json(
        { error: "댓글을 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    if (comment.userId !== session.user.id) {
      return NextResponse.json(
        { error: "삭제 권한이 없습니다" },
        { status: 403 }
      );
    }

    await prisma.comment.delete({
      where: { id: commentId },
    });

    return NextResponse.json({
      message: "댓글이 삭제되었습니다",
    });

  } catch (error) {
    console.error("Comment delete error:", error);
    return NextResponse.json(
      { error: "댓글 삭제 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/files/[id]/download/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import { createReadStream } from "fs";
import { stat } from "fs/promises";

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const fileId = params.id;

    // 파일 조회
    const file = await prisma.file.findUnique({
      where: { id: fileId },
    });

    if (!file) {
      return NextResponse.json(
        { error: "파일을 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    // 권한 확인 (소유자 또는 공유받은 사용자)
    const isOwner = file.userId === session.user.id;
    
    if (!isOwner) {
      const sharedResource = await prisma.sharedResource.findFirst({
        where: {
          resourceType: "FILE",
          resourceId: fileId,
          sharedWithId: session.user.id,
        },
      });

      if (!sharedResource) {
        return NextResponse.json(
          { error: "파일에 접근할 권한이 없습니다" },
          { status: 403 }
        );
      }
    }

    // 파일 존재 확인
    try {
      await stat(file.filepath);
    } catch (error) {
      return NextResponse.json(
        { error: "파일이 존재하지 않습니다" },
        { status: 404 }
      );
    }

    // 파일 스트림 읽기
    const fileStream = createReadStream(file.filepath);
    const chunks: Buffer[] = [];

    for await (const chunk of fileStream) {
      chunks.push(Buffer.from(chunk));
    }

    const buffer = Buffer.concat(chunks);

    // 파일 다운로드 응답
    return new NextResponse(buffer, {
      status: 200,
      headers: {
        "Content-Type": file.mimeType,
        "Content-Disposition": `attachment; filename="${encodeURIComponent(file.originalName)}"`,
        "Content-Length": buffer.length.toString(),
      },
    });
  } catch (error) {
    console.error("File download error:", error);
    return NextResponse.json(
      { error: "파일 다운로드 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/files/[id]/move/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// 파일 이동
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const fileId = params.id;
    const body = await request.json();
    const { folderId } = body; // null이면 루트로 이동

    // 파일 확인
    const file = await prisma.file.findUnique({
      where: { id: fileId },
    });

    if (!file) {
      return NextResponse.json(
        { error: "파일을 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    if (file.userId !== session.user.id) {
      return NextResponse.json(
        { error: "권한이 없습니다" },
        { status: 403 }
      );
    }

    // 대상 폴더 확인 (있는 경우)
    if (folderId) {
      const targetFolder = await prisma.folder.findUnique({
        where: { id: folderId },
      });

      if (!targetFolder) {
        return NextResponse.json(
          { error: "대상 폴더를 찾을 수 없습니다" },
          { status: 404 }
        );
      }

      if (targetFolder.userId !== session.user.id) {
        return NextResponse.json(
          { error: "대상 폴더에 대한 권한이 없습니다" },
          { status: 403 }
        );
      }
    }

    // 파일 이동
    const updatedFile = await prisma.file.update({
      where: { id: fileId },
      data: {
        folderId: folderId || null,
      },
    });

    return NextResponse.json({
      message: "파일이 이동되었습니다",
      file: {
        ...updatedFile,
        size: updatedFile.size.toString(),
      },
    });

  } catch (error) {
    console.error("File move error:", error);
    return NextResponse.json(
      { error: "파일 이동 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/files/[id]/share/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// 파일 공유 생성
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const fileId = params.id;
    const body = await request.json();
    const { sharedWithEmail, permission = "VIEW" } = body;

    if (!sharedWithEmail) {
      return NextResponse.json(
        { error: "공유할 사용자 이메일을 입력하세요" },
        { status: 400 }
      );
    }

    // 파일 확인
    const file = await prisma.file.findUnique({
      where: { id: fileId },
    });

    if (!file) {
      return NextResponse.json(
        { error: "파일을 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    // 소유자 확인
    if (file.userId !== session.user.id) {
      return NextResponse.json(
        { error: "파일 소유자만 공유할 수 있습니다" },
        { status: 403 }
      );
    }

    // 공유 대상 사용자 확인
    const sharedWithUser = await prisma.user.findUnique({
      where: { email: sharedWithEmail },
    });

    if (!sharedWithUser) {
      return NextResponse.json(
        { error: "해당 이메일의 사용자를 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    // 본인에게 공유 방지
    if (sharedWithUser.id === session.user.id) {
      return NextResponse.json(
        { error: "본인에게는 공유할 수 없습니다" },
        { status: 400 }
      );
    }

    // 이미 공유된 경우 확인
    const existingShare = await prisma.sharedResource.findFirst({
      where: {
        resourceType: "FILE",
        resourceId: fileId,
        sharedWithId: sharedWithUser.id,
      },
    });

    if (existingShare) {
      return NextResponse.json(
        { error: "이미 공유된 파일입니다" },
        { status: 409 }
      );
    }

    // 공유 생성
    const share = await prisma.sharedResource.create({
      data: {
        resourceType: "FILE",
        resourceId: fileId,
        ownerId: session.user.id,
        sharedWithId: sharedWithUser.id,
        permission,
      },
      include: {
        sharedWith: {
          select: {
            id: true,
            email: true,
            name: true,
          },
        },
      },
    });

    return NextResponse.json(
      {
        message: "파일이 공유되었습니다",
        share,
      },
      { status: 201 }
    );

  } catch (error) {
    console.error("File share error:", error);
    return NextResponse.json(
      { error: "파일 공유 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}

// 파일 공유 목록 조회
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const fileId = params.id;

    // 파일 확인 및 권한 체크
    const file = await prisma.file.findUnique({
      where: { id: fileId },
    });

    if (!file) {
      return NextResponse.json(
        { error: "파일을 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    if (file.userId !== session.user.id) {
      return NextResponse.json(
        { error: "권한이 없습니다" },
        { status: 403 }
      );
    }

    // 공유 목록 조회
    const shares = await prisma.sharedResource.findMany({
      where: {
        resourceType: "FILE",
        resourceId: fileId,
      },
      include: {
        sharedWith: {
          select: {
            id: true,
            email: true,
            name: true,
          },
        },
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    return NextResponse.json({ shares });

  } catch (error) {
    console.error("Share list error:", error);
    return NextResponse.json(
      { error: "공유 목록 조회 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}

// 공유 삭제
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const shareId = searchParams.get("shareId");

    if (!shareId) {
      return NextResponse.json(
        { error: "공유 ID가 필요합니다" },
        { status: 400 }
      );
    }

    // 공유 확인
    const share = await prisma.sharedResource.findUnique({
      where: { id: shareId },
    });

    if (!share) {
      return NextResponse.json(
        { error: "공유 정보를 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    // 소유자 확인
    if (share.ownerId !== session.user.id) {
      return NextResponse.json(
        { error: "권한이 없습니다" },
        { status: 403 }
      );
    }

    // 공유 삭제
    await prisma.sharedResource.delete({
      where: { id: shareId },
    });

    return NextResponse.json({
      message: "공유가 취소되었습니다",
    });

  } catch (error) {
    console.error("Share delete error:", error);
    return NextResponse.json(
      { error: "공유 취소 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/files/[id]/tags/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// 파일 태그 목록 조회
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
    }

    const file = await prisma.file.findUnique({
      where: { id: params.id },
      include: {
        fileTags: { include: { tag: true } },
      },
    });

    if (!file) {
      return NextResponse.json(
        { error: "파일을 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    return NextResponse.json({ tags: file.fileTags.map((ft: any) => ft.tag) });
  } catch (error) {
    console.error("Tag GET error:", error);
    return NextResponse.json(
      { error: "태그 조회 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}

// 파일 태그 추가
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
    }

    const body = await request.json();
    const { tagName } = body;

    if (!tagName || !tagName.trim()) {
      return NextResponse.json(
        { error: "태그 이름을 입력하세요" },
        { status: 400 }
      );
    }

    // 파일 확인
    const file = await prisma.file.findUnique({ where: { id: params.id } });
    if (!file) {
      return NextResponse.json(
        { error: "파일을 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    // 소유자 확인
    if (file.userId !== session.user.id) {
      return NextResponse.json(
        { error: "태그를 추가할 권한이 없습니다" },
        { status: 403 }
      );
    }

    const normalizedName = tagName.trim().toLowerCase();

    // 태그 upsert (없으면 생성, 있으면 기존 사용)
    const tag = await prisma.tag.upsert({
      where: { name: normalizedName },
      update: {},
      create: { name: normalizedName },
    });

    // 이미 연결됐는지 확인
    const existing = await prisma.fileTag.findUnique({
      where: {
        fileId_tagId: { fileId: params.id, tagId: tag.id },
      },
    });

    if (existing) {
      return NextResponse.json(
        { error: "이미 추가된 태그입니다" },
        { status: 400 }
      );
    }

    // 파일-태그 연결
    await prisma.fileTag.create({
      data: { fileId: params.id, tagId: tag.id },
    });

    // 태그가 추가된 파일 전체 반환 (프론트에서 즉시 반영)
    const updatedFile = await prisma.file.findUnique({
      where: { id: params.id },
      include: {
        fileTags: { include: { tag: true } },
      },
    });

    // BigInt를 String으로 변환
    const serializedFile = updatedFile ? {
      ...updatedFile,
      size: updatedFile.size.toString(),
    } : null;

    return NextResponse.json(
      { message: "태그가 추가되었습니다", tag, file: serializedFile },
      { status: 201 }
    );
  } catch (error) {
    console.error("Tag POST error:", error);
    return NextResponse.json(
      { error: "태그 추가 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}

// 파일 태그 삭제
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
    }

    const body = await request.json();
    const { tagId } = body;

    if (!tagId) {
      return NextResponse.json(
        { error: "tagId를 제공하세요" },
        { status: 400 }
      );
    }

    // 파일 확인 + 소유자 확인
    const file = await prisma.file.findUnique({ where: { id: params.id } });
    if (!file) {
      return NextResponse.json(
        { error: "파일을 찾을 수 없습니다" },
        { status: 404 }
      );
    }
    if (file.userId !== session.user.id) {
      return NextResponse.json(
        { error: "태그를 삭제할 권한이 없습니다" },
        { status: 403 }
      );
    }

    // 파일-태그 연결 삭제
    await prisma.fileTag.delete({
      where: {
        fileId_tagId: { fileId: params.id, tagId },
      },
    });

    // 업데이트된 파일 반환
    const updatedFile = await prisma.file.findUnique({
      where: { id: params.id },
      include: {
        fileTags: { include: { tag: true } },
      },
    });

    // BigInt를 String으로 변환
    const serializedFile = updatedFile ? {
      ...updatedFile,
      size: updatedFile.size.toString(),
    } : null;

    return NextResponse.json({
      message: "태그가 삭제되었습니다",
      file: serializedFile,
    });
  } catch (error) {
    console.error("Tag DELETE error:", error);
    return NextResponse.json(
      { error: "태그 삭제 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/files/thumbnail/[filename]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { readFile } from "fs/promises";
import { join } from "path";
import { existsSync } from "fs";

const STORAGE_PATH = process.env.STORAGE_PATH || "./storage";

export async function GET(
  request: NextRequest,
  { params }: { params: { filename: string } }
) {
  try {
    const thumbnailPath = join(STORAGE_PATH, "thumbnails", params.filename);

    if (!existsSync(thumbnailPath)) {
      return NextResponse.json(
        { error: "썸네일을 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    const fileBuffer = await readFile(thumbnailPath);

    return new NextResponse(fileBuffer, {
      headers: {
        "Content-Type": "image/jpeg",
        "Cache-Control": "public, max-age=31536000, immutable",
      },
    });
  } catch (error) {
    console.error("Thumbnail serve error:", error);
    return NextResponse.json(
      { error: "썸네일 로딩 실패" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/files/upload/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import { writeFile, mkdir } from "fs/promises";
import { existsSync } from "fs";
import { join } from "path";
import crypto from "crypto";
import sharp from "sharp";

const STORAGE_PATH = process.env.STORAGE_PATH || "./storage";
const MAX_FILE_SIZE = parseInt(process.env.NEXT_PUBLIC_MAX_FILE_SIZE || "52428800"); // 50MB

export async function POST(request: NextRequest) {
  try {
    // 1. 세션 확인
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
    }

    const formData = await request.formData();
    const file = formData.get("file") as File;
    const folderId = formData.get("folderId") as string | null;

    // 2. 파일 유효성 검사
    if (!file) {
      return NextResponse.json({ error: "파일을 선택해주세요" }, { status: 400 });
    }

    if (file.size > MAX_FILE_SIZE) {
      return NextResponse.json(
        { error: `파일 크기는 ${MAX_FILE_SIZE / (1024 * 1024)}MB를 초과할 수 없습니다` },
        { status: 400 }
      );
    }

    // 3. 파일 해시 생성 (중복 체크용)
    const bytes = await file.arrayBuffer();
    const buffer = Buffer.from(bytes);
    const fileHash = crypto.createHash("sha256").update(buffer).digest("hex");

    /**
     * 4. 시스템 전체 중복 확인 (Hash 기반)
     * DB의 hash 필드에 @unique 제약조건이 있으므로, 
     * 다른 유저가 올린 파일이라도 해시가 같으면 create 시 에러가 발생합니다.
     */
    const existingFile = await prisma.file.findFirst({
      where: { hash: fileHash },
    });

    if (existingFile) {
      const isMine = existingFile.userId === session.user.id;
      return NextResponse.json(
        { 
          error: isMine 
            ? "이미 내 보관함에 동일한 파일이 존재합니다." 
            : "이미 시스템에 등록된 동일한 내용의 파일입니다.",
          existingFile: { id: existingFile.id, originalName: existingFile.originalName } 
        },
        { status: 409 } // Conflict
      );
    }

    // 5. 고유 파일명 및 경로 설정
    const fileExtension = file.name.split(".").pop() || "bin";
    const uniqueFilename = `${crypto.randomUUID()}.${fileExtension}`;

    const uploadDir = join(STORAGE_PATH, "files");
    const thumbnailDir = join(STORAGE_PATH, "thumbnails");
    
    if (!existsSync(uploadDir)) await mkdir(uploadDir, { recursive: true });
    if (!existsSync(thumbnailDir)) await mkdir(thumbnailDir, { recursive: true });

    // 6. 물리 파일 저장
    const filepath = join(uploadDir, uniqueFilename);
    await writeFile(filepath, buffer);

    // 7. 썸네일 생성 (이미지인 경우만)
    let thumbnailUrl: string | null = null;
    if (file.type.startsWith("image/")) {
      try {
        const thumbnailFilename = `thumb_${uniqueFilename.replace(/\.\w+$/, ".jpg")}`;
        const thumbnailPath = join(thumbnailDir, thumbnailFilename);
        
        await sharp(buffer)
          .resize(300, 300, { fit: "cover", position: "center" })
          .jpeg({ quality: 80 })
          .toFile(thumbnailPath);
        
        thumbnailUrl = `/api/files/thumbnail/${thumbnailFilename}`;
      } catch (err) {
        console.error("Thumbnail generation failed:", err);
        // 썸네일 실패는 파일 업로드 자체를 중단시키지 않음
      }
    }

    /**
     * 8. DB 저장 및 최종 중복 에러 핸들링
     * findFirst 이후 create 직전에 다른 요청이 들어올 경우를 대비해 
     * Prisma의 P2002(Unique 제약 위반) 에러를 Catch합니다.
     */
    try {
      const savedFile = await prisma.file.create({
        data: {
          filename: uniqueFilename,
          originalName: file.name,
          filepath: filepath,
          size: BigInt(file.size),
          mimeType: file.type,
          hash: fileHash,
          thumbnailUrl,
          userId: session.user.id,
          folderId: folderId || null,
        },
      });

      return NextResponse.json(
        {
          message: "파일이 업로드되었습니다",
          file: {
            id: savedFile.id,
            filename: savedFile.filename,
            originalName: savedFile.originalName,
            size: savedFile.size.toString(),
            mimeType: savedFile.mimeType,
            thumbnailUrl: savedFile.thumbnailUrl,
            createdAt: savedFile.createdAt,
          },
        },
        { status: 201 }
      );
    } catch (dbError: any) {
      if (dbError.code === "P2002") {
        return NextResponse.json(
          { error: "이미 존재하는 파일입니다(중복 데이터)." },
          { status: 409 }
        );
      }
      throw dbError; // 다른 DB 오류는 외부 catch 블록에서 처리
    }

  } catch (error) {
    console.error("File upload error:", error);
    return NextResponse.json(
      { error: "파일 업로드 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/folders/[id]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// 폴더 상세 조회
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const folderId = params.id;

    const folder = await prisma.folder.findUnique({
      where: { id: folderId },
      include: {
        _count: {
          select: {
            children: true,
            files: true,
          },
        },
        parent: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

    if (!folder) {
      return NextResponse.json(
        { error: "폴더를 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    if (folder.userId !== session.user.id) {
      return NextResponse.json(
        { error: "권한이 없습니다" },
        { status: 403 }
      );
    }

    return NextResponse.json({ folder });

  } catch (error) {
    console.error("Folder fetch error:", error);
    return NextResponse.json(
      { error: "폴더 조회 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}

// 폴더 수정 (이름 변경)
export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const folderId = params.id;
    const body = await request.json();
    const { name, color, icon } = body;

    const folder = await prisma.folder.findUnique({
      where: { id: folderId },
    });

    if (!folder) {
      return NextResponse.json(
        { error: "폴더를 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    if (folder.userId !== session.user.id) {
      return NextResponse.json(
        { error: "권한이 없습니다" },
        { status: 403 }
      );
    }

    // 이름 변경 시 중복 확인
    if (name && name !== folder.name) {
      const existingFolder = await prisma.folder.findFirst({
        where: {
          userId: session.user.id,
          parentId: folder.parentId,
          name: name.trim(),
          id: { not: folderId },
        },
      });

      if (existingFolder) {
        return NextResponse.json(
          { error: "같은 이름의 폴더가 이미 존재합니다" },
          { status: 409 }
        );
      }
    }

    // 폴더 수정
    const updatedFolder = await prisma.folder.update({
      where: { id: folderId },
      data: {
        name: name?.trim() || folder.name,
        color: color !== undefined ? color : folder.color,
        icon: icon !== undefined ? icon : folder.icon,
      },
      include: {
        _count: {
          select: {
            children: true,
            files: true,
          },
        },
      },
    });

    return NextResponse.json({
      message: "폴더가 수정되었습니다",
      folder: updatedFolder,
    });

  } catch (error) {
    console.error("Folder update error:", error);
    return NextResponse.json(
      { error: "폴더 수정 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}

// 폴더 삭제
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const folderId = params.id;

    const folder = await prisma.folder.findUnique({
      where: { id: folderId },
      include: {
        _count: {
          select: {
            children: true,
            files: true,
          },
        },
      },
    });

    if (!folder) {
      return NextResponse.json(
        { error: "폴더를 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    if (folder.userId !== session.user.id) {
      return NextResponse.json(
        { error: "권한이 없습니다" },
        { status: 403 }
      );
    }

    // 하위 폴더나 파일이 있으면 경고
    if (folder._count.children > 0 || folder._count.files > 0) {
      return NextResponse.json(
        { 
          error: "폴더가 비어있지 않습니다",
          info: `하위 폴더 ${folder._count.children}개, 파일 ${folder._count.files}개`
        },
        { status: 400 }
      );
    }

    // 폴더 삭제
    await prisma.folder.delete({
      where: { id: folderId },
    });

    return NextResponse.json({
      message: "폴더가 삭제되었습니다",
    });

  } catch (error) {
    console.error("Folder delete error:", error);
    return NextResponse.json(
      { error: "폴더 삭제 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/folders/[id]/share/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// 폴더 공유 생성
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const folderId = params.id;
    const body = await request.json();
    const { sharedWithEmail, permission = "VIEW" } = body;

    if (!sharedWithEmail) {
      return NextResponse.json(
        { error: "공유할 사용자 이메일을 입력하세요" },
        { status: 400 }
      );
    }

    // 폴더 확인
    const folder = await prisma.folder.findUnique({
      where: { id: folderId },
    });

    if (!folder) {
      return NextResponse.json(
        { error: "폴더를 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    // 소유자 확인
    if (folder.userId !== session.user.id) {
      return NextResponse.json(
        { error: "폴더 소유자만 공유할 수 있습니다" },
        { status: 403 }
      );
    }

    // 공유 대상 사용자 확인
    const sharedWithUser = await prisma.user.findUnique({
      where: { email: sharedWithEmail },
    });

    if (!sharedWithUser) {
      return NextResponse.json(
        { error: "해당 이메일의 사용자를 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    // 본인에게 공유 방지
    if (sharedWithUser.id === session.user.id) {
      return NextResponse.json(
        { error: "본인에게는 공유할 수 없습니다" },
        { status: 400 }
      );
    }

    // 이미 공유된 경우 확인
    const existingShare = await prisma.sharedResource.findFirst({
      where: {
        resourceType: "FOLDER",
        resourceId: folderId,
        sharedWithId: sharedWithUser.id,
      },
    });

    if (existingShare) {
      return NextResponse.json(
        { error: "이미 공유된 폴더입니다" },
        { status: 409 }
      );
    }

    // 공유 생성
    const share = await prisma.sharedResource.create({
      data: {
        resourceType: "FOLDER",
        resourceId: folderId,
        ownerId: session.user.id,
        sharedWithId: sharedWithUser.id,
        permission,
      },
    });

    // 공유 대상 정보 수동 조회
    const shareWithUser = await prisma.user.findUnique({
      where: { id: share.sharedWithId },
      select: {
        id: true,
        email: true,
        name: true,
      },
    });

    return NextResponse.json(
      {
        message: "폴더가 공유되었습니다",
        share: {
          ...share,
          sharedWith: shareWithUser,
        },
      },
      { status: 201 }
    );

  } catch (error) {
    console.error("Folder share error:", error);
    return NextResponse.json(
      { error: "폴더 공유 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}

// 폴더 공유 목록 조회
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const folderId = params.id;

    // 폴더 확인
    const folder = await prisma.folder.findUnique({
      where: { id: folderId },
    });

    if (!folder) {
      return NextResponse.json(
        { error: "폴더를 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    if (folder.userId !== session.user.id) {
      return NextResponse.json(
        { error: "권한이 없습니다" },
        { status: 403 }
      );
    }

    // 공유 목록 조회
    const shares = await prisma.sharedResource.findMany({
      where: {
        resourceType: "FOLDER",
        resourceId: folderId,
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    // 각 공유의 사용자 정보 수동 조회
    const sharesWithUsers = await Promise.all(
      shares.map(async (share: any) => {
        const sharedWith = await prisma.user.findUnique({
          where: { id: share.sharedWithId },
          select: {
            id: true,
            email: true,
            name: true,
          },
        });

        return {
          ...share,
          sharedWith,
        };
      })
    );

    return NextResponse.json({ shares: sharesWithUsers });

  } catch (error) {
    console.error("Share list error:", error);
    return NextResponse.json(
      { error: "공유 목록 조회 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}

// 공유 삭제
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const shareId = searchParams.get("shareId");

    if (!shareId) {
      return NextResponse.json(
        { error: "공유 ID가 필요합니다" },
        { status: 400 }
      );
    }

    // 공유 확인
    const share = await prisma.sharedResource.findUnique({
      where: { id: shareId },
    });

    if (!share) {
      return NextResponse.json(
        { error: "공유 정보를 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    // 소유자 확인
    if (share.ownerId !== session.user.id) {
      return NextResponse.json(
        { error: "권한이 없습니다" },
        { status: 403 }
      );
    }

    // 공유 삭제
    await prisma.sharedResource.delete({
      where: { id: shareId },
    });

    return NextResponse.json({
      message: "공유가 취소되었습니다",
    });

  } catch (error) {
    console.error("Share delete error:", error);
    return NextResponse.json(
      { error: "공유 취소 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/folders/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// 폴더 및 파일 목록 조회
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const parentId = searchParams.get("parentId");

    // 특정 폴더의 하위 폴더 목록 조회
    const folders = await prisma.folder.findMany({
      where: {
        userId: session.user.id,
        parentId: parentId || null,
      },
      orderBy: {
        name: "asc",
      },
      include: {
        _count: {
          select: {
            children: true,
            files: true,
          },
        },
      },
    });

    // 특정 폴더 내의 파일 목록 조회
    const files = await prisma.file.findMany({
      where: {
        userId: session.user.id,
        folderId: parentId || null,
      },
      orderBy: {
        originalName: "asc",
      },
      select: {
        id: true,
        filename: true,
        originalName: true,
        size: true,
        mimeType: true,
        thumbnailUrl: true,
        createdAt: true,
        updatedAt: true,
      },
    });

    // BigInt 타입인 size를 문자열로 변환하여 JSON 직렬화 에러 및 타입 에러 방지
    return NextResponse.json({
      folders,
      files: files.map((f: any) => ({
        ...f,
        size: f.size.toString(),
      })),
    });

  } catch (error) {
    console.error("Folders fetch error:", error);
    return NextResponse.json(
      { error: "폴더 조회 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}

// 폴더 생성
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { name, parentId, color, icon } = body;

    if (!name || name.trim().length === 0) {
      return NextResponse.json(
        { error: "폴더 이름을 입력하세요" },
        { status: 400 }
      );
    }

    // 부모 폴더가 지정된 경우 권한 및 존재 여부 확인
    if (parentId) {
      const parentFolder = await prisma.folder.findUnique({
        where: { id: parentId },
      });

      if (!parentFolder) {
        return NextResponse.json(
          { error: "부모 폴더를 찾을 수 없습니다" },
          { status: 404 }
        );
      }

      if (parentFolder.userId !== session.user.id) {
        return NextResponse.json(
          { error: "권한이 없습니다" },
          { status: 403 }
        );
      }
    }

    // 동일 위치 내 같은 이름의 폴더가 있는지 중복 확인
    const existingFolder = await prisma.folder.findFirst({
      where: {
        userId: session.user.id,
        parentId: parentId || null,
        name: name.trim(),
      },
    });

    if (existingFolder) {
      return NextResponse.json(
        { error: "같은 이름의 폴더가 이미 존재합니다" },
        { status: 409 }
      );
    }

    // 폴더 생성 실행
    const folder = await prisma.folder.create({
      data: {
        name: name.trim(),
        parentId: parentId || null,
        userId: session.user.id,
        color: color || null,
        icon: icon || null,
      },
      include: {
        _count: {
          select: {
            children: true,
            files: true,
          },
        },
      },
    });

    return NextResponse.json(
      {
        message: "폴더가 생성되었습니다",
        folder,
      },
      { status: 201 }
    );

  } catch (error) {
    console.error("Folder create error:", error);
    return NextResponse.json(
      { error: "폴더 생성 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/posts/[id]/comments/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// 댓글 작성
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const postId = params.id;
    const body = await request.json();
    const { content } = body;

    if (!content || content.trim() === "") {
      return NextResponse.json(
        { error: "댓글 내용을 입력하세요" },
        { status: 400 }
      );
    }

    // 게시글 존재 확인
    const post = await prisma.post.findUnique({
      where: { id: postId },
    });

    if (!post) {
      return NextResponse.json(
        { error: "게시글을 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    // 댓글 작성
    const comment = await prisma.comment.create({
      data: {
        content,
        postId,
        userId: session.user.id,
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

    return NextResponse.json(
      {
        message: "댓글이 작성되었습니다",
        comment,
      },
      { status: 201 }
    );

  } catch (error) {
    console.error("Comment create error:", error);
    return NextResponse.json(
      { error: "댓글 작성 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/posts/[id]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// 게시글 상세 조회
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const postId = params.id;

    const post = await prisma.post.findUnique({
      where: { id: postId },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
        comments: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
              },
            },
          },
          orderBy: {
            createdAt: "asc",
          },
        },
      },
    });

    if (!post) {
      return NextResponse.json(
        { error: "게시글을 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    // 권한 확인
    const isOwner = post.userId === session.user.id;
    const isPublic = post.visibility === "PUBLIC";

    // 공유 확인
    let isShared = false;
    if (!isOwner && !isPublic && post.visibility === "SHARED") {
      const shareCheck = await prisma.sharedResource.findFirst({
        where: {
          resourceType: "POST",
          resourceId: postId,
          sharedWithId: session.user.id,
        },
      });
      isShared = !!shareCheck;
    }

    // 접근 권한 확인
    const canView = isOwner || isPublic || isShared;

    console.log("=== 게시글 접근 확인 ===");
    console.log("사용자 ID:", session.user.id);
    console.log("게시글 소유자:", post.userId);
    console.log("공개 설정:", post.visibility);
    console.log("소유자:", isOwner);
    console.log("공개 글:", isPublic);
    console.log("공유받음:", isShared);
    console.log("접근 가능:", canView);

    if (!canView) {
      return NextResponse.json(
        { error: "접근 권한이 없습니다" },
        { status: 403 }
      );
    }

    return NextResponse.json({ post });

  } catch (error) {
    console.error("Post fetch error:", error);
    return NextResponse.json(
      { error: "게시글 조회 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}

// 게시글 수정
export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const postId = params.id;
    const body = await request.json();

    const post = await prisma.post.findUnique({
      where: { id: postId },
    });

    if (!post) {
      return NextResponse.json(
        { error: "게시글을 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    if (post.userId !== session.user.id) {
      return NextResponse.json(
        { error: "수정 권한이 없습니다" },
        { status: 403 }
      );
    }

    const updatedPost = await prisma.post.update({
      where: { id: postId },
      data: {
        title: body.title,
        content: body.content,
        visibility: body.visibility,
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

    return NextResponse.json({
      message: "게시글이 수정되었습니다",
      post: updatedPost,
    });

  } catch (error) {
    console.error("Post update error:", error);
    return NextResponse.json(
      { error: "게시글 수정 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}

// 게시글 삭제
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const postId = params.id;

    const post = await prisma.post.findUnique({
      where: { id: postId },
    });

    if (!post) {
      return NextResponse.json(
        { error: "게시글을 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    if (post.userId !== session.user.id) {
      return NextResponse.json(
        { error: "삭제 권한이 없습니다" },
        { status: 403 }
      );
    }

    await prisma.post.delete({
      where: { id: postId },
    });

    return NextResponse.json({
      message: "게시글이 삭제되었습니다",
    });

  } catch (error) {
    console.error("Post delete error:", error);
    return NextResponse.json(
      { error: "게시글 삭제 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/posts/[id]/tags/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// 게시글의 태그 목록 조회
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const postId = params.id;

    // 게시글 확인
    const post = await prisma.post.findUnique({
      where: { id: postId },
    });

    if (!post) {
      return NextResponse.json(
        { error: "게시글을 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    // 태그 조회
    const postTags = await prisma.postTag.findMany({
      where: { postId },
      include: {
        tag: true,
      },
    });

    return NextResponse.json({
      tags: postTags.map((pt) => pt.tag),
    });
  } catch (error) {
    console.error("Post tags fetch error:", error);
    return NextResponse.json(
      { error: "태그 조회 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}

// 게시글에 태그 추가
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const postId = params.id;
    const body = await request.json();
    const { tagName } = body;

    if (!tagName) {
      return NextResponse.json(
        { error: "태그 이름을 입력하세요" },
        { status: 400 }
      );
    }

    // 게시글 확인
    const post = await prisma.post.findUnique({
      where: { id: postId },
    });

    if (!post) {
      return NextResponse.json(
        { error: "게시글을 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    if (post.userId !== session.user.id) {
      return NextResponse.json(
        { error: "권한이 없습니다" },
        { status: 403 }
      );
    }

    // 태그 찾기 또는 생성
    let tag = await prisma.tag.findUnique({
      where: { name: tagName.trim().toLowerCase() },
    });

    if (!tag) {
      tag = await prisma.tag.create({
        data: { name: tagName.trim().toLowerCase() },
      });
    }

    // 이미 추가된 태그인지 확인
    const existingPostTag = await prisma.postTag.findUnique({
      where: {
        postId_tagId: {
          postId,
          tagId: tag.id,
        },
      },
    });

    if (existingPostTag) {
      return NextResponse.json(
        { error: "이미 추가된 태그입니다" },
        { status: 409 }
      );
    }

    // 태그 추가
    await prisma.postTag.create({
      data: {
        postId,
        tagId: tag.id,
      },
    });

    return NextResponse.json(
      {
        message: "태그가 추가되었습니다",
        tag,
      },
      { status: 201 }
    );
  } catch (error) {
    console.error("Post tag add error:", error);
    return NextResponse.json(
      { error: "태그 추가 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}

// 게시글에서 태그 제거
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const postId = params.id;
    const { searchParams } = new URL(request.url);
    const tagId = searchParams.get("tagId");

    if (!tagId) {
      return NextResponse.json(
        { error: "태그 ID가 필요합니다" },
        { status: 400 }
      );
    }

    // 게시글 확인
    const post = await prisma.post.findUnique({
      where: { id: postId },
    });

    if (!post) {
      return NextResponse.json(
        { error: "게시글을 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    if (post.userId !== session.user.id) {
      return NextResponse.json(
        { error: "권한이 없습니다" },
        { status: 403 }
      );
    }

    // 태그 제거
    await prisma.postTag.delete({
      where: {
        postId_tagId: {
          postId,
          tagId,
        },
      },
    });

    return NextResponse.json({
      message: "태그가 제거되었습니다",
    });
  } catch (error) {
    console.error("Post tag remove error:", error);
    return NextResponse.json(
      { error: "태그 제거 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/posts/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import { z } from "zod";

const postSchema = z.object({
  title: z.string().min(1, "제목을 입력하세요").max(200),
  content: z.string().min(1, "내용을 입력하세요"),
  visibility: z.enum(["PRIVATE", "SHARED", "PUBLIC"]).optional(),
});

// 게시글 목록 조회
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get("page") || "1");
    const limit = parseInt(searchParams.get("limit") || "20");
    const visibility = searchParams.get("visibility");
    const search = searchParams.get("search") || "";

    const skip = (page - 1) * limit;

    // 1. 나에게 공유된 게시글 ID 목록
    const sharedPosts = await prisma.sharedResource.findMany({
      where: {
        resourceType: "POST",
        sharedWithId: session.user.id,
      },
      select: {
        resourceId: true,
      },
    });

    const sharedPostIds = sharedPosts.map((sr) => sr.resourceId);

    // 2. 조회 조건 구성
    let where: any = {};
    
    if (visibility === "my") {
      // 내 글만
      where.userId = session.user.id;
    } else if (visibility === "public") {
      // 공개 글만
      where.visibility = "PUBLIC";
    } else if (visibility === "shared") {
      // 나에게 공유된 글만
      where.id = { in: sharedPostIds };
    } else {
      // 전체 (기본)
      where.OR = [
        { userId: session.user.id },           // 내가 작성한 글
        { visibility: "PUBLIC" },              // 공개 글
        { id: { in: sharedPostIds } },         // 나에게 공유된 글
      ];
    }

    // 검색어 필터
    if (search) {
      const searchCondition = {
        OR: [
          { title: { contains: search, mode: "insensitive" } },
          { content: { contains: search, mode: "insensitive" } },
        ],
      };

      if (where.OR) {
        where.AND = [
          { OR: where.OR },
          searchCondition,
        ];
        delete where.OR;
      } else {
        where.AND = [searchCondition];
      }
    }

    const [posts, total] = await Promise.all([
      prisma.post.findMany({
        where,
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true,
            },
          },
          _count: {
            select: {
              comments: true,
            },
          },
        },
        orderBy: { createdAt: "desc" },
        skip,
        take: limit,
      }),
      prisma.post.count({ where }),
    ]);

    // 3. 각 게시글에 공유 정보 추가
    const postsWithShareInfo = await Promise.all(
      posts.map(async (post) => {
        const isShared = sharedPostIds.includes(post.id);
        let sharedBy = null;

        if (isShared && post.userId !== session.user.id) {
          // 공유받은 게시글인 경우 공유자 정보 조회
          const shareInfo = await prisma.sharedResource.findFirst({
            where: {
              resourceType: "POST",
              resourceId: post.id,
              sharedWithId: session.user.id,
            },
            include: {
              owner: {
                select: {
                  id: true,
                  name: true,
                  email: true,
                },
              },
            },
          });

          if (shareInfo) {
            sharedBy = shareInfo.owner.name;
          }
        }

        return {
          ...post,
          isOwner: post.userId === session.user.id,
          isShared: isShared && post.userId !== session.user.id,
          sharedBy,
        };
      })
    );

    return NextResponse.json({
      posts: postsWithShareInfo,
      pagination: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    });

  } catch (error) {
    console.error("Posts fetch error:", error);
    return NextResponse.json(
      { error: "게시글 조회 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}

// 게시글 생성
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const body = await request.json();
    const validation = postSchema.safeParse(body);

    if (!validation.success) {
      return NextResponse.json(
        { error: validation.error.errors[0].message },
        { status: 400 }
      );
    }

    const { title, content, visibility = "PRIVATE" } = validation.data;

    const post = await prisma.post.create({
      data: {
        title,
        content,
        visibility,
        userId: session.user.id,
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
      },
    });

    return NextResponse.json(
      {
        message: "게시글이 작성되었습니다",
        post,
      },
      { status: 201 }
    );

  } catch (error) {
    console.error("Post create error:", error);
    return NextResponse.json(
      { error: "게시글 작성 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/saved-searches/[id]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// 저장된 검색 삭제
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const searchId = params.id;

    const savedSearch = await prisma.savedSearch.findUnique({
      where: { id: searchId },
    });

    if (!savedSearch) {
      return NextResponse.json(
        { error: "저장된 검색을 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    if (savedSearch.userId !== session.user.id) {
      return NextResponse.json(
        { error: "권한이 없습니다" },
        { status: 403 }
      );
    }

    await prisma.savedSearch.delete({
      where: { id: searchId },
    });

    return NextResponse.json({
      message: "저장된 검색이 삭제되었습니다",
    });
  } catch (error) {
    console.error("Saved search delete error:", error);
    return NextResponse.json(
      { error: "삭제 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/saved-searches/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// 저장된 검색 목록
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const savedSearches = await prisma.savedSearch.findMany({
      where: {
        userId: session.user.id,
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    return NextResponse.json({ savedSearches });
  } catch (error) {
    console.error("Saved searches fetch error:", error);
    return NextResponse.json(
      { error: "저장된 검색 조회 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}

// 검색 저장
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { name, query } = body;

    if (!name || !query) {
      return NextResponse.json(
        { error: "이름과 검색 조건을 입력하세요" },
        { status: 400 }
      );
    }

    const savedSearch = await prisma.savedSearch.create({
      data: {
        name,
        query,
        userId: session.user.id,
      },
    });

    return NextResponse.json(
      {
        message: "검색이 저장되었습니다",
        savedSearch,
      },
      { status: 201 }
    );
  } catch (error) {
    console.error("Save search error:", error);
    return NextResponse.json(
      { error: "검색 저장 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/search/route.ts">
export const dynamic = 'force-dynamic';

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const q = searchParams.get("q") || "";
    const type = searchParams.get("type") || "ALL";       // ALL | FILE | POST
    const mimeType = searchParams.get("mimeType") || "";   // image | video | pdf | document | zip
    const tagsParam = searchParams.get("tags") || "";       // "tagId1,tagId2"
    const dateFrom = searchParams.get("dateFrom") || "";
    const dateTo = searchParams.get("dateTo") || "";

    const tagIds = tagsParam ? tagsParam.split(",").filter(Boolean) : [];

    let files: any[] = [];
    let posts: any[] = [];

    // ===== 파일 검색 =====
    if (type === "ALL" || type === "FILE") {
      const fileWhere: any = {
        userId: session.user.id,
      };

      // 키워드
      if (q.trim()) {
        fileWhere.originalName = {
          contains: q.trim(),
          mode: "insensitive",
        };
      }

      // MIME 타입 필터
      if (mimeType) {
        const mimeMap: Record<string, any> = {
          image: { startsWith: "image/" },
          video: { startsWith: "video/" },
          pdf: { equals: "application/pdf" },
          document: {
            in: [
              "application/msword",
              "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
              "application/vnd.ms-excel",
              "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
              "application/vnd.ms-powerpoint",
              "application/vnd.openxmlformats-officedocument.presentationml.presentation",
              "text/plain",
            ],
          },
          zip: {
            in: [
              "application/zip",
              "application/x-rar-compressed",
              "application/x-7z-compressed",
            ],
          },
        };

        if (mimeMap[mimeType]) {
          fileWhere.mimeType = mimeMap[mimeType];
        }
      }

      // 날짜 필터
      if (dateFrom || dateTo) {
        fileWhere.createdAt = {};
        if (dateFrom) fileWhere.createdAt.gte = new Date(dateFrom);
        if (dateTo) {
          const to = new Date(dateTo);
          to.setHours(23, 59, 59, 999);
          fileWhere.createdAt.lte = to;
        }
      }

      // 태그 필터
      if (tagIds.length > 0) {
        fileWhere.fileTags = {
          some: {
            tagId: { in: tagIds },
          },
        };
      }

      files = await prisma.file.findMany({
        where: fileWhere,
        include: {
          fileTags: {
            include: { tag: true },
          },
        },
        orderBy: { createdAt: "desc" },
        take: 50,
      });

      // BigInt 직렬화
      files = files.map(file => ({
        ...file,
        size: file.size.toString(),
      }));
    }

    // ===== 게시글 검색 =====
    if (type === "ALL" || type === "POST") {
      // 먼저 공유받은 게시글 ID 목록 조회
      const sharedPostIds = await prisma.sharedResource.findMany({
        where: {
          resourceType: "POST",
          sharedWithId: session.user.id,
        },
        select: { resourceId: true },
      });

      const postWhere: any = {
        OR: [
          { userId: session.user.id },
          { visibility: "PUBLIC" },
          {
            visibility: "SHARED",
            id: { in: sharedPostIds.map(sr => sr.resourceId) },
          },
        ],
      };

      // 키워드
      if (q.trim()) {
        postWhere.AND = [
          {
            OR: [
              { title: { contains: q.trim(), mode: "insensitive" } },
              { content: { contains: q.trim(), mode: "insensitive" } },
            ],
          },
        ];
      }

      // 날짜 필터
      if (dateFrom || dateTo) {
        const dateFilter: any = {};
        if (dateFrom) dateFilter.gte = new Date(dateFrom);
        if (dateTo) {
          const to = new Date(dateTo);
          to.setHours(23, 59, 59, 999);
          dateFilter.lte = to;
        }

        if (postWhere.AND) {
          postWhere.AND.push({ createdAt: dateFilter });
        } else {
          postWhere.AND = [{ createdAt: dateFilter }];
        }
      }

      // 태그 필터
      if (tagIds.length > 0) {
        const tagFilter = {
          postTags: { some: { tagId: { in: tagIds } } },
        };
        if (postWhere.AND) {
          postWhere.AND.push(tagFilter);
        } else {
          postWhere.AND = [tagFilter];
        }
      }

      posts = await prisma.post.findMany({
        where: postWhere,
        include: {
          user: { select: { id: true, name: true } },
          postTags: { include: { tag: true } },
          _count: { select: { comments: true } },
        },
        orderBy: { createdAt: "desc" },
        take: 50,
      });
    }

    return NextResponse.json({
      files,
      posts,
      total: files.length + posts.length,
      query: q,
      filters: { type, mimeType, tagIds, dateFrom, dateTo },
    });
  } catch (error) {
    console.error("Search error:", error);
    return NextResponse.json(
      { error: "검색 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/tags/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// 태그 목록 조회
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const search = searchParams.get("search") || "";

    // 모든 태그 조회 (사용 횟수 포함)
    const tags = await prisma.tag.findMany({
      where: search
        ? {
            name: {
              contains: search,
              mode: "insensitive",
            },
          }
        : {},
      include: {
        _count: {
          select: {
            fileTags: true,
            postTags: true,
          },
        },
      },
      orderBy: {
        name: "asc",
      },
    });

    return NextResponse.json({
      tags: tags.map((tag) => ({
        ...tag,
        usageCount: tag._count.fileTags + tag._count.postTags,
      })),
    });
  } catch (error) {
    console.error("Tags fetch error:", error);
    return NextResponse.json(
      { error: "태그 조회 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}

// 태그 생성
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { name, color } = body;

    if (!name || name.trim().length === 0) {
      return NextResponse.json(
        { error: "태그 이름을 입력하세요" },
        { status: 400 }
      );
    }

    // 중복 확인
    const existingTag = await prisma.tag.findUnique({
      where: { name: name.trim().toLowerCase() },
    });

    if (existingTag) {
      return NextResponse.json(
        { error: "이미 존재하는 태그입니다", tag: existingTag },
        { status: 409 }
      );
    }

    // 태그 생성
    const tag = await prisma.tag.create({
      data: {
        name: name.trim().toLowerCase(),
        color: color || null,
      },
    });

    return NextResponse.json(
      {
        message: "태그가 생성되었습니다",
        tag,
      },
      { status: 201 }
    );
  } catch (error) {
    console.error("Tag create error:", error);
    return NextResponse.json(
      { error: "태그 생성 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/users/fcm-token/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// FCM 토큰 등록
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { fcmToken } = body;

    if (!fcmToken) {
      return NextResponse.json(
        { error: "FCM 토큰을 제공하세요" },
        { status: 400 }
      );
    }

    // 토큰 저장
    await prisma.user.update({
      where: { id: session.user.id },
      data: { fcmToken },
    });

    return NextResponse.json({
      message: "FCM 토큰이 등록되었습니다",
    });
  } catch (error) {
    console.error("FCM token registration error:", error);
    return NextResponse.json(
      { error: "토큰 등록 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}

// FCM 토큰 삭제 (로그아웃 시)
export async function DELETE(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    await prisma.user.update({
      where: { id: session.user.id },
      data: { fcmToken: null },
    });

    return NextResponse.json({
      message: "FCM 토큰이 삭제되었습니다",
    });
  } catch (error) {
    console.error("FCM token deletion error:", error);
    return NextResponse.json(
      { error: "토큰 삭제 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/users/presence/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// 온라인 상태 업데이트
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { isOnline, networkType } = body;

    await prisma.user.update({
      where: { id: session.user.id },
      data: {
        isOnline: isOnline !== undefined ? isOnline : true,
        lastSeenAt: new Date(),
        networkType: networkType || "WIFI",
      },
    });

    return NextResponse.json({
      message: "온라인 상태가 업데이트되었습니다",
    });
  } catch (error) {
    console.error("Presence update error:", error);
    return NextResponse.json(
      { error: "상태 업데이트 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/chat/page.tsx">
"use client";

import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import { useEffect, useState, useCallback } from "react";
import Link from "next/link";
import { useSocket } from "@/hooks/useSocket";
import { toast } from "@/components/Toast";

interface ChatRoom {
  id: string;
  name: string | null;
  type: "DIRECT" | "GROUP";
  members: any[];
  messages: any[];
  unreadCount: number;
  updatedAt: string;
}

export default function ChatPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const { socket, isConnected } = useSocket();

  const [chatRooms, setChatRooms] = useState<ChatRoom[]>([]);
  const [loading, setLoading] = useState(true);
  const [showNewChatModal, setShowNewChatModal] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [searchResults, setSearchResults] = useState<any[]>([]);
  const [isSearching, setIsSearching] = useState(false);
  const [isCreating, setIsCreating] = useState(false);

  useEffect(() => {
    if (status === "unauthenticated") router.push("/login");
  }, [status, router]);

  const fetchChatRooms = useCallback(async () => {
    try {
      const res = await fetch("/api/chat/rooms");
      if (res.ok) {
        const data = await res.json();
        setChatRooms(data.chatRooms || []);
      }
    } catch (err) {
      console.error("채팅방 목록 로드 실패:", err);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    if (session) fetchChatRooms();
  }, [session, fetchChatRooms]);

  // ✅ 실시간: 다른 채팅방에서 새 메시지 오면 목록 순서/미리보기 갱신
  useEffect(() => {
    if (!socket) return;

    const handleNewMessage = (data: any) => {
      setChatRooms((prev) => {
        const roomIndex = prev.findIndex((r) => r.id === data.chatRoomId);
        if (roomIndex === -1) return prev;

        const updated = [...prev];
        const room = { ...updated[roomIndex] };

        // 마지막 메시지 업데이트
        room.messages = [data];
        room.updatedAt = data.createdAt || new Date().toISOString();

        // 내가 보낸 메시지가 아니면 unread 증가
        if (data.senderId !== session?.user?.id) {
          room.unreadCount = (room.unreadCount || 0) + 1;
        }

        // 해당 방을 맨 위로 올리기
        updated.splice(roomIndex, 1);
        return [room, ...updated];
      });
    };

    socket.on("message:receive", handleNewMessage);
    socket.on("message:new", handleNewMessage);

    return () => {
      socket.off("message:receive", handleNewMessage);
      socket.off("message:new", handleNewMessage);
    };
  }, [socket, session?.user?.id]);

  const searchUsers = async () => {
    if (!searchQuery.trim()) return;
    setIsSearching(true);
    try {
      const res = await fetch(
        `/api/users/search?q=${encodeURIComponent(searchQuery)}`
      );
      if (res.ok) {
        const data = await res.json();
        setSearchResults(data.users || []);
        if ((data.users || []).length === 0) {
          toast.info("검색 결과가 없습니다");
        }
      }
    } catch {
      toast.error("사용자 검색에 실패했습니다");
    } finally {
      setIsSearching(false);
    }
  };

  const createChatRoom = async (otherUserId: string) => {
    setIsCreating(true);
    try {
      const res = await fetch("/api/chat/rooms", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ type: "DIRECT", memberIds: [otherUserId] }),
      });

      if (res.ok) {
        const data = await res.json();
        router.push(`/chat/${data.chatRoom.id}`);
      } else {
        // ✅ alert() → toast.error()
        toast.error("채팅방 생성에 실패했습니다");
      }
    } catch {
      toast.error("채팅방 생성 중 오류가 발생했습니다");
    } finally {
      setIsCreating(false);
    }
  };

  const closeModal = () => {
    setShowNewChatModal(false);
    setSearchResults([]);
    setSearchQuery("");
  };

  const getChatRoomName = (chatRoom: ChatRoom) => {
    if (chatRoom.type === "GROUP") return chatRoom.name || "그룹 채팅";
    const other = chatRoom.members.find(
      (m) => m.user.id !== session?.user?.id
    );
    return other?.user.name || "알 수 없음";
  };

  const getChatRoomInitial = (chatRoom: ChatRoom) => {
    return getChatRoomName(chatRoom)[0]?.toUpperCase() || "?";
  };

  const getLastMessage = (chatRoom: ChatRoom) => {
    if (!chatRoom.messages?.length) return "메시지가 없습니다";
    const last = chatRoom.messages[0];
    if (last.type === "FILE") return "📎 파일";
    if (last.type === "CALL_LOG") return "📞 통화";
    return last.content || "메시지가 없습니다";
  };

  const formatDate = (dateStr: string) => {
    const date = new Date(dateStr);
    if (isNaN(date.getTime())) return "";
    const now = new Date();
    const isToday = date.toDateString() === now.toDateString();
    if (isToday) {
      return date.toLocaleTimeString("ko-KR", {
        hour: "2-digit",
        minute: "2-digit",
      });
    }
    return date.toLocaleDateString("ko-KR", { month: "short", day: "numeric" });
  };

  if (status === "loading") {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="text-gray-400">로딩 중...</div>
      </div>
    );
  }

  if (!session) return null;

  return (
    <div className="min-h-screen bg-gray-50">
      {/* ── 헤더 ── */}
      <header className="bg-white border-b sticky top-0 z-10">
        <div className="max-w-2xl mx-auto px-4 py-4 flex justify-between items-center">
          <div className="flex items-center gap-3">
            <h1 className="text-xl font-bold text-gray-900">💬 채팅</h1>
            {/* ✅ isConnected 이제 실제로 작동 */}
            <span
              className={`w-2 h-2 rounded-full ${
                isConnected ? "bg-green-500" : "bg-gray-300"
              }`}
              title={isConnected ? "연결됨" : "연결 중..."}
            />
          </div>
          <div className="flex items-center gap-2">
            <Link
              href="/dashboard"
              className="text-sm text-gray-500 hover:text-gray-700"
            >
              ← 대시보드
            </Link>
            <button
              onClick={() => setShowNewChatModal(true)}
              className="px-3 py-1.5 bg-blue-600 text-white text-sm rounded-lg hover:bg-blue-700 font-medium"
            >
              + 새 채팅
            </button>
          </div>
        </div>
      </header>

      {/* ── 채팅방 목록 ── */}
      <main className="max-w-2xl mx-auto px-4 py-4">
        {loading ? (
          // 스켈레톤 UI
          <div className="space-y-1">
            {[1, 2, 3].map((i) => (
              <div
                key={i}
                className="bg-white rounded-xl p-4 flex gap-3 animate-pulse"
              >
                <div className="w-12 h-12 rounded-full bg-gray-200 flex-shrink-0" />
                <div className="flex-1 space-y-2 py-1">
                  <div className="h-4 bg-gray-200 rounded w-1/3" />
                  <div className="h-3 bg-gray-100 rounded w-2/3" />
                </div>
              </div>
            ))}
          </div>
        ) : chatRooms.length === 0 ? (
          <div className="text-center py-16">
            <p className="text-4xl mb-4">💬</p>
            <p className="text-gray-500 mb-4">아직 대화가 없어요</p>
            <button
              onClick={() => setShowNewChatModal(true)}
              className="px-4 py-2 bg-blue-600 text-white rounded-lg text-sm font-medium"
            >
              첫 채팅 시작하기
            </button>
          </div>
        ) : (
          <div className="space-y-1">
            {chatRooms.map((chatRoom) => (
              <Link
                key={chatRoom.id}
                href={`/chat/${chatRoom.id}`}
                className="flex items-center gap-3 bg-white hover:bg-gray-50 rounded-xl p-4 transition"
              >
                {/* 아바타 */}
                <div className="w-12 h-12 rounded-full bg-blue-100 flex items-center justify-center text-blue-600 font-bold text-lg flex-shrink-0">
                  {getChatRoomInitial(chatRoom)}
                </div>

                {/* 내용 */}
                <div className="flex-1 min-w-0">
                  <div className="flex items-center justify-between mb-0.5">
                    <span className="font-semibold text-gray-900 text-sm">
                      {getChatRoomName(chatRoom)}
                    </span>
                    <span className="text-xs text-gray-400 flex-shrink-0 ml-2">
                      {formatDate(chatRoom.updatedAt)}
                    </span>
                  </div>
                  <div className="flex items-center justify-between">
                    <p className="text-sm text-gray-500 truncate">
                      {getLastMessage(chatRoom)}
                    </p>
                    {chatRoom.unreadCount > 0 && (
                      <span className="ml-2 min-w-[20px] h-5 px-1.5 bg-blue-600 text-white text-xs rounded-full flex items-center justify-center flex-shrink-0">
                        {chatRoom.unreadCount > 99 ? "99+" : chatRoom.unreadCount}
                      </span>
                    )}
                  </div>
                </div>
              </Link>
            ))}
          </div>
        )}
      </main>

      {/* ── 새 채팅 모달 ── */}
      {showNewChatModal && (
        <div
          className="fixed inset-0 z-50 flex items-end sm:items-center justify-center bg-black/50 backdrop-blur-sm p-4"
          onClick={closeModal}
        >
          <div
            className="bg-white rounded-2xl shadow-2xl w-full max-w-md p-6"
            onClick={(e) => e.stopPropagation()}
          >
            <h3 className="text-lg font-bold mb-4 text-gray-900">
              새 채팅 시작
            </h3>

            <div className="flex gap-2 mb-4">
              <input
                type="text"
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                onKeyDown={(e) => e.key === "Enter" && searchUsers()}
                placeholder="이름 또는 이메일로 검색"
                className="flex-1 px-4 py-2.5 border border-gray-200 rounded-xl outline-none focus:border-blue-500 text-gray-900 bg-gray-50 text-sm"
                autoFocus
              />
              <button
                onClick={searchUsers}
                disabled={isSearching}
                className="px-4 py-2.5 bg-blue-600 text-white rounded-xl font-medium text-sm disabled:opacity-50"
              >
                {isSearching ? "..." : "검색"}
              </button>
            </div>

            {searchResults.length > 0 && (
              <div className="space-y-2 max-h-60 overflow-y-auto mb-4">
                {searchResults.map((user) => (
                  <button
                    key={user.id}
                    onClick={() => createChatRoom(user.id)}
                    disabled={isCreating}
                    className="w-full p-3 text-left border border-gray-100 rounded-xl hover:bg-blue-50 hover:border-blue-200 transition disabled:opacity-50"
                  >
                    <div className="flex items-center gap-3">
                      <div className="w-9 h-9 rounded-full bg-blue-100 flex items-center justify-center text-blue-600 font-bold text-sm flex-shrink-0">
                        {user.name?.[0]?.toUpperCase() || "?"}
                      </div>
                      <div className="flex-1 min-w-0">
                        <p className="font-medium text-gray-900 text-sm">
                          {user.name}
                        </p>
                        <p className="text-xs text-gray-500 truncate">
                          {user.email}
                        </p>
                      </div>
                      {user.isOnline && (
                        <span className="w-2 h-2 bg-green-500 rounded-full flex-shrink-0" />
                      )}
                    </div>
                  </button>
                ))}
              </div>
            )}

            <div className="flex justify-end">
              <button
                onClick={closeModal}
                className="px-4 py-2 text-gray-500 hover:bg-gray-100 rounded-xl text-sm font-medium"
              >
                닫기
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/app/find-email/page.tsx">
// =============================================
// 파일 1: src/app/find-email/page.tsx
// 이메일(아이디) 찾기 페이지
// =============================================
"use client";

import { useState } from "react";
import Link from "next/link";

export default function FindEmailPage() {
  const [name, setName] = useState("");
  const [loading, setLoading] = useState(false);
  const [result, setResult] = useState<{ maskedEmail: string } | null>(null);
  const [sent, setSent] = useState(false);
  const [error, setError] = useState("");

  const handleFind = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");
    setLoading(true);
    try {
      const res = await fetch("/api/auth/find-email", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name }),
      });
      const data = await res.json();
      if (res.ok) {
        setResult(data);
      } else {
        setError(data.error || "이메일을 찾을 수 없습니다");
      }
    } catch {
      setError("오류가 발생했습니다");
    } finally {
      setLoading(false);
    }
  };

  const handleSendFull = async () => {
    setLoading(true);
    try {
      const res = await fetch("/api/auth/find-email/send", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name }),
      });
      if (res.ok) setSent(true);
      else setError("이메일 발송 실패");
    } catch {
      setError("발송 중 오류가 발생했습니다");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="eum-root">
      <div className="eum-bg"><div className="eum-blob b1"/><div className="eum-blob b2"/></div>
      <div className="eum-container">
        <Link href="/login" className="eum-back">← 로그인으로 돌아가기</Link>

        <div className="eum-card">
          <div className="eum-icon-wrap">📧</div>
          <h2 className="eum-title">이메일 찾기</h2>
          <p className="eum-sub">가입 시 입력한 이름으로 이메일을 찾을 수 있습니다</p>

          {!result && !sent && (
            <form onSubmit={handleFind} className="eum-form">
              {error && <div className="eum-error">⚠️ {error}</div>}
              <div className="eum-field">
                <label className="eum-label">이름</label>
                <input type="text" value={name} onChange={(e) => setName(e.target.value)}
                  placeholder="가입 시 입력한 이름" className="eum-input" required />
              </div>
              <button type="submit" disabled={loading} className="eum-btn">
                {loading ? "찾는 중..." : "이메일 찾기"}
              </button>
            </form>
          )}

          {result && !sent && (
            <div className="eum-result">
              <p className="eum-result-label">가입된 이메일</p>
              <p className="eum-result-email">{result.maskedEmail}</p>
              <p className="eum-result-desc">전체 이메일 주소를 받으시겠습니까?</p>
              <button onClick={handleSendFull} disabled={loading} className="eum-btn">
                {loading ? "발송 중..." : "이메일로 전체 주소 받기"}
              </button>
              <Link href="/login" className="eum-link-btn">로그인으로 돌아가기</Link>
            </div>
          )}

          {sent && (
            <div className="eum-success">
              <div className="eum-success-icon">✅</div>
              <p className="eum-success-msg">이메일이 발송되었습니다!</p>
              <p className="eum-success-sub">받은 메일함을 확인해주세요<br/>(스팸함도 확인해보세요)</p>
              <Link href="/login" className="eum-btn" style={{display:"block",textAlign:"center",textDecoration:"none",marginTop:"16px"}}>
                로그인으로 돌아가기
              </Link>
            </div>
          )}
        </div>
      </div>
      <style>{EUM_FIND_STYLE}</style>
    </div>
  );
}

const EUM_FIND_STYLE = `
  * { box-sizing: border-box; margin: 0; padding: 0; }
  .eum-root { min-height: 100vh; min-height: 100dvh; background: #0f0c29; display: flex; align-items: center; justify-content: center; padding: 24px 20px; position: relative; overflow: hidden; font-family: 'Pretendard','Apple SD Gothic Neo',-apple-system,sans-serif; }
  .eum-bg { position: fixed; inset: 0; pointer-events: none; z-index: 0; }
  .eum-blob { position: absolute; border-radius: 50%; filter: blur(80px); opacity: 0.25; }
  .b1 { width: 380px; height: 380px; background: #7c3aed; top: -100px; left: -100px; }
  .b2 { width: 320px; height: 320px; background: #2563eb; bottom: -80px; right: -80px; }
  .eum-container { position: relative; z-index: 1; width: 100%; max-width: 400px; display: flex; flex-direction: column; gap: 16px; }
  .eum-back { font-size: 13px; color: rgba(255,255,255,0.4); text-decoration: none; display: inline-flex; align-items: center; gap: 4px; transition: color 0.2s; }
  .eum-back:hover { color: rgba(255,255,255,0.7); }
  .eum-card { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); border-radius: 24px; padding: 36px 28px; backdrop-filter: blur(20px); box-shadow: 0 25px 50px rgba(0,0,0,0.4); }
  .eum-icon-wrap { font-size: 40px; text-align: center; margin-bottom: 16px; }
  .eum-title { font-size: 22px; font-weight: 700; color: white; text-align: center; margin-bottom: 8px; }
  .eum-sub { font-size: 14px; color: rgba(255,255,255,0.5); text-align: center; line-height: 1.6; margin-bottom: 24px; }
  .eum-form { display: flex; flex-direction: column; gap: 16px; }
  .eum-field { display: flex; flex-direction: column; gap: 7px; }
  .eum-label { font-size: 13px; font-weight: 600; color: rgba(255,255,255,0.7); }
  .eum-input { background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12); border-radius: 12px; padding: 13px 16px; color: white; font-size: 16px; transition: all 0.2s; outline: none; width: 100%; -webkit-appearance: none; }
  .eum-input::placeholder { color: rgba(255,255,255,0.25); }
  .eum-input:focus { border-color: #7c3aed; background: rgba(124,58,237,0.1); box-shadow: 0 0 0 3px rgba(124,58,237,0.2); }
  .eum-error { background: rgba(239,68,68,0.15); border: 1px solid rgba(239,68,68,0.3); color: #fca5a5; font-size: 13px; padding: 12px 14px; border-radius: 12px; }
  .eum-btn { width: 100%; padding: 14px; background: linear-gradient(135deg, #7c3aed, #2563eb); border: none; border-radius: 12px; color: white; font-size: 15px; font-weight: 700; cursor: pointer; transition: all 0.2s; min-height: 50px; box-shadow: 0 4px 20px rgba(124,58,237,0.35); -webkit-tap-highlight-color: transparent; }
  .eum-btn:disabled { opacity: 0.5; cursor: not-allowed; }
  .eum-result { text-align: center; display: flex; flex-direction: column; gap: 12px; }
  .eum-result-label { font-size: 12px; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 1px; }
  .eum-result-email { font-size: 22px; font-weight: 700; color: #a78bfa; letter-spacing: 1px; }
  .eum-result-desc { font-size: 13px; color: rgba(255,255,255,0.5); }
  .eum-link-btn { text-align: center; font-size: 13px; color: rgba(255,255,255,0.35); text-decoration: none; margin-top: 4px; display: block; }
  .eum-success { text-align: center; display: flex; flex-direction: column; align-items: center; gap: 10px; }
  .eum-success-icon { font-size: 52px; }
  .eum-success-msg { font-size: 20px; font-weight: 700; color: white; }
  .eum-success-sub { font-size: 14px; color: rgba(255,255,255,0.5); line-height: 1.7; }
  .eum-expire { font-size: 12px; color: rgba(255,165,0,0.8); }
`;
</file>

<file path="src/app/register/page.tsx">
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import Link from "next/link";
import { 
  Mail, 
  Lock, 
  User, 
  Eye, 
  EyeOff, 
  Cloud, 
  AlertCircle, 
  Loader2, 
  CheckCircle2, 
  ChevronRight,
  ShieldCheck,
  FileText
} from "lucide-react";

interface PrivacyConsent {
  terms: boolean;
  privacy: boolean;
  age: boolean;
  marketing: boolean;
}

export default function RegisterPage() {
  const router = useRouter();

  // 입력 상태
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [passwordConfirm, setPasswordConfirm] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const [showPasswordConfirm, setShowPasswordConfirm] = useState(false);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  // 개인정보 동의 상태
  const [showPrivacyModal, setShowPrivacyModal] = useState(false);
  const [showFullText, setShowFullText] = useState<"terms" | "privacy" | null>(null);
  const [consent, setConsent] = useState<PrivacyConsent>({
    terms: false, privacy: false, age: false, marketing: false,
  });
  const [consentDone, setConsentDone] = useState(false);

  // 유효성 검사 로직
  const passwordRules = {
    length: password.length >= 8,
    combo: /(?=.*[a-zA-Z])(?=.*\d)/.test(password),
  };
  const passwordMatch = password === passwordConfirm && passwordConfirm.length > 0;
  const emailValid = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  const allRequiredConsent = consent.terms && consent.privacy && consent.age;

  const handleAllConsent = (checked: boolean) => {
    setConsent({ terms: checked, privacy: checked, age: checked, marketing: checked });
  };

  const handleConsentSubmit = () => {
    if (!allRequiredConsent) return;
    setConsentDone(true);
    setShowPrivacyModal(false);
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");

    if (!consentDone) {
      setShowPrivacyModal(true);
      return;
    }

    if (!passwordRules.length || !passwordRules.combo || !passwordMatch) {
      setError("입력하신 정보를 다시 확인해주세요.");
      return;
    }

    setLoading(true);
    try {
      // 💡 오류 해결 포인트: API 경로가 /api/auth/register 인지 /api/register 인지 확인 필요
      // 현재 프로젝트 구조에 맞춰 엔드포인트를 호출합니다.
      const res = await fetch("/api/auth/register", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ 
          name, 
          email, 
          password, 
          marketingConsent: consent.marketing 
        }),
      });

      const data = await res.json();

      if (res.ok) {
        // 성공 시 로그인 페이지로 이동하며 성공 메시지 전달
        router.push("/login?signup=success");
      } else {
        setError(data.error || "이미 사용 중인 이메일이거나 가입 정보가 올바르지 않습니다.");
      }
    } catch (err) {
      setError("서버와의 통신 중 오류가 발생했습니다.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-[#0f0c29] text-white flex items-center justify-center p-6 relative overflow-hidden font-sans">
      {/* 배경 장식 */}
      <div className="absolute top-[-10%] left-[-10%] w-[40%] h-[40%] bg-purple-600/20 blur-[100px] rounded-full -z-10" />
      <div className="absolute bottom-[-10%] right-[-10%] w-[40%] h-[40%] bg-blue-600/20 blur-[100px] rounded-full -z-10" />

      <div className="max-w-md w-full relative z-10">
        {/* 로고 영역 */}
        <div className="text-center mb-8 flex flex-col items-center">
          <Link href="/" className="inline-flex items-center gap-3 group">
            <div className="w-12 h-12 bg-gradient-to-br from-purple-500 to-blue-600 rounded-2xl flex items-center justify-center shadow-xl group-hover:scale-110 transition-transform">
              <Cloud size={28} fill="currentColor" />
            </div>
            <div className="text-left">
              <h1 className="text-3xl font-black tracking-tighter italic leading-none">EUM</h1>
              <p className="text-[10px] text-white/40 uppercase tracking-[0.2em] font-bold mt-1">Personal Cloud</p>
            </div>
          </Link>
        </div>

        {/* 회원가입 카드 */}
        <div className="bg-white/5 border border-white/10 p-8 rounded-[40px] backdrop-blur-2xl shadow-2xl">
          <div className="mb-6">
            <h2 className="text-2xl font-bold mb-1">회원가입</h2>
            <p className="text-white/50 text-sm">이음의 새 가족이 되어주세요 ✨</p>
          </div>

          {error && (
            <div className="mb-6 flex items-center gap-2 bg-red-500/10 border border-red-500/20 text-red-400 p-4 rounded-2xl text-sm">
              <AlertCircle size={18} />
              <p>{error}</p>
            </div>
          )}

          <form onSubmit={handleSubmit} className="space-y-4">
            {/* 이름 입력 */}
            <div className="space-y-1.5">
              <label className="text-xs font-bold text-white/40 ml-1 uppercase tracking-wider">Name</label>
              <div className="relative group">
                <div className="absolute inset-y-0 left-4 flex items-center text-white/20 group-focus-within:text-purple-400 transition-colors">
                  <User size={18} />
                </div>
                <input
                  type="text"
                  value={name}
                  onChange={(e) => setName(e.target.value)}
                  placeholder="홍길동"
                  className="w-full bg-white/5 border border-white/10 rounded-2xl py-3.5 pl-12 pr-4 outline-none focus:border-purple-500/50 focus:bg-white/10 transition-all"
                  required
                />
              </div>
            </div>

            {/* 이메일 입력 */}
            <div className="space-y-1.5">
              <label className="text-xs font-bold text-white/40 ml-1 uppercase tracking-wider">Email</label>
              <div className="relative group">
                <div className="absolute inset-y-0 left-4 flex items-center text-white/20 group-focus-within:text-purple-400 transition-colors">
                  <Mail size={18} />
                </div>
                <input
                  type="email"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  placeholder="example@email.com"
                  className={`w-full bg-white/5 border border-white/10 rounded-2xl py-3.5 pl-12 pr-4 outline-none focus:border-purple-500/50 focus:bg-white/10 transition-all ${email && !emailValid ? "border-red-500/50" : emailValid ? "border-emerald-500/50" : ""}`}
                  required
                />
              </div>
            </div>

            {/* 비밀번호 입력 */}
            <div className="space-y-1.5">
              <label className="text-xs font-bold text-white/40 ml-1 uppercase tracking-wider">Password</label>
              <div className="relative group">
                <div className="absolute inset-y-0 left-4 flex items-center text-white/20 group-focus-within:text-purple-400 transition-colors">
                  <Lock size={18} />
                </div>
                <input
                  type={showPassword ? "text" : "password"}
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  placeholder="8자 이상, 영문+숫자"
                  className="w-full bg-white/5 border border-white/10 rounded-2xl py-3.5 pl-12 pr-12 outline-none focus:border-purple-500/50 focus:bg-white/10 transition-all"
                  required
                />
                <button
                  type="button"
                  onClick={() => setShowPassword(!showPassword)}
                  className="absolute inset-y-0 right-4 flex items-center text-white/20 hover:text-white"
                >
                  {showPassword ? <EyeOff size={18} /> : <Eye size={18} />}
                </button>
              </div>
              {/* 비밀번호 규칙 체크 표시 */}
              {password && (
                <div className="flex gap-3 px-1 mt-1">
                  <div className={`flex items-center gap-1 text-[11px] ${passwordRules.length ? "text-emerald-400" : "text-white/20"}`}>
                    <CheckCircle2 size={12} /> 8자 이상
                  </div>
                  <div className={`flex items-center gap-1 text-[11px] ${passwordRules.combo ? "text-emerald-400" : "text-white/20"}`}>
                    <CheckCircle2 size={12} /> 영문+숫자
                  </div>
                </div>
              )}
            </div>

            {/* 비밀번호 확인 */}
            <div className="space-y-1.5">
              <label className="text-xs font-bold text-white/40 ml-1 uppercase tracking-wider">Confirm Password</label>
              <div className="relative group">
                <div className="absolute inset-y-0 left-4 flex items-center text-white/20 group-focus-within:text-purple-400 transition-colors">
                  <Lock size={18} />
                </div>
                <input
                  type={showPasswordConfirm ? "text" : "password"}
                  value={passwordConfirm}
                  onChange={(e) => setPasswordConfirm(e.target.value)}
                  placeholder="비밀번호 재입력"
                  className={`w-full bg-white/5 border border-white/10 rounded-2xl py-3.5 pl-12 pr-12 outline-none focus:border-purple-500/50 focus:bg-white/10 transition-all ${passwordConfirm && !passwordMatch ? "border-red-500/50" : passwordMatch ? "border-emerald-500/50" : ""}`}
                  required
                />
                <button
                  type="button"
                  onClick={() => setShowPasswordConfirm(!showPasswordConfirm)}
                  className="absolute inset-y-0 right-4 flex items-center text-white/20 hover:text-white"
                >
                  {showPasswordConfirm ? <EyeOff size={18} /> : <Eye size={18} />}
                </button>
              </div>
            </div>

            {/* 약관 동의 섹션 */}
            <div className="pt-2">
              {consentDone ? (
                <button 
                  type="button" 
                  onClick={() => setShowPrivacyModal(true)}
                  className="w-full bg-emerald-500/10 border border-emerald-500/30 rounded-2xl p-3 flex items-center justify-between group"
                >
                  <div className="flex items-center gap-2 text-emerald-400 text-sm font-medium">
                    <ShieldCheck size={18} />
                    <span>약관 동의 완료</span>
                  </div>
                  <span className="text-[10px] text-white/20 group-hover:text-white/40">변경하기</span>
                </button>
              ) : (
                <button
                  type="button"
                  onClick={() => setShowPrivacyModal(true)}
                  className="w-full bg-white/5 border border-dashed border-white/20 rounded-2xl p-3 text-white/40 text-sm hover:bg-white/10 hover:border-white/40 transition-all flex items-center justify-center gap-2"
                >
                  <FileText size={18} />
                  개인정보 수집 동의 (필수)
                </button>
              )}
            </div>

            <button
              type="submit"
              disabled={loading || !consentDone}
              className="w-full py-4 bg-gradient-to-r from-purple-500 to-blue-600 text-white font-bold rounded-2xl hover:opacity-90 active:scale-[0.98] transition-all flex items-center justify-center gap-2 shadow-xl shadow-purple-500/20 disabled:opacity-30 mt-4"
            >
              {loading ? <Loader2 size={20} className="animate-spin" /> : <>회원가입 <ChevronRight size={20} /></>}
            </button>
          </form>

          <div className="mt-6 text-center">
            <p className="text-white/40 text-sm">
              이미 계정이 있으신가요?{" "}
              <Link href="/login" className="text-white font-bold hover:text-purple-400 underline underline-offset-4">
                로그인
              </Link>
            </p>
          </div>
        </div>
      </div>

      {/* 동의 모달 (생략: 기존 로직과 동일하나 디자인을 EUM 스타일로 조정) */}
      {showPrivacyModal && (
        <div className="fixed inset-0 z-[100] flex items-end sm:items-center justify-center p-0 sm:p-4 bg-black/80 backdrop-blur-sm animate-in fade-in duration-200">
          <div className="bg-[#1a1735] w-full max-w-lg rounded-t-[32px] sm:rounded-[32px] p-8 border border-white/10 shadow-2xl overflow-y-auto max-h-[90vh]">
            <h3 className="text-xl font-bold mb-2">서비스 이용 동의</h3>
            <p className="text-white/40 text-sm mb-6">원활한 서비스 제공을 위해 필수 항목에 동의가 필요합니다.</p>
            
            <div className="space-y-1">
              <label className="flex items-center gap-3 p-4 bg-white/5 rounded-2xl cursor-pointer hover:bg-white/10 transition-colors mb-4">
                <input 
                  type="checkbox" 
                  className="w-5 h-5 rounded-lg accent-purple-500"
                  checked={consent.terms && consent.privacy && consent.age && consent.marketing}
                  onChange={(e) => handleAllConsent(e.target.checked)}
                />
                <span className="font-bold">전체 동의하기</span>
              </label>
              
              <div className="space-y-1 px-1">
                {[
                  { key: "terms", label: "[필수] 서비스 이용약관", type: "terms" },
                  { key: "privacy", label: "[필수] 개인정보 처리방침", type: "privacy" },
                  { key: "age", label: "[필수] 만 14세 이상입니다", type: null },
                  { key: "marketing", label: "[선택] 마케팅 정보 수신", type: null },
                ].map((item) => (
                  <div key={item.key} className="flex items-center justify-between py-3 border-b border-white/5 last:border-0">
                    <label className="flex items-center gap-3 cursor-pointer">
                      <input 
                        type="checkbox" 
                        className="w-4 h-4 rounded accent-purple-500"
                        checked={consent[item.key as keyof PrivacyConsent]}
                        onChange={(e) => setConsent({ ...consent, [item.key]: e.target.checked })}
                      />
                      <span className={`text-sm ${item.key === 'marketing' ? 'text-white/40' : 'text-white/70'}`}>{item.label}</span>
                    </label>
                    {item.type && (
                      <button 
                        onClick={() => setShowFullText(item.type as "terms" | "privacy")}
                        className="text-[11px] text-white/30 underline"
                      >전문보기</button>
                    )}
                  </div>
                ))}
              </div>
            </div>

            <div className="mt-8 flex gap-3">
              <button 
                onClick={() => setShowPrivacyModal(false)}
                className="flex-1 py-4 bg-white/5 rounded-2xl font-bold hover:bg-white/10 transition-colors"
              >취소</button>
              <button 
                onClick={handleConsentSubmit}
                disabled={!allRequiredConsent}
                className="flex-[2] py-4 bg-gradient-to-r from-purple-500 to-blue-600 rounded-2xl font-bold disabled:opacity-30"
              >동의하고 계속하기</button>
            </div>
          </div>
        </div>
      )}

      {/* 약관 전문 모달 (기존 로직 유지) */}
      {showFullText && (
        <div className="fixed inset-0 z-[110] flex items-center justify-center p-4 bg-black/90">
          <div className="bg-[#1a1735] w-full max-w-2xl rounded-[32px] p-8 border border-white/10 flex flex-col max-h-[80vh]">
            <h4 className="text-lg font-bold mb-4">{showFullText === "terms" ? "이용약관" : "개인정보 처리방침"}</h4>
            <div className="flex-1 overflow-y-auto bg-black/20 rounded-2xl p-6 text-sm text-white/60 leading-relaxed whitespace-pre-wrap">
              {showFullText === "terms" ? TERMS_TEXT : PRIVACY_TEXT}
            </div>
            <button 
              onClick={() => setShowFullText(null)}
              className="mt-6 w-full py-4 bg-white/10 rounded-2xl font-bold"
            >확인</button>
          </div>
        </div>
      )}
    </div>
  );
}

// 약관 텍스트 데이터 (생략 - 기존 데이터 사용)
const TERMS_TEXT = `...`;
const PRIVACY_TEXT = `...`;
</file>

<file path="src/app/reset-password/confirm/page.tsx">
"use client";

import { useState, useEffect, Suspense } from "react";
import { useSearchParams, useRouter } from "next/navigation";
import Link from "next/link";

function ResetPasswordContent() {
  const searchParams = useSearchParams();
  const router = useRouter();
  const token = searchParams.get("token");

  const [password, setPassword] = useState("");
  const [confirm, setConfirm] = useState("");
  const [loading, setLoading] = useState(false);
  const [done, setDone] = useState(false);
  const [error, setError] = useState("");

  useEffect(() => {
    if (!token) {
      setError("유효하지 않은 링크입니다");
    }
  }, [token]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");

    if (password !== confirm) {
      setError("비밀번호가 일치하지 않습니다");
      return;
    }
    if (password.length < 8 || !/(?=.*[a-zA-Z])(?=.*\d)/.test(password)) {
      setError("비밀번호는 8자 이상, 영문+숫자 조합이어야 합니다");
      return;
    }

    setLoading(true);
    try {
      const res = await fetch("/api/auth/reset-password/confirm", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ token, password }),
      });
      const data = await res.json();
      if (res.ok) {
        setDone(true);
        setTimeout(() => router.push("/login"), 3000);
      } else {
        setError(data.error || "오류가 발생했습니다");
      }
    } catch {
      setError("오류가 발생했습니다");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="eum-card">
      <div className="eum-icon-wrap">🔑</div>
      <h2 className="eum-title">새 비밀번호 설정</h2>

      {done ? (
        <div className="eum-success">
          <div className="eum-success-icon">✅</div>
          <p className="eum-success-msg">비밀번호가 변경되었습니다!</p>
          <p className="eum-success-sub">3초 후 로그인 페이지로 이동합니다</p>
          <Link
            href="/login"
            className="eum-btn"
            style={{
              display: "block",
              textAlign: "center",
              textDecoration: "none",
              marginTop: "16px",
            }}
          >
            로그인하러 가기
          </Link>
        </div>
      ) : (
        <>
          <p className="eum-sub">새로 사용할 비밀번호를 입력해주세요</p>
          <form onSubmit={handleSubmit} className="eum-form">
            {error && <div className="eum-error">⚠️ {error}</div>}
            <div className="eum-field">
              <label className="eum-label">새 비밀번호</label>
              <input
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                placeholder="8자 이상, 영문+숫자"
                className="eum-input"
                required
              />
            </div>
            <div className="eum-field">
              <label className="eum-label">비밀번호 확인</label>
              <input
                type="password"
                value={confirm}
                onChange={(e) => setConfirm(e.target.value)}
                placeholder="비밀번호를 다시 입력하세요"
                className="eum-input"
                required
              />
              {confirm && (
                <span
                  style={{
                    fontSize: "12px",
                    marginTop: "4px",
                    color: password === confirm ? "#4ade80" : "#f87171",
                  }}
                >
                  {password === confirm ? "✅ 일치합니다" : "❌ 일치하지 않습니다"}
                </span>
              )}
            </div>
            <button
              type="submit"
              disabled={loading || !token}
              className="eum-btn"
            >
              {loading ? "변경 중..." : "비밀번호 변경하기"}
            </button>
          </form>
        </>
      )}
    </div>
  );
}

export default function ResetPasswordConfirmPage() {
  return (
    <div className="eum-root">
      <div className="eum-bg">
        <div className="eum-blob b1" />
        <div className="eum-blob b2" />
      </div>
      <div className="eum-container">
        <Suspense fallback={<div className="eum-card" style={{ color: 'white', textAlign: 'center' }}>불러오는 중...</div>}>
          <ResetPasswordContent />
        </Suspense>
      </div>
      <style>{EUM_FIND_STYLE}</style>
    </div>
  );
}

const EUM_FIND_STYLE = `
  * { box-sizing: border-box; margin: 0; padding: 0; }
  .eum-root { min-height: 100vh; min-height: 100dvh; background: #0f0c29; display: flex; align-items: center; justify-content: center; padding: 24px 20px; position: relative; overflow: hidden; font-family: 'Pretendard','Apple SD Gothic Neo',-apple-system,sans-serif; }
  .eum-bg { position: fixed; inset: 0; pointer-events: none; z-index: 0; }
  .eum-blob { position: absolute; border-radius: 50%; filter: blur(80px); opacity: 0.25; }
  .b1 { width: 380px; height: 380px; background: #7c3aed; top: -100px; left: -100px; }
  .b2 { width: 320px; height: 320px; background: #2563eb; bottom: -80px; right: -80px; }
  .eum-container { position: relative; z-index: 1; width: 100%; max-width: 400px; }
  .eum-card { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); border-radius: 24px; padding: 36px 28px; backdrop-filter: blur(20px); box-shadow: 0 25px 50px rgba(0,0,0,0.4); }
  .eum-icon-wrap { font-size: 40px; text-align: center; margin-bottom: 16px; }
  .eum-title { font-size: 22px; font-weight: 700; color: white; text-align: center; margin-bottom: 8px; }
  .eum-sub { font-size: 14px; color: rgba(255,255,255,0.5); text-align: center; line-height: 1.6; margin-bottom: 24px; }
  .eum-form { display: flex; flex-direction: column; gap: 16px; }
  .eum-field { display: flex; flex-direction: column; gap: 7px; }
  .eum-label { font-size: 13px; font-weight: 600; color: rgba(255,255,255,0.7); }
  .eum-input { background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12); border-radius: 12px; padding: 13px 16px; color: white; font-size: 16px; transition: all 0.2s; outline: none; width: 100%; -webkit-appearance: none; }
  .eum-input::placeholder { color: rgba(255,255,255,0.25); }
  .eum-input:focus { border-color: #7c3aed; background: rgba(124,58,237,0.1); box-shadow: 0 0 0 3px rgba(124,58,237,0.2); }
  .eum-error { background: rgba(239,68,68,0.15); border: 1px solid rgba(239,68,68,0.3); color: #fca5a5; font-size: 13px; padding: 12px 14px; border-radius: 12px; }
  .eum-btn { width: 100%; padding: 14px; background: linear-gradient(135deg, #7c3aed, #2563eb); border: none; border-radius: 12px; color: white; font-size: 15px; font-weight: 700; cursor: pointer; transition: all 0.2s; min-height: 50px; box-shadow: 0 4px 20px rgba(124,58,237,0.35); -webkit-tap-highlight-color: transparent; }
  .eum-btn:disabled { opacity: 0.5; cursor: not-allowed; }
  .eum-success { text-align: center; display: flex; flex-direction: column; align-items: center; gap: 10px; }
  .eum-success-icon { font-size: 52px; }
  .eum-success-msg { font-size: 20px; font-weight: 700; color: white; }
  .eum-success-sub { font-size: 14px; color: rgba(255,255,255,0.5); line-height: 1.7; }
`;
</file>

<file path="src/app/reset-password/page.tsx">
"use client";

import { useState } from "react";
import Link from "next/link";

export default function ResetPasswordPage() {
  const [email, setEmail] = useState("");
  const [loading, setLoading] = useState(false);
  const [sent, setSent] = useState(false);
  const [error, setError] = useState("");

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");
    setLoading(true);
    try {
      const res = await fetch("/api/auth/reset-password", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email }),
      });
      const data = await res.json();
      if (res.ok) setSent(true);
      else setError(data.error || "오류가 발생했습니다");
    } catch {
      setError("오류가 발생했습니다");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="eum-root">
      <div className="eum-bg">
        <div className="eum-blob b1" />
        <div className="eum-blob b2" />
      </div>
      <div className="eum-container">
        <Link href="/login" className="eum-back">← 로그인으로 돌아가기</Link>
        <div className="eum-card">
          <div className="eum-icon-wrap">🔐</div>
          <h2 className="eum-title">비밀번호 재설정</h2>
          {!sent ? (
            <>
              <p className="eum-sub">
                가입한 이메일 주소를 입력하면<br />
                비밀번호 재설정 링크를 보내드립니다
              </p>
              <form onSubmit={handleSubmit} className="eum-form">
                {error && <div className="eum-error">⚠️ {error}</div>}
                <div className="eum-field">
                  <label className="eum-label">이메일</label>
                  <input
                    type="email"
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                    placeholder="가입한 이메일 주소"
                    className="eum-input"
                    required
                  />
                </div>
                <button type="submit" disabled={loading} className="eum-btn">
                  {loading ? "전송 중..." : "재설정 링크 받기"}
                </button>
              </form>
            </>
          ) : (
            <div className="eum-success">
              <div className="eum-success-icon">📨</div>
              <p className="eum-success-msg">메일을 발송했습니다!</p>
              <p className="eum-success-sub">
                <strong>{email}</strong>로 전송된<br />
                링크를 클릭해 비밀번호를 재설정하세요<br />
                <span className="eum-expire">링크는 15분간 유효합니다</span>
              </p>
              <Link
                href="/login"
                className="eum-btn"
                style={{ display: "block", textAlign: "center", textDecoration: "none", marginTop: "16px" }}
              >
                로그인으로 돌아가기
              </Link>
            </div>
          )}
        </div>
      </div>
      <style>{EUM_FIND_STYLE}</style>
    </div>
  );
}

const EUM_FIND_STYLE = `
  * { box-sizing: border-box; margin: 0; padding: 0; }
  .eum-root { min-height: 100vh; min-height: 100dvh; background: #0f0c29; display: flex; align-items: center; justify-content: center; padding: 24px 20px; position: relative; overflow: hidden; font-family: 'Pretendard','Apple SD Gothic Neo',-apple-system,sans-serif; }
  .eum-bg { position: fixed; inset: 0; pointer-events: none; z-index: 0; }
  .eum-blob { position: absolute; border-radius: 50%; filter: blur(80px); opacity: 0.25; }
  .b1 { width: 380px; height: 380px; background: #7c3aed; top: -100px; left: -100px; }
  .b2 { width: 320px; height: 320px; background: #2563eb; bottom: -80px; right: -80px; }
  .eum-container { position: relative; z-index: 1; width: 100%; max-width: 400px; display: flex; flex-direction: column; gap: 16px; }
  .eum-back { font-size: 13px; color: rgba(255,255,255,0.4); text-decoration: none; display: inline-flex; align-items: center; gap: 4px; transition: color 0.2s; }
  .eum-back:hover { color: rgba(255,255,255,0.7); }
  .eum-card { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); border-radius: 24px; padding: 36px 28px; backdrop-filter: blur(20px); box-shadow: 0 25px 50px rgba(0,0,0,0.4); }
  .eum-icon-wrap { font-size: 40px; text-align: center; margin-bottom: 16px; }
  .eum-title { font-size: 22px; font-weight: 700; color: white; text-align: center; margin-bottom: 8px; }
  .eum-sub { font-size: 14px; color: rgba(255,255,255,0.5); text-align: center; line-height: 1.6; margin-bottom: 24px; }
  .eum-form { display: flex; flex-direction: column; gap: 16px; }
  .eum-field { display: flex; flex-direction: column; gap: 7px; }
  .eum-label { font-size: 13px; font-weight: 600; color: rgba(255,255,255,0.7); }
  .eum-input { background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12); border-radius: 12px; padding: 13px 16px; color: white; font-size: 16px; transition: all 0.2s; outline: none; width: 100%; -webkit-appearance: none; }
  .eum-input::placeholder { color: rgba(255,255,255,0.25); }
  .eum-input:focus { border-color: #7c3aed; background: rgba(124,58,237,0.1); box-shadow: 0 0 0 3px rgba(124,58,237,0.2); }
  .eum-error { background: rgba(239,68,68,0.15); border: 1px solid rgba(239,68,68,0.3); color: #fca5a5; font-size: 13px; padding: 12px 14px; border-radius: 12px; }
  .eum-btn { width: 100%; padding: 14px; background: linear-gradient(135deg, #7c3aed, #2563eb); border: none; border-radius: 12px; color: white; font-size: 15px; font-weight: 700; cursor: pointer; transition: all 0.2s; min-height: 50px; box-shadow: 0 4px 20px rgba(124,58,237,0.35); -webkit-tap-highlight-color: transparent; }
  .eum-btn:disabled { opacity: 0.5; cursor: not-allowed; }
  .eum-success { text-align: center; display: flex; flex-direction: column; align-items: center; gap: 10px; }
  .eum-success-icon { font-size: 52px; }
  .eum-success-msg { font-size: 20px; font-weight: 700; color: white; }
  .eum-success-sub { font-size: 14px; color: rgba(255,255,255,0.5); line-height: 1.7; }
  .eum-expire { font-size: 12px; color: rgba(255,165,0,0.8); }
`;
</file>

<file path="src/components/Breadcrumb.tsx">
"use client";

interface BreadcrumbItem {
  id: string | null;
  name: string;
}

interface BreadcrumbProps {
  path: BreadcrumbItem[];
  onNavigate: (folderId: string | null) => void;
}

export default function Breadcrumb({ path, onNavigate }: BreadcrumbProps) {
  return (
    <div className="flex items-center gap-2 text-sm text-gray-600 mb-4">
      {path.map((item, index) => (
        <div key={item.id || "root"} className="flex items-center gap-2">
          <button
            onClick={() => onNavigate(item.id)}
            className={`hover:text-blue-600 ${
              index === path.length - 1
                ? "font-semibold text-gray-900"
                : "text-gray-600"
            }`}
          >
            {item.name}
          </button>
          {index < path.length - 1 && (
            <span className="text-gray-400">/</span>
          )}
        </div>
      ))}
    </div>
  );
}
</file>

<file path="src/components/FileDropZone.tsx">
"use client";

import { useState, DragEvent } from "react";

interface FileDropZoneProps {
  onFileSelect: (file: File) => void;
  uploading: boolean;
}

export default function FileDropZone({ onFileSelect, uploading }: FileDropZoneProps) {
  const [isDragging, setIsDragging] = useState(false);

  const handleDragEnter = (e: DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(true);
  };

  const handleDragLeave = (e: DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);
  };

  const handleDragOver = (e: DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
  };

  const handleDrop = (e: DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);

    const files = Array.from(e.dataTransfer.files);
    if (files.length > 0) {
      onFileSelect(files[0]);
    }
  };

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (files && files.length > 0) {
      onFileSelect(files[0]);
    }
  };

  return (
    <div
      className={`relative border-2 border-dashed rounded-lg p-8 text-center transition ${
        isDragging
          ? "border-blue-500 bg-blue-50"
          : "border-gray-300 bg-gray-50 hover:border-gray-400"
      } ${uploading ? "opacity-50 pointer-events-none" : ""}`}
      onDragEnter={handleDragEnter}
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
    >
      <input
        type="file"
        onChange={handleFileChange}
        disabled={uploading}
        className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
      />

      <div className="pointer-events-none">
        <div className="text-4xl mb-4">
          {uploading ? "⏳" : "📤"}
        </div>
        <p className="text-lg font-medium text-gray-700 mb-2">
          {uploading ? "업로드 중..." : "파일을 드래그하거나 클릭하세요"}
        </p>
        <p className="text-sm text-gray-500">
          이미지, 동영상, 문서 (최대 2GB)
        </p>
      </div>
    </div>
  );
}
</file>

<file path="src/components/FileFilters.tsx">
"use client";

interface FileFiltersProps {
  fileType: string;
  onFileTypeChange: (type: string) => void;
  sortBy: string;
  onSortByChange: (sort: string) => void;
}

export default function FileFilters({
  fileType,
  onFileTypeChange,
  sortBy,
  onSortByChange,
}: FileFiltersProps) {
  return (
    <div className="flex flex-wrap gap-4 items-center">
      {/* 파일 타입 필터 */}
      <div>
        <label className="text-sm text-gray-600 mr-2">타입:</label>
        <select
          value={fileType}
          onChange={(e) => onFileTypeChange(e.target.value)}
          className="px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
        >
          <option value="">전체</option>
          <option value="image">이미지</option>
          <option value="video">동영상</option>
          <option value="document">문서</option>
        </select>
      </div>

      {/* 정렬 */}
      <div>
        <label className="text-sm text-gray-600 mr-2">정렬:</label>
        <select
          value={sortBy}
          onChange={(e) => onSortByChange(e.target.value)}
          className="px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
        >
          <option value="createdAt-desc">최신순</option>
          <option value="createdAt-asc">오래된순</option>
          <option value="originalName-asc">이름 (가나다순)</option>
          <option value="originalName-desc">이름 (역순)</option>
          <option value="size-desc">크기 (큰 순)</option>
          <option value="size-asc">크기 (작은 순)</option>
        </select>
      </div>
    </div>
  );
}
</file>

<file path="src/components/FileGridSkeleton.tsx">
export default function FileGridSkeleton({ count = 8 }: { count?: number }) {
  return (
    <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
      {Array.from({ length: count }).map((_, i) => (
        <div key={i} className="border rounded-lg overflow-hidden animate-pulse">
          <div className="aspect-square bg-gray-200" />
          <div className="p-3 space-y-2">
            <div className="h-4 bg-gray-200 rounded w-3/4" />
            <div className="h-3 bg-gray-200 rounded w-1/2" />
          </div>
        </div>
      ))}
    </div>
  );
}
</file>

<file path="src/components/FilePreviewModal.tsx">
"use client";

import { useEffect } from "react";

interface FilePreviewModalProps {
  file: {
    id: string;
    originalName: string;
    mimeType: string;
    size: string;
  } | null;
  onClose: () => void;
}

export default function FilePreviewModal({ file, onClose }: FilePreviewModalProps) {
  // ESC 키로 닫기
  useEffect(() => {
    const handleEsc = (e: KeyboardEvent) => {
      if (e.key === "Escape") onClose();
    };
    window.addEventListener("keydown", handleEsc);
    return () => window.removeEventListener("keydown", handleEsc);
  }, [onClose]);

  if (!file) return null;

  const isImage = file.mimeType.startsWith("image/");
  const isVideo = file.mimeType.startsWith("video/");
  const isPdf = file.mimeType.includes("pdf");

  const formatFileSize = (bytes: string) => {
    const size = parseInt(bytes);
    if (size < 1024) return `${size} B`;
    if (size < 1024 * 1024) return `${(size / 1024).toFixed(2)} KB`;
    if (size < 1024 * 1024 * 1024) return `${(size / (1024 * 1024)).toFixed(2)} MB`;
    return `${(size / (1024 * 1024 * 1024)).toFixed(2)} GB`;
  };

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-75 p-4"
      onClick={onClose}
    >
      <div
        className="relative bg-white rounded-lg shadow-xl max-w-4xl w-full max-h-[90vh] overflow-hidden"
        onClick={(e) => e.stopPropagation()}
      >
        {/* 헤더 */}
        <div className="flex items-center justify-between p-4 border-b">
          <div>
            <h3 className="text-lg font-semibold text-gray-900">
              {file.originalName}
            </h3>
            <p className="text-sm text-gray-500">
              {formatFileSize(file.size)} • {file.mimeType}
            </p>
          </div>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-gray-600 text-2xl font-bold"
          >
            ×
          </button>
        </div>

        {/* 미리보기 영역 */}
        <div className="p-4 flex items-center justify-center bg-gray-100 min-h-[400px] max-h-[60vh] overflow-auto">
          {isImage && (
            <img
              src={`/api/files/${file.id}/download`}
              alt={file.originalName}
              className="max-w-full max-h-full object-contain"
            />
          )}

          {isVideo && (
            <video
              controls
              className="max-w-full max-h-full"
              src={`/api/files/${file.id}/download`}
            >
              비디오를 재생할 수 없습니다.
            </video>
          )}

          {isPdf && (
            <iframe
              src={`/api/files/${file.id}/download`}
              className="w-full h-[60vh]"
              title={file.originalName}
            />
          )}

          {!isImage && !isVideo && !isPdf && (
            <div className="text-center text-gray-500">
              <p className="text-4xl mb-4">📄</p>
              <p>미리보기를 지원하지 않는 파일 형식입니다</p>
              <p className="text-sm mt-2">다운로드하여 확인하세요</p>
            </div>
          )}
        </div>

        {/* 푸터 */}
        <div className="flex items-center justify-end gap-2 p-4 border-t bg-gray-50">
          <a
            href={`/api/files/${file.id}/download`}
            download={file.originalName}
            className="px-4 py-2 text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 rounded-md"
          >
            다운로드
          </a>
          <button
            onClick={onClose}
            className="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 hover:bg-gray-50 rounded-md"
          >
            닫기
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/LazyImage.tsx">
"use client";

import { useState, useEffect, useRef } from "react";

interface LazyImageProps {
  src: string;
  alt: string;
  className?: string;
}

export default function LazyImage({ src, alt, className = "" }: LazyImageProps) {
  const [isLoaded, setIsLoaded] = useState(false);
  const [isInView, setIsInView] = useState(false);
  const imgRef = useRef<HTMLImageElement>(null);

  useEffect(() => {
    if (!imgRef.current) return;

    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsInView(true);
          observer.disconnect();
        }
      },
      { rootMargin: "50px" }
    );

    observer.observe(imgRef.current);

    return () => observer.disconnect();
  }, []);

  return (
    <div className={`relative ${className}`} ref={imgRef}>
      {!isLoaded && (
        <div className="absolute inset-0 bg-gray-200 animate-pulse" />
      )}
      {isInView && (
        <img
          src={src}
          alt={alt}
          className={`${className} ${isLoaded ? "opacity-100" : "opacity-0"} transition-opacity duration-300`}
          onLoad={() => setIsLoaded(true)}
          onError={(e) => {
            e.currentTarget.style.display = "none";
          }}
        />
      )}
    </div>
  );
}
</file>

<file path="src/components/SearchBar.tsx">
"use client";

import { useState } from "react";

interface SearchBarProps {
  onSearch: (query: string) => void;
  placeholder?: string;
}

export default function SearchBar({ onSearch, placeholder = "검색..." }: SearchBarProps) {
  const [query, setQuery] = useState("");

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    onSearch(query);
  };

  return (
    <form onSubmit={handleSubmit} className="flex gap-2">
      <input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder={placeholder}
        className="flex-1 px-4 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
      />
      <button
        type="submit"
        className="px-6 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
      >
        검색
      </button>
      {query && (
        <button
          type="button"
          onClick={() => {
            setQuery("");
            onSearch("");
          }}
          className="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300"
        >
          초기화
        </button>
      )}
    </form>
  );
}
</file>

<file path="src/components/UploadProgress.tsx">
"use client";

interface UploadProgressProps {
  fileName: string;
  progress: number;
  onCancel?: () => void;
}

export default function UploadProgress({ fileName, progress, onCancel }: UploadProgressProps) {
  return (
    <div className="bg-white border border-gray-200 rounded-lg p-4 shadow-sm">
      <div className="flex items-center justify-between mb-2">
        <div className="flex-1 mr-4">
          <p className="text-sm font-medium text-gray-900 truncate">{fileName}</p>
          <p className="text-xs text-gray-500">{progress}% 완료</p>
        </div>
        {onCancel && (
          <button
            onClick={onCancel}
            className="text-gray-400 hover:text-gray-600"
          >
            ✕
          </button>
        )}
      </div>
      <div className="w-full bg-gray-200 rounded-full h-2">
        <div
          className="bg-blue-600 h-2 rounded-full transition-all duration-300"
          style={{ width: `${progress}%` }}
        />
      </div>
    </div>
  );
}
</file>

<file path="src/lib/db.ts">
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
  });

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;

export default prisma;
</file>

<file path="src/lib/demo-mode.ts">
/**
 * 데모 모드 설정
 * 앱스토어 심사용 데모 계정 및 샘플 데이터
 */

export const DEMO_MODE = process.env.NEXT_PUBLIC_DEMO_MODE === 'true';

// 심사관용 데모 계정
export const DEMO_USERS = [
  {
    id: 'demo-reviewer-001',
    email: 'reviewer@appstore.com',
    password: 'Demo2024!Review',
    name: 'App Store Reviewer',
    role: 'USER' as const,
  },
  {
    id: 'demo-user-001',
    email: 'testuser@demo.com',
    password: 'Demo2024!Test',
    name: 'Test User',
    role: 'USER' as const,
  },
];

// 데모 유저인지 확인
export function isDemoUser(email: string): boolean {
  return DEMO_USERS.some((user) => user.email === email);
}

// 데모 계정 정보 가져오기
export function getDemoUser(email: string) {
  return DEMO_USERS.find((user) => user.email === email);
}
</file>

<file path="src/lib/email.ts">
import nodemailer from "nodemailer";

interface EmailOptions {
  to: string;
  subject: string;
  html: string;
}

export async function sendEmail({ to, subject, html }: EmailOptions) {
  const transporter = nodemailer.createTransport({
    service: "gmail",
    auth: {
      user: process.env.EMAIL_USER,
      pass: process.env.EMAIL_PASS,
    },
  });

  await transporter.sendMail({
    from: `"이음 (Eum)" <${process.env.EMAIL_USER}>`,
    to,
    subject,
    html,
  });
}
</file>

<file path="src/lib/fcm.ts">
import * as admin from "firebase-admin";

/**
 * Firebase Admin SDK 초기화 (싱글톤 패턴)
 */
function initFirebase() {
  if (admin.apps.length > 0) return true;

  const serviceAccountVar = process.env.FIREBASE_SERVICE_ACCOUNT_KEY;
  if (!serviceAccountVar) {
    console.warn("⚠️ FIREBASE_SERVICE_ACCOUNT_KEY 미설정");
    return false;
  }

  try {
    let configStr = serviceAccountVar.trim();
    if (configStr.startsWith("'") && configStr.endsWith("'")) configStr = configStr.slice(1, -1);
    if (configStr.startsWith('"') && configStr.endsWith('"')) configStr = configStr.slice(1, -1);

    const serviceAccount = JSON.parse(configStr);
    if (serviceAccount.private_key) {
      serviceAccount.private_key = serviceAccount.private_key.replace(/\\n/g, '\n');
    }

    admin.initializeApp({
      credential: admin.credential.cert(serviceAccount),
    });
    console.log("✅ Firebase Admin 초기화 성공!");
    return true;
  } catch (error: any) {
    console.error("❌ Firebase 초기화 에러:", error.message);
    return false;
  }
}

/**
 * 핵심 푸시 전송 로직
 */
export async function sendPushNotification(
  fcmToken: string,
  payload: { title: string; body: string; data?: Record<string, string> }
) {
  if (!initFirebase()) return { success: false, error: "Initialization failed" };

  try {
    const message: admin.messaging.Message = {
      token: fcmToken,
      notification: {
        title: payload.title,
        body: payload.body,
      },
      data: payload.data || {},
      webpush: {
        headers: { Urgency: "high" },
        notification: {
          icon: "/icon-192x192.png",
          badge: "/badge-72x72.png",
          requireInteraction: payload.data?.type === "call_request",
        },
        fcmOptions: {
          link: payload.data?.click_action || "/chat",
        },
      },
      android: { 
        priority: "high",
        notification: {
          sound: "default",
          clickAction: "FLUTTER_NOTIFICATION_CLICK"
        }
      },
      apns: { 
        payload: { 
          aps: { 
            sound: "default", 
            badge: 1,
            contentAvailable: true 
          } 
        } 
      },
    };

    const response = await admin.messaging().send(message);
    return { success: true, messageId: response };
  } catch (error: any) {
    console.error("FCM Send Error:", error);
    return { success: false, error: error.code || error.message };
  }
}

/**
 * 통화 요청 알림 전송 (추가된 부분)
 */
export async function sendCallNotification(
  token: string, 
  senderName: string, 
  callType: string, 
  callId: string, 
  chatRoomId: string
) {
  const isVideo = callType === "VIDEO";
  return sendPushNotification(token, {
    title: `📞 ${senderName}님으로부터 통화 요청`,
    body: `${isVideo ? "영상 통화" : "음성 통화"} 요청이 왔습니다.`,
    data: {
      type: "call_request",
      callId,
      chatRoomId,
      callType,
      click_action: `/chat/${chatRoomId}?callId=${callId}`
    },
  });
}

/**
 * 채팅 메시지 알림 전송
 */
export async function sendChatMessageNotification(token: string, senderName: string, content: string, chatRoomId: string) {
  return sendPushNotification(token, {
    title: senderName,
    body: content || "새 메시지가 도착했습니다.",
    data: { 
      type: "chat_message", 
      chatRoomId, 
      click_action: `/chat/${chatRoomId}` 
    },
  });
}

/**
 * 파일 공유 알림 전송
 */
export async function sendFileSharedNotification(token: string, senderName: string, fileName: string, chatRoomId: string) {
  return sendPushNotification(token, {
    title: `📎 ${senderName}님의 파일 공유`,
    body: fileName,
    data: { 
      type: "file_shared", 
      chatRoomId, 
      click_action: `/chat/${chatRoomId}` 
    },
  });
}

export { admin };
</file>

<file path="src/lib/firebase.ts">
import { initializeApp, getApps, getApp } from "firebase/app";
import { getMessaging, getToken, onMessage, Messaging } from "firebase/messaging";

const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
};

// Firebase 앱 초기화 (서버 사이드 에러 방지)
const app = getApps().length === 0 ? initializeApp(firebaseConfig) : getApp();

let messaging: Messaging | null = null;

/**
 * 메시징 객체 초기화
 */
export const getFirebaseMessaging = () => {
  if (typeof window !== "undefined" && "serviceWorker" in navigator) {
    if (!messaging) {
      try {
        messaging = getMessaging(app);
      } catch (error) {
        console.error("Firebase Messaging 초기화 실패:", error);
      }
    }
  }
  return messaging;
};

/**
 * FCM 토큰 요청
 */
export async function requestNotificationPermission(): Promise<string | null> {
  try {
    if (typeof window === "undefined") return null;

    const permission = await Notification.requestPermission();
    if (permission !== "granted") {
      console.warn("⚠️ 알림 권한이 거부되었습니다.");
      return null;
    }

    const messaging = getFirebaseMessaging();
    if (!messaging) return null;

    // 1. 서비스 워커 등록 및 '준비' 상태 대기
    // 경로가 정확히 /firebase-messaging-sw.js 인지 확인하세요.
    const registration = await navigator.serviceWorker.register("/firebase-messaging-sw.js");
    
    // 서비스 워커가 활성화될 때까지 기다리는 로직 추가 (중요)
    while (registration.active?.state !== 'activated') {
      await new Promise(resolve => setTimeout(resolve, 100)); // 100ms씩 대기
      if (registration.installing?.state === 'redundant') break; 
    }

    console.log("✅ 서비스 워커 활성화 확인됨");

    // 2. 토큰 가져오기 (registration 객체를 직접 전달)
    const token = await getToken(messaging, {
      vapidKey: process.env.NEXT_PUBLIC_FIREBASE_VAPID_KEY,
      serviceWorkerRegistration: registration,
    });

    if (token) {
      console.log("✅ FCM 토큰 생성 성공:", token);
      return token;
    } 
    
    return null;
  } catch (error) {
    console.error("❌ FCM 토큰 요청 실패:", error);
    return null;
  }
}

/**
 * 포그라운드 메시지 수신 리스너 (앱을 켜놓고 있을 때)
 */
export function onForegroundMessage(callback: (payload: any) => void) {
  const messaging = getFirebaseMessaging();
  if (!messaging) return () => {};

  // 브라우저 탭이 활성화된 상태에서 푸시가 오면 이 로직이 실행됩니다.
  return onMessage(messaging, (payload) => {
    console.log("📬 포그라운드 메시지 수신:", payload);
    callback(payload);
  });
}

/**
 * FCM 토큰 서버 등록
 */
export async function registerFCMToken() {
  const token = await requestNotificationPermission();
  
  if (token) {
    try {
      const res = await fetch("/api/users/fcm-token", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ fcmToken: token }),
      });

      if (res.ok) {
        console.log("✅ FCM 토큰 서버 등록 성공");
        return true;
      }
    } catch (error) {
      console.error("FCM 토큰 서버 전송 오류:", error);
    }
  }
  return false;
}

/**
 * FCM 토큰 삭제
 */
export async function unregisterFCMToken() {
  try {
    const res = await fetch("/api/users/fcm-token", {
      method: "DELETE",
    });
    return res.ok;
  } catch (error) {
    console.error("FCM 토큰 삭제 오류:", error);
    return false;
  }
}
</file>

<file path="src/lib/rate-limit.ts">
import { NextRequest } from "next/server";

interface RateLimitStore {
  [key: string]: {
    count: number;
    resetTime: number;
  };
}

const store: RateLimitStore = {};

export function rateLimit(
  limit: number = 100, // 요청 횟수
  windowMs: number = 60 * 1000 // 시간 윈도우 (1분)
) {
  return async (request: NextRequest): Promise<{ success: boolean; remaining: number }> => {
    // IP 주소 또는 사용자 ID로 식별
    const identifier = request.headers.get("x-forwarded-for") || 
                      request.headers.get("x-real-ip") || 
                      "unknown";
    
    const now = Date.now();
    const record = store[identifier];

    // 첫 요청이거나 윈도우가 만료된 경우
    if (!record || now > record.resetTime) {
      store[identifier] = {
        count: 1,
        resetTime: now + windowMs,
      };
      return { success: true, remaining: limit - 1 };
    }

    // 제한 초과
    if (record.count >= limit) {
      return { success: false, remaining: 0 };
    }

    // 카운트 증가
    record.count++;
    return { success: true, remaining: limit - record.count };
  };
}

// 주기적으로 만료된 항목 정리
setInterval(() => {
  const now = Date.now();
  for (const key in store) {
    if (store[key].resetTime < now) {
      delete store[key];
    }
  }
}, 60 * 1000); // 1분마다
</file>

<file path="src/lib/sanitize.ts">
/**
 * XSS 방지를 위한 HTML 이스케이프
 */
export function escapeHtml(text: string): string {
  const map: { [key: string]: string } = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;',
  };
  
  return text.replace(/[&<>"']/g, (char) => map[char]);
}

/**
 * 파일명 sanitize (경로 조작 방지)
 */
export function sanitizeFilename(filename: string): string {
  // 위험한 문자 제거
  return filename
    .replace(/[\/\\]/g, '_')      // 슬래시 제거
    .replace(/\.\./g, '_')         // 상위 디렉토리 접근 방지
    .replace(/[<>:"|?*]/g, '_')    // 파일시스템 예약 문자
    .slice(0, 255);                // 길이 제한
}

/**
 * URL 파라미터 검증
 */
export function validateUrlParam(param: string, type: 'id' | 'email' | 'string'): boolean {
  switch (type) {
    case 'id':
      // CUID 형식 검증
      return /^c[a-z0-9]{24}$/.test(param);
    case 'email':
      return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(param);
    case 'string':
      return param.length > 0 && param.length <= 1000;
    default:
      return false;
  }
}
</file>

<file path="src/lib/webrtc.ts">
// WebRTC 연결 안정화 유틸리티
export const ICE_SERVERS = {
  iceServers: [
    { urls: "stun:stun.l.google.com:19302" },
    { urls: "stun:stun1.l.google.com:19302" },
    { urls: "stun:stun2.l.google.com:19302" },
  ],
};

export const getMediaStream = async (video: boolean = true) => {
  try {
    return await navigator.mediaDevices.getUserMedia({
      video,
      audio: true,
    });
  } catch (error) {
    console.error("Media access error:", error);
    return null;
  }
};
</file>

<file path="src/pages/api/socket/io.ts">
import { Server as NetServer } from "http";
import { NextApiRequest } from "next";
import { Server as ServerIO } from "socket.io";

// 만약 types 파일이 따로 없다면 아래 인터페이스를 상단에 추가하세요
import { NextApiResponse } from "next";
import { Socket } from "net";
import { Server as SocketIOServer } from "socket.io";

export type NextApiResponseServerIo = NextApiResponse & {
  socket: Socket & {
    server: NetServer & {
      io: SocketIOServer;
    };
  };
};

export const config = {
  api: {
    bodyParser: false,
  },
};

const ioHandler = (req: NextApiRequest, res: NextApiResponseServerIo) => {
  if (!res.socket.server.io) {
    const path = "/api/socket/io";
    const httpServer: NetServer = res.socket.server as any;
    const io = new ServerIO(httpServer, {
      path: path,
      addTrailingSlash: false,
      pingTimeout: 60000,
      cors: {
        origin: "*",
        methods: ["GET", "POST"],
      },
    });

    io.on("connection", (socket) => {
      // 룸 조인 및 기본 이벤트
      socket.on("join-room", (roomId: string) => {
        socket.join(roomId);
      });

      // 메시지 수신 및 전달
      socket.on("send-message", (data) => {
        io.to(data.roomId).emit("receive-message", data);
      });

      // WebRTC 시그널링
      socket.on("call-user", (data) => {
        socket.to(data.to).emit("call-made", { offer: data.offer, socket: socket.id });
      });
    });

    res.socket.server.io = io;
  }

  res.end();
};

export default ioHandler;
</file>

<file path="next.config.js">
// next.config.js (또는 next.config.mjs)
// Docker standalone 빌드 + 보안 헤더 설정

/** @type {import('next').NextConfig} */
const nextConfig = {
  // Docker 멀티스테이지 빌드용 — 최소 파일만 포함
  output: "standalone",

  // 이미지 최적화 도메인
  images: {
    remotePatterns: [
      { protocol: "https", hostname: "**" },
    ],
    formats: ["image/avif", "image/webp"],
  },

  // 실험적 기능
  experimental: {
    serverComponentsExternalPackages: ["sharp", "winston", "socket.io"],
  },

  // ── 보안 헤더 (Nginx가 없는 환경 대비) ──────────────────
  async headers() {
    return [
      {
        source: "/:path*",
        headers: [
          { key: "X-Frame-Options",        value: "SAMEORIGIN" },
          { key: "X-Content-Type-Options",  value: "nosniff" },
          { key: "Referrer-Policy",         value: "strict-origin-when-cross-origin" },
          { key: "Permissions-Policy",      value: "camera=(), microphone=(), geolocation=()" },
        ],
      },
      // 정적 파일 장기 캐시
      {
        source: "/_next/static/:path*",
        headers: [
          { key: "Cache-Control", value: "public, max-age=31536000, immutable" },
        ],
      },
    ];
  },

  // ── 리디렉션 ─────────────────────────────────────────────
  async redirects() {
    return [
      {
        source:      "/home",
        destination: "/dashboard",
        permanent:   true,
      },
    ];
  },

  // BigInt JSON 직렬화 경고 억제
  webpack(config) {
    config.resolve.fallback = { fs: false, path: false };
    return config;
  },
};

module.exports = nextConfig;
</file>

<file path="src/__tests__/lib/api-response.test.ts">
import { ok, created, paginated, ApiError, ErrorCode } from "@/lib/api-response";

describe("API 응답 빌더", () => {
  it("ok()는 success: true와 data를 반환해야 한다", async () => {
    const res  = ok({ id: "1", name: "파일" });
    const body = await res.json();
    expect(res.status).toBe(200);
    expect(body.success).toBe(true);
    expect(body.data).toEqual({ id: "1", name: "파일" });
  });

  it("created()는 201 상태 코드를 반환해야 한다", async () => {
    const res = created({ id: "new" });
    expect(res.status).toBe(201);
  });

  it("paginated()는 meta를 포함해야 한다", async () => {
    const res  = paginated(["a", "b"], { page: 1, limit: 10, total: 2, hasMore: false });
    const body = await res.json();
    expect(body.data).toHaveLength(2);
    expect(body.meta.total).toBe(2);
    expect(body.meta.hasMore).toBe(false);
  });

  it("ApiError.unauthorized()는 401과 올바른 코드를 반환해야 한다", async () => {
    const res  = ApiError.unauthorized();
    const body = await res.json();
    expect(res.status).toBe(401);
    expect(body.success).toBe(false);
    expect(body.code).toBe(ErrorCode.UNAUTHORIZED);
  });

  it("ApiError.notFound()는 리소스명을 포함해야 한다", async () => {
    const res  = ApiError.notFound("파일");
    const body = await res.json();
    expect(res.status).toBe(404);
    expect(body.error).toContain("파일");
  });

  it("ApiError.validation()은 details를 포함해야 한다", async () => {
    const res  = ApiError.validation("이메일 형식 오류", [{ field: "email", message: "invalid" }]);
    const body = await res.json();
    expect(res.status).toBe(422);
    expect(body.details).toBeDefined();
  });
});
</file>

<file path="src/__tests__/lib/cache.test.ts">
import cache, { withCache } from "@/lib/cache";

describe("MemoryCache", () => {
  beforeEach(() => {
    // 캐시 클리어 (내부 map 초기화 대신 만료된 키 제거 방식)
    jest.useFakeTimers();
  });
  afterEach(() => jest.useRealTimers());

  it("값을 저장하고 조회할 수 있어야 한다", () => {
    cache.set("test:1", { name: "이음" }, 60);
    expect(cache.get("test:1")).toEqual({ name: "이음" });
  });

  it("TTL 만료 후 null을 반환해야 한다", () => {
    cache.set("test:ttl", "value", 1); // 1초
    jest.advanceTimersByTime(2000);    // 2초 경과
    expect(cache.get("test:ttl")).toBeNull();
  });

  it("태그로 관련 캐시를 일괄 무효화해야 한다", () => {
    cache.set("a", 1, 60, ["tag:x"]);
    cache.set("b", 2, 60, ["tag:x"]);
    cache.set("c", 3, 60, ["tag:y"]);
    cache.invalidateByTag("tag:x");
    expect(cache.get("a")).toBeNull();
    expect(cache.get("b")).toBeNull();
    expect(cache.get("c")).toBe(3);
  });

  it("패턴으로 캐시를 무효화해야 한다", () => {
    cache.set("user:1:files", [], 60);
    cache.set("user:1:posts", [], 60);
    cache.set("user:2:files", [], 60);
    cache.invalidateByPattern("user:1:");
    expect(cache.get("user:1:files")).toBeNull();
    expect(cache.get("user:1:posts")).toBeNull();
    expect(cache.get("user:2:files")).toEqual([]);
  });
});

describe("withCache", () => {
  it("fetcher를 처음에만 실행하고 이후에는 캐시를 반환해야 한다", async () => {
    const fetcher = jest.fn().mockResolvedValue({ data: 42 });
    const key = `test:withcache:${Date.now()}`;

    const first  = await withCache(key, fetcher, 60);
    const second = await withCache(key, fetcher, 60);

    expect(first).toEqual({ data: 42 });
    expect(second).toEqual({ data: 42 });
    expect(fetcher).toHaveBeenCalledTimes(1); // 한 번만 실행
  });
});
</file>

<file path="src/__tests__/lib/components/ErrorBoundary.test.tsx">
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import { ErrorBoundary, SectionErrorBoundary } from "@/components/ErrorBoundary";

// 에러를 던지는 테스트용 컴포넌트
function Bomb({ shouldThrow }: { shouldThrow: boolean }) {
  if (shouldThrow) throw new Error("테스트 에러입니다");
  return <div>정상 렌더링</div>;
}

// console.error 억제 (에러 바운더리 테스트 시 노이즈 방지)
beforeEach(() => { jest.spyOn(console, "error").mockImplementation(() => {}); });
afterEach(() => jest.restoreAllMocks());

describe("ErrorBoundary", () => {
  it("에러 없으면 children을 렌더링해야 한다", () => {
    render(
      <ErrorBoundary level="section">
        <Bomb shouldThrow={false} />
      </ErrorBoundary>
    );
    expect(screen.getByText("정상 렌더링")).toBeInTheDocument();
  });

  it("에러 발생 시 fallback UI를 보여줘야 한다", () => {
    render(
      <ErrorBoundary level="section">
        <Bomb shouldThrow={true} />
      </ErrorBoundary>
    );
    expect(screen.getByText(/오류가 발생했습니다/)).toBeInTheDocument();
  });

  it("'다시 시도' 클릭 시 리셋되어야 한다", () => {
    const { rerender } = render(
      <ErrorBoundary level="section">
        <Bomb shouldThrow={true} />
      </ErrorBoundary>
    );
    fireEvent.click(screen.getByText("다시 시도"));
    rerender(
      <ErrorBoundary level="section">
        <Bomb shouldThrow={false} />
      </ErrorBoundary>
    );
    expect(screen.getByText("정상 렌더링")).toBeInTheDocument();
  });

  it("커스텀 fallback을 사용할 수 있어야 한다", () => {
    render(
      <ErrorBoundary level="section" fallback={<div>커스텀 에러 UI</div>}>
        <Bomb shouldThrow={true} />
      </ErrorBoundary>
    );
    expect(screen.getByText("커스텀 에러 UI")).toBeInTheDocument();
  });

  it("inline 레벨에서 재시도 버튼이 있어야 한다", () => {
    render(
      <ErrorBoundary level="inline">
        <Bomb shouldThrow={true} />
      </ErrorBoundary>
    );
    expect(screen.getByText("재시도")).toBeInTheDocument();
  });
});
</file>

<file path="src/__tests__/lib/components/MentionTextarea.test.tsx">
import { render as rtlRender, screen as rtlScreen, fireEvent as rtlFireEvent, waitFor } from "@testing-library/react";
import MentionTextarea from "@/components/MentionTextarea";

describe("MentionTextarea", () => {
  beforeEach(() => {
    (global.fetch as jest.Mock).mockResolvedValue({
      json: () => Promise.resolve({ users: [
        { id: "u1", name: "홍길동", isOnline: true },
        { id: "u2", name: "홍철수", isOnline: false },
      ]}),
    });
  });

  it("기본 텍스트 입력이 동작해야 한다", () => {
    const onChange = jest.fn();
    rtlRender(<MentionTextarea value="" onChange={onChange} />);
    const ta = rtlScreen.getByPlaceholderText("댓글을 입력하세요...");
    rtlFireEvent.change(ta, { target: { value: "안녕하세요" } });
    expect(onChange).toHaveBeenCalledWith("안녕하세요", []);
  });

  it("@를 입력하면 사용자 목록이 표시되어야 한다", async () => {
    const onChange = jest.fn();
    rtlRender(<MentionTextarea value="" onChange={onChange} />);
    const ta = rtlScreen.getByPlaceholderText("댓글을 입력하세요...");
    rtlFireEvent.change(ta, { target: { value: "@홍", selectionStart: 2 } });
    await waitFor(() => {
      expect(rtlScreen.getByText("홍길동")).toBeInTheDocument();
    });
  });
});
</file>

<file path="src/__tests__/lib/validators.test.ts">
import { registerSchema, createPostSchema, createCommentSchema } from "@/lib/validators";

describe("registerSchema", () => {
  const valid = { name: "홍길동", email: "test@eum.app", password: "Secure1!" };

  it("유효한 데이터를 통과시켜야 한다", () => {
    expect(registerSchema.safeParse(valid).success).toBe(true);
  });

  it("이름이 1자이면 실패해야 한다", () => {
    const r = registerSchema.safeParse({ ...valid, name: "홍" });
    expect(r.success).toBe(false);
  });

  it("이메일 형식이 잘못되면 실패해야 한다", () => {
    const r = registerSchema.safeParse({ ...valid, email: "not-an-email" });
    expect(r.success).toBe(false);
  });

  it("비밀번호에 특수문자가 없으면 실패해야 한다", () => {
    const r = registerSchema.safeParse({ ...valid, password: "Secure123" });
    expect(r.success).toBe(false);
  });

  it("비밀번호에 대문자가 없으면 실패해야 한다", () => {
    const r = registerSchema.safeParse({ ...valid, password: "secure1!" });
    expect(r.success).toBe(false);
  });
});

describe("createPostSchema", () => {
  it("제목이 비어있으면 실패해야 한다", () => {
    const r = createPostSchema.safeParse({ title: "", content: "내용" });
    expect(r.success).toBe(false);
  });

  it("visibility 기본값은 PUBLIC이어야 한다", () => {
    const r = createPostSchema.safeParse({ title: "제목", content: "내용" });
    expect(r.success).toBe(true);
    if (r.success) expect(r.data.visibility).toBe("PUBLIC");
  });

  it("허용되지 않은 visibility 값은 실패해야 한다", () => {
    const r = createPostSchema.safeParse({ title: "제목", content: "내용", visibility: "INVALID" });
    expect(r.success).toBe(false);
  });
});

describe("createCommentSchema", () => {
  it("빈 댓글은 실패해야 한다", () => {
    const r = createCommentSchema.safeParse({ content: "" });
    expect(r.success).toBe(false);
  });

  it("2000자 초과 댓글은 실패해야 한다", () => {
    const r = createCommentSchema.safeParse({ content: "a".repeat(2001) });
    expect(r.success).toBe(false);
  });

  it("mentionIds 없이도 유효해야 한다", () => {
    const r = createCommentSchema.safeParse({ content: "좋은 글이네요!" });
    expect(r.success).toBe(true);
  });
});
</file>

<file path="src/app/(auth)/signup/page.tsx">
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import Link from "next/link";

export default function SignupPage() {
  const router = useRouter();
  const [formData, setFormData] = useState({ name: "", email: "", password: "" });
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");
    setLoading(true);

    try {
      const res = await fetch("/api/auth/signup", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(formData),
      });
      const data = await res.json();
      if (!res.ok) {
        setError(data.error || "회원가입에 실패했습니다");
        setLoading(false);
        return;
      }
      // ✅ alert() 제거 → 로그인 페이지가 ?signup=success 쿼리 처리
      router.push("/login?signup=success");
    } catch {
      setError("서버 오류가 발생했습니다");
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">☁️ Personal Cloud</h2>
          <p className="mt-2 text-center text-sm text-gray-600">새 계정 만들기</p>
        </div>

        <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
          {error && (
            <div className="rounded-md bg-red-50 p-4">
              <p className="text-sm text-red-800">{error}</p>
            </div>
          )}

          <div className="rounded-md shadow-sm -space-y-px">
            <div>
              <label htmlFor="name" className="sr-only">이름</label>
              <input
                id="name" type="text" required
                value={formData.name}
                onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-t-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm"
                placeholder="이름"
              />
            </div>
            <div>
              <label htmlFor="email" className="sr-only">이메일</label>
              <input
                id="email" type="email" required
                value={formData.email}
                onChange={(e) => setFormData({ ...formData, email: e.target.value })}
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm"
                placeholder="이메일 주소"
              />
            </div>
            <div>
              <label htmlFor="password" className="sr-only">비밀번호</label>
              <input
                id="password" type="password" required
                value={formData.password}
                onChange={(e) => setFormData({ ...formData, password: e.target.value })}
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-b-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm"
                placeholder="비밀번호 (최소 8자)"
              />
            </div>
          </div>

          <button
            type="submit" disabled={loading}
            className="w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400"
          >
            {loading ? "처리 중..." : "회원가입"}
          </button>

          <div className="text-center">
            <p className="text-sm text-gray-600">
              이미 계정이 있으신가요?{" "}
              <Link href="/login" className="font-medium text-blue-600 hover:text-blue-500">로그인</Link>
            </p>
          </div>
        </form>
      </div>
    </div>
  );
}
</file>

<file path="src/app/activity-log/page.tsx">
"use client";

import { useState, useEffect, useCallback } from "react";
import Link from "next/link";
import {
  ChevronLeft, Activity, FileUp, Trash2, Download, Share2,
  FolderPlus, FolderMinus, FileText, MessageSquare, User,
  Lock, LogIn, LogOut, MessageCircle, Phone, PhoneOff,
  RefreshCw, ChevronLeft as Prev, ChevronRight as Next,
  Filter,
} from "lucide-react";
import { toast } from "@/components/Toast";
import { useConfirm } from "@/components/ConfirmDialog";

type ActivityAction =
  | "FILE_UPLOAD" | "FILE_DELETE" | "FILE_DOWNLOAD" | "FILE_SHARE"
  | "FOLDER_CREATE" | "FOLDER_DELETE"
  | "POST_CREATE" | "POST_DELETE"
  | "COMMENT_CREATE" | "COMMENT_DELETE"
  | "PROFILE_UPDATE" | "PASSWORD_CHANGE"
  | "LOGIN" | "LOGOUT"
  | "CHAT_MESSAGE" | "CALL_START" | "CALL_END";

interface ActivityLog {
  id: string;
  action: ActivityAction;
  target?: string;
  targetId?: string;
  meta?: Record<string, string>;
  createdAt: string;
}

const ACTION_META: Record<ActivityAction, { label: string; icon: React.ElementType; color: string; bg: string }> = {
  FILE_UPLOAD:    { label: "파일 업로드",    icon: FileUp,       color: "text-blue-600",   bg: "bg-blue-50 dark:bg-blue-900/30" },
  FILE_DELETE:    { label: "파일 삭제",      icon: Trash2,       color: "text-red-600",    bg: "bg-red-50 dark:bg-red-900/30" },
  FILE_DOWNLOAD:  { label: "파일 다운로드",  icon: Download,     color: "text-green-600",  bg: "bg-green-50 dark:bg-green-900/30" },
  FILE_SHARE:     { label: "파일 공유",      icon: Share2,       color: "text-purple-600", bg: "bg-purple-50 dark:bg-purple-900/30" },
  FOLDER_CREATE:  { label: "폴더 생성",      icon: FolderPlus,   color: "text-yellow-600", bg: "bg-yellow-50 dark:bg-yellow-900/30" },
  FOLDER_DELETE:  { label: "폴더 삭제",      icon: FolderMinus,  color: "text-red-600",    bg: "bg-red-50 dark:bg-red-900/30" },
  POST_CREATE:    { label: "게시글 작성",    icon: FileText,     color: "text-indigo-600", bg: "bg-indigo-50 dark:bg-indigo-900/30" },
  POST_DELETE:    { label: "게시글 삭제",    icon: Trash2,       color: "text-red-600",    bg: "bg-red-50 dark:bg-red-900/30" },
  COMMENT_CREATE: { label: "댓글 작성",      icon: MessageSquare,color: "text-cyan-600",   bg: "bg-cyan-50 dark:bg-cyan-900/30" },
  COMMENT_DELETE: { label: "댓글 삭제",      icon: Trash2,       color: "text-red-600",    bg: "bg-red-50 dark:bg-red-900/30" },
  PROFILE_UPDATE: { label: "프로필 수정",    icon: User,         color: "text-gray-600",   bg: "bg-gray-50 dark:bg-gray-800" },
  PASSWORD_CHANGE:{ label: "비밀번호 변경",  icon: Lock,         color: "text-orange-600", bg: "bg-orange-50 dark:bg-orange-900/30" },
  LOGIN:          { label: "로그인",         icon: LogIn,        color: "text-green-600",  bg: "bg-green-50 dark:bg-green-900/30" },
  LOGOUT:         { label: "로그아웃",       icon: LogOut,       color: "text-gray-600",   bg: "bg-gray-50 dark:bg-gray-800" },
  CHAT_MESSAGE:   { label: "채팅 메시지",    icon: MessageCircle,color: "text-purple-600", bg: "bg-purple-50 dark:bg-purple-900/30" },
  CALL_START:     { label: "통화 시작",      icon: Phone,        color: "text-blue-600",   bg: "bg-blue-50 dark:bg-blue-900/30" },
  CALL_END:       { label: "통화 종료",      icon: PhoneOff,     color: "text-gray-600",   bg: "bg-gray-50 dark:bg-gray-800" },
};

const ACTION_GROUPS = [
  { label: "전체", value: "" },
  { label: "파일", value: "FILE_UPLOAD" },
  { label: "공유", value: "FILE_SHARE" },
  { label: "게시글", value: "POST_CREATE" },
  { label: "로그인", value: "LOGIN" },
];

function timeAgo(dateStr: string) {
  const diff = Date.now() - new Date(dateStr).getTime();
  const m = Math.floor(diff / 60000);
  if (m < 1) return "방금 전";
  if (m < 60) return `${m}분 전`;
  const h = Math.floor(m / 60);
  if (h < 24) return `${h}시간 전`;
  return new Date(dateStr).toLocaleDateString("ko-KR", { month: "short", day: "numeric", hour: "2-digit", minute: "2-digit" });
}

export default function ActivityLogPage() {
  const { confirmDialog, openConfirm } = useConfirm();
  const [logs, setLogs] = useState<ActivityLog[]>([]);
  const [loading, setLoading] = useState(true);
  const [page, setPage] = useState(1);
  const [totalPages, setTotalPages] = useState(1);
  const [total, setTotal] = useState(0);
  const [filter, setFilter] = useState("");

  const fetchLogs = useCallback(async () => {
    setLoading(true);
    try {
      const params = new URLSearchParams({ page: String(page), limit: "30" });
      if (filter) params.set("action", filter);
      const res = await fetch(`/api/activity-logs?${params}`);
      if (!res.ok) throw new Error();
      const data = await res.json();
      setLogs(data.logs);
      setTotalPages(data.totalPages);
      setTotal(data.total);
    } catch {
      toast.error("활동 로그를 불러오지 못했습니다");
    } finally {
      setLoading(false);
    }
  }, [page, filter]);

  useEffect(() => { fetchLogs(); }, [fetchLogs]);
  useEffect(() => { setPage(1); }, [filter]);

  const clearLogs = async () => {
    const ok = await openConfirm({
      title: "활동 로그 전체 삭제",
      message: "모든 활동 내역을 삭제할까요? 복구할 수 없습니다.",
      confirmText: "삭제",
      confirmVariant: "danger",
    });
    if (!ok) return;
    await fetch("/api/activity-logs", { method: "DELETE" });
    setLogs([]);
    setTotal(0);
    toast.success("활동 로그를 삭제했습니다");
  };

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900">
      {confirmDialog}

      {/* 헤더 */}
      <div className="bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700 sticky top-0 z-10">
        <div className="max-w-2xl mx-auto px-4 py-3 flex items-center gap-3">
          <Link href="/profile" className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
            <ChevronLeft size={20} className="text-gray-600 dark:text-slate-400" />
          </Link>
          <Activity size={20} className="text-gray-800 dark:text-slate-200" />
          <h1 className="text-lg font-semibold text-gray-900 dark:text-slate-100 flex-1">
            활동 내역
            {total > 0 && <span className="ml-2 text-sm font-normal text-gray-500 dark:text-slate-400">({total}건)</span>}
          </h1>
          <button onClick={fetchLogs} className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
            <RefreshCw size={16} className="text-gray-500 dark:text-slate-400" />
          </button>
        </div>

        {/* 필터 탭 */}
        <div className="max-w-2xl mx-auto px-4 pb-2 flex gap-1 overflow-x-auto">
          {ACTION_GROUPS.map((g) => (
            <button
              key={g.value}
              onClick={() => setFilter(g.value)}
              className={`px-3 py-1.5 rounded-full text-xs font-medium whitespace-nowrap transition-colors ${
                filter === g.value
                  ? "bg-blue-600 text-white"
                  : "text-gray-500 dark:text-slate-400 hover:bg-gray-100 dark:hover:bg-slate-700"
              }`}
            >
              {g.label}
            </button>
          ))}
        </div>
      </div>

      <div className="max-w-2xl mx-auto px-4 py-4">
        {/* 전체 삭제 */}
        {logs.length > 0 && (
          <div className="flex justify-end mb-3">
            <button
              onClick={clearLogs}
              className="flex items-center gap-1.5 text-xs text-red-500 hover:text-red-600 font-medium px-3 py-1.5 rounded-lg hover:bg-red-50 dark:hover:bg-red-900/20 transition-colors"
            >
              <Trash2 size={12} /> 전체 삭제
            </button>
          </div>
        )}

        {/* 로그 목록 */}
        {loading ? (
          <div className="space-y-2">
            {[...Array(8)].map((_, i) => (
              <div key={i} className="bg-white dark:bg-slate-800 rounded-xl p-4 animate-pulse flex gap-3">
                <div className="w-9 h-9 rounded-full bg-gray-200 dark:bg-slate-700 shrink-0" />
                <div className="flex-1 space-y-2">
                  <div className="h-3.5 bg-gray-200 dark:bg-slate-700 rounded w-1/3" />
                  <div className="h-3 bg-gray-100 dark:bg-slate-700/50 rounded w-1/2" />
                </div>
              </div>
            ))}
          </div>
        ) : logs.length === 0 ? (
          <div className="flex flex-col items-center justify-center py-24 text-center">
            <div className="w-16 h-16 rounded-full bg-gray-100 dark:bg-slate-800 flex items-center justify-center mb-4">
              <Activity size={28} className="text-gray-400 dark:text-slate-500" />
            </div>
            <p className="text-gray-500 dark:text-slate-400 font-medium">활동 내역이 없습니다</p>
          </div>
        ) : (
          <>
            <div className="space-y-2">
              {logs.map((log) => {
                const meta = ACTION_META[log.action];
                const Icon = meta.icon;
                return (
                  <div key={log.id} className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 px-4 py-3 flex items-center gap-3">
                    <div className={`w-9 h-9 rounded-full flex items-center justify-center shrink-0 ${meta.bg}`}>
                      <Icon size={15} className={meta.color} />
                    </div>
                    <div className="flex-1 min-w-0">
                      <p className="text-sm font-medium text-gray-900 dark:text-slate-100">{meta.label}</p>
                      {log.target && (
                        <p className="text-xs text-gray-500 dark:text-slate-400 truncate">{log.target}</p>
                      )}
                      {log.meta?.ip && (
                        <p className="text-[10px] text-gray-400 dark:text-slate-500 mt-0.5">IP: {log.meta.ip}</p>
                      )}
                    </div>
                    <span className="text-xs text-gray-400 dark:text-slate-500 shrink-0">{timeAgo(log.createdAt)}</span>
                  </div>
                );
              })}
            </div>

            {/* 페이지네이션 */}
            {totalPages > 1 && (
              <div className="flex items-center justify-center gap-3 mt-6">
                <button
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page === 1}
                  className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 disabled:opacity-30 transition-colors"
                >
                  <Prev size={16} className="text-gray-600 dark:text-slate-400" />
                </button>
                <span className="text-sm text-gray-600 dark:text-slate-400">
                  {page} / {totalPages}
                </span>
                <button
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page === totalPages}
                  className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 disabled:opacity-30 transition-colors"
                >
                  <Next size={16} className="text-gray-600 dark:text-slate-400" />
                </button>
              </div>
            )}
          </>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/app/admin/page.tsx">
"use client";

import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import { useEffect, useState, useCallback } from "react";
import Link from "next/link";
import {
  Users,
  Files,
  MessageSquare,
  BarChart2,
  ShieldAlert,
  ChevronLeft,
  Search,
  UserX,
  UserCheck,
  Trash2,
  RefreshCw,
  Crown,
  User,
} from "lucide-react";
import { toast } from "@/components/Toast";
import { useConfirm } from "@/components/ConfirmDialog";

interface UserRow {
  id: string;
  name: string;
  email: string;
  role: "USER" | "ADMIN";
  emailVerified: boolean;
  isOnline: boolean;
  createdAt: string;
  _count: { files: number; posts: number; comments: number };
}

interface Stats {
  totalUsers: number;
  totalFiles: number;
  totalPosts: number;
  totalComments: number;
  onlineUsers: number;
  adminCount: number;
}

export default function AdminPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const { confirmDialog, openConfirm } = useConfirm();

  const [users, setUsers] = useState<UserRow[]>([]);
  const [stats, setStats] = useState<Stats | null>(null);
  const [loading, setLoading] = useState(true);
  const [search, setSearch] = useState("");
  const [roleFilter, setRoleFilter] = useState<"ALL" | "USER" | "ADMIN">("ALL");
  const [actionLoading, setActionLoading] = useState<string | null>(null);

  // 권한 체크
  useEffect(() => {
    if (status === "loading") return;
    if (!session?.user || (session.user as any).role !== "ADMIN") {
      router.replace("/dashboard");
    }
  }, [session, status, router]);

  const fetchData = useCallback(async () => {
    setLoading(true);
    try {
      const [usersRes, statsRes] = await Promise.all([
        fetch("/api/admin/users"),
        fetch("/api/admin/stats"),
      ]);
      if (usersRes.ok) setUsers(await usersRes.json());
      if (statsRes.ok) setStats(await statsRes.json());
    } catch {
      toast.error("데이터를 불러오지 못했습니다");
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  // 역할 변경 (USER ↔ ADMIN)
  const toggleRole = async (user: UserRow) => {
    const newRole = user.role === "ADMIN" ? "USER" : "ADMIN";
    const confirmed = await openConfirm({
      title: "역할 변경",
      message: `${user.name}님을 ${newRole === "ADMIN" ? "관리자" : "일반 사용자"}로 변경할까요?`,
      confirmText: "변경",
      confirmVariant: "primary",
    });
    if (!confirmed) return;

    setActionLoading(user.id);
    try {
      const res = await fetch(`/api/admin/users/${user.id}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ role: newRole }),
      });
      if (!res.ok) throw new Error();
      setUsers((prev) =>
        prev.map((u) => (u.id === user.id ? { ...u, role: newRole } : u))
      );
      toast.success(`역할을 ${newRole === "ADMIN" ? "관리자" : "일반 사용자"}로 변경했습니다`);
    } catch {
      toast.error("역할 변경에 실패했습니다");
    } finally {
      setActionLoading(null);
    }
  };

  // 계정 삭제
  const deleteUser = async (user: UserRow) => {
    if (user.id === session?.user?.id) {
      toast.error("자신의 계정은 삭제할 수 없습니다");
      return;
    }
    const confirmed = await openConfirm({
      title: "계정 삭제",
      message: `${user.name}님의 계정을 삭제할까요? 모든 데이터가 영구 삭제됩니다.`,
      confirmText: "삭제",
      confirmVariant: "danger",
    });
    if (!confirmed) return;

    setActionLoading(user.id);
    try {
      const res = await fetch(`/api/admin/users/${user.id}`, { method: "DELETE" });
      if (!res.ok) throw new Error();
      setUsers((prev) => prev.filter((u) => u.id !== user.id));
      if (stats) setStats({ ...stats, totalUsers: stats.totalUsers - 1 });
      toast.success("계정을 삭제했습니다");
    } catch {
      toast.error("삭제에 실패했습니다");
    } finally {
      setActionLoading(null);
    }
  };

  const filtered = users.filter((u) => {
    const matchSearch =
      u.name.toLowerCase().includes(search.toLowerCase()) ||
      u.email.toLowerCase().includes(search.toLowerCase());
    const matchRole = roleFilter === "ALL" || u.role === roleFilter;
    return matchSearch && matchRole;
  });

  if (status === "loading" || (session && (session.user as any)?.role !== "ADMIN")) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600" />
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900 dark:bg-slate-900">
      {confirmDialog}

      {/* 헤더 */}
      <div className="bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700 dark:border-slate-700 sticky top-0 z-10">
        <div className="max-w-6xl mx-auto px-4 py-3 flex items-center gap-3">
          <Link href="/dashboard" className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 dark:bg-slate-700 transition-colors">
            <ChevronLeft size={20} className="text-gray-600 dark:text-slate-400" />
          </Link>
          <ShieldAlert size={20} className="text-red-500" />
          <h1 className="text-lg font-semibold text-gray-900 dark:text-slate-100 flex-1">관리자 대시보드</h1>
          <button
            onClick={fetchData}
            className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 dark:bg-slate-700 transition-colors"
          >
            <RefreshCw size={16} className="text-gray-500 dark:text-slate-400" />
          </button>
        </div>
      </div>

      <div className="max-w-6xl mx-auto px-4 py-6 space-y-6">
        {/* 통계 카드 */}
        {stats && (
          <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-3">
            {[
              { label: "전체 사용자", value: stats.totalUsers, icon: Users, color: "text-blue-600", bg: "bg-blue-50" },
              { label: "접속 중", value: stats.onlineUsers, icon: UserCheck, color: "text-green-600", bg: "bg-green-50" },
              { label: "관리자", value: stats.adminCount, icon: Crown, color: "text-yellow-600", bg: "bg-yellow-50" },
              { label: "파일 수", value: stats.totalFiles, icon: Files, color: "text-purple-600", bg: "bg-purple-50" },
              { label: "게시글 수", value: stats.totalPosts, icon: BarChart2, color: "text-orange-600", bg: "bg-orange-50" },
              { label: "댓글 수", value: stats.totalComments, icon: MessageSquare, color: "text-pink-600", bg: "bg-pink-50" },
            ].map((s) => {
              const Icon = s.icon;
              return (
                <div key={s.label} className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 dark:border-slate-700 p-4">
                  <div className={`w-8 h-8 rounded-lg ${s.bg} flex items-center justify-center mb-2`}>
                    <Icon size={16} className={s.color} />
                  </div>
                  <p className="text-2xl font-bold text-gray-900 dark:text-slate-100">{s.value.toLocaleString()}</p>
                  <p className="text-xs text-gray-500 dark:text-slate-400 mt-0.5">{s.label}</p>
                </div>
              );
            })}
          </div>
        )}

        {/* 사용자 관리 */}
        <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 dark:border-slate-700">
          <div className="p-4 border-b border-gray-100 dark:border-slate-700">
            <h2 className="font-semibold text-gray-900 dark:text-slate-100 mb-3">사용자 관리</h2>
            <div className="flex gap-2 flex-wrap">
              {/* 검색 */}
              <div className="relative flex-1 min-w-48">
                <Search size={14} className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400 dark:text-slate-500" />
                <input
                  type="text"
                  placeholder="이름 또는 이메일 검색"
                  value={search}
                  onChange={(e) => setSearch(e.target.value)}
                  className="w-full pl-8 pr-3 py-2 text-sm border border-gray-200 dark:border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
              </div>
              {/* 역할 필터 */}
              <div className="flex gap-1">
                {(["ALL", "USER", "ADMIN"] as const).map((r) => (
                  <button
                    key={r}
                    onClick={() => setRoleFilter(r)}
                    className={`px-3 py-2 text-xs font-medium rounded-lg transition-colors ${
                      roleFilter === r
                        ? "bg-blue-600 text-white"
                        : "bg-gray-100 dark:bg-slate-700 text-gray-600 dark:text-slate-400 hover:bg-gray-200"
                    }`}
                  >
                    {r === "ALL" ? "전체" : r === "USER" ? "일반" : "관리자"}
                  </button>
                ))}
              </div>
            </div>
          </div>

          {/* 테이블 */}
          <div className="overflow-x-auto">
            {loading ? (
              <div className="p-8 flex justify-center">
                <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600" />
              </div>
            ) : filtered.length === 0 ? (
              <div className="p-8 text-center text-gray-400 dark:text-slate-500 text-sm">
                검색 결과가 없습니다
              </div>
            ) : (
              <table className="w-full text-sm">
                <thead>
                  <tr className="border-b border-gray-100 dark:border-slate-700 bg-gray-50 dark:bg-slate-900">
                    <th className="text-left px-4 py-3 text-xs font-semibold text-gray-500 dark:text-slate-400">사용자</th>
                    <th className="text-left px-4 py-3 text-xs font-semibold text-gray-500 dark:text-slate-400">역할</th>
                    <th className="text-left px-4 py-3 text-xs font-semibold text-gray-500 dark:text-slate-400 hidden md:table-cell">활동</th>
                    <th className="text-left px-4 py-3 text-xs font-semibold text-gray-500 dark:text-slate-400 hidden lg:table-cell">가입일</th>
                    <th className="text-left px-4 py-3 text-xs font-semibold text-gray-500 dark:text-slate-400">상태</th>
                    <th className="text-right px-4 py-3 text-xs font-semibold text-gray-500 dark:text-slate-400">액션</th>
                  </tr>
                </thead>
                <tbody>
                  {filtered.map((u) => (
                    <tr key={u.id} className="border-b border-gray-50 hover:bg-gray-50 dark:hover:bg-slate-700 dark:bg-slate-900 transition-colors">
                      <td className="px-4 py-3">
                        <div className="flex items-center gap-2">
                          <div className="w-8 h-8 rounded-full bg-gradient-to-br from-blue-400 to-purple-500 flex items-center justify-center text-white text-xs font-bold shrink-0">
                            {u.name[0]}
                          </div>
                          <div>
                            <p className="font-medium text-gray-900 dark:text-slate-100 flex items-center gap-1">
                              {u.name}
                              {u.id === session?.user?.id && (
                                <span className="text-[9px] bg-blue-100 text-blue-600 px-1 rounded">나</span>
                              )}
                            </p>
                            <p className="text-xs text-gray-400 dark:text-slate-500">{u.email}</p>
                          </div>
                        </div>
                      </td>
                      <td className="px-4 py-3">
                        <span className={`text-xs font-semibold px-2 py-1 rounded-full ${
                          u.role === "ADMIN"
                            ? "bg-yellow-100 text-yellow-700"
                            : "bg-gray-100 dark:bg-slate-700 text-gray-600 dark:text-slate-400"
                        }`}>
                          {u.role === "ADMIN" ? "👑 관리자" : "일반"}
                        </span>
                      </td>
                      <td className="px-4 py-3 hidden md:table-cell">
                        <div className="text-xs text-gray-500 dark:text-slate-400 space-y-0.5">
                          <div>파일 {u._count.files}개</div>
                          <div>게시글 {u._count.posts}개</div>
                        </div>
                      </td>
                      <td className="px-4 py-3 hidden lg:table-cell text-xs text-gray-500 dark:text-slate-400">
                        {new Date(u.createdAt).toLocaleDateString("ko-KR")}
                      </td>
                      <td className="px-4 py-3">
                        <div className="flex items-center gap-1.5">
                          <span className={`w-2 h-2 rounded-full ${u.isOnline ? "bg-green-500" : "bg-gray-300"}`} />
                          <span className="text-xs text-gray-500 dark:text-slate-400">{u.isOnline ? "온라인" : "오프라인"}</span>
                        </div>
                      </td>
                      <td className="px-4 py-3">
                        <div className="flex items-center justify-end gap-1">
                          <button
                            onClick={() => toggleRole(u)}
                            disabled={actionLoading === u.id || u.id === session?.user?.id}
                            title={u.role === "ADMIN" ? "일반 사용자로 변경" : "관리자로 승격"}
                            className="p-1.5 rounded-lg hover:bg-yellow-50 text-yellow-600 hover:text-yellow-700 transition-colors disabled:opacity-30 disabled:cursor-not-allowed"
                          >
                            {u.role === "ADMIN" ? <User size={14} /> : <Crown size={14} />}
                          </button>
                          <button
                            onClick={() => deleteUser(u)}
                            disabled={actionLoading === u.id || u.id === session?.user?.id}
                            title="계정 삭제"
                            className="p-1.5 rounded-lg hover:bg-red-50 text-red-400 hover:text-red-500 transition-colors disabled:opacity-30 disabled:cursor-not-allowed"
                          >
                            <Trash2 size={14} />
                          </button>
                        </div>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            )}
          </div>

          <div className="px-4 py-3 border-t border-gray-100 dark:border-slate-700 text-xs text-gray-400 dark:text-slate-500">
            총 {filtered.length}명 / {users.length}명
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/admin/stats/page.tsx">
"use client";
// src/app/admin/stats/page.tsx — 관리자 통계 & 관리 대시보드

import { useState, useEffect, useCallback } from "react";
import Link from "next/link";
import {
  ChevronLeft, Users, HardDrive, FileText, MessageSquare,
  TrendingUp, Ban, Bell, RefreshCw, Plus, Trash2, X,
  AlertTriangle, CheckCircle, Info, Wrench,
} from "lucide-react";
import { formatFileSize } from "@/lib/client-utils";
import { toast } from "@/components/Toast";
import { useConfirm } from "@/components/ConfirmDialog";

interface Stats {
  summary: {
    totalUsers: number; activeUsers: number; bannedUsers: number;
    totalFiles: number; totalStorage: string;
    totalPosts: number; totalComments: number;
    newUsersLast30: number; newFilesLast30: number;
  };
  topStorageUsers: { id: string; name: string; email: string; storageUsed: string }[];
  filesByType: { type: string; count: number; size: string }[];
  dailySignups: { date: string; count: number }[];
  dailyUploads: { date: string; count: number }[];
}

interface Notice {
  id: string; title: string; content: string; type: string;
  isActive: boolean; endsAt: string | null; createdAt: string;
}

const NOTICE_ICONS = {
  INFO:        <Info size={14} className="text-blue-500" />,
  WARNING:     <AlertTriangle size={14} className="text-amber-500" />,
  MAINTENANCE: <Wrench size={14} className="text-purple-500" />,
};

// 간단한 바 차트 컴포넌트
function MiniBarChart({ data, label }: { data: { date: string; count: number }[]; label: string }) {
  const max = Math.max(...data.map((d) => d.count), 1);
  return (
    <div>
      <p className="text-xs font-semibold text-gray-500 dark:text-slate-400 mb-3">{label}</p>
      <div className="flex items-end gap-1 h-20">
        {data.slice(-14).map((d, i) => (
          <div key={i} className="flex-1 flex flex-col items-center gap-1 group relative">
            <div
              className="w-full bg-blue-500/20 dark:bg-blue-400/20 hover:bg-blue-500/40 rounded-sm transition-all"
              style={{ height: `${Math.max((d.count / max) * 100, 4)}%` }}
            />
            <div className="absolute bottom-full mb-1 hidden group-hover:block bg-gray-800 text-white text-[10px] px-1.5 py-0.5 rounded whitespace-nowrap z-10">
              {d.date}: {d.count}
            </div>
          </div>
        ))}
      </div>
      <div className="flex justify-between mt-1 text-[9px] text-gray-400 dark:text-slate-500">
        <span>{data[0]?.date?.slice(5)}</span>
        <span>{data[data.length - 1]?.date?.slice(5)}</span>
      </div>
    </div>
  );
}

export default function AdminStatsPage() {
  const { confirmDialog, openConfirm } = useConfirm();
  const [stats, setStats] = useState<Stats | null>(null);
  const [notices, setNotices] = useState<Notice[]>([]);
  const [loading, setLoading] = useState(true);
  const [tab, setTab] = useState<"overview" | "users" | "notices">("overview");

  // 공지 폼
  const [showNoticeForm, setShowNoticeForm] = useState(false);
  const [noticeForm, setNoticeForm] = useState({ title: "", content: "", type: "INFO", endsAt: "" });
  const [savingNotice, setSavingNotice] = useState(false);

  const fetchAll = useCallback(async () => {
    setLoading(true);
    try {
      const [statsRes, noticesRes] = await Promise.all([
        fetch("/api/admin/stats"),
        fetch("/api/admin/notices"),
      ]);
      if (statsRes.ok) setStats(await statsRes.json());
      if (noticesRes.ok) setNotices((await noticesRes.json()).notices ?? []);
    } catch { toast.error("데이터를 불러오지 못했습니다"); }
    finally { setLoading(false); }
  }, []);

  useEffect(() => { fetchAll(); }, [fetchAll]);

  const banUser = async (id: string, name: string) => {
    const ok = await openConfirm({ title: "사용자 정지", message: `${name}을 정지하시겠습니까?`, confirmText: "정지", confirmVariant: "danger" });
    if (!ok) return;
    const res = await fetch(`/api/admin/users/${id}/ban`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ reason: "관리자 결정" }) });
    if (res.ok) { toast.success(`${name}이 정지되었습니다`); fetchAll(); }
  };

  const unbanUser = async (id: string, name: string) => {
    const res = await fetch(`/api/admin/users/${id}/ban`, { method: "DELETE" });
    if (res.ok) { toast.success(`${name}의 정지가 해제되었습니다`); fetchAll(); }
  };

  const saveNotice = async () => {
    if (!noticeForm.title.trim() || !noticeForm.content.trim()) { toast.error("제목과 내용을 입력해주세요"); return; }
    setSavingNotice(true);
    try {
      const res = await fetch("/api/admin/notices", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(noticeForm) });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error);
      setNotices((n) => [data.notice, ...n]);
      setShowNoticeForm(false);
      setNoticeForm({ title: "", content: "", type: "INFO", endsAt: "" });
      toast.success("공지가 등록되었습니다");
    } catch (e: any) { toast.error(e.message); }
    finally { setSavingNotice(false); }
  };

  const deleteNotice = async (id: string) => {
    const ok = await openConfirm({ title: "공지 삭제", message: "이 공지를 삭제하시겠습니까?", confirmText: "삭제", confirmVariant: "danger" });
    if (!ok) return;
    await fetch(`/api/admin/notices/${id}`, { method: "DELETE" });
    setNotices((n) => n.filter((x) => x.id !== id));
    toast.success("공지가 삭제되었습니다");
  };

  const s = stats?.summary;

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900">
      {confirmDialog}

      {/* 헤더 */}
      <div className="bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700 sticky top-0 z-10">
        <div className="max-w-5xl mx-auto px-4 py-3 flex items-center gap-3">
          <Link href="/admin" className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
            <ChevronLeft size={20} className="text-gray-600 dark:text-slate-400" />
          </Link>
          <TrendingUp size={20} className="text-gray-800 dark:text-slate-200" />
          <h1 className="text-lg font-semibold text-gray-900 dark:text-slate-100 flex-1">통계 & 관리</h1>
          <button onClick={fetchAll} className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700">
            <RefreshCw size={16} className={`text-gray-500 dark:text-slate-400 ${loading ? "animate-spin" : ""}`} />
          </button>
        </div>
        {/* 탭 */}
        <div className="max-w-5xl mx-auto px-4 flex gap-1 pb-1">
          {(["overview", "users", "notices"] as const).map((t) => (
            <button key={t} onClick={() => setTab(t)}
              className={`px-4 py-2 text-xs font-semibold rounded-lg transition ${tab === t ? "bg-blue-600 text-white" : "text-gray-500 dark:text-slate-400 hover:bg-gray-100 dark:hover:bg-slate-700"}`}>
              {{ overview: "📊 개요", users: "👥 사용자", notices: "📢 공지" }[t]}
            </button>
          ))}
        </div>
      </div>

      <div className="max-w-5xl mx-auto px-4 py-6">

        {/* ── 개요 탭 ── */}
        {tab === "overview" && (
          <div className="space-y-5">
            {/* KPI 카드 */}
            <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
              {[
                { label: "전체 사용자", value: s?.totalUsers ?? 0, sub: `신규 +${s?.newUsersLast30 ?? 0}/30일`, icon: Users, color: "text-blue-600", bg: "bg-blue-50 dark:bg-blue-900/20" },
                { label: "전체 파일", value: s?.totalFiles ?? 0, sub: `신규 +${s?.newFilesLast30 ?? 0}/30일`, icon: HardDrive, color: "text-green-600", bg: "bg-green-50 dark:bg-green-900/20" },
                { label: "총 저장 용량", value: formatFileSize(s?.totalStorage ?? "0"), sub: "사용 중", icon: HardDrive, color: "text-purple-600", bg: "bg-purple-50 dark:bg-purple-900/20" },
                { label: "게시글", value: s?.totalPosts ?? 0, sub: `댓글 ${s?.totalComments ?? 0}개`, icon: FileText, color: "text-orange-600", bg: "bg-orange-50 dark:bg-orange-900/20" },
              ].map(({ label, value, sub, icon: Icon, color, bg }) => (
                <div key={label} className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-4">
                  <div className={`w-9 h-9 rounded-xl ${bg} flex items-center justify-center mb-3`}>
                    <Icon size={18} className={color} />
                  </div>
                  <p className="text-2xl font-black text-gray-900 dark:text-slate-100">{value.toLocaleString()}</p>
                  <p className="text-xs font-medium text-gray-600 dark:text-slate-300 mt-0.5">{label}</p>
                  <p className="text-[10px] text-gray-400 dark:text-slate-500 mt-0.5">{sub}</p>
                </div>
              ))}
            </div>

            {/* 차트 */}
            <div className="grid md:grid-cols-2 gap-4">
              <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-5">
                {stats?.dailySignups && stats.dailySignups.length > 0
                  ? <MiniBarChart data={stats.dailySignups} label="일별 신규 가입자 (최근 14일)" />
                  : <p className="text-xs text-gray-400 dark:text-slate-500 text-center py-8">데이터 없음</p>}
              </div>
              <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-5">
                {stats?.dailyUploads && stats.dailyUploads.length > 0
                  ? <MiniBarChart data={stats.dailyUploads} label="일별 파일 업로드 (최근 14일)" />
                  : <p className="text-xs text-gray-400 dark:text-slate-500 text-center py-8">데이터 없음</p>}
              </div>
            </div>

            {/* 파일 타입 분포 */}
            {stats?.filesByType && (
              <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-5">
                <p className="text-xs font-semibold text-gray-500 dark:text-slate-400 mb-4">파일 타입별 분포</p>
                <div className="space-y-2">
                  {stats.filesByType.map(({ type, count, size }) => {
                    const total = stats.filesByType.reduce((a, b) => a + b.count, 0);
                    const pct = total > 0 ? Math.round((count / total) * 100) : 0;
                    return (
                      <div key={type} className="flex items-center gap-3">
                        <span className="text-xs text-gray-700 dark:text-slate-300 w-12">{type}</span>
                        <div className="flex-1 h-2 bg-gray-100 dark:bg-slate-700 rounded-full overflow-hidden">
                          <div className="h-full bg-blue-500 rounded-full" style={{ width: `${pct}%` }} />
                        </div>
                        <span className="text-xs text-gray-500 dark:text-slate-400 w-16 text-right">{count}개 ({pct}%)</span>
                        <span className="text-[10px] text-gray-400 dark:text-slate-500 w-16 text-right">{formatFileSize(size)}</span>
                      </div>
                    );
                  })}
                </div>
              </div>
            )}

            {/* 저장 사용량 Top 10 */}
            {stats?.topStorageUsers && (
              <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-5">
                <p className="text-xs font-semibold text-gray-500 dark:text-slate-400 mb-4">저장 사용량 Top 10</p>
                <div className="divide-y divide-gray-100 dark:divide-slate-700">
                  {stats.topStorageUsers.map((u, i) => (
                    <div key={u.id} className="flex items-center gap-3 py-2.5">
                      <span className="text-xs font-bold text-gray-400 dark:text-slate-500 w-5">{i + 1}</span>
                      <div className="flex-1 min-w-0">
                        <p className="text-sm font-medium text-gray-900 dark:text-slate-100 truncate">{u.name}</p>
                        <p className="text-[10px] text-gray-400 dark:text-slate-500 truncate">{u.email}</p>
                      </div>
                      <span className="text-xs font-semibold text-gray-700 dark:text-slate-300">{formatFileSize(u.storageUsed)}</span>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        )}

        {/* ── 사용자 탭 ── */}
        {tab === "users" && (
          <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700">
            <div className="px-5 py-4 border-b border-gray-100 dark:border-slate-700 flex items-center justify-between">
              <p className="text-sm font-semibold text-gray-900 dark:text-slate-100">저장 사용량 상위 사용자</p>
              {s && <span className="text-xs text-gray-400 dark:text-slate-500">정지: {s.bannedUsers}명</span>}
            </div>
            <div className="divide-y divide-gray-100 dark:divide-slate-700">
              {(stats?.topStorageUsers ?? []).map((u) => (
                <div key={u.id} className="flex items-center gap-3 px-5 py-3">
                  <div className="w-9 h-9 rounded-full bg-gradient-to-br from-blue-400 to-purple-500 flex items-center justify-center text-white text-sm font-bold shrink-0">
                    {u.name[0]}
                  </div>
                  <div className="flex-1 min-w-0">
                    <p className="text-sm font-medium text-gray-900 dark:text-slate-100 truncate">{u.name}</p>
                    <p className="text-xs text-gray-400 dark:text-slate-500 truncate">{u.email} · {formatFileSize(u.storageUsed)}</p>
                  </div>
                  <div className="flex gap-2 shrink-0">
                    <button onClick={() => banUser(u.id, u.name)}
                      className="flex items-center gap-1 px-2.5 py-1.5 text-xs font-semibold text-red-600 bg-red-50 dark:bg-red-900/20 hover:bg-red-100 rounded-lg transition">
                      <Ban size={11} /> 정지
                    </button>
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}

        {/* ── 공지 탭 ── */}
        {tab === "notices" && (
          <div className="space-y-4">
            <div className="flex justify-end">
              <button onClick={() => setShowNoticeForm(true)}
                className="flex items-center gap-1.5 px-4 py-2 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-xl transition">
                <Plus size={14} /> 공지 등록
              </button>
            </div>

            {/* 공지 등록 폼 */}
            {showNoticeForm && (
              <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-5 space-y-4">
                <div className="flex items-center justify-between">
                  <h3 className="text-sm font-bold text-gray-900 dark:text-slate-100">새 공지 등록</h3>
                  <button onClick={() => setShowNoticeForm(false)} className="text-gray-400 hover:text-gray-600 dark:hover:text-slate-300"><X size={16} /></button>
                </div>
                <div className="flex gap-2">
                  {["INFO", "WARNING", "MAINTENANCE"].map((t) => (
                    <button key={t} onClick={() => setNoticeForm((f) => ({ ...f, type: t }))}
                      className={`px-3 py-1.5 text-xs font-semibold rounded-lg transition ${noticeForm.type === t ? "bg-blue-600 text-white" : "bg-gray-100 dark:bg-slate-700 text-gray-600 dark:text-slate-400"}`}>
                      {t === "INFO" ? "ℹ️ 안내" : t === "WARNING" ? "⚠️ 경고" : "🔧 점검"}
                    </button>
                  ))}
                </div>
                <input type="text" value={noticeForm.title} onChange={(e) => setNoticeForm((f) => ({ ...f, title: e.target.value }))}
                  placeholder="공지 제목" className="w-full px-4 py-2.5 text-sm border border-gray-200 dark:border-slate-600 rounded-xl bg-white dark:bg-slate-700 dark:text-slate-100 focus:outline-none focus:ring-2 focus:ring-blue-500" />
                <textarea value={noticeForm.content} onChange={(e) => setNoticeForm((f) => ({ ...f, content: e.target.value }))}
                  placeholder="공지 내용" rows={3}
                  className="w-full px-4 py-2.5 text-sm border border-gray-200 dark:border-slate-600 rounded-xl bg-white dark:bg-slate-700 dark:text-slate-100 focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none" />
                <div className="flex items-center gap-3">
                  <label className="text-xs text-gray-500 dark:text-slate-400">종료일:</label>
                  <input type="datetime-local" value={noticeForm.endsAt} onChange={(e) => setNoticeForm((f) => ({ ...f, endsAt: e.target.value }))}
                    className="text-xs border border-gray-200 dark:border-slate-600 rounded-lg px-3 py-1.5 bg-white dark:bg-slate-700 dark:text-slate-100 focus:outline-none" />
                </div>
                <div className="flex gap-2">
                  <button onClick={() => setShowNoticeForm(false)} className="flex-1 py-2.5 text-sm text-gray-600 dark:text-slate-400 bg-gray-100 dark:bg-slate-700 hover:bg-gray-200 rounded-xl transition">취소</button>
                  <button onClick={saveNotice} disabled={savingNotice} className="flex-1 py-2.5 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-xl transition disabled:opacity-50">
                    {savingNotice ? "등록 중..." : "등록"}
                  </button>
                </div>
              </div>
            )}

            {/* 공지 목록 */}
            {notices.length === 0 ? (
              <div className="flex flex-col items-center py-20 text-center">
                <Bell size={32} className="text-gray-300 dark:text-slate-600 mb-3" />
                <p className="text-gray-500 dark:text-slate-400 font-medium">등록된 공지가 없습니다</p>
              </div>
            ) : (
              <div className="space-y-2">
                {notices.map((n) => (
                  <div key={n.id} className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-4 flex items-start gap-3">
                    <div className="mt-0.5">{NOTICE_ICONS[n.type as keyof typeof NOTICE_ICONS] ?? NOTICE_ICONS.INFO}</div>
                    <div className="flex-1 min-w-0">
                      <p className="text-sm font-semibold text-gray-900 dark:text-slate-100">{n.title}</p>
                      <p className="text-xs text-gray-500 dark:text-slate-400 mt-0.5 line-clamp-2">{n.content}</p>
                      {n.endsAt && <p className="text-[10px] text-gray-400 dark:text-slate-500 mt-1">~{new Date(n.endsAt).toLocaleString("ko-KR")}</p>}
                    </div>
                    <button onClick={() => deleteNotice(n.id)} className="p-1.5 text-gray-400 hover:text-red-500 hover:bg-red-50 dark:hover:bg-red-900/20 rounded-lg transition">
                      <Trash2 size={13} />
                    </button>
                  </div>
                ))}
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/app/api/activity-logs/route.ts">
// src/app/api/activity-logs/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// GET /api/activity-logs?page=1&limit=30&action=FILE_UPLOAD
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const page   = Math.max(1, parseInt(searchParams.get("page")  ?? "1"));
    const limit  = Math.min(50, parseInt(searchParams.get("limit") ?? "30"));
    const action = searchParams.get("action") ?? undefined;
    const skip   = (page - 1) * limit;

    const where: any = { userId: session.user.id };
    if (action) where.action = action;

    const [logs, total] = await Promise.all([
      prisma.activityLog.findMany({
        where,
        orderBy: { createdAt: "desc" },
        skip,
        take: limit,
      }),
      prisma.activityLog.count({ where }),
    ]);

    return NextResponse.json({
      logs,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    });
  } catch (error) {
    console.error("GET /api/activity-logs error:", error);
    return NextResponse.json({ error: "서버 오류" }, { status: 500 });
  }
}

// DELETE /api/activity-logs — 내 로그 전체 삭제
export async function DELETE(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
    }

    await prisma.activityLog.deleteMany({ where: { userId: session.user.id } });
    return NextResponse.json({ message: "활동 로그를 모두 삭제했습니다" });
  } catch (error) {
    console.error("DELETE /api/activity-logs error:", error);
    return NextResponse.json({ error: "서버 오류" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/admin/notices/route.ts">
// ══════════════════════════════════════════════════════════
// src/app/api/admin/notices/route.ts — 시스템 공지 CRUD
// ══════════════════════════════════════════════════════════

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// GET — 활성 공지 (모든 사용자 접근 가능)
export async function GET() {
  const notices = await prisma.systemNotice.findMany({
    where: {
      isActive: true,
      OR: [
        { endsAt: null },
        { endsAt: { gt: new Date() } },
      ],
    },
    orderBy: { createdAt: "desc" },
    take: 5,
  });
  return NextResponse.json({ notices });
}

// POST — 공지 생성 (관리자 전용)
export async function POST(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user || session.user.role !== "ADMIN")
    return NextResponse.json({ error: "관리자 권한이 필요합니다" }, { status: 403 });

  const { title, content, type = "INFO", startsAt, endsAt } = await request.json();
  if (!title?.trim() || !content?.trim())
    return NextResponse.json({ error: "제목과 내용이 필요합니다" }, { status: 400 });

  const notice = await prisma.systemNotice.create({
    data: {
      title: title.trim(),
      content: content.trim(),
      type,
      createdBy: session.user.id,
      startsAt: startsAt ? new Date(startsAt) : null,
      endsAt:   endsAt   ? new Date(endsAt)   : null,
    },
  });

  return NextResponse.json({ notice, message: "공지가 등록되었습니다" });
}
</file>

<file path="src/app/api/admin/users/[id]/ban/route.ts">
// src/app/api/admin/users/[id]/ban/route.ts
// POST — 사용자 정지 / DELETE — 정지 해제

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user || session.user.role !== "ADMIN")
    return NextResponse.json({ error: "관리자 권한이 필요합니다" }, { status: 403 });

  if (params.id === session.user.id)
    return NextResponse.json({ error: "자신을 정지할 수 없습니다" }, { status: 400 });

  const { reason } = await request.json();

  const user = await prisma.user.update({
    where: { id: params.id },
    data: { isBanned: true, banReason: reason ?? "관리자 결정", bannedAt: new Date() },
    select: { id: true, name: true, email: true, isBanned: true },
  });

  return NextResponse.json({ user, message: `${user.name}이 정지되었습니다` });
}

export async function DELETE(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user || session.user.role !== "ADMIN")
    return NextResponse.json({ error: "관리자 권한이 필요합니다" }, { status: 403 });

  const user = await prisma.user.update({
    where: { id: params.id },
    data: { isBanned: false, banReason: null, bannedAt: null },
    select: { id: true, name: true, isBanned: true },
  });

  return NextResponse.json({ user, message: `${user.name}의 정지가 해제되었습니다` });
}
</file>

<file path="src/app/api/admin/users/[id]/route.ts">
// src/app/api/admin/users/[id]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

async function requireAdmin(selfId: string) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return null;
  const user = await prisma.user.findUnique({ where: { id: session.user.id } });
  if (!user || user.role !== "ADMIN") return null;
  return user;
}

// PATCH /api/admin/users/[id] — 역할 변경
export async function PATCH(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
  const admin = await requireAdmin(session.user.id);
  if (!admin) return NextResponse.json({ error: "관리자 권한이 필요합니다" }, { status: 403 });

  const { role } = await request.json();
  if (!["USER", "ADMIN"].includes(role)) {
    return NextResponse.json({ error: "올바르지 않은 역할입니다" }, { status: 400 });
  }

  const updated = await prisma.user.update({
    where: { id: params.id },
    data: { role },
    select: { id: true, name: true, role: true },
  });

  return NextResponse.json(updated);
}

// DELETE /api/admin/users/[id] — 계정 삭제
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
  const admin = await requireAdmin(session.user.id);
  if (!admin) return NextResponse.json({ error: "관리자 권한이 필요합니다" }, { status: 403 });

  // 자신 삭제 방지
  if (params.id === session.user.id) {
    return NextResponse.json({ error: "자신의 계정은 삭제할 수 없습니다" }, { status: 400 });
  }

  await prisma.user.delete({ where: { id: params.id } });
  return NextResponse.json({ message: "계정을 삭제했습니다" });
}
</file>

<file path="src/app/api/admin/users/route.ts">
// src/app/api/admin/users/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

async function requireAdmin() {
  const session = await getServerSession(authOptions);
  if (!session?.user) return null;
  const user = await prisma.user.findUnique({ where: { id: session.user.id } });
  if (!user || user.role !== "ADMIN") return null;
  return user;
}

// GET /api/admin/users — 전체 사용자 목록
export async function GET(request: NextRequest) {
  const admin = await requireAdmin();
  if (!admin) {
    return NextResponse.json({ error: "관리자 권한이 필요합니다" }, { status: 403 });
  }

  const users = await prisma.user.findMany({
    orderBy: { createdAt: "desc" },
    select: {
      id: true,
      name: true,
      email: true,
      role: true,
      emailVerified: true,
      isOnline: true,
      createdAt: true,
      _count: {
        select: { files: true, posts: true, comments: true },
      },
    },
  });

  return NextResponse.json(users);
}
</file>

<file path="src/app/api/auth/2fa/disable/route.ts">
// src/app/api/auth/2fa/disable/route.ts
// DELETE → 2FA 비활성화 (현재 OTP 코드 또는 백업 코드 확인 후)

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import * as OTPAuth from "otpauth";

export async function DELETE(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
    }

    const { code } = await request.json();

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { twoFactorSecret: true, twoFactorEnabled: true, twoFactorBackups: true },
    });

    if (!user?.twoFactorEnabled) {
      return NextResponse.json({ error: "2단계 인증이 활성화되어 있지 않습니다" }, { status: 400 });
    }

    // TOTP 또는 백업 코드 검증
    let valid = false;

    if (user.twoFactorSecret) {
      const totp = new OTPAuth.TOTP({
        algorithm: "SHA1", digits: 6, period: 30,
        secret: OTPAuth.Secret.fromBase32(user.twoFactorSecret),
      });
      valid = totp.validate({ token: code.replace(/\s/g, ""), window: 1 }) !== null;
    }

    // 백업 코드 확인
    if (!valid && user.twoFactorBackups?.includes(code.toUpperCase())) {
      valid = true;
    }

    if (!valid) {
      return NextResponse.json({ error: "코드가 올바르지 않습니다" }, { status: 400 });
    }

    await prisma.user.update({
      where: { id: session.user.id },
      data: {
        twoFactorEnabled: false,
        twoFactorSecret: null,
        twoFactorBackups: [],
      },
    });

    return NextResponse.json({ message: "2단계 인증이 비활성화되었습니다" });
  } catch (error) {
    console.error("DELETE /api/auth/2fa/disable error:", error);
    return NextResponse.json({ error: "서버 오류" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/auth/2fa/setup/route.ts">
// src/app/api/auth/2fa/setup/route.ts
// POST → 비밀키 생성 + QR코드 반환 (아직 활성화 안 됨)
// PATCH → OTP 검증 후 2FA 최종 활성화 + 백업 코드 발급

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import * as OTPAuth from "otpauth";
import QRCode from "qrcode";
import crypto from "crypto";

// 백업 코드 8개 생성
function generateBackupCodes(): string[] {
  return Array.from({ length: 8 }, () =>
    crypto.randomBytes(4).toString("hex").toUpperCase()
  );
}

// POST /api/auth/2fa/setup — 비밀키 + QR코드 생성
export async function POST() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { email: true, twoFactorEnabled: true },
    });

    if (user?.twoFactorEnabled) {
      return NextResponse.json({ error: "이미 2단계 인증이 활성화되어 있습니다" }, { status: 400 });
    }

    // TOTP 비밀키 생성
    const secret = new OTPAuth.Secret();
    const totp = new OTPAuth.TOTP({
      issuer: "이음 (Eum)",
      label: user?.email ?? session.user.email ?? "user",
      algorithm: "SHA1",
      digits: 6,
      period: 30,
      secret,
    });

    const otpauthUrl = totp.toString();
    const qrCodeDataUrl = await QRCode.toDataURL(otpauthUrl);

    // 임시로 비밀키 저장 (아직 활성화 안 됨)
    await prisma.user.update({
      where: { id: session.user.id },
      data: { twoFactorSecret: secret.base32 },
    });

    return NextResponse.json({
      secret: secret.base32,
      qrCode: qrCodeDataUrl,
      manualKey: secret.base32.match(/.{1,4}/g)?.join(" "), // 가독성 좋게 4자리씩 분리
    });
  } catch (error) {
    console.error("POST /api/auth/2fa/setup error:", error);
    return NextResponse.json({ error: "서버 오류" }, { status: 500 });
  }
}

// PATCH /api/auth/2fa/setup — OTP 검증 후 활성화
export async function PATCH(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
    }

    const { code } = await request.json();
    if (!code || typeof code !== "string") {
      return NextResponse.json({ error: "OTP 코드가 필요합니다" }, { status: 400 });
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { twoFactorSecret: true, twoFactorEnabled: true },
    });

    if (!user?.twoFactorSecret) {
      return NextResponse.json({ error: "먼저 QR코드를 생성해주세요" }, { status: 400 });
    }

    const totp = new OTPAuth.TOTP({
      algorithm: "SHA1",
      digits: 6,
      period: 30,
      secret: OTPAuth.Secret.fromBase32(user.twoFactorSecret),
    });

    const delta = totp.validate({ token: code.replace(/\s/g, ""), window: 1 });
    if (delta === null) {
      return NextResponse.json({ error: "OTP 코드가 올바르지 않습니다" }, { status: 400 });
    }

    const backupCodes = generateBackupCodes();

    await prisma.user.update({
      where: { id: session.user.id },
      data: {
        twoFactorEnabled: true,
        twoFactorBackups: backupCodes,
      },
    });

    return NextResponse.json({
      message: "2단계 인증이 활성화되었습니다",
      backupCodes,
    });
  } catch (error) {
    console.error("PATCH /api/auth/2fa/setup error:", error);
    return NextResponse.json({ error: "서버 오류" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/auth/verify-email/confirm/route.ts">
// src/app/api/auth/verify-email/confirm/route.ts
// 이메일 인증 링크 클릭 시 호출되는 엔드포인트

import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const token = searchParams.get("token");

  if (!token) {
    return NextResponse.redirect(
      new URL("/profile?verified=error&reason=missing_token", request.url)
    );
  }

  try {
    const record = await prisma.emailVerificationToken.findUnique({
      where: { token },
      include: { user: true },
    });

    if (!record) {
      return NextResponse.redirect(
        new URL("/profile?verified=error&reason=invalid_token", request.url)
      );
    }

    if (new Date() > record.expiresAt) {
      await prisma.emailVerificationToken.delete({ where: { id: record.id } });
      return NextResponse.redirect(
        new URL("/profile?verified=error&reason=expired", request.url)
      );
    }

    // 이메일 인증 완료
    await prisma.user.update({
      where: { id: record.userId },
      data: { emailVerified: true },
    });

    // 토큰 삭제
    await prisma.emailVerificationToken.delete({ where: { id: record.id } });

    return NextResponse.redirect(
      new URL("/profile?verified=success", request.url)
    );
  } catch (error) {
    console.error("GET /api/auth/verify-email/confirm error:", error);
    return NextResponse.redirect(
      new URL("/profile?verified=error&reason=server_error", request.url)
    );
  }
}
</file>

<file path="src/app/api/auth/verify-email/route.ts">
// src/app/api/auth/verify-email/route.ts
// 이메일 인증 재발송 + 토큰 검증 API

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import { sendEmail } from "@/lib/email";
import crypto from "crypto";

// POST /api/auth/verify-email — 인증 이메일 발송 (로그인 상태)
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
    });

    if (!user) {
      return NextResponse.json({ error: "사용자를 찾을 수 없습니다" }, { status: 404 });
    }
    if (user.emailVerified) {
      return NextResponse.json({ error: "이미 인증된 이메일입니다" }, { status: 400 });
    }

    // 기존 토큰 삭제 후 새 토큰 생성
    await prisma.emailVerificationToken.deleteMany({
      where: { userId: user.id },
    });

    const token = crypto.randomBytes(32).toString("hex");
    const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24시간

    await prisma.emailVerificationToken.create({
      data: { userId: user.id, token, expiresAt },
    });

    const verifyUrl = `${process.env.NEXTAUTH_URL}/api/auth/verify-email/confirm?token=${token}`;

    await sendEmail({
      to: user.email,
      subject: "[이음] 이메일 인증을 완료해주세요",
      html: `
        <div style="font-family: sans-serif; max-width: 480px; margin: 0 auto; padding: 32px;">
          <h1 style="font-size: 24px; color: #1e293b; margin-bottom: 8px;">이음 이메일 인증</h1>
          <p style="color: #475569; margin-bottom: 24px;">
            안녕하세요, <strong>${user.name}</strong>님!<br/>
            아래 버튼을 클릭하여 이메일 인증을 완료해주세요.
          </p>
          <a href="${verifyUrl}"
             style="display: inline-block; background: #2563eb; color: white;
                    padding: 12px 28px; border-radius: 8px; text-decoration: none;
                    font-weight: bold; font-size: 15px;">
            이메일 인증하기
          </a>
          <p style="color: #94a3b8; font-size: 13px; margin-top: 24px;">
            이 링크는 24시간 후 만료됩니다.<br/>
            본인이 요청하지 않았다면 이 이메일을 무시해주세요.
          </p>
        </div>
      `,
    });

    return NextResponse.json({ message: "인증 이메일을 발송했습니다" });
  } catch (error) {
    console.error("POST /api/auth/verify-email error:", error);
    return NextResponse.json({ error: "이메일 발송 중 오류가 발생했습니다" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/chat/rooms/[id]/messages/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { prisma } from "@/lib/db";
import { sendChatMessageNotification, sendFileSharedNotification } from "@/lib/fcm";

// BigInt 직렬화 유틸
function serialize(data: any) {
  return JSON.parse(
    JSON.stringify(data, (key, value) =>
      typeof value === "bigint" ? value.toString() : value
    )
  );
}

// ─── GET: 메시지 목록 조회 ───────────────────────────────
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
    }

    const chatRoomId = params.id;
    const { searchParams } = new URL(request.url);
    const limit = parseInt(searchParams.get("limit") || "50");
    const before = searchParams.get("before");

    // 멤버십 확인
    const membership = await prisma.chatRoomMember.findFirst({
      where: { chatRoomId, userId: session.user.id },
    });

    if (!membership) {
      return NextResponse.json(
        { error: "채팅방에 참여하지 않았습니다" },
        { status: 403 }
      );
    }

    const messages = await prisma.chatMessage.findMany({
      where: {
        chatRoomId,
        ...(before && { createdAt: { lt: new Date(before) } }),
      },
      include: {
        sender: { select: { id: true, name: true, email: true } },
        file: { select: { id: true, originalName: true, size: true, mimeType: true } },
      },
      orderBy: { createdAt: "desc" },
      take: limit,
    });

    return NextResponse.json(serialize({ messages: messages.reverse() }));
  } catch (error) {
    console.error("GET Messages Error:", error);
    return NextResponse.json({ error: "메시지 조회 실패" }, { status: 500 });
  }
}

// ─── POST: 메시지 전송 ────────────────────────────────────
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
    }

    const chatRoomId = params.id;
    const { type, content, fileId, callId } = await request.json();

    // 메시지 생성
    const message = await prisma.chatMessage.create({
      data: {
        chatRoomId,
        senderId: session.user.id,
        type,
        content:
          type === "TEXT" || type === "CALL_LOG" || type === "SYSTEM"
            ? content
            : null,
        fileId: type === "FILE" ? fileId : null,
        callId: callId || null,
      },
      include: {
        sender: { select: { id: true, name: true, email: true } },
        file: true,
      },
    });

    const serializedMessage = serialize(message);

    // ✅ 이벤트명 통일: "message:new" → "message:receive"
    // (클라이언트 useSocket.ts의 listen 이벤트와 일치)
    const io = (global as any).io;
    if (io) {
      io.to(`chat:${chatRoomId}`).emit("message:receive", serializedMessage);
      console.log(`📡 소켓 브로드캐스트: chat:${chatRoomId}`);
    } else {
      console.warn("⚠️ global.io 없음 — 소켓 서버 상태 확인 필요");
    }

    // 채팅방 멤버 조회 (파일 권한 + FCM용)
    const members = await prisma.chatRoomMember.findMany({
      where: { chatRoomId },
      include: { user: { select: { id: true, name: true, fcmToken: true } } },
    });

    // 파일 공유 시 멤버들에게 권한 부여
    if (type === "FILE" && fileId) {
      for (const member of members) {
        if (member.userId !== session.user.id) {
          await prisma.sharedResource.upsert({
            where: {
              resourceType_resourceId_sharedWithId: {
                resourceType: "FILE",
                resourceId: fileId,
                sharedWithId: member.userId,
              },
            },
            update: {},
            create: {
              resourceType: "FILE",
              resourceId: fileId,
              ownerId: session.user.id,
              sharedWithId: member.userId,
              permission: "VIEW",
            },
          });
        }
      }
    }

    // 채팅방 updatedAt 갱신
    await prisma.chatRoom.update({
      where: { id: chatRoomId },
      data: { updatedAt: new Date() },
    });

    // FCM 푸시 알림 (나 제외한 멤버들)
    for (const member of members) {
      if (member.userId !== session.user.id && member.user.fcmToken) {
        try {
          if (type === "TEXT") {
            await sendChatMessageNotification(
              member.user.fcmToken,
              session.user.name || "사용자",
              content,
              chatRoomId
            );
          } else if (type === "FILE" && message.file) {
            await sendFileSharedNotification(
              member.user.fcmToken,
              session.user.name || "사용자",
              (message.file as any).originalName,
              chatRoomId
            );
          }
        } catch (error) {
          console.error(`❌ FCM 실패 (${member.user.name}):`, error);
        }
      }
    }

    return NextResponse.json({ data: serializedMessage }, { status: 201 });
  } catch (error) {
    console.error("POST Message Error:", error);
    return NextResponse.json({ error: "메시지 전송 실패" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/errors/report/route.ts">
// src/app/api/errors/report/route.ts
// 클라이언트 에러 수신 및 서버 로깅

import { NextRequest, NextResponse } from "next/server";
import logger from "@/lib/logger";
import { withRequestLog } from "@/lib/request-logger";

interface ErrorReport {
  message: string;
  stack?:  string;
  context?: object;
  url?:    string;
  ua?:     string;
  ts?:     string;
}

export const POST = withRequestLog(async (request: NextRequest) => {
  let body: ErrorReport;
  try {
    body = await request.json();
  } catch {
    return NextResponse.json({ ok: true }); // 파싱 실패해도 204
  }

  logger.error("[Client Error]", {
    message: body.message?.slice(0, 500),
    stack:   body.stack?.slice(0, 2000),
    url:     body.url,
    ua:      body.ua?.slice(0, 200),
    ts:      body.ts,
    context: body.context,
    ip:      request.headers.get("x-forwarded-for") ?? "unknown",
  });

  return NextResponse.json({ ok: true });
});
</file>

<file path="src/app/api/files/[id]/encrypt/route.ts">
// src/app/api/files/[id]/encrypt/route.ts
// POST — 파일에 비밀번호 설정 (AES-256-GCM 암호화)
// DELETE — 비밀번호 해제 (복호화)

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import crypto from "crypto";
import { readFile, writeFile } from "fs/promises";
import { existsSync } from "fs";

const ALGO = "aes-256-gcm";

function deriveKey(password: string, salt: Buffer): Buffer {
  return crypto.pbkdf2Sync(password, salt, 100_000, 32, "sha256");
}

// POST — 암호화 (잠금)
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });

  const { password } = await request.json();
  if (!password || password.length < 4)
    return NextResponse.json({ error: "비밀번호는 4자 이상이어야 합니다" }, { status: 400 });

  const file = await prisma.file.findFirst({
    where: { id: params.id, userId: session.user.id },
  });
  if (!file) return NextResponse.json({ error: "파일을 찾을 수 없습니다" }, { status: 404 });
  if (file.isEncrypted) return NextResponse.json({ error: "이미 암호화된 파일입니다" }, { status: 400 });
  if (!existsSync(file.filepath))
    return NextResponse.json({ error: "파일을 찾을 수 없습니다" }, { status: 404 });

  // AES-256-GCM 암호화
  const salt = crypto.randomBytes(16);
  const iv   = crypto.randomBytes(12);
  const key  = deriveKey(password, salt);
  const cipher = crypto.createCipheriv(ALGO, key, iv);

  const plaintext = await readFile(file.filepath);
  const encrypted = Buffer.concat([cipher.update(plaintext), cipher.final()]);
  const authTag   = cipher.getAuthTag();

  // 형식: [4B salt_len][salt][12B iv][16B authTag][encrypted]
  const out = Buffer.concat([
    Buffer.from([salt.length]),
    salt, iv, authTag, encrypted,
  ]);
  await writeFile(file.filepath, out);

  await prisma.file.update({
    where: { id: params.id },
    data: { isEncrypted: true },
  });

  return NextResponse.json({ message: "파일이 암호화되었습니다" });
}

// DELETE — 복호화 (잠금 해제)
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });

  const { password } = await request.json();
  if (!password) return NextResponse.json({ error: "비밀번호가 필요합니다" }, { status: 400 });

  const file = await prisma.file.findFirst({
    where: { id: params.id, userId: session.user.id },
  });
  if (!file) return NextResponse.json({ error: "파일을 찾을 수 없습니다" }, { status: 404 });
  if (!file.isEncrypted) return NextResponse.json({ error: "암호화되지 않은 파일입니다" }, { status: 400 });

  try {
    const raw   = await readFile(file.filepath);
    const saltLen = raw[0];
    const salt  = raw.slice(1, 1 + saltLen);
    const iv    = raw.slice(1 + saltLen, 1 + saltLen + 12);
    const authTag = raw.slice(1 + saltLen + 12, 1 + saltLen + 12 + 16);
    const ciphertext = raw.slice(1 + saltLen + 12 + 16);

    const key = deriveKey(password, salt);
    const decipher = crypto.createDecipheriv(ALGO, key, iv);
    decipher.setAuthTag(authTag);

    const decrypted = Buffer.concat([decipher.update(ciphertext), decipher.final()]);
    await writeFile(file.filepath, decrypted);

    await prisma.file.update({
      where: { id: params.id },
      data: { isEncrypted: false },
    });

    return NextResponse.json({ message: "암호화가 해제되었습니다" });
  } catch {
    return NextResponse.json({ error: "비밀번호가 올바르지 않습니다" }, { status: 400 });
  }
}
</file>

<file path="src/app/api/files/[id]/favorite/route.ts">
// src/app/api/files/[id]/favorite/route.ts
// POST — 즐겨찾기 토글 (starred)
// PATCH — 핀 고정 토글 (pinned)

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// POST — 즐겨찾기 토글
export async function POST(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });

  const file = await prisma.file.findFirst({
    where: { id: params.id, userId: session.user.id },
    select: { id: true, isStarred: true },
  });
  if (!file) return NextResponse.json({ error: "파일을 찾을 수 없습니다" }, { status: 404 });

  const updated = await prisma.file.update({
    where: { id: params.id },
    data: { isStarred: !file.isStarred },
    select: { id: true, isStarred: true },
  });

  return NextResponse.json({ starred: updated.isStarred });
}

// PATCH — 핀 고정 토글
export async function PATCH(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });

  const file = await prisma.file.findFirst({
    where: { id: params.id, userId: session.user.id },
    select: { id: true, isPinned: true },
  });
  if (!file) return NextResponse.json({ error: "파일을 찾을 수 없습니다" }, { status: 404 });

  // 핀 고정은 최대 10개
  if (!file.isPinned) {
    const pinnedCount = await prisma.file.count({
      where: { userId: session.user.id, isPinned: true },
    });
    if (pinnedCount >= 10)
      return NextResponse.json({ error: "핀 고정은 최대 10개까지 가능합니다" }, { status: 400 });
  }

  const updated = await prisma.file.update({
    where: { id: params.id },
    data: { isPinned: !file.isPinned },
    select: { id: true, isPinned: true },
  });

  return NextResponse.json({ pinned: updated.isPinned });
}

// ── schema.prisma File 모델에 추가할 필드 ──────────────────
// isStarred  Boolean  @default(false) @map("is_starred")
// isPinned   Boolean  @default(false) @map("is_pinned")
// @@index([userId, isStarred])
// @@index([userId, isPinned])
</file>

<file path="src/app/api/files/[id]/public-link/route.ts">
// src/app/api/files/[id]/public-link/route.ts
// POST → 공개 공유 링크 생성 (토큰 발급)
// DELETE → 공개 링크 비활성화

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import crypto from "crypto";

// POST — 공개 링크 생성
export async function POST(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });

  const file = await prisma.file.findUnique({ where: { id: params.id } });
  if (!file) return NextResponse.json({ error: "파일을 찾을 수 없습니다" }, { status: 404 });
  if (file.userId !== session.user.id)
    return NextResponse.json({ error: "권한이 없습니다" }, { status: 403 });

  // 이미 토큰 있으면 재사용, 없으면 새로 발급
  const token = file.publicToken ?? crypto.randomBytes(24).toString("hex");

  await prisma.file.update({
    where: { id: params.id },
    data: { publicToken: token },
  });

  const link = `${process.env.NEXTAUTH_URL}/share/${token}`;
  return NextResponse.json({ token, link });
}

// DELETE — 공개 링크 비활성화
export async function DELETE(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });

  const file = await prisma.file.findUnique({ where: { id: params.id } });
  if (!file || file.userId !== session.user.id)
    return NextResponse.json({ error: "권한이 없습니다" }, { status: 403 });

  await prisma.file.update({ where: { id: params.id }, data: { publicToken: null } });
  return NextResponse.json({ message: "공개 링크가 비활성화되었습니다" });
}
</file>

<file path="src/app/api/files/[id]/restore/route.ts">
// src/app/api/files/[id]/restore/route.ts
// POST — 휴지통에서 복구

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function POST(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });

  const file = await prisma.file.findUnique({ where: { id: params.id } });
  if (!file || file.userId !== session.user.id)
    return NextResponse.json({ error: "권한이 없습니다" }, { status: 403 });
  if (!file.deletedAt)
    return NextResponse.json({ error: "휴지통에 있는 파일이 아닙니다" }, { status: 400 });

  await prisma.file.update({
    where: { id: params.id },
    data: { deletedAt: null },
  });

  return NextResponse.json({ message: "파일이 복구되었습니다" });
}
</file>

<file path="src/app/api/files/[id]/route.ts">
// src/app/api/files/[id]/route.ts (DELETE 메서드 교체)
// 기존 DELETE를 soft delete로 변경

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import { unlink } from "fs/promises";
import { existsSync } from "fs";

// PATCH — 파일 메타 수정 (기존 유지)
export async function GET(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });

  const file = await prisma.file.findFirst({
    where: { id: params.id, userId: session.user.id },
    include: { fileTags: { include: { tag: true } } },
  });

  if (!file) return NextResponse.json({ error: "파일을 찾을 수 없습니다" }, { status: 404 });
  return NextResponse.json(file);
}

// DELETE — 휴지통으로 이동 (soft delete)
export async function DELETE(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });

    const file = await prisma.file.findUnique({ where: { id: params.id } });
    if (!file) return NextResponse.json({ error: "파일을 찾을 수 없습니다" }, { status: 404 });
    if (file.userId !== session.user.id)
      return NextResponse.json({ error: "권한이 없습니다" }, { status: 403 });

    // 이미 삭제된 파일이면 영구 삭제
    if (file.deletedAt) {
      if (existsSync(file.filepath)) await unlink(file.filepath);
      if (file.thumbnailUrl && existsSync(file.thumbnailUrl)) await unlink(file.thumbnailUrl);
      await prisma.file.delete({ where: { id: params.id } });
      return NextResponse.json({ message: "파일이 영구 삭제되었습니다", permanent: true });
    }

    // 처음 삭제: 휴지통으로 이동
    await prisma.file.update({
      where: { id: params.id },
      data: { deletedAt: new Date() },
    });

    return NextResponse.json({ message: "파일이 휴지통으로 이동되었습니다", permanent: false });
  } catch (error) {
    console.error("File delete error:", error);
    return NextResponse.json({ error: "파일 삭제 중 오류가 발생했습니다" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/files/[id]/thumbnail/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import sharp from "sharp";
import { existsSync } from "fs";
import { writeFile, mkdir } from "fs/promises";
import { join } from "path";

const STORAGE_PATH = process.env.STORAGE_PATH || "./storage";

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const fileId = params.id;

    // 파일 정보 조회
    const file = await prisma.file.findUnique({
      where: { id: fileId },
    });

    if (!file) {
      return NextResponse.json(
        { error: "파일을 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    // 권한 확인
    const isOwner = file.userId === session.user.id;

    // 공유 확인
    let isShared = false;
    if (!isOwner) {
      const shareCheck = await prisma.sharedResource.findFirst({
        where: {
          resourceType: "FILE",
          resourceId: fileId,
          sharedWithId: session.user.id,
        },
      });
      isShared = !!shareCheck;
    }

    const canView = isOwner || isShared;

    if (!canView) {
      return NextResponse.json(
        { error: "접근 권한이 없습니다" },
        { status: 403 }
      );
    }

    // 이미지 파일만 썸네일 생성
    if (!file.mimeType.startsWith("image/")) {
      return NextResponse.json(
        { error: "이미지 파일만 썸네일을 생성할 수 있습니다" },
        { status: 400 }
      );
    }

    const thumbnailDir = join(STORAGE_PATH, "thumbnails");
    const thumbnailPath = join(thumbnailDir, `${fileId}.jpg`);

    // 썸네일이 이미 존재하면 반환
    if (existsSync(thumbnailPath)) {
      const thumbnailBuffer = await sharp(thumbnailPath).toBuffer();
      return new NextResponse(new Uint8Array(thumbnailBuffer), {
        headers: {
          "Content-Type": "image/jpeg",
          "Cache-Control": "public, max-age=31536000",
        },
      });
    }

    // 원본 파일 존재 확인
    if (!existsSync(file.filepath)) {
      return NextResponse.json(
        { error: "원본 파일을 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    // 썸네일 디렉토리 생성
    if (!existsSync(thumbnailDir)) {
      await mkdir(thumbnailDir, { recursive: true });
    }

    // 썸네일 생성
    const thumbnailBuffer = await sharp(file.filepath)
      .resize(300, 300, {
        fit: "cover",
        position: "center",
      })
      .jpeg({ quality: 80 })
      .toBuffer();

    // 썸네일 저장
    await writeFile(thumbnailPath, thumbnailBuffer);

    // DB 업데이트
    await prisma.file.update({
      where: { id: fileId },
      data: {
        thumbnailUrl: `/api/files/${fileId}/thumbnail`,
      },
    });

    return new NextResponse(new Uint8Array(thumbnailBuffer), {
      headers: {
        "Content-Type": "image/jpeg",
        "Cache-Control": "public, max-age=31536000",
      },
    });

  } catch (error) {
    console.error("Thumbnail generation error:", error);
    return NextResponse.json(
      { error: "썸네일 생성 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/files/[id]/versions/[versionId]/rollback/route.ts">
// src/app/api/files/[id]/versions/[versionId]/rollback/route.ts
// POST — 특정 버전으로 롤백 (현재 파일을 버전 스냅샷으로 교체)

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import { copyFile } from "fs/promises";
import { existsSync } from "fs";

export async function POST(
  _req: NextRequest,
  { params }: { params: { id: string; versionId: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });

  const [file, version] = await Promise.all([
    prisma.file.findFirst({ where: { id: params.id, userId: session.user.id } }),
    prisma.fileVersion.findFirst({ where: { id: params.versionId, fileId: params.id } }),
  ]);

  if (!file) return NextResponse.json({ error: "파일을 찾을 수 없습니다" }, { status: 404 });
  if (!version) return NextResponse.json({ error: "버전을 찾을 수 없습니다" }, { status: 404 });
  if (!existsSync(version.filepath))
    return NextResponse.json({ error: "버전 스냅샷 파일이 없습니다" }, { status: 404 });

  // 롤백 전 현재 상태를 새 버전으로 저장
  const latest = await prisma.fileVersion.findFirst({
    where: { fileId: params.id }, orderBy: { versionNum: "desc" },
  });
  const nextVer = (latest?.versionNum ?? 0) + 1;
  const snapshotPath = version.filepath.replace(`_v${version.versionNum}`, `_v${nextVer}_before_rollback`);

  if (existsSync(file.filepath)) {
    await copyFile(file.filepath, snapshotPath);
    await prisma.fileVersion.create({
      data: {
        fileId: params.id, versionNum: nextVer,
        filepath: snapshotPath, size: file.size,
        createdBy: session.user.id,
        comment: `롤백 전 자동 저장 (v${version.versionNum}으로 롤백)`,
      },
    });
  }

  // 실제 롤백: 버전 스냅샷 → 현재 파일 경로로 복사
  await copyFile(version.filepath, file.filepath);
  await prisma.file.update({
    where: { id: params.id },
    data: { size: version.size, updatedAt: new Date() },
  });

  return NextResponse.json({
    message: `버전 ${version.versionNum}으로 롤백되었습니다`,
    versionNum: version.versionNum,
  });
}
</file>

<file path="src/app/api/files/[id]/versions/route.ts">
// src/app/api/files/[id]/versions/route.ts
// GET  — 버전 목록 조회
// POST — 현재 파일을 새 버전으로 저장

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import { copyFile, mkdir } from "fs/promises";
import { existsSync } from "fs";
import path from "path";

const VERSIONS_DIR = process.env.STORAGE_PATH
  ? path.join(process.env.STORAGE_PATH, "versions")
  : "./storage/versions";

export async function GET(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });

  const file = await prisma.file.findFirst({
    where: { id: params.id, userId: session.user.id },
  });
  if (!file) return NextResponse.json({ error: "파일을 찾을 수 없습니다" }, { status: 404 });

  const versions = await prisma.fileVersion.findMany({
    where: { fileId: params.id },
    include: { user: { select: { name: true } } },
    orderBy: { versionNum: "desc" },
  });

  return NextResponse.json({ versions });
}

export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });

  const file = await prisma.file.findFirst({
    where: { id: params.id, userId: session.user.id },
  });
  if (!file) return NextResponse.json({ error: "파일을 찾을 수 없습니다" }, { status: 404 });

  const { comment } = await request.json().catch(() => ({}));

  // 최신 버전 번호
  const latest = await prisma.fileVersion.findFirst({
    where: { fileId: params.id },
    orderBy: { versionNum: "desc" },
  });
  const nextVer = (latest?.versionNum ?? 0) + 1;

  // 버전 스냅샷 저장
  if (!existsSync(VERSIONS_DIR)) await mkdir(VERSIONS_DIR, { recursive: true });
  const ext = path.extname(file.filepath);
  const snapshotPath = path.join(VERSIONS_DIR, `${params.id}_v${nextVer}${ext}`);

  if (!existsSync(file.filepath)) {
    return NextResponse.json({ error: "원본 파일을 찾을 수 없습니다" }, { status: 404 });
  }
  await copyFile(file.filepath, snapshotPath);

  const version = await prisma.fileVersion.create({
    data: {
      fileId: params.id,
      versionNum: nextVer,
      filepath: snapshotPath,
      size: file.size,
      createdBy: session.user.id,
      comment: comment ?? null,
    },
  });

  // 최대 10개 버전 유지 (가장 오래된 것 삭제)
  const allVersions = await prisma.fileVersion.findMany({
    where: { fileId: params.id },
    orderBy: { versionNum: "asc" },
  });
  if (allVersions.length > 10) {
    const toDelete = allVersions.slice(0, allVersions.length - 10);
    for (const v of toDelete) {
      try {
        const { unlink } = await import("fs/promises");
        if (existsSync(v.filepath)) await unlink(v.filepath);
        await prisma.fileVersion.delete({ where: { id: v.id } });
      } catch {}
    }
  }

  return NextResponse.json({ version, message: `버전 ${nextVer}이 저장되었습니다` });
}
</file>

<file path="src/app/api/files/route.ts">
// src/app/api/files/route.ts
// ⚠️ 수정사항:
// 1. myFilesWhere에 deletedAt: null 추가 (휴지통 파일 노출 방지)
// 2. pinned=true 쿼리파라미터 지원 추가 (PinnedFilesSection용)

export const dynamic = "force-dynamic";

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const page      = parseInt(searchParams.get("page")      || "1");
    const limit     = parseInt(searchParams.get("limit")     || "20");
    const sortBy    = searchParams.get("sortBy")    || "createdAt";
    const sortOrder = (searchParams.get("sortOrder") || "desc") as "asc" | "desc";
    const folderId  = searchParams.get("folderId");
    const search    = searchParams.get("search")    || "";
    const fileType  = searchParams.get("fileType")  || "";
    const startDate = searchParams.get("startDate");
    const endDate   = searchParams.get("endDate");
    const filter    = searchParams.get("filter")    || "all";
    // ✅ 추가: 고정 파일 전용 필터
    const pinnedOnly = searchParams.get("pinned") === "true";

    const skip = (page - 1) * limit;

    // ✅ 수정: deletedAt: null 추가
    const myFilesWhere: any = {
      userId:    session.user.id,
      deletedAt: null,
    };

    // 고정 파일만 조회
    if (pinnedOnly) {
      myFilesWhere.isPinned = true;
      const files = await prisma.file.findMany({
        where:   myFilesWhere,
        orderBy: { updatedAt: "desc" },
        take:    limit,
        select: {
          id: true, originalName: true, mimeType: true,
          size: true, thumbnailUrl: true, createdAt: true,
          isStarred: true, isPinned: true,
        },
      });
      return NextResponse.json({ files: files.map((f: any) => ({ ...f, size: f.size.toString() })) });
    }

    if (folderId === "null" || !folderId) {
      myFilesWhere.folderId = null;
    } else {
      myFilesWhere.folderId = folderId;
    }

    if (search) {
      myFilesWhere.OR = [
        { originalName: { contains: search, mode: "insensitive" } },
        { filename:     { contains: search, mode: "insensitive" } },
      ];
    }

    if (fileType === "image") {
      myFilesWhere.mimeType = { startsWith: "image/" };
    } else if (fileType === "video") {
      myFilesWhere.mimeType = { startsWith: "video/" };
    } else if (fileType === "document") {
      myFilesWhere.OR = [
        { mimeType: { contains: "pdf" } },
        { mimeType: { contains: "document" } },
        { mimeType: { contains: "word" } },
      ];
    }

    if (startDate || endDate) {
      myFilesWhere.createdAt = {};
      if (startDate) myFilesWhere.createdAt.gte = new Date(startDate);
      if (endDate)   myFilesWhere.createdAt.lte = new Date(endDate);
    }

    const sharedResources = await prisma.sharedResource.findMany({
      where: { resourceType: "FILE", sharedWithId: session.user.id },
    });
    const sharedFileIds = sharedResources.map((sr: any) => sr.resourceId);

    const sharedFilesData = sharedFileIds.length > 0
      ? await prisma.file.findMany({
          where:   { id: { in: sharedFileIds }, deletedAt: null },
          include: { user: { select: { id: true, name: true, email: true } }, fileTags: { include: { tag: true } } },
        })
      : [];

    const sharedFilesWithMeta = sharedFilesData.map((file: any) => {
      const shareInfo = sharedResources.find((sr: any) => sr.resourceId === file.id);
      return {
        ...file, size: file.size.toString(),
        isShared: true, isOwner: false,
        sharedBy: file.user?.name, sharedByEmail: file.user?.email,
        sharedAt: shareInfo?.createdAt, permission: shareInfo?.permission,
      };
    });

    let myFiles:      any[] = [];
    let totalMyFiles  = 0;

    if (filter === "all" || filter === "mine") {
      [myFiles, totalMyFiles] = await Promise.all([
        prisma.file.findMany({
          where:   myFilesWhere,
          orderBy: { [sortBy]: sortOrder },
          skip:    filter === "mine" ? skip : undefined,
          take:    filter === "mine" ? limit : undefined,
          include: { fileTags: { include: { tag: true } } },
        }),
        prisma.file.count({ where: myFilesWhere }),
      ]);
    }

    const myFilesWithMeta = myFiles.map((file) => ({
      ...file, size: file.size.toString(), isShared: false, isOwner: true,
    }));

    let resultFiles: any[] = [];
    let finalTotal = 0;

    if (filter === "all") {
      const combined = [...myFilesWithMeta, ...sharedFilesWithMeta];
      combined.sort((a, b) => {
        const aVal = (a as any)[sortBy], bVal = (b as any)[sortBy];
        return sortOrder === "desc" ? (aVal > bVal ? -1 : 1) : (aVal > bVal ? 1 : -1);
      });
      finalTotal  = combined.length;
      resultFiles = combined.slice(skip, skip + limit);
    } else if (filter === "mine") {
      resultFiles = myFilesWithMeta;
      finalTotal  = totalMyFiles;
    } else {
      sharedFilesWithMeta.sort((a: any, b: any) => {
        const aVal = (a as any)[sortBy], bVal = (b as any)[sortBy];
        return sortOrder === "desc" ? (aVal > bVal ? -1 : 1) : (aVal > bVal ? 1 : -1);
      });
      finalTotal  = sharedFilesWithMeta.length;
      resultFiles = sharedFilesWithMeta.slice(skip, skip + limit);
    }

    return NextResponse.json({
      files: resultFiles,
      pagination: { total: finalTotal, page, limit, totalPages: Math.ceil(finalTotal / limit) },
      stats: { myFiles: totalMyFiles, sharedFiles: sharedFilesWithMeta.length },
    });

  } catch (error) {
    console.error("Files fetch error:", error);
    return NextResponse.json({ error: "파일 목록 조회 중 오류가 발생했습니다" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/files/shared/route.ts">
// src/app/api/files/shared/route.ts
// ⚠️ 수정: SharedResource 모델에 file 직접 관계 없음
//    resourceId로 별도 File 조회로 변경

export const dynamic = "force-dynamic";

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
    }

    // 1. 공유받은 리소스 조회 (FILE 타입만)
    const sharedResources = await prisma.sharedResource.findMany({
      where: {
        resourceType: "FILE",
        sharedWithId: session.user.id,
      },
      include: {
        owner: { select: { name: true, email: true } },
      },
      orderBy: { createdAt: "desc" },
    });

    if (sharedResources.length === 0) {
      return NextResponse.json({ files: [] });
    }

    // 2. resourceId로 파일 정보 별도 조회
    const fileIds = sharedResources.map((sr: any) => sr.resourceId);
    const files = await prisma.file.findMany({
      where:  { id: { in: fileIds }, deletedAt: null },
      select: {
        id: true, filename: true, originalName: true,
        size: true, mimeType: true, thumbnailUrl: true, createdAt: true,
        user: { select: { name: true, email: true } },
      },
    });

    const fileMap = Object.fromEntries(files.map((f: any) => [f.id, f]));

    // 3. 조합
    const result = sharedResources
      .map((share: any) => {
        const file = fileMap[share.resourceId];
        if (!file) return null;
        return {
          id:            file.id,
          filename:      file.filename,
          originalName:  file.originalName,
          size:          file.size.toString(),
          mimeType:      file.mimeType,
          thumbnailUrl:  file.thumbnailUrl,
          createdAt:     file.createdAt,
          sharedBy:      share.owner.name,
          sharedByEmail: share.owner.email,
          permission:    share.permission,
          sharedAt:      share.createdAt,
        };
      })
      .filter(Boolean);

    return NextResponse.json({ files: result });

  } catch (error) {
    console.error("Shared files fetch error:", error);
    return NextResponse.json(
      { error: "공유 파일 조회 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/files/trash/route.ts">
// src/app/api/files/trash/route.ts
// GET  — 휴지통 파일 목록
// DELETE — 휴지통 비우기 (영구 삭제)

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import { unlink } from "fs/promises";
import { existsSync } from "fs";

export async function GET() {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });

  const files = await prisma.file.findMany({
    where: { userId: session.user.id, deletedAt: { not: null } },
    orderBy: { deletedAt: "desc" },
    select: {
      id: true, originalName: true, mimeType: true,
      size: true, thumbnailUrl: true, deletedAt: true, createdAt: true,
    },
  });

  return NextResponse.json({ files });
}

export async function DELETE() {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });

  const files = await prisma.file.findMany({
    where: { userId: session.user.id, deletedAt: { not: null } },
    select: { id: true, filepath: true, thumbnailUrl: true },
  });

  // 실제 파일 삭제
  await Promise.all(
    files.map(async (f: any) => {
      try {
        if (existsSync(f.filepath)) await unlink(f.filepath);
        if (f.thumbnailUrl && existsSync(f.thumbnailUrl)) await unlink(f.thumbnailUrl);
      } catch {}
    })
  );

  // DB 영구 삭제
  await prisma.file.deleteMany({
    where: { userId: session.user.id, deletedAt: { not: null } },
  });

  return NextResponse.json({ message: `${files.length}개 파일이 영구 삭제되었습니다`, count: files.length });
}
</file>

<file path="src/app/api/folders/[id]/download/route.ts">
// src/app/api/folders/[id]/download/route.ts
// GET — 폴더 전체를 ZIP으로 압축해 다운로드

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import { existsSync, createReadStream } from "fs";
import path from "path";
import archiver from "archiver";
import { PassThrough } from "stream";

// npm install archiver && npm install --save-dev @types/archiver

async function getFolderFiles(
  folderId: string,
  userId: string,
  prefix = ""
): Promise<{ filepath: string; archiveName: string }[]> {
  const [files, subFolders] = await Promise.all([
    prisma.file.findMany({
      where: { folderId, userId, deletedAt: null },
      select: { filepath: true, originalName: true },
    }),
    prisma.folder.findMany({
      where: { parentId: folderId, userId },
      select: { id: true, name: true },
    }),
  ]);

  const result: { filepath: string; archiveName: string }[] = [];

  for (const f of files) {
    if (existsSync(f.filepath)) {
      result.push({ filepath: f.filepath, archiveName: path.join(prefix, f.originalName) });
    }
  }

  for (const sf of subFolders) {
    const subFiles = await getFolderFiles(sf.id, userId, path.join(prefix, sf.name));
    result.push(...subFiles);
  }

  return result;
}

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });

  const folder = await prisma.folder.findFirst({
    where: { id: params.id, userId: session.user.id },
  });
  if (!folder) return NextResponse.json({ error: "폴더를 찾을 수 없습니다" }, { status: 404 });

  const files = await getFolderFiles(params.id, session.user.id, "");

  if (files.length === 0) {
    return NextResponse.json({ error: "폴더에 파일이 없습니다" }, { status: 400 });
  }

  // archiver로 ZIP 스트림 생성
  const passThrough = new PassThrough();
  const archive = archiver("zip", { zlib: { level: 6 } });

  archive.on("error", (err) => { passThrough.destroy(err); });
  archive.pipe(passThrough);

  for (const { filepath, archiveName } of files) {
    archive.append(createReadStream(filepath), { name: archiveName });
  }
  archive.finalize();

  const readable = new ReadableStream({
    start(controller) {
      passThrough.on("data", (chunk) => controller.enqueue(chunk));
      passThrough.on("end", () => controller.close());
      passThrough.on("error", (err) => controller.error(err));
    },
  });

  const zipName = `${folder.name}.zip`;
  return new NextResponse(readable, {
    headers: {
      "Content-Type": "application/zip",
      "Content-Disposition": `attachment; filename*=UTF-8''${encodeURIComponent(zipName)}`,
    },
  });
}
</file>

<file path="src/app/api/folders/[id]/move/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// 폴더 이동
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const folderId = params.id;
    const body = await request.json();
    const { parentId } = body; // null이면 루트로 이동

    // 폴더 확인
    const folder = await prisma.folder.findUnique({
      where: { id: folderId },
    });

    if (!folder) {
      return NextResponse.json(
        { error: "폴더를 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    if (folder.userId !== session.user.id) {
      return NextResponse.json(
        { error: "권한이 없습니다" },
        { status: 403 }
      );
    }

    // 자기 자신으로 이동 방지
    if (parentId === folderId) {
      return NextResponse.json(
        { error: "폴더를 자기 자신으로 이동할 수 없습니다" },
        { status: 400 }
      );
    }

    // 대상 폴더 확인 (있는 경우)
    if (parentId) {
      const targetFolder = await prisma.folder.findUnique({
        where: { id: parentId },
      });

      if (!targetFolder) {
        return NextResponse.json(
          { error: "대상 폴더를 찾을 수 없습니다" },
          { status: 404 }
        );
      }

      if (targetFolder.userId !== session.user.id) {
        return NextResponse.json(
          { error: "대상 폴더에 대한 권한이 없습니다" },
          { status: 403 }
        );
      }

      // 순환 참조 방지 (자식 폴더로 이동 불가)
      const isDescendant = await checkIsDescendant(parentId, folderId);
      if (isDescendant) {
        return NextResponse.json(
          { error: "하위 폴더로는 이동할 수 없습니다" },
          { status: 400 }
        );
      }
    }

    // 같은 위치에 같은 이름의 폴더가 있는지 확인
    const existingFolder = await prisma.folder.findFirst({
      where: {
        userId: session.user.id,
        parentId: parentId || null,
        name: folder.name,
        id: { not: folderId },
      },
    });

    if (existingFolder) {
      return NextResponse.json(
        { error: "대상 위치에 같은 이름의 폴더가 이미 존재합니다" },
        { status: 409 }
      );
    }

    // 폴더 이동
    const updatedFolder = await prisma.folder.update({
      where: { id: folderId },
      data: {
        parentId: parentId || null,
      },
      include: {
        _count: {
          select: {
            children: true,
            files: true,
          },
        },
      },
    });

    return NextResponse.json({
      message: "폴더가 이동되었습니다",
      folder: updatedFolder,
    });

  } catch (error) {
    console.error("Folder move error:", error);
    return NextResponse.json(
      { error: "폴더 이동 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}

// 순환 참조 확인 헬퍼 함수
async function checkIsDescendant(
  targetId: string,
  ancestorId: string
): Promise<boolean> {
  let currentId: string | null = targetId;

  while (currentId) {
    if (currentId === ancestorId) {
      return true;
    }

    const folder: { parentId: string | null } | null = await prisma.folder.findUnique({
      where: { id: currentId },
      select: { parentId: true },
    });

    currentId = folder?.parentId ?? null;
  }

  return false;
}
</file>

<file path="src/app/api/health/route.ts">
// src/app/api/health/route.ts
// Docker HEALTHCHECK + 로드밸런서 상태 확인용

import { NextResponse } from "next/server";
import { prisma } from "@/lib/db";

export const dynamic = "force-dynamic";

export async function GET() {
  const start = Date.now();

  // DB 연결 확인
  let dbOk = false;
  try {
    await prisma.$queryRaw`SELECT 1`;
    dbOk = true;
  } catch {}

  const latencyMs = Date.now() - start;
  const status    = dbOk ? 200 : 503;

  return NextResponse.json(
    {
      status:    dbOk ? "ok" : "degraded",
      timestamp: new Date().toISOString(),
      uptime:    process.uptime(),
      latencyMs,
      checks: {
        database: dbOk ? "ok" : "error",
        memory: {
          heapUsed:  Math.round(process.memoryUsage().heapUsed / 1024 / 1024),
          heapTotal: Math.round(process.memoryUsage().heapTotal / 1024 / 1024),
          unit: "MB",
        },
      },
    },
    { status }
  );
}
</file>

<file path="src/app/api/link-preview/route.ts">
// src/app/api/link-preview/route.ts
// GET /api/link-preview?url=https://...
// Open Graph 메타데이터 추출

import { NextRequest, NextResponse } from "next/server";
import { withCache, TTL } from "@/lib/cache";

interface OGData {
  title:       string | null;
  description: string | null;
  image:       string | null;
  siteName:    string | null;
  url:         string;
  favicon:     string | null;
}

function extractMeta(html: string, property: string): string | null {
  // og: 태그
  const ogMatch = html.match(
    new RegExp(`<meta[^>]+property=["']${property}["'][^>]+content=["']([^"']+)["']`, "i")
  ) ?? html.match(
    new RegExp(`<meta[^>]+content=["']([^"']+)["'][^>]+property=["']${property}["']`, "i")
  );
  if (ogMatch) return ogMatch[1];
  return null;
}

function extractMetaName(html: string, name: string): string | null {
  return html.match(
    new RegExp(`<meta[^>]+name=["']${name}["'][^>]+content=["']([^"']+)["']`, "i")
  )?.[1] ?? null;
}

function extractTitle(html: string): string | null {
  return html.match(/<title[^>]*>([^<]+)<\/title>/i)?.[1]?.trim() ?? null;
}

export async function GET(request: NextRequest) {
  const url = new URL(request.url).searchParams.get("url");
  if (!url) return NextResponse.json({ error: "url 파라미터가 필요합니다" }, { status: 400 });

  // URL 유효성 검사
  let parsed: URL;
  try {
    parsed = new URL(url);
    if (!["http:", "https:"].includes(parsed.protocol))
      return NextResponse.json({ error: "HTTP/HTTPS URL만 지원합니다" }, { status: 400 });
  } catch {
    return NextResponse.json({ error: "유효하지 않은 URL입니다" }, { status: 400 });
  }

  const cacheKey = `og:${url}`;
  const cached = withCache<OGData | null>(
    cacheKey,
    async () => {
      try {
        const res = await fetch(url, {
          headers: { "User-Agent": "EumBot/1.0 (+https://eum.app)" },
          signal: AbortSignal.timeout(5000),
        });
        if (!res.ok) return null;

        const html = await res.text();
        const origin = parsed.origin;

        const og: OGData = {
          title:       extractMeta(html, "og:title")       ?? extractTitle(html),
          description: extractMeta(html, "og:description") ?? extractMetaName(html, "description"),
          image:       extractMeta(html, "og:image"),
          siteName:    extractMeta(html, "og:site_name")   ?? parsed.hostname,
          url,
          favicon:     `${origin}/favicon.ico`,
        };

        // 상대 URL → 절대 URL 변환
        if (og.image && !og.image.startsWith("http")) {
          og.image = og.image.startsWith("/")
            ? `${origin}${og.image}`
            : `${origin}/${og.image}`;
        }

        return og;
      } catch {
        return null;
      }
    },
    TTL.LONG  // 1시간 캐시
  );

  const data = await cached;
  if (!data) return NextResponse.json({ error: "미리보기를 가져올 수 없습니다" }, { status: 422 });

  return NextResponse.json(data, {
    headers: { "Cache-Control": "public, max-age=3600" },
  });
}
</file>

<file path="src/app/api/notifications/[id]/route.ts">
// src/app/api/notifications/[id]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// PATCH /api/notifications/[id] — 단건 읽음 처리
export async function PATCH(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
    }

    const notification = await prisma.notification.findFirst({
      where: { id: params.id, userId: session.user.id },
    });
    if (!notification) {
      return NextResponse.json({ error: "알림을 찾을 수 없습니다" }, { status: 404 });
    }

    const updated = await prisma.notification.update({
      where: { id: params.id },
      data: { isRead: true },
    });

    return NextResponse.json(updated);
  } catch (error) {
    console.error("PATCH /api/notifications/[id] error:", error);
    return NextResponse.json({ error: "서버 오류가 발생했습니다" }, { status: 500 });
  }
}

// DELETE /api/notifications/[id] — 단건 삭제
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
    }

    const notification = await prisma.notification.findFirst({
      where: { id: params.id, userId: session.user.id },
    });
    if (!notification) {
      return NextResponse.json({ error: "알림을 찾을 수 없습니다" }, { status: 404 });
    }

    await prisma.notification.delete({ where: { id: params.id } });

    return NextResponse.json({ message: "알림을 삭제했습니다" });
  } catch (error) {
    console.error("DELETE /api/notifications/[id] error:", error);
    return NextResponse.json({ error: "서버 오류가 발생했습니다" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/notifications/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// 1. 알림 설정 인터페이스
interface NotificationPreferences {
  pushEnabled: boolean;
  comment: boolean;
  share: boolean;
  chat: boolean;
  system: boolean;
  fileUpload: boolean;
  marketing: boolean;
}

// 2. 기본값 설정
const DEFAULT_PREFS: NotificationPreferences = {
  pushEnabled: true,
  comment: true,
  share: true,
  chat: true,
  system: true,
  fileUpload: true,
  marketing: false,
};

// [GET] 설정 조회
export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { notificationPrefs: true },
    });

    /**
     * [빌드 에러 해결 핵심]
     * TypeScript가 'JsonValue'와 'NotificationPreferences'가 겹치지 않는다고 에러를 내므로,
     * 아예 'any' 타입 변수에 담아서 타입 검사기(Linter)를 완전히 통과시킵니다.
     */
    const rawData: any = user?.notificationPrefs;
    const prefs = rawData || DEFAULT_PREFS;

    return NextResponse.json({ 
      prefs: { ...DEFAULT_PREFS, ...prefs } 
    });
  } catch (error) {
    console.error("GET /api/notifications/preferences error:", error);
    return NextResponse.json({ error: "설정을 불러오지 못했습니다" }, { status: 500 });
  }
}

// [POST] 설정 저장
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
    }

    const body = await request.json();
    const { prefs } = body;

    // 업데이트 시에도 'any'로 캐스팅하여 타입 충돌 방지
    await prisma.user.update({
      where: { id: session.user.id },
      data: {
        notificationPrefs: prefs as any,
      },
    });

    return NextResponse.json({ message: "알림 설정이 저장되었습니다" });
  } catch (error) {
    console.error("POST /api/notifications/preferences error:", error);
    return NextResponse.json({ error: "설정 저장 중 오류가 발생했습니다" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/posts/[id]/bookmark/route.ts">
// src/app/api/posts/[id]/bookmark/route.ts
// POST — 북마크 토글

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function POST(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });

  const existing = await prisma.postBookmark.findUnique({
    where: { postId_userId: { postId: params.id, userId: session.user.id } },
  });

  if (existing) {
    await prisma.postBookmark.delete({ where: { id: existing.id } });
    return NextResponse.json({ bookmarked: false });
  } else {
    await prisma.postBookmark.create({ data: { postId: params.id, userId: session.user.id } });
    return NextResponse.json({ bookmarked: true });
  }
}

export async function GET(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ bookmarked: false });

  const bookmark = await prisma.postBookmark.findUnique({
    where: { postId_userId: { postId: params.id, userId: session.user.id } },
  });

  return NextResponse.json({ bookmarked: !!bookmark });
}
</file>

<file path="src/app/api/posts/[id]/like/route.ts">
// src/app/api/posts/[id]/like/route.ts
// POST — 좋아요 토글 (있으면 취소, 없으면 추가)

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function POST(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });

  const existing = await prisma.postLike.findUnique({
    where: { postId_userId: { postId: params.id, userId: session.user.id } },
  });

  if (existing) {
    await prisma.postLike.delete({ where: { id: existing.id } });
    const count = await prisma.postLike.count({ where: { postId: params.id } });
    return NextResponse.json({ liked: false, count });
  } else {
    await prisma.postLike.create({ data: { postId: params.id, userId: session.user.id } });
    const count = await prisma.postLike.count({ where: { postId: params.id } });
    return NextResponse.json({ liked: true, count });
  }
}

// GET — 좋아요 상태 조회
export async function GET(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ liked: false, count: 0 });

  const [liked, count] = await Promise.all([
    prisma.postLike.findUnique({
      where: { postId_userId: { postId: params.id, userId: session.user.id } },
    }),
    prisma.postLike.count({ where: { postId: params.id } }),
  ]);

  return NextResponse.json({ liked: !!liked, count });
}
</file>

<file path="src/app/api/posts/[id]/share/route.ts">
// src/app/api/posts/[id]/share/route.ts
// ✅ 수정: catch(error) → catch(err) with type cast
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
    }

    const postId = params.id;
    const body = await request.json();
    const { sharedWithEmail, permission = "VIEW" } = body;

    if (!sharedWithEmail) {
      return NextResponse.json({ error: "공유할 사용자 이메일을 입력하세요" }, { status: 400 });
    }

    const post = await prisma.post.findUnique({ where: { id: postId } });
    if (!post) {
      return NextResponse.json({ error: "게시글을 찾을 수 없습니다" }, { status: 404 });
    }
    if (post.userId !== session.user.id) {
      return NextResponse.json({ error: "권한이 없습니다" }, { status: 403 });
    }

    const sharedWithUser = await prisma.user.findUnique({
      where: { email: sharedWithEmail },
    });
    if (!sharedWithUser) {
      return NextResponse.json({ error: "사용자를 찾을 수 없습니다" }, { status: 404 });
    }
    if (sharedWithUser.id === session.user.id) {
      return NextResponse.json({ error: "자기 자신에게는 공유할 수 없습니다" }, { status: 400 });
    }

    const existing = await prisma.sharedResource.findFirst({
      where: { resourceType: "POST", resourceId: postId, sharedWithId: sharedWithUser.id },
    });

    if (existing) {
      const updated = await prisma.sharedResource.update({
        where: { id: existing.id },
        data: { permission },
      });
      return NextResponse.json({ message: "공유 권한이 업데이트되었습니다", share: updated });
    }

    const share = await prisma.sharedResource.create({
      data: {
        resourceType: "POST",
        resourceId:   postId,
        ownerId:      session.user.id,
        sharedWithId: sharedWithUser.id,
        permission,
      },
    });

    return NextResponse.json({ message: "게시글이 공유되었습니다", share }, { status: 201 });

  } catch (err: unknown) {
    const e = err as any;
    console.error("게시글 공유 오류:", e?.message ?? err);
    return NextResponse.json({ error: "게시글 공유 중 오류가 발생했습니다" }, { status: 500 });
  }
}

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
    }

    const shares = await prisma.sharedResource.findMany({
      where: { resourceType: "POST", resourceId: params.id, ownerId: session.user.id },
      include: { sharedWith: { select: { id: true, name: true, email: true } } },
    });

    return NextResponse.json({ shares });
  } catch (err: unknown) {
    console.error("게시글 공유 목록 오류:", err);
    return NextResponse.json({ error: "서버 오류가 발생했습니다" }, { status: 500 });
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
    }

    const { shareId } = await request.json();
    const share = await prisma.sharedResource.findUnique({ where: { id: shareId } });
    if (!share || share.ownerId !== session.user.id) {
      return NextResponse.json({ error: "권한이 없습니다" }, { status: 403 });
    }

    await prisma.sharedResource.delete({ where: { id: shareId } });
    return NextResponse.json({ message: "공유가 취소되었습니다" });
  } catch (err: unknown) {
    console.error("게시글 공유 취소 오류:", err);
    return NextResponse.json({ error: "서버 오류가 발생했습니다" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/posts/bookmarks/route.ts">
// src/app/api/posts/bookmarks/route.ts
// GET — 내 북마크 목록

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function GET() {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });

  const bookmarks = await prisma.postBookmark.findMany({
    where: { userId: session.user.id },
    include: {
      post: {
        select: {
          id: true, title: true, content: true, createdAt: true,
          user: { select: { id: true, name: true } },
          _count: { select: { comments: true, likes: true } },
        },
      },
    },
    orderBy: { createdAt: "desc" },
  });

  return NextResponse.json({
    posts: bookmarks.map((b) => ({ ...b.post, bookmarkedAt: b.createdAt })),
  });
}
</file>

<file path="src/app/api/share/[token]/route.ts">
// src/app/api/share/[token]/route.ts
// 공개 토큰으로 파일 정보 조회 (비로그인 접근 가능)

import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { createReadStream } from "fs";
import { stat } from "fs/promises";

export async function GET(
  request: NextRequest,
  { params }: { params: { token: string } }
) {
  const file = await prisma.file.findUnique({
    where: { publicToken: params.token },
    select: {
      id: true, originalName: true, mimeType: true,
      size: true, filepath: true, thumbnailUrl: true,
      createdAt: true,
      user: { select: { name: true } },
      deletedAt: true,
    },
  });

  if (!file || file.deletedAt) {
    return NextResponse.json({ error: "파일을 찾을 수 없거나 만료된 링크입니다" }, { status: 404 });
  }

  const download = new URL(request.url).searchParams.get("download");

  // 메타데이터만 반환
  if (!download) {
    return NextResponse.json({
      originalName: file.originalName,
      mimeType: file.mimeType,
      size: file.size.toString(),
      thumbnailUrl: file.thumbnailUrl,
      createdAt: file.createdAt,
      ownerName: file.user.name,
    });
  }

  // 파일 스트림 반환 (다운로드)
  try {
    const fileStat = await stat(file.filepath);
    const stream = createReadStream(file.filepath);
    const readable = new ReadableStream({
      start(controller) {
        stream.on("data", (chunk) => controller.enqueue(chunk));
        stream.on("end", () => controller.close());
        stream.on("error", (err) => controller.error(err));
      },
    });

    return new NextResponse(readable, {
      headers: {
        "Content-Type": file.mimeType,
        "Content-Length": fileStat.size.toString(),
        "Content-Disposition": `attachment; filename*=UTF-8''${encodeURIComponent(file.originalName)}`,
      },
    });
  } catch {
    return NextResponse.json({ error: "파일을 읽을 수 없습니다" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/share/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// 공유 목록 조회
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
    }

    // 내가 공유받은 목록
    const sharedWithMe = await prisma.sharedResource.findMany({
      where: { sharedWithId: session.user.id },
      include: {
        owner: {
          select: { id: true, name: true, email: true },
        },
      },
      orderBy: { createdAt: "desc" },
    });

    // 내가 공유한 목록
    const sharedByMe = await prisma.sharedResource.findMany({
      where: { ownerId: session.user.id },
      include: {
        sharedWith: {
          select: { id: true, name: true, email: true },
        },
      },
      orderBy: { createdAt: "desc" },
    });

    return NextResponse.json({ sharedWithMe, sharedByMe });
  } catch (error) {
    console.error("Share list error:", error);
    return NextResponse.json(
      { error: "공유 목록 조회 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}

// 공유 생성
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
    }

    const body = await request.json();
    const { resourceType, resourceId, sharedWithEmail, permission } = body;

    // 필수값 확인
    if (!resourceType || !resourceId || !sharedWithEmail) {
      return NextResponse.json(
        { error: "resourceType, resourceId, sharedWithEmail 은 필수입니다" },
        { status: 400 }
      );
    }

    // 공유 대상 사용자 찾기 (이메일로)
    const sharedWithUser = await prisma.user.findUnique({
      where: { email: sharedWithEmail.trim().toLowerCase() },
    });

    if (!sharedWithUser) {
      return NextResponse.json(
        { error: "해당 이메일의 사용자를 찾을 수 없습니다" },
        { status: 404 }
      );
    }

    // 자기 자신에게 공유 방지
    if (sharedWithUser.id === session.user.id) {
      return NextResponse.json(
        { error: "자기 자신에게는 공유할 수 없습니다" },
        { status: 400 }
      );
    }

    // 리소스 존재 + 소유자 확인
    if (resourceType === "FILE") {
      const file = await prisma.file.findUnique({
        where: { id: resourceId },
      });
      if (!file) {
        return NextResponse.json(
          { error: "파일을 찾을 수 없습니다" },
          { status: 404 }
        );
      }
      if (file.userId !== session.user.id) {
        return NextResponse.json(
          { error: "파일 소유자만 공유할 수 있습니다" },
          { status: 403 }
        );
      }
    } else if (resourceType === "FOLDER") {
      const folder = await prisma.folder.findUnique({
        where: { id: resourceId },
      });
      if (!folder) {
        return NextResponse.json(
          { error: "폴더를 찾을 수 없습니다" },
          { status: 404 }
        );
      }
      if (folder.userId !== session.user.id) {
        return NextResponse.json(
          { error: "폴더 소유자만 공유할 수 있습니다" },
          { status: 403 }
        );
      }
    } else if (resourceType === "POST") {
      const post = await prisma.post.findUnique({
        where: { id: resourceId },
      });
      if (!post) {
        return NextResponse.json(
          { error: "게시글을 찾을 수 없습니다" },
          { status: 404 }
        );
      }
      if (post.userId !== session.user.id) {
        return NextResponse.json(
          { error: "게시글 작성자만 공유할 수 있습니다" },
          { status: 403 }
        );
      }
    } else {
      return NextResponse.json(
        { error: "올바르지 않은 resourceType 입니다 (FILE | FOLDER | POST)" },
        { status: 400 }
      );
    }

    // 이미 공유 중인지 확인
    const existing = await prisma.sharedResource.findFirst({
      where: {
        resourceType,
        resourceId,
        sharedWithId: sharedWithUser.id,
      },
    });

    if (existing) {
      // 이미 있으면 권한만 업데이트
      const updated = await prisma.sharedResource.update({
        where: { id: existing.id },
        data: { permission: permission || "VIEW" },
      });
      return NextResponse.json({
        message: "공유 권한이 업데이트되었습니다",
        share: updated,
      });
    }

    // 새 공유 생성
    const share = await prisma.sharedResource.create({
      data: {
        resourceType,
        resourceId,
        ownerId: session.user.id,        // ← sharedById → ownerId 수정
        sharedWithId: sharedWithUser.id,
        permission: permission || "VIEW",
      },
    });

    return NextResponse.json(
      { message: "공유가 완료되었습니다", share },
      { status: 201 }
    );
  } catch (error) {
    console.error("Share create error:", error);
    return NextResponse.json(
      { error: "공유 중 오류가 발생했습니다" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/users/[id]/follow/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const targetUserId = params.id;

    if (session.user.id === targetUserId) {
      return NextResponse.json(
        { error: "자기 자신은 팔로우할 수 없습니다." },
        { status: 400 }
      );
    }

    // 팔로우 생성
    await prisma.follow.create({
      data: {
        followerId: session.user.id,
        followingId: targetUserId,
      },
    });

    // 🔥 알림 생성 (message 필수 추가)
    await prisma.notification.create({
      data: {
        user: {
          connect: { id: targetUserId },
        },
        type: "SYSTEM",
        title: `${session.user.name}님이 팔로우했습니다`,
        message: `${session.user.name}님이 당신을 팔로우했습니다.`, // ✅ 추가
        link: `/users/${session.user.id}`,
      },
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Follow error:", error);
    return NextResponse.json({ error: "Server Error" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/users/[id]/followers/route.ts">
// src/app/api/users/[id]/followers/route.ts
// GET /api/users/[id]/followers?type=followers|following

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });

  const type = new URL(request.url).searchParams.get("type") ?? "followers";

  const users =
    type === "followers"
      ? await prisma.follow.findMany({
          where: { followingId: params.id },
          include: { follower: { select: { id: true, name: true, email: true, isOnline: true } } },
          orderBy: { createdAt: "desc" },
        }).then((r) => r.map((f) => ({ ...f.follower, followedAt: f.createdAt })))
      : await prisma.follow.findMany({
          where: { followerId: params.id },
          include: { following: { select: { id: true, name: true, email: true, isOnline: true } } },
          orderBy: { createdAt: "desc" },
        }).then((r) => r.map((f) => ({ ...f.following, followedAt: f.createdAt })));

  return NextResponse.json({ users });
}
</file>

<file path="src/app/api/users/[id]/public/route.ts">
// src/app/api/users/[id]/public/route.ts
// 공개 프로필 조회 (비밀번호 해시 등 민감 정보 제외)

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function GET(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });

  const user = await prisma.user.findUnique({
    where: { id: params.id },
    select: {
      id: true, name: true, email: true, role: true,
      isOnline: true, createdAt: true,
      _count: { select: { files: true, posts: true, comments: true } },
    },
  });

  if (!user) return NextResponse.json({ error: "사용자를 찾을 수 없습니다" }, { status: 404 });

  return NextResponse.json(user);
}
</file>

<file path="src/app/api/users/me/api-keys/[keyId]/route.ts">
// src/app/api/users/me/api-keys/[keyId]/route.ts
// DELETE — API 키 삭제

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function DELETE(
  _req: NextRequest,
  { params }: { params: { keyId: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });

  const key = await prisma.apiKey.findFirst({
    where: { id: params.keyId, userId: session.user.id },
  });
  if (!key) return NextResponse.json({ error: "API 키를 찾을 수 없습니다" }, { status: 404 });

  await prisma.apiKey.delete({ where: { id: params.keyId } });
  return NextResponse.json({ message: "API 키가 삭제되었습니다" });
}

// ─────────────────────────────────────────────────────────
// src/lib/api-key-auth.ts
// 외부 API 엔드포인트에서 Bearer 토큰 인증 시 사용
// ─────────────────────────────────────────────────────────
//
// import { verifyApiKey } from "@/lib/api-key-auth";
//
// export async function GET(request: NextRequest) {
//   const auth = await verifyApiKey(request, ["read:files"]);
//   if (!auth.ok) return NextResponse.json({ error: auth.error }, { status: 401 });
//   const { userId } = auth;
//   ...
// }
</file>

<file path="src/app/api/users/me/api-keys/route.ts">
// src/app/api/users/me/api-keys/route.ts
// GET    — API 키 목록
// POST   — 새 API 키 생성

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import crypto from "crypto";
import bcrypt from "bcryptjs";

const MAX_KEYS = 10;
const VALID_SCOPES = ["read:files", "write:files", "read:posts", "write:posts", "read:profile"];

export async function GET() {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });

  const keys = await prisma.apiKey.findMany({
    where: { userId: session.user.id },
    select: {
      id: true, name: true, keyPrefix: true,
      scopes: true, lastUsedAt: true, expiresAt: true, createdAt: true,
    },
    orderBy: { createdAt: "desc" },
  });

  return NextResponse.json({ keys });
}

export async function POST(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });

  const count = await prisma.apiKey.count({ where: { userId: session.user.id } });
  if (count >= MAX_KEYS)
    return NextResponse.json({ error: `API 키는 최대 ${MAX_KEYS}개까지 생성할 수 있습니다` }, { status: 400 });

  const { name, scopes = [], expiresInDays } = await request.json();

  if (!name?.trim()) return NextResponse.json({ error: "이름이 필요합니다" }, { status: 400 });
  const validScopes = (scopes as string[]).filter((s) => VALID_SCOPES.includes(s));

  // eum_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 형식
  const rawKey = `eum_${crypto.randomBytes(32).toString("hex")}`;
  const keyHash = await bcrypt.hash(rawKey, 10);
  const keyPrefix = rawKey.slice(0, 12); // "eum_xxxxxxxx"

  const expiresAt = expiresInDays
    ? new Date(Date.now() + expiresInDays * 86400000)
    : null;

  const key = await prisma.apiKey.create({
    data: {
      userId: session.user.id,
      name: name.trim(),
      keyHash,
      keyPrefix,
      scopes: validScopes,
      expiresAt,
    },
  });

  // rawKey는 생성 직후 1번만 반환 (이후 조회 불가)
  return NextResponse.json({
    key: {
      id: key.id, name: key.name, keyPrefix: key.keyPrefix,
      scopes: key.scopes, expiresAt: key.expiresAt, createdAt: key.createdAt,
    },
    rawKey, // ⚠️ 지금 복사하지 않으면 다시 볼 수 없습니다
  });
}
</file>

<file path="src/app/api/users/me/avatar/route.ts">
// src/app/api/users/me/avatar/route.ts
// POST — 아바타 또는 커버 이미지 업로드

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import { writeFile, mkdir, unlink } from "fs/promises";
import { existsSync } from "fs";
import path from "path";
import sharp from "sharp";
import crypto from "crypto";

const STORAGE_PATH = process.env.STORAGE_PATH ?? "./storage";
const AVATAR_DIR   = path.join(STORAGE_PATH, "avatars");
const COVER_DIR    = path.join(STORAGE_PATH, "covers");

export async function POST(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });

  const formData = await request.formData();
  const file     = formData.get("file") as File | null;
  const type     = formData.get("type") as "avatar" | "cover" | null;

  if (!file)                    return NextResponse.json({ error: "파일이 필요합니다" }, { status: 400 });
  if (!["avatar", "cover"].includes(type ?? ""))
    return NextResponse.json({ error: "type은 avatar 또는 cover여야 합니다" }, { status: 400 });
  if (!file.type.startsWith("image/"))
    return NextResponse.json({ error: "이미지 파일만 업로드 가능합니다" }, { status: 400 });
  if (file.size > 5 * 1024 * 1024)
    return NextResponse.json({ error: "파일 크기는 5MB 이하여야 합니다" }, { status: 400 });

  const isAvatar = type === "avatar";
  const dir      = isAvatar ? AVATAR_DIR : COVER_DIR;
  if (!existsSync(dir)) await mkdir(dir, { recursive: true });

  const id      = crypto.randomUUID();
  const outPath = path.join(dir, `${session.user.id}_${id}.webp`);

  const bytes  = await file.arrayBuffer();
  const buffer = Buffer.from(bytes);

  // 아바타: 400x400 정사각형 / 커버: 1200x400
  await sharp(buffer)
    .rotate()
    .resize(
      isAvatar ? 400 : 1200,
      isAvatar ? 400 : 400,
      { fit: isAvatar ? "cover" : "cover", position: "attention" }
    )
    .webp({ quality: 85 })
    .toFile(outPath);

  // 기존 파일 삭제
  const user = await prisma.user.findUnique({
    where: { id: session.user.id },
    select: { avatarUrl: true, coverUrl: true },
  });
  const oldPath = isAvatar ? user?.avatarUrl : user?.coverUrl;
  if (oldPath && existsSync(oldPath)) await unlink(oldPath).catch(() => {});

  // DB 업데이트
  const updated = await prisma.user.update({
    where: { id: session.user.id },
    data: isAvatar
      ? { avatarUrl: outPath }
      : { coverUrl:  outPath },
    select: { avatarUrl: true, coverUrl: true },
  });

  // 공개 URL 반환 (Next.js image serving API 통해)
  const publicUrl = `/api/users/me/avatar?type=${type}&v=${id}`;
  return NextResponse.json({ url: outPath, publicUrl, message: "업로드 완료" });
}

// GET — 아바타/커버 이미지 파일 서빙
export async function GET(request: NextRequest) {
  const session = await getServerSession(authOptions);
  const userId  = new URL(request.url).searchParams.get("userId") ?? session?.user?.id;
  const type    = new URL(request.url).searchParams.get("type") ?? "avatar";

  if (!userId) return new NextResponse(null, { status: 404 });

  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { avatarUrl: true, coverUrl: true },
  });

  const filePath = type === "avatar" ? user?.avatarUrl : user?.coverUrl;
  if (!filePath || !existsSync(filePath)) return new NextResponse(null, { status: 404 });

  const { readFile } = await import("fs/promises");
  const data = await readFile(filePath);
  return new NextResponse(data, {
    headers: {
      "Content-Type": "image/webp",
      "Cache-Control": "public, max-age=3600",
    },
  });
}

// ── schema.prisma User 모델에 추가 ─────────────────────────
// avatarUrl  String? @map("avatar_url")
// coverUrl   String? @map("cover_url")
</file>

<file path="src/app/api/users/me/onboarding/route.ts">
// src/app/api/users/me/onboarding/route.ts
// POST — 온보딩 완료 기록 (DB에 저장)
// GET  — 온보딩 완료 여부 확인

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function POST() {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });

  await prisma.user.update({
    where: { id: session.user.id },
    data: { onboardingDone: true },
  });

  return NextResponse.json({ message: "온보딩 완료" });
}

export async function GET() {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ onboardingDone: false });

  const user = await prisma.user.findUnique({
    where: { id: session.user.id },
    select: { onboardingDone: true },
  });

  return NextResponse.json({ onboardingDone: user?.onboardingDone ?? false });
}
</file>

<file path="src/app/api/users/me/sessions/route.ts">
// src/app/api/users/me/sessions/route.ts
// GET  — 내 활성 세션 목록
// DELETE — 특정 세션 또는 현재 외 모든 세션 로그아웃

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// GET — 세션 목록
export async function GET(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });

  const sessions = await prisma.userSession.findMany({
    where: { userId: session.user.id },
    orderBy: { lastActive: "desc" },
    take: 20,
  });

  // 현재 세션 토큰 (쿠키에서)
  const currentToken = request.cookies.get("next-auth.session-token")?.value
    ?? request.cookies.get("__Secure-next-auth.session-token")?.value;

  return NextResponse.json({
    sessions: sessions.map((s) => ({
      ...s,
      isCurrent: s.token === currentToken,
    })),
  });
}

// DELETE — 세션 종료
export async function DELETE(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });

  const { sessionId, revokeAll } = await request.json();

  if (revokeAll) {
    // 현재 세션 제외하고 전부 삭제
    const currentToken = request.cookies.get("next-auth.session-token")?.value
      ?? request.cookies.get("__Secure-next-auth.session-token")?.value;

    await prisma.userSession.deleteMany({
      where: {
        userId: session.user.id,
        token: currentToken ? { not: currentToken } : undefined,
      },
    });
    return NextResponse.json({ message: "다른 모든 기기에서 로그아웃되었습니다" });
  }

  if (sessionId) {
    const s = await prisma.userSession.findFirst({
      where: { id: sessionId, userId: session.user.id },
    });
    if (!s) return NextResponse.json({ error: "세션을 찾을 수 없습니다" }, { status: 404 });
    await prisma.userSession.delete({ where: { id: sessionId } });
    return NextResponse.json({ message: "세션이 종료되었습니다" });
  }

  return NextResponse.json({ error: "sessionId 또는 revokeAll 필요" }, { status: 400 });
}
</file>

<file path="src/app/api/users/mention-search/route.ts">
// src/app/api/users/mention-search/route.ts
// GET /api/users/mention-search?q=검색어&limit=5
// @멘션 자동완성용 빠른 사용자 검색

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import { withCache, TTL } from "@/lib/cache";

export async function GET(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ users: [] });

  const q = new URL(request.url).searchParams.get("q")?.trim() ?? "";
  if (q.length < 1) return NextResponse.json({ users: [] });

  const users = await withCache(
    `mention-search:${q.toLowerCase()}`,
    () => prisma.user.findMany({
      where: {
        id:   { not: session.user.id },
        name: { contains: q, mode: "insensitive" },
      },
      select: { id: true, name: true, isOnline: true },
      take:   6,
      orderBy: [{ isOnline: "desc" }, { name: "asc" }],
    }),
    TTL.SHORT
  );

  return NextResponse.json({ users });
}
</file>

<file path="src/app/api/users/search/route.ts">
// src/app/api/users/search/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function GET(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });

  const { searchParams } = new URL(request.url);
  const q = searchParams.get("q")?.trim() ?? "";
  const page = Math.max(1, parseInt(searchParams.get("page") ?? "1"));
  const limit = 20;

  if (q.length < 1) return NextResponse.json({ users: [], total: 0 });

  const where = {
    OR: [
      { name:  { contains: q, mode: "insensitive" as const } },
      { email: { contains: q, mode: "insensitive" as const } },
    ],
    id: { not: session.user.id },
  };

  const [users, total] = await Promise.all([
    prisma.user.findMany({
      where,
      select: {
        id: true, name: true, email: true,
        role: true, isOnline: true, createdAt: true,
        _count: { select: { files: true, posts: true } },
        followers: { where: { followerId: session.user.id }, select: { id: true } },
      },
      skip: (page - 1) * limit,
      take: limit,
      orderBy: [{ isOnline: "desc" }, { name: "asc" }],
    }),
    prisma.user.count({ where }),
  ]);

  return NextResponse.json({
    users: users.map((u) => ({ ...u, isFollowing: u.followers.length > 0, followers: undefined })),
    total,
    totalPages: Math.ceil(total / limit),
  });
}
</file>

<file path="src/app/banned/page.tsx">
// src/app/banned/page.tsx
// middleware.ts에서 isBanned 사용자를 이 페이지로 리디렉션

import { signOut } from "next-auth/react";
import Link from "next/link";

export default function BannedPage() {
  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gray-50 dark:bg-slate-900 px-4">
      <div className="max-w-md w-full text-center space-y-6">
        <div className="w-20 h-20 rounded-2xl bg-red-50 dark:bg-red-900/30 flex items-center justify-center mx-auto text-4xl">
          🚫
        </div>
        <div>
          <h1 className="text-2xl font-black text-gray-900 dark:text-slate-100 mb-2">
            계정이 정지되었습니다
          </h1>
          <p className="text-gray-500 dark:text-slate-400 text-sm">
            이 계정은 서비스 이용 규정 위반으로 인해 정지되었습니다.
            <br />
            문의사항은 관리자에게 연락해 주세요.
          </p>
        </div>
        <div className="flex flex-col gap-3">
          <a
            href="mailto:admin@eum.app"
            className="w-full py-3 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-xl transition text-center"
          >
            관리자에게 문의
          </a>
          <Link
            href="/api/auth/signout"
            className="w-full py-3 text-sm font-semibold text-gray-700 dark:text-slate-300 bg-white dark:bg-slate-800 border border-gray-200 dark:border-slate-700 hover:bg-gray-50 dark:hover:bg-slate-700 rounded-xl transition text-center"
          >
            로그아웃
          </Link>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/global-error.tsx">
// ══════════════════════════════════════════════════════════
// src/app/global-error.tsx — 최상위 에러 핸들러 (레이아웃 오류)
// ══════════════════════════════════════════════════════════
// "use client";
// export default function GlobalError({ error, reset }) {
//   return (
//     <html><body>
//       <div className="min-h-screen flex items-center justify-center">
//         <div className="text-center">
//           <h1 className="text-2xl font-bold mb-4">치명적 오류</h1>
//           <button onClick={reset} className="px-6 py-2 bg-blue-600 text-white rounded-xl">
//             앱 재시작
//           </button>
//         </div>
//       </div>
//     </body></html>
//   );
// }
</file>

<file path="src/app/globals.css">
/* - 모바일 UI/UX 대응 */
:root {
  --sat: env(safe-area-inset-top);
  --sab: env(safe-area-inset-bottom);
}

html, body {
  /* 키보드 대응을 위한 높이 설정 */
  height: -webkit-fill-available;
  overflow: hidden; /* 바디 스크롤 방지, 내부 스크롤 사용 */
}

.safe-area-bottom {
  padding-bottom: var(--sab);
}

/* 메시지 리스트 영역: 입력창 높이를 제외한 가변 높이 */
.chat-messages-container {
  height: calc(100vh - 80px - var(--sat) - var(--sab));
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

/* 모바일 입력창 하단 고정 */
.chat-input-wrapper {
  position: sticky;
  bottom: 0;
  padding-bottom: max(1rem, var(--sab));
  background: white;
  z-index: 50;
}
</file>

<file path="src/app/notifications/page.tsx">
"use client";

import { useState, useEffect, useCallback } from "react";
import { useRouter } from "next/navigation";
import Link from "next/link";
import {
  Bell,
  BellOff,
  MessageCircle,
  Share2,
  FileUp,
  Phone,
  Info,
  MessageSquare,
  Trash2,
  CheckCheck,
  ChevronLeft,
  RefreshCw,
} from "lucide-react";
import { toast } from "@/components/Toast";

type NotificationType = "COMMENT" | "SHARE" | "CHAT" | "SYSTEM" | "FILE_UPLOAD" | "CALL";

interface Notification {
  id: string;
  type: NotificationType;
  title: string;
  body?: string;
  link?: string;
  isRead: boolean;
  createdAt: string;
}

// 타입별 아이콘 + 색상
const TYPE_META: Record<
  NotificationType,
  { icon: React.ElementType; color: string; bg: string; label: string }
> = {
  COMMENT:     { icon: MessageSquare, color: "text-blue-600",  bg: "bg-blue-50",   label: "댓글" },
  SHARE:       { icon: Share2,        color: "text-green-600", bg: "bg-green-50",  label: "공유" },
  CHAT:        { icon: MessageCircle, color: "text-purple-600",bg: "bg-purple-50", label: "채팅" },
  SYSTEM:      { icon: Info,          color: "text-gray-600 dark:text-slate-400",  bg: "bg-gray-50 dark:bg-slate-900",   label: "시스템" },
  FILE_UPLOAD: { icon: FileUp,        color: "text-orange-600",bg: "bg-orange-50", label: "파일" },
  CALL:        { icon: Phone,         color: "text-red-600",   bg: "bg-red-50",    label: "전화" },
};

function timeAgo(dateStr: string): string {
  const diff = Date.now() - new Date(dateStr).getTime();
  const m = Math.floor(diff / 60000);
  if (m < 1) return "방금 전";
  if (m < 60) return `${m}분 전`;
  const h = Math.floor(m / 60);
  if (h < 24) return `${h}시간 전`;
  const d = Math.floor(h / 24);
  if (d < 7) return `${d}일 전`;
  return new Date(dateStr).toLocaleDateString("ko-KR");
}

export default function NotificationsPage() {
  const router = useRouter();
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [unreadCount, setUnreadCount] = useState(0);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState<"all" | "unread">("all");
  const [deletingId, setDeletingId] = useState<string | null>(null);

  const fetchNotifications = useCallback(async () => {
    setLoading(true);
    try {
      const res = await fetch(
        `/api/notifications${filter === "unread" ? "?unread=true" : ""}`
      );
      if (!res.ok) throw new Error("failed");
      const data = await res.json();
      setNotifications(data.notifications);
      setUnreadCount(data.unreadCount);
    } catch {
      toast.error("알림을 불러오지 못했습니다");
    } finally {
      setLoading(false);
    }
  }, [filter]);

  useEffect(() => {
    fetchNotifications();
  }, [fetchNotifications]);

  // 단건 읽음
  const markRead = async (id: string) => {
    setNotifications((prev) =>
      prev.map((n) => (n.id === id ? { ...n, isRead: true } : n))
    );
    setUnreadCount((c) => Math.max(0, c - 1));
    await fetch(`/api/notifications/${id}`, { method: "PATCH" });
  };

  // 단건 삭제
  const deleteOne = async (id: string) => {
    setDeletingId(id);
    try {
      await fetch(`/api/notifications/${id}`, { method: "DELETE" });
      setNotifications((prev) => prev.filter((n) => n.id !== id));
      const wasUnread = notifications.find((n) => n.id === id)?.isRead === false;
      if (wasUnread) setUnreadCount((c) => Math.max(0, c - 1));
      toast.success("알림을 삭제했습니다");
    } catch {
      toast.error("삭제 중 오류가 발생했습니다");
    } finally {
      setDeletingId(null);
    }
  };

  // 전체 읽음
  const markAllRead = async () => {
    await fetch("/api/notifications", { method: "PATCH" });
    setNotifications((prev) => prev.map((n) => ({ ...n, isRead: true })));
    setUnreadCount(0);
    toast.success("모든 알림을 읽음 처리했습니다");
  };

  // 전체 삭제
  const deleteAll = async () => {
    await fetch("/api/notifications", { method: "DELETE" });
    setNotifications([]);
    setUnreadCount(0);
    toast.success("모든 알림을 삭제했습니다");
  };

  // 알림 클릭: 읽음 처리 후 링크 이동
  const handleClick = (n: Notification) => {
    if (!n.isRead) markRead(n.id);
    if (n.link) router.push(n.link);
  };

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900 dark:bg-slate-900">
      {/* 헤더 */}
      <div className="bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700 dark:border-slate-700 sticky top-0 z-10">
        <div className="max-w-2xl mx-auto px-4 py-3 flex items-center gap-3">
          <Link href="/dashboard" className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 dark:bg-slate-700 transition-colors">
            <ChevronLeft size={20} className="text-gray-600 dark:text-slate-400" />
          </Link>
          <div className="flex items-center gap-2 flex-1">
            <Bell size={20} className="text-gray-800" />
            <h1 className="text-lg font-semibold text-gray-900 dark:text-slate-100">알림</h1>
            {unreadCount > 0 && (
              <span className="bg-red-500 text-white text-xs font-bold px-2 py-0.5 rounded-full">
                {unreadCount}
              </span>
            )}
          </div>
          <button
            onClick={fetchNotifications}
            className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 dark:bg-slate-700 transition-colors"
            title="새로고침"
          >
            <RefreshCw size={16} className="text-gray-500 dark:text-slate-400" />
          </button>
        </div>

        {/* 필터 탭 */}
        <div className="max-w-2xl mx-auto px-4 pb-2 flex gap-1">
          {(["all", "unread"] as const).map((f) => (
            <button
              key={f}
              onClick={() => setFilter(f)}
              className={`px-3 py-1.5 rounded-full text-sm font-medium transition-colors ${
                filter === f
                  ? "bg-blue-600 text-white"
                  : "text-gray-500 dark:text-slate-400 hover:bg-gray-100 dark:hover:bg-slate-700 dark:bg-slate-700"
              }`}
            >
              {f === "all" ? "전체" : `읽지 않음 ${unreadCount > 0 ? `(${unreadCount})` : ""}`}
            </button>
          ))}
        </div>
      </div>

      <div className="max-w-2xl mx-auto px-4 py-4">
        {/* 일괄 액션 */}
        {notifications.length > 0 && (
          <div className="flex justify-end gap-2 mb-3">
            {unreadCount > 0 && (
              <button
                onClick={markAllRead}
                className="flex items-center gap-1.5 text-sm text-blue-600 hover:text-blue-700 font-medium px-3 py-1.5 rounded-lg hover:bg-blue-50 transition-colors"
              >
                <CheckCheck size={14} />
                모두 읽음
              </button>
            )}
            <button
              onClick={deleteAll}
              className="flex items-center gap-1.5 text-sm text-red-500 hover:text-red-600 font-medium px-3 py-1.5 rounded-lg hover:bg-red-50 transition-colors"
            >
              <Trash2 size={14} />
              전체 삭제
            </button>
          </div>
        )}

        {/* 알림 목록 */}
        {loading ? (
          <div className="space-y-3">
            {[...Array(5)].map((_, i) => (
              <div key={i} className="bg-white dark:bg-slate-800 rounded-xl p-4 animate-pulse">
                <div className="flex gap-3">
                  <div className="w-10 h-10 rounded-full bg-gray-200 shrink-0" />
                  <div className="flex-1 space-y-2">
                    <div className="h-4 bg-gray-200 rounded w-3/4" />
                    <div className="h-3 bg-gray-100 dark:bg-slate-700 rounded w-1/2" />
                  </div>
                </div>
              </div>
            ))}
          </div>
        ) : notifications.length === 0 ? (
          <div className="flex flex-col items-center justify-center py-24 text-center">
            <div className="w-16 h-16 rounded-full bg-gray-100 dark:bg-slate-700 flex items-center justify-center mb-4">
              <BellOff size={28} className="text-gray-400 dark:text-slate-500" />
            </div>
            <p className="text-gray-500 dark:text-slate-400 font-medium">알림이 없습니다</p>
            <p className="text-gray-400 dark:text-slate-500 text-sm mt-1">
              {filter === "unread" ? "읽지 않은 알림이 없습니다" : "새 알림이 오면 여기 표시됩니다"}
            </p>
          </div>
        ) : (
          <div className="space-y-2">
            {notifications.map((n) => {
              const meta = TYPE_META[n.type];
              const Icon = meta.icon;
              return (
                <div
                  key={n.id}
                  className={`bg-white dark:bg-slate-800 rounded-xl border transition-all ${
                    n.isRead ? "border-gray-100 dark:border-slate-700" : "border-blue-100 shadow-sm"
                  }`}
                >
                  <div
                    className={`flex items-start gap-3 p-4 cursor-pointer hover:bg-gray-50 dark:hover:bg-slate-700 dark:bg-slate-900 rounded-xl transition-colors ${
                      !n.isRead ? "bg-blue-50/40" : ""
                    }`}
                    onClick={() => handleClick(n)}
                  >
                    {/* 아이콘 */}
                    <div className={`w-10 h-10 rounded-full flex items-center justify-center shrink-0 ${meta.bg}`}>
                      <Icon size={18} className={meta.color} />
                    </div>

                    {/* 내용 */}
                    <div className="flex-1 min-w-0">
                      <div className="flex items-start justify-between gap-2">
                        <p className={`text-sm leading-snug ${n.isRead ? "text-gray-700 dark:text-slate-300" : "text-gray-900 dark:text-slate-100 font-semibold"}`}>
                          {n.title}
                        </p>
                        <div className="flex items-center gap-1 shrink-0">
                          {!n.isRead && (
                            <span className="w-2 h-2 rounded-full bg-blue-500 shrink-0" />
                          )}
                        </div>
                      </div>
                      {n.body && (
                        <p className="text-xs text-gray-500 dark:text-slate-400 mt-0.5 line-clamp-2">{n.body}</p>
                      )}
                      <div className="flex items-center gap-2 mt-1.5">
                        <span className={`text-[10px] font-medium px-1.5 py-0.5 rounded-full ${meta.bg} ${meta.color}`}>
                          {meta.label}
                        </span>
                        <span className="text-xs text-gray-400 dark:text-slate-500">{timeAgo(n.createdAt)}</span>
                      </div>
                    </div>
                  </div>

                  {/* 액션 버튼 */}
                  <div className="flex border-t border-gray-100 dark:border-slate-700">
                    {!n.isRead && (
                      <button
                        onClick={(e) => { e.stopPropagation(); markRead(n.id); }}
                        className="flex-1 py-2 text-xs text-blue-600 font-medium hover:bg-blue-50 transition-colors rounded-bl-xl"
                      >
                        읽음 처리
                      </button>
                    )}
                    <button
                      onClick={(e) => { e.stopPropagation(); deleteOne(n.id); }}
                      disabled={deletingId === n.id}
                      className={`${n.isRead ? "w-full rounded-b-xl" : "flex-1"} py-2 text-xs text-red-400 font-medium hover:bg-red-50 transition-colors ${n.isRead ? "rounded-bl-xl" : ""} rounded-br-xl`}
                    >
                      {deletingId === n.id ? "삭제 중..." : "삭제"}
                    </button>
                  </div>
                </div>
              );
            })}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/app/notifications/settings/page.tsx">
"use client";

import { useState, useEffect } from "react";
import Link from "next/link";
import {
  Bell, BellOff, ChevronLeft, MessageSquare, Share2,
  MessageCircle, Phone, Info, FileUp, Mail, RefreshCw,
} from "lucide-react";
import { registerFCMToken, unregisterFCMToken } from "@/lib/firebase";
import { toast } from "@/components/Toast";

interface NotificationPreferences {
  pushEnabled: boolean;
  comment:     boolean;
  share:       boolean;
  chat:        boolean;
  call:        boolean;
  system:      boolean;
  fileUpload:  boolean;
  emailDigest: boolean;
}

const DEFAULT_PREFS: NotificationPreferences = {
  pushEnabled: true,
  comment:     true,
  share:       true,
  chat:        true,
  call:        true,
  system:      true,
  fileUpload:  false,
  emailDigest: false,
};

interface SettingItem {
  key: keyof NotificationPreferences;
  label: string;
  desc: string;
  icon: React.ElementType;
  color: string;
  bg: string;
  requiresPush?: boolean; // pushEnabled가 false면 비활성화
}

const SETTINGS: SettingItem[] = [
  {
    key: "comment", label: "댓글 알림", requiresPush: true,
    desc: "내 게시글에 새 댓글이 달렸을 때",
    icon: MessageSquare, color: "text-blue-600", bg: "bg-blue-50 dark:bg-blue-900/30",
  },
  {
    key: "share", label: "공유 알림", requiresPush: true,
    desc: "파일이나 폴더가 공유되었을 때",
    icon: Share2, color: "text-green-600", bg: "bg-green-50 dark:bg-green-900/30",
  },
  {
    key: "chat", label: "채팅 알림", requiresPush: true,
    desc: "새 채팅 메시지가 도착했을 때",
    icon: MessageCircle, color: "text-purple-600", bg: "bg-purple-50 dark:bg-purple-900/30",
  },
  {
    key: "call", label: "통화 알림", requiresPush: true,
    desc: "음성/영상 통화 요청이 들어왔을 때",
    icon: Phone, color: "text-red-600", bg: "bg-red-50 dark:bg-red-900/30",
  },
  {
    key: "system", label: "시스템 알림", requiresPush: true,
    desc: "서비스 공지 및 중요 안내",
    icon: Info, color: "text-gray-600", bg: "bg-gray-50 dark:bg-gray-800",
  },
  {
    key: "fileUpload", label: "파일 업로드 완료", requiresPush: true,
    desc: "대용량 파일 업로드가 완료되었을 때",
    icon: FileUp, color: "text-orange-600", bg: "bg-orange-50 dark:bg-orange-900/30",
  },
  {
    key: "emailDigest", label: "이메일 주간 요약",
    desc: "매주 활동 요약을 이메일로 받기 (준비 중)",
    icon: Mail, color: "text-indigo-600", bg: "bg-indigo-50 dark:bg-indigo-900/30",
  },
];

// ─── Toggle 버튼 ─────────────────────────────────────
function Toggle({
  enabled, onToggle, disabled = false,
}: {
  enabled: boolean; onToggle: () => void; disabled?: boolean;
}) {
  return (
    <button
      onClick={onToggle}
      disabled={disabled}
      aria-checked={enabled}
      role="switch"
      className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors
        focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2
        ${enabled ? "bg-blue-600" : "bg-gray-200 dark:bg-slate-600"}
        ${disabled ? "opacity-40 cursor-not-allowed" : "cursor-pointer"}`}
    >
      <span
        className={`inline-block h-4 w-4 transform rounded-full bg-white shadow transition-transform
          ${enabled ? "translate-x-6" : "translate-x-1"}`}
      />
    </button>
  );
}

export default function NotificationSettingsPage() {
  const [prefs, setPrefs] = useState<NotificationPreferences>(DEFAULT_PREFS);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [browserPermission, setBrowserPermission] = useState<NotificationPermission | null>(null);

  // 브라우저 알림 권한 상태
  useEffect(() => {
    if ("Notification" in window) {
      setBrowserPermission(Notification.permission);
    }
  }, []);

  // 서버에서 설정 불러오기
  useEffect(() => {
    fetch("/api/notifications/preferences")
      .then((r) => r.json())
      .then((d) => setPrefs({ ...DEFAULT_PREFS, ...d.prefs }))
      .catch(() => toast.error("설정을 불러오지 못했습니다"))
      .finally(() => setLoading(false));
  }, []);

  // 개별 토글 저장 (debounce 없이 즉시 저장)
  const toggle = async (key: keyof NotificationPreferences) => {
    const newPrefs = { ...prefs, [key]: !prefs[key] };
    setPrefs(newPrefs);
    setSaving(true);
    try {
      await fetch("/api/notifications/preferences", {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(newPrefs),
      });
    } catch {
      // 실패 시 롤백
      setPrefs(prefs);
      toast.error("설정 저장에 실패했습니다");
    } finally {
      setSaving(false);
    }
  };

  // 푸시 전체 토글 (FCM 연동 포함)
  const togglePush = async () => {
    setSaving(true);
    if (prefs.pushEnabled) {
      await unregisterFCMToken();
      await toggle("pushEnabled");
    } else {
      if (browserPermission === "denied") {
        toast.error("브라우저 설정에서 알림 권한을 허용한 뒤 다시 시도해주세요.");
        setSaving(false);
        return;
      }
      const success = await registerFCMToken();
      if (success) {
        setBrowserPermission("granted");
        await toggle("pushEnabled");
      } else {
        toast.error("알림 권한을 허용해주세요.");
      }
    }
    setSaving(false);
  };

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900">
      {/* 헤더 */}
      <div className="bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700 sticky top-0 z-10">
        <div className="max-w-2xl mx-auto px-4 py-3 flex items-center gap-3">
          <Link
            href="/profile"
            className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors"
          >
            <ChevronLeft size={20} className="text-gray-600 dark:text-slate-400" />
          </Link>
          <Bell size={20} className="text-gray-800 dark:text-slate-200" />
          <h1 className="text-lg font-semibold text-gray-900 dark:text-slate-100 flex-1">
            알림 설정
          </h1>
          {saving && (
            <RefreshCw size={14} className="animate-spin text-blue-500" />
          )}
        </div>
      </div>

      <div className="max-w-2xl mx-auto px-4 py-6 space-y-4">

        {/* 브라우저 권한 경고 */}
        {browserPermission === "denied" && (
          <div className="flex items-start gap-3 p-4 bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-700 rounded-xl">
            <BellOff size={18} className="text-amber-600 shrink-0 mt-0.5" />
            <div>
              <p className="text-sm font-semibold text-amber-800 dark:text-amber-400">
                브라우저 알림이 차단됨
              </p>
              <p className="text-xs text-amber-700 dark:text-amber-500 mt-0.5">
                주소창 왼쪽 자물쇠 아이콘 → 알림 → 허용으로 변경 후 새로고침하세요.
              </p>
            </div>
          </div>
        )}

        {/* 푸시 알림 마스터 토글 */}
        <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-5">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              <div className="w-10 h-10 rounded-full bg-blue-50 dark:bg-blue-900/30 flex items-center justify-center">
                <Bell size={20} className="text-blue-600 dark:text-blue-400" />
              </div>
              <div>
                <p className="font-semibold text-gray-900 dark:text-slate-100">
                  푸시 알림 전체
                </p>
                <p className="text-xs text-gray-500 dark:text-slate-400 mt-0.5">
                  앱을 닫아도 알림을 받습니다
                </p>
              </div>
            </div>
            <Toggle
              enabled={prefs.pushEnabled}
              onToggle={togglePush}
              disabled={loading || browserPermission === "denied"}
            />
          </div>
        </div>

        {/* 알림 종류별 설정 */}
        <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 overflow-hidden">
          <div className="px-5 py-3 border-b border-gray-100 dark:border-slate-700">
            <p className="text-xs font-semibold text-gray-500 dark:text-slate-400 uppercase tracking-wide">
              알림 종류
            </p>
          </div>

          {loading ? (
            <div className="p-8 flex justify-center">
              <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600" />
            </div>
          ) : (
            <div className="divide-y divide-gray-100 dark:divide-slate-700">
              {SETTINGS.map(({ key, label, desc, icon: Icon, color, bg, requiresPush }) => {
                const isDisabled = requiresPush && !prefs.pushEnabled;
                return (
                  <div
                    key={key}
                    className={`flex items-center gap-3 px-5 py-4 transition-colors
                      ${isDisabled ? "opacity-50" : "hover:bg-gray-50 dark:hover:bg-slate-700/50"}`}
                  >
                    <div className={`w-9 h-9 rounded-full ${bg} flex items-center justify-center shrink-0`}>
                      <Icon size={16} className={color} />
                    </div>
                    <div className="flex-1 min-w-0">
                      <p className="text-sm font-medium text-gray-900 dark:text-slate-100">
                        {label}
                        {key === "emailDigest" && (
                          <span className="ml-2 text-[10px] font-semibold bg-gray-100 dark:bg-slate-700 text-gray-500 dark:text-slate-400 px-1.5 py-0.5 rounded">
                            준비 중
                          </span>
                        )}
                      </p>
                      <p className="text-xs text-gray-500 dark:text-slate-400">{desc}</p>
                    </div>
                    <Toggle
                      enabled={prefs[key]}
                      onToggle={() => toggle(key)}
                      disabled={loading || saving || isDisabled || key === "emailDigest"}
                    />
                  </div>
                );
              })}
            </div>
          )}
        </div>

        {/* 안내 */}
        <p className="text-xs text-center text-gray-400 dark:text-slate-500 pb-4">
          설정은 자동으로 저장됩니다. 변경 사항은 즉시 반영됩니다.
        </p>
      </div>
    </div>
  );
}
</file>

<file path="src/app/page.tsx">
"use client";

import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import { useEffect, useRef, useState } from "react";
import Link from "next/link";
import {
  Cloud, ShieldCheck, Zap, Share2, ArrowRight,
  MessageCircle, Search, Bell, Smartphone, Lock,
  HardDrive, Globe, CheckCircle2,
} from "lucide-react";

function useInView(threshold = 0.15) {
  const ref = useRef<HTMLDivElement>(null);
  const [inView, setInView] = useState(false);
  useEffect(() => {
    const obs = new IntersectionObserver(([e]) => { if (e.isIntersecting) setInView(true); }, { threshold });
    if (ref.current) obs.observe(ref.current);
    return () => obs.disconnect();
  }, [threshold]);
  return { ref, inView };
}

function CountUp({ to, suffix = "" }: { to: number; suffix?: string }) {
  const [val, setVal] = useState(0);
  const { ref, inView } = useInView();
  useEffect(() => {
    if (!inView) return;
    const step = Math.ceil(to / 60);
    let cur = 0;
    const t = setInterval(() => {
      cur = Math.min(cur + step, to);
      setVal(cur);
      if (cur >= to) clearInterval(t);
    }, 16);
    return () => clearInterval(t);
  }, [inView, to]);
  return <span ref={ref}>{val.toLocaleString()}{suffix}</span>;
}

const FEATURES = [
  {
    icon: HardDrive, color: "from-blue-500 to-cyan-400",
    title: "스마트 파일 관리",
    desc: "폴더 계층, 태그, 전문 검색으로 수천 개의 파일을 한눈에 정리하세요.",
    points: ["폴더 & 태그 기반 분류", "파일 미리보기 (이미지·영상·PDF)", "퍼미션 기반 선택 공유"],
  },
  {
    icon: MessageCircle, color: "from-purple-500 to-pink-400",
    title: "실시간 채팅 & 통화",
    desc: "텍스트, 파일 전송, 음성·영상 통화까지 하나의 앱에서 해결하세요.",
    points: ["WebRTC 음성·영상 통화", "채팅방 파일 첨부", "온라인 프레즌스 표시"],
  },
  {
    icon: ShieldCheck, color: "from-green-500 to-emerald-400",
    title: "강력한 보안",
    desc: "bcrypt 암호화, 세션 보호, 2단계 인증으로 데이터를 안전하게 지킵니다.",
    points: ["비밀번호 bcrypt 해싱", "TOTP 2단계 인증", "역할 기반 접근 제어"],
  },
  {
    icon: Bell, color: "from-orange-500 to-amber-400",
    title: "스마트 알림",
    desc: "댓글, 공유, 채팅, 통화 요청을 FCM 푸시로 실시간 수신하세요.",
    points: ["FCM 브라우저 푸시", "알림 종류별 개별 설정", "앱 내 알림 히스토리"],
  },
  {
    icon: Search, color: "from-indigo-500 to-violet-400",
    title: "통합 전문 검색",
    desc: "파일명, 게시글 본문, 태그, 작성자를 한 번에 검색하세요.",
    points: ["파일 + 게시글 통합 검색", "태그 필터링", "저장된 검색 조건"],
  },
  {
    icon: Smartphone, color: "from-rose-500 to-pink-400",
    title: "PWA 모바일 앱",
    desc: "홈 화면에 추가하면 네이티브 앱처럼 사용할 수 있습니다.",
    points: ["홈 화면 설치 지원", "오프라인 캐싱", "모바일 최적화 UI"],
  },
];

const STATS = [
  { value: 5120, suffix: "MB", label: "1인당 무료 저장용량" },
  { value: 50,   suffix: "MB", label: "최대 파일 업로드 크기" },
  { value: 99,   suffix: "%",  label: "업타임 목표" },
  { value: 2048, suffix: "+",  label: "지원 파일 형식" },
];

export default function HomePage() {
  const { status } = useSession();
  const router = useRouter();

  useEffect(() => {
    if (status === "authenticated") router.push("/dashboard");
  }, [status, router]);

  if (status === "loading") return (
    <div className="min-h-screen bg-[#0f0c29] flex items-center justify-center">
      <div className="w-12 h-12 border-4 border-purple-500/20 border-t-purple-500 rounded-full animate-spin" />
    </div>
  );

  return (
    <div className="min-h-screen bg-[#0f0c29] text-white overflow-x-hidden selection:bg-purple-500/30">

      {/* 배경 */}
      <div className="fixed inset-0 -z-10 pointer-events-none overflow-hidden">
        <div className="absolute -top-40 -left-40 w-[700px] h-[700px] bg-purple-700/20 rounded-full blur-[120px]" />
        <div className="absolute top-1/2 -right-40 w-[500px] h-[500px] bg-blue-700/15 rounded-full blur-[100px]" />
        <div className="absolute -bottom-40 left-1/3 w-[600px] h-[600px] bg-indigo-700/10 rounded-full blur-[120px]" />
        <div className="absolute inset-0 opacity-[0.03]"
          style={{ backgroundImage: "linear-gradient(#fff 1px,transparent 1px),linear-gradient(90deg,#fff 1px,transparent 1px)", backgroundSize: "60px 60px" }} />
      </div>

      {/* 네비게이션 */}
      <nav className="sticky top-0 z-50 border-b border-white/5 backdrop-blur-xl bg-[#0f0c29]/80">
        <div className="max-w-6xl mx-auto px-6 h-16 flex items-center justify-between">
          <div className="flex items-center gap-2">
            <div className="w-8 h-8 rounded-xl bg-gradient-to-br from-purple-500 to-blue-600 flex items-center justify-center">
              <Cloud size={16} className="text-white" />
            </div>
            <span className="text-lg font-black tracking-tight">이음</span>
          </div>
          <div className="hidden md:flex items-center gap-6 text-sm text-white/50">
            <a href="#features" className="hover:text-white transition-colors">기능</a>
            <a href="#stats" className="hover:text-white transition-colors">사양</a>
            <a href="#tech" className="hover:text-white transition-colors">기술 스택</a>
          </div>
          <div className="flex items-center gap-3">
            <Link href="/login" className="px-4 py-2 text-sm font-semibold text-white/60 hover:text-white transition-colors">
              로그인
            </Link>
            <Link href="/register" className="px-4 py-2 text-sm font-bold bg-white text-black rounded-xl hover:bg-purple-50 transition-all">
              무료 시작
            </Link>
          </div>
        </div>
      </nav>

      <div className="max-w-6xl mx-auto px-6">

        {/* 히어로 */}
        <section className="pt-24 pb-32 text-center">
          <div className="inline-flex items-center gap-2 px-4 py-2 rounded-full bg-white/5 border border-white/10 text-purple-300 text-xs font-bold mb-10">
            <span className="relative flex h-2 w-2">
              <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-purple-400 opacity-75" />
              <span className="relative inline-flex rounded-full h-2 w-2 bg-purple-500" />
            </span>
            NEXT-GEN PERSONAL CLOUD
          </div>

          <h1 className="text-5xl md:text-7xl lg:text-8xl font-black mb-8 leading-[1.05] tracking-tight">
            사람과 파일을<br />
            <span className="bg-clip-text text-transparent bg-gradient-to-r from-purple-400 via-blue-300 to-emerald-300">
              하나로 잇다
            </span>
          </h1>

          <p className="text-lg md:text-xl text-white/45 max-w-2xl mx-auto mb-14 leading-relaxed">
            파일 관리부터 실시간 채팅, WebRTC 통화, 스마트 검색까지.<br className="hidden md:block" />
            하나의 플랫폼에서 모든 것을 경험하세요.
          </p>

          <div className="flex flex-col sm:flex-row items-center justify-center gap-4 mb-20">
            <Link
              href="/register"
              className="group w-full sm:w-auto px-8 py-4 bg-white text-black font-black rounded-2xl hover:bg-purple-50 transition-all flex items-center justify-center gap-2 shadow-xl shadow-white/10"
            >
              지금 무료로 시작하기
              <ArrowRight size={18} className="group-hover:translate-x-1 transition-transform" />
            </Link>
            <a
              href="#features"
              className="w-full sm:w-auto px-8 py-4 bg-white/5 text-white font-bold rounded-2xl border border-white/10 hover:bg-white/10 transition-all"
            >
              기능 둘러보기
            </a>
          </div>

          {/* 미리보기 모형 */}
          <div className="relative max-w-3xl mx-auto">
            <div className="relative bg-white/5 border border-white/10 rounded-[28px] p-1 shadow-2xl shadow-purple-900/20">
              <div className="bg-slate-900/80 rounded-[22px] p-4 text-left">
                <div className="flex items-center gap-2 mb-4">
                  <div className="w-3 h-3 rounded-full bg-red-500/70" />
                  <div className="w-3 h-3 rounded-full bg-yellow-500/70" />
                  <div className="w-3 h-3 rounded-full bg-green-500/70" />
                  <div className="flex-1 mx-4 h-6 bg-white/5 rounded-full" />
                </div>
                <div className="grid grid-cols-3 gap-2">
                  {["📁 Documents", "🖼️ Photos", "🎬 Videos", "📄 Reports", "🎵 Music", "📊 Data"].map((name) => (
                    <div key={name} className="bg-white/5 rounded-xl p-3 flex items-center gap-2 border border-white/5">
                      <span className="text-sm">{name.split(" ")[0]}</span>
                      <span className="text-xs text-white/40 truncate">{name.split(" ").slice(1).join(" ")}</span>
                    </div>
                  ))}
                </div>
                <div className="mt-3 flex gap-2">
                  <div className="flex-1 h-10 bg-blue-500/20 rounded-xl border border-blue-500/30 flex items-center px-3 gap-2">
                    <div className="w-2 h-2 rounded-full bg-green-400 animate-pulse" />
                    <span className="text-xs text-white/40">김철수님과 채팅 중...</span>
                  </div>
                  <div className="w-10 h-10 bg-purple-500/20 rounded-xl border border-purple-500/30 flex items-center justify-center">
                    <Bell size={14} className="text-purple-300" />
                  </div>
                </div>
              </div>
            </div>
            <div className="absolute -inset-4 bg-gradient-to-r from-purple-600/20 via-blue-600/10 to-emerald-600/20 rounded-[40px] blur-2xl -z-10" />
          </div>
        </section>

        {/* 통계 */}
        <section id="stats" className="py-20">
          <div className="grid grid-cols-2 md:grid-cols-4 gap-6">
            {STATS.map(({ value, suffix, label }) => (
              <div key={label} className="text-center p-6 rounded-[24px] bg-white/5 border border-white/10 hover:border-purple-500/30 transition-all">
                <p className="text-4xl font-black mb-2 bg-clip-text text-transparent bg-gradient-to-r from-purple-300 to-blue-300">
                  <CountUp to={value} suffix={suffix} />
                </p>
                <p className="text-white/40 text-xs font-medium">{label}</p>
              </div>
            ))}
          </div>
        </section>

        {/* 기능 */}
        <section id="features" className="py-20">
          <div className="text-center mb-16">
            <p className="text-purple-400 text-xs font-bold uppercase tracking-widest mb-4">FEATURES</p>
            <h2 className="text-4xl md:text-5xl font-black mb-4">필요한 모든 것이<br />한 곳에</h2>
            <p className="text-white/40 max-w-xl mx-auto">개인 스토리지를 넘어서는 올인원 생산성 플랫폼</p>
          </div>
          <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-5">
            {FEATURES.map(({ icon: Icon, color, title, desc, points }) => (
              <div key={title} className="group p-6 rounded-[24px] bg-white/5 border border-white/10 hover:border-white/20 hover:-translate-y-1 transition-all duration-300">
                <div className={`w-12 h-12 rounded-2xl bg-gradient-to-br ${color} flex items-center justify-center mb-5 shadow-lg group-hover:scale-110 transition-transform`}>
                  <Icon size={22} className="text-white" />
                </div>
                <h3 className="text-lg font-bold mb-2">{title}</h3>
                <p className="text-white/40 text-sm leading-relaxed mb-4">{desc}</p>
                <ul className="space-y-1.5">
                  {points.map((pt) => (
                    <li key={pt} className="flex items-center gap-2 text-xs text-white/50">
                      <CheckCircle2 size={12} className="text-emerald-400 shrink-0" />
                      {pt}
                    </li>
                  ))}
                </ul>
              </div>
            ))}
          </div>
        </section>

        {/* 기술 스택 */}
        <section id="tech" className="py-20">
          <div className="relative p-10 rounded-[40px] bg-gradient-to-b from-white/8 to-transparent border border-white/10 overflow-hidden">
            <div className="absolute top-0 right-0 p-8 opacity-5">
              <Globe size={160} />
            </div>
            <div className="relative z-10">
              <div className="flex items-center gap-3 mb-10">
                <CheckCircle2 className="text-emerald-400" size={22} />
                <h3 className="text-2xl font-black tracking-tight">SYSTEM OPERATIONAL</h3>
              </div>
              <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-6 gap-6">
                {[
                  { label: "Framework", value: "Next.js 14" },
                  { label: "Database",  value: "PostgreSQL" },
                  { label: "ORM",       value: "Prisma 5" },
                  { label: "Auth",      value: "NextAuth.js" },
                  { label: "Realtime",  value: "Socket.IO" },
                  { label: "Security",  value: "bcrypt + TOTP" },
                ].map(({ label, value }) => (
                  <div key={label}>
                    <p className="text-white/25 text-[10px] font-bold uppercase tracking-widest mb-1">{label}</p>
                    <p className="text-white font-mono text-sm font-semibold">{value}</p>
                  </div>
                ))}
              </div>
            </div>
          </div>
        </section>

        {/* CTA */}
        <section className="py-20 text-center">
          <h2 className="text-4xl md:text-5xl font-black mb-6">지금 바로 시작하세요</h2>
          <p className="text-white/40 mb-10 max-w-md mx-auto">신용카드 불필요. 5GB 무료 스토리지로 바로 시작하세요.</p>
          <Link
            href="/register"
            className="group inline-flex items-center gap-2 px-10 py-5 bg-white text-black font-black rounded-2xl hover:bg-purple-50 transition-all text-lg shadow-2xl shadow-white/10"
          >
            무료로 시작하기
            <ArrowRight size={20} className="group-hover:translate-x-1 transition-transform" />
          </Link>
        </section>
      </div>

      {/* 푸터 */}
      <footer className="border-t border-white/5 py-10">
        <div className="max-w-6xl mx-auto px-6 flex flex-col md:flex-row items-center justify-between gap-4">
          <div className="flex items-center gap-2">
            <div className="w-6 h-6 rounded-lg bg-gradient-to-br from-purple-500 to-blue-600 flex items-center justify-center">
              <Cloud size={12} className="text-white" />
            </div>
            <span className="text-sm font-bold text-white/40">이음 (Eum)</span>
          </div>
          <p className="text-white/20 text-xs font-medium tracking-widest uppercase">
            © 2026 EUM CLOUD SERVICE. ALL RIGHTS RESERVED.
          </p>
          <div className="flex gap-4 text-xs text-white/30">
            <Link href="/login" className="hover:text-white/60 transition-colors">로그인</Link>
            <Link href="/register" className="hover:text-white/60 transition-colors">회원가입</Link>
          </div>
        </div>
      </footer>
    </div>
  );
}
</file>

<file path="src/app/posts/[id]/page.tsx">
"use client";

import { useSession } from "next-auth/react";
import { useRouter, useParams } from "next/navigation";
import { useEffect, useState } from "react";
import Link from "next/link";
import { toast } from "@/components/Toast";
import { useConfirm } from "@/components/ConfirmDialog";

interface Comment {
  id: string;
  content: string;
  createdAt: string;
  user: { id: string; name: string };
}

interface Post {
  id: string;
  title: string;
  content: string;
  visibility: string;
  createdAt: string;
  user: { id: string; name: string; email: string };
  comments: Comment[];
}

// PostShareModal은 기존 컴포넌트 그대로 사용
import PostShareModal from "@/components/PostShareModal";

export default function PostDetailPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const params = useParams();
  const postId = params.id as string;

  const [post, setPost] = useState<Post | null>(null);
  const [loading, setLoading] = useState(true);
  const [comment, setComment] = useState("");
  const [submitting, setSubmitting] = useState(false);
  const [shareModalOpen, setShareModalOpen] = useState(false);

  const { confirmDialog, openConfirm } = useConfirm();

  useEffect(() => {
    if (status === "unauthenticated") router.push("/login");
  }, [status, router]);

  useEffect(() => {
    if (session && postId) fetchPost();
  }, [session, postId]);

  const fetchPost = async () => {
    try {
      const res = await fetch(`/api/posts/${postId}`);
      if (res.ok) {
        const data = await res.json();
        setPost(data.post);
      } else {
        // ✅ alert() → toast + router.push
        toast.error("게시글을 불러올 수 없습니다");
        router.push("/posts");
      }
    } catch {
      toast.error("게시글 로드 중 오류가 발생했습니다");
    } finally {
      setLoading(false);
    }
  };

  const handleCommentSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!comment.trim()) return;
    setSubmitting(true);

    try {
      const res = await fetch(`/api/posts/${postId}/comments`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ content: comment }),
      });

      if (res.ok) {
        setComment("");
        fetchPost();
      } else {
        toast.error("댓글 작성에 실패했습니다");
      }
    } catch {
      toast.error("오류가 발생했습니다");
    } finally {
      setSubmitting(false);
    }
  };

  const handleDeleteComment = (commentId: string) => {
    // ✅ confirm() → ConfirmDialog
    openConfirm({
      title: "댓글 삭제",
      message: "댓글을 삭제하시겠습니까?",
      confirmLabel: "삭제",
      variant: "danger",
      onConfirm: async () => {
        try {
          const res = await fetch(`/api/comments/${commentId}`, { method: "DELETE" });
          if (res.ok) {
            fetchPost();
          } else {
            toast.error("댓글 삭제에 실패했습니다");
          }
        } catch {
          toast.error("오류가 발생했습니다");
        }
      },
    });
  };

  const handleDeletePost = () => {
    // ✅ confirm() → ConfirmDialog
    openConfirm({
      title: "게시글 삭제",
      message: "게시글을 삭제하면 되돌릴 수 없습니다. 삭제하시겠습니까?",
      confirmLabel: "삭제",
      variant: "danger",
      onConfirm: async () => {
        try {
          const res = await fetch(`/api/posts/${postId}`, { method: "DELETE" });
          if (res.ok) {
            toast.success("게시글이 삭제되었습니다");
            router.push("/posts");
          } else {
            toast.error("삭제에 실패했습니다");
          }
        } catch {
          toast.error("오류가 발생했습니다");
        }
      },
    });
  };

  const getVisibilityBadge = (visibility: string) => {
    const badges: Record<string, { text: string; color: string }> = {
      PUBLIC: { text: "공개", color: "bg-green-100 text-green-700" },
      SHARED: { text: "공유", color: "bg-blue-100 text-blue-700" },
      PRIVATE: { text: "비공개", color: "bg-gray-100 text-gray-700" },
    };
    return badges[visibility] || badges.PRIVATE;
  };

  if (status === "loading" || loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <p className="text-gray-600">로딩 중...</p>
      </div>
    );
  }

  if (!session || !post) return null;

  const isAuthor = post.user.id === session.user.id;
  const badge = getVisibilityBadge(post.visibility);

  return (
    <div className="min-h-screen bg-gray-50">
      {confirmDialog}

      <header className="bg-white shadow">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
          <Link href="/posts" className="text-gray-600 hover:text-gray-900">
            ← 목록으로
          </Link>
        </div>
      </header>

      <main className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        {/* 게시글 본문 */}
        <div className="bg-white rounded-lg shadow p-6 mb-6">
          <div className="flex items-start justify-between mb-4">
            <div className="flex-1">
              <h1 className="text-2xl font-bold text-gray-900 mb-2">{post.title}</h1>
              <div className="flex items-center gap-4 text-sm text-gray-500">
                <span>{post.user.name}</span>
                <span>•</span>
                <span>{new Date(post.createdAt).toLocaleDateString("ko-KR")}</span>
                <span className={`px-2 py-1 text-xs rounded-full ${badge.color}`}>
                  {badge.text}
                </span>
              </div>
            </div>
            {isAuthor && (
              <div className="flex gap-2">
                {post.visibility === "SHARED" && (
                  <button
                    onClick={() => setShareModalOpen(true)}
                    className="px-3 py-1 text-sm text-blue-600 border border-blue-300 hover:bg-blue-50 rounded"
                  >
                    공유 관리
                  </button>
                )}
                <button
                  onClick={handleDeletePost}
                  className="px-3 py-1 text-sm text-red-600 border border-red-300 hover:bg-red-50 rounded"
                >
                  삭제
                </button>
              </div>
            )}
          </div>

          {post.visibility === "SHARED" && (
            <div className="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-md">
              <p className="text-sm text-blue-800">
                🔗 이 게시글은 <strong>특정 사용자에게만 공유</strong>된 상태입니다.
                {isAuthor && <> "공유 관리" 버튼을 클릭하여 공유 대상을 관리할 수 있습니다.</>}
              </p>
            </div>
          )}

          <div className="prose max-w-none">
            <p className="whitespace-pre-wrap text-gray-700">{post.content}</p>
          </div>
        </div>

        {/* 댓글 */}
        <div className="bg-white rounded-lg shadow p-6">
          <h2 className="text-lg font-semibold text-gray-900 mb-4">
            댓글 ({post.comments.length})
          </h2>

          <form onSubmit={handleCommentSubmit} className="mb-6">
            <textarea
              value={comment}
              onChange={(e) => setComment(e.target.value)}
              rows={3}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 mb-2 text-gray-900"
              placeholder="댓글을 입력하세요"
            />
            <div className="flex justify-end">
              <button
                type="submit"
                disabled={submitting || !comment.trim()}
                className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:bg-gray-400 transition"
              >
                {submitting ? "작성 중..." : "댓글 작성"}
              </button>
            </div>
          </form>

          <div className="space-y-4">
            {post.comments.length === 0 ? (
              <p className="text-center text-gray-500 py-4">첫 댓글을 작성해보세요</p>
            ) : (
              post.comments.map((c) => (
                <div key={c.id} className="border-t pt-4 first:border-t-0 first:pt-0">
                  <div className="flex items-start justify-between">
                    <div className="flex-1">
                      <div className="flex items-center gap-2 mb-1">
                        <span className="font-medium text-gray-900">{c.user.name}</span>
                        <span className="text-sm text-gray-500">
                          {new Date(c.createdAt).toLocaleDateString("ko-KR")}
                        </span>
                      </div>
                      <p className="text-gray-700">{c.content}</p>
                    </div>
                    {c.user.id === session.user.id && (
                      <button
                        onClick={() => handleDeleteComment(c.id)}
                        className="text-red-500 hover:text-red-700 text-sm ml-4 flex-shrink-0"
                      >
                        삭제
                      </button>
                    )}
                  </div>
                </div>
              ))
            )}
          </div>
        </div>
      </main>

      {shareModalOpen && (
        <PostShareModal
          postId={postId}
          postTitle={post.title}
          onClose={() => setShareModalOpen(false)}
        />
      )}
    </div>
  );
}
</file>

<file path="src/app/posts/new/page.tsx">
"use client";

import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import { useState, useEffect } from "react";
import Link from "next/link";
import { toast } from "@/components/Toast";

export default function NewPostPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const [formData, setFormData] = useState({
    title: "",
    content: "",
    visibility: "PRIVATE",
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  useEffect(() => {
    if (status === "unauthenticated") router.push("/login");
  }, [status, router]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");
    setLoading(true);

    try {
      const res = await fetch("/api/posts", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(formData),
      });

      const data = await res.json();

      if (!res.ok) {
        setError(data.error || "게시글 작성 실패");
        setLoading(false);
        return;
      }

      // ✅ alert() → toast (작성 완료 후 바로 이동하므로 toast.success로 충분)
      toast.success("게시글이 작성되었습니다");
      router.push(`/posts/${data.post.id}`);
    } catch {
      setError("작성 중 오류가 발생했습니다");
      setLoading(false);
    }
  };

  if (status === "loading") {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <p className="text-gray-600">로딩 중...</p>
      </div>
    );
  }

  if (!session) return null;

  return (
    <div className="min-h-screen bg-gray-50">
      <header className="bg-white shadow">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
          <div className="flex items-center gap-4">
            <Link href="/posts" className="text-gray-600 hover:text-gray-900">
              ← 목록
            </Link>
            <h1 className="text-2xl font-bold text-gray-900">글쓰기</h1>
          </div>
        </div>
      </header>

      <main className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div className="bg-white rounded-lg shadow p-6">
          {error && (
            <div className="mb-4 p-4 bg-red-50 border border-red-200 rounded-md">
              <p className="text-sm text-red-800">{error}</p>
            </div>
          )}

          <form onSubmit={handleSubmit} className="space-y-6">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">제목</label>
              <input
                type="text"
                value={formData.title}
                onChange={(e) => setFormData({ ...formData, title: e.target.value })}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-900"
                placeholder="제목을 입력하세요"
                required
              />
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">공개 설정</label>
              <select
                value={formData.visibility}
                onChange={(e) => setFormData({ ...formData, visibility: e.target.value })}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-900"
              >
                <option value="PRIVATE">비공개</option>
                <option value="SHARED">공유</option>
                <option value="PUBLIC">공개</option>
              </select>
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">내용</label>
              <textarea
                value={formData.content}
                onChange={(e) => setFormData({ ...formData, content: e.target.value })}
                rows={15}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-900"
                placeholder="내용을 입력하세요"
                required
              />
            </div>

            <div className="flex justify-end gap-2">
              <Link
                href="/posts"
                className="px-4 py-2 text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50"
              >
                취소
              </Link>
              <button
                type="submit"
                disabled={loading}
                className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:bg-gray-400 transition"
              >
                {loading ? "작성 중..." : "작성하기"}
              </button>
            </div>
          </form>
        </div>
      </main>
    </div>
  );
}
</file>

<file path="src/app/posts/page.tsx">
"use client";

import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import { useEffect, useState } from "react";
import Link from "next/link";
import SearchBar from "@/components/SearchBar";

interface Post {
  id: string;
  title: string;
  content: string;
  visibility: string;
  createdAt: string;
  user: {
    id: string;
    name: string;
  };
  _count: {
    comments: number;
  };
  isOwner: boolean;
  isShared: boolean;
  sharedBy?: string;
}

export default function PostsPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const [posts, setPosts] = useState<Post[]>([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState<"all" | "my" | "public" | "shared">("all");
  const [searchQuery, setSearchQuery] = useState("");

  useEffect(() => {
    if (status === "unauthenticated") {
      router.push("/login");
    }
  }, [status, router]);

  useEffect(() => {
    if (session) {
      fetchPosts();
    }
  }, [session, filter, searchQuery]);

  const fetchPosts = async () => {
    setLoading(true);
    try {
      const params = new URLSearchParams();
      if (filter !== "all") {
        params.set("visibility", filter);
      }
      if (searchQuery) {
        params.set("search", searchQuery);
      }

      const res = await fetch(`/api/posts?${params}`);
      if (res.ok) {
        const data = await res.json();
        setPosts(data.posts);
      } else {
        console.error("Failed to fetch posts");
      }
    } catch (err) {
      console.error("Failed to fetch posts:", err);
    } finally {
      setLoading(false);
    }
  };

  const getVisibilityBadge = (visibility: string) => {
    const badges = {
      PUBLIC: { text: "공개", color: "bg-green-100 text-green-700" },
      SHARED: { text: "공유", color: "bg-blue-100 text-blue-700" },
      PRIVATE: { text: "비공개", color: "bg-gray-100 text-gray-700" },
    };
    return badges[visibility as keyof typeof badges] || badges.PRIVATE;
  };

  if (status === "loading") {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <p className="text-gray-600">로딩 중...</p>
      </div>
    );
  }

  if (!session) return null;

  return (
    <div className="min-h-screen bg-gray-50">
      {/* 헤더 */}
      <header className="bg-white shadow">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4 flex justify-between items-center">
          <div className="flex items-center gap-4">
            <Link href="/dashboard" className="text-2xl">
              ☁️
            </Link>
            <h1 className="text-2xl font-bold text-gray-900">게시판</h1>
          </div>
          <Link
            href="/posts/new"
            className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
          >
            글쓰기
          </Link>
        </div>
      </header>

      {/* 메인 */}
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        {/* 필터 */}
        <div className="flex gap-2 mb-4">
          <button
            onClick={() => setFilter("all")}
            className={`px-4 py-2 rounded-md ${
              filter === "all"
                ? "bg-blue-600 text-white"
                : "bg-white text-gray-700 border hover:bg-gray-50"
            }`}
          >
            전체
          </button>
          <button
            onClick={() => setFilter("my")}
            className={`px-4 py-2 rounded-md ${
              filter === "my"
                ? "bg-blue-600 text-white"
                : "bg-white text-gray-700 border hover:bg-gray-50"
            }`}
          >
            내 글
          </button>
          <button
            onClick={() => setFilter("public")}
            className={`px-4 py-2 rounded-md ${
              filter === "public"
                ? "bg-green-600 text-white"
                : "bg-white text-gray-700 border hover:bg-gray-50"
            }`}
          >
            공개 글
          </button>
          <button
            onClick={() => setFilter("shared")}
            className={`px-4 py-2 rounded-md ${
              filter === "shared"
                ? "bg-purple-600 text-white"
                : "bg-white text-gray-700 border hover:bg-gray-50"
            }`}
          >
            공유받은 글
          </button>
        </div>

        {/* 검색 */}
        <div className="mb-6">
          <SearchBar
            onSearch={setSearchQuery}
            placeholder="게시글 검색..."
          />
        </div>

        {/* 설명 */}
        <div className="mb-4 p-4 bg-blue-50 border border-blue-200 rounded-md">
          <p className="text-sm text-blue-800">
            <strong>💡 공개 설정 안내:</strong>
            <br />
            • <strong>비공개</strong>: 나만 볼 수 있음
            <br />
            • <strong>공유</strong>: 특정 사용자에게만 공유 (파일처럼 이메일로 공유)
            <br />
            • <strong>공개</strong>: 모든 사용자가 볼 수 있음
          </p>
        </div>

        {/* 게시글 목록 */}
        {loading ? (
          <p className="text-center text-gray-500 py-8">로딩 중...</p>
        ) : posts.length === 0 ? (
          <div className="bg-white rounded-lg shadow p-8 text-center">
            <p className="text-gray-500">게시글이 없습니다</p>
            <Link
              href="/posts/new"
              className="inline-block mt-4 text-blue-600 hover:text-blue-700"
            >
              첫 게시글을 작성해보세요
            </Link>
          </div>
        ) : (
          <div className="space-y-4">
            {posts.map((post) => {
              const badge = getVisibilityBadge(post.visibility);
              
              return (
                <Link
                  key={post.id}
                  href={`/posts/${post.id}`}
                  className={`block bg-white rounded-lg shadow hover:shadow-md transition p-6 ${
                    post.isShared ? "border-2 border-purple-300" : ""
                  }`}
                >
                  {/* 공유받은 글 헤더 */}
                  {post.isShared && (
                    <div className="mb-3 flex items-center gap-2 text-sm text-purple-700 bg-purple-50 px-3 py-2 rounded">
                      <span>🔗</span>
                      <span><strong>{post.sharedBy}님</strong>이 공유한 글</span>
                    </div>
                  )}

                  <div className="flex items-start justify-between">
                    <div className="flex-1">
                      <div className="flex items-center gap-2 mb-2">
                        <h3 className="text-lg font-semibold text-gray-900">
                          {post.title}
                        </h3>
                        {post.isShared && (
                          <span className="px-2 py-1 text-xs bg-purple-100 text-purple-700 rounded">
                            공유받음
                          </span>
                        )}
                      </div>
                      <p className="text-gray-600 mb-3 line-clamp-2">
                        {post.content}
                      </p>
                      <div className="flex items-center gap-4 text-sm text-gray-500">
                        <span>{post.isShared ? post.sharedBy : post.user.name}</span>
                        <span>•</span>
                        <span>
                          {new Date(post.createdAt).toLocaleDateString("ko-KR")}
                        </span>
                        <span>•</span>
                        <span>댓글 {post._count.comments}</span>
                      </div>
                    </div>
                    <span className={`px-3 py-1 text-xs rounded-full ${badge.color}`}>
                      {badge.text}
                    </span>
                  </div>
                </Link>
              );
            })}
          </div>
        )}
      </main>
    </div>
  );
}
</file>

<file path="src/app/search/page.tsx">
"use client";

import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import { useEffect, useState } from "react";
import Link from "next/link";
import { toast } from "@/components/Toast";
import { useConfirm } from "@/components/ConfirmDialog";

interface SearchResult { files: any[]; posts: any[]; total: number; }
interface SavedSearch { id: string; name: string; query: string; filters: string; createdAt: string; }
interface Tag { id: string; name: string; }

export default function SearchPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const { confirmDialog, openConfirm } = useConfirm();

  const [query, setQuery] = useState("");
  const [results, setResults] = useState<SearchResult>({ files: [], posts: [], total: 0 });
  const [loading, setLoading] = useState(false);
  const [hasSearched, setHasSearched] = useState(false);

  const [showFilters, setShowFilters] = useState(false);
  const [filterType, setFilterType] = useState<"ALL" | "FILE" | "POST">("ALL");
  const [filterMimeType, setFilterMimeType] = useState("");
  const [filterTagIds, setFilterTagIds] = useState<string[]>([]);
  const [filterDateFrom, setFilterDateFrom] = useState("");
  const [filterDateTo, setFilterDateTo] = useState("");

  const [allTags, setAllTags] = useState<Tag[]>([]);
  const [savedSearches, setSavedSearches] = useState<SavedSearch[]>([]);
  const [showSaveModal, setShowSaveModal] = useState(false);
  const [saveSearchName, setSaveSearchName] = useState("");
  const [showSavedList, setShowSavedList] = useState(false);

  useEffect(() => {
    if (status === "unauthenticated") router.push("/login");
  }, [status, router]);

  useEffect(() => {
    if (session) { fetchTags(); fetchSavedSearches(); }
  }, [session]);

  const fetchTags = async () => {
    try {
      const res = await fetch("/api/tags");
      if (res.ok) setAllTags((await res.json()).tags || []);
    } catch {}
  };

  const fetchSavedSearches = async () => {
    try {
      const res = await fetch("/api/search/saved");
      if (res.ok) setSavedSearches((await res.json()).savedSearches || []);
    } catch {}
  };

  const activeFilterCount = [
    filterType !== "ALL",
    filterMimeType !== "",
    filterTagIds.length > 0,
    filterDateFrom !== "",
    filterDateTo !== "",
  ].filter(Boolean).length;

  const handleSearch = async (overrideQuery?: string) => {
    const searchQuery = overrideQuery ?? query;
    // ✅ alert() → toast.warning
    if (!searchQuery.trim() && filterTagIds.length === 0) {
      toast.warning("검색어 또는 태그를 선택하세요");
      return;
    }

    setLoading(true);
    setHasSearched(true);

    try {
      const params = new URLSearchParams();
      if (searchQuery.trim()) params.set("q", searchQuery.trim());
      if (filterType !== "ALL") params.set("type", filterType);
      if (filterMimeType) params.set("mimeType", filterMimeType);
      if (filterTagIds.length > 0) params.set("tags", filterTagIds.join(","));
      if (filterDateFrom) params.set("dateFrom", filterDateFrom);
      if (filterDateTo) params.set("dateTo", filterDateTo);

      const res = await fetch(`/api/search?${params}`);
      if (res.ok) {
        setResults(await res.json());
      } else {
        toast.error("검색 중 오류가 발생했습니다");
      }
    } catch {
      toast.error("검색 중 오류가 발생했습니다");
    } finally {
      setLoading(false);
    }
  };

  const handleResetFilters = () => {
    setFilterType("ALL");
    setFilterMimeType("");
    setFilterTagIds([]);
    setFilterDateFrom("");
    setFilterDateTo("");
  };

  const handleToggleTag = (tagId: string) =>
    setFilterTagIds((prev) =>
      prev.includes(tagId) ? prev.filter((id) => id !== tagId) : [...prev, tagId]
    );

  const handleSaveSearch = async () => {
    // ✅ alert() → toast.warning
    if (!saveSearchName.trim()) {
      toast.warning("검색 이름을 입력하세요");
      return;
    }
    try {
      const filters = JSON.stringify({
        type: filterType, mimeType: filterMimeType,
        tagIds: filterTagIds, dateFrom: filterDateFrom, dateTo: filterDateTo,
      });
      const res = await fetch("/api/search/saved", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name: saveSearchName.trim(), query, filters }),
      });
      if (res.ok) {
        toast.success("검색이 저장되었습니다");
        setShowSaveModal(false);
        setSaveSearchName("");
        fetchSavedSearches();
      } else {
        toast.error("저장에 실패했습니다");
      }
    } catch {
      toast.error("저장 중 오류가 발생했습니다");
    }
  };

  const handleLoadSavedSearch = (saved: SavedSearch) => {
    setQuery(saved.query || "");
    try {
      const filters = JSON.parse(saved.filters || "{}");
      setFilterType(filters.type || "ALL");
      setFilterMimeType(filters.mimeType || "");
      setFilterTagIds(filters.tagIds || []);
      setFilterDateFrom(filters.dateFrom || "");
      setFilterDateTo(filters.dateTo || "");
    } catch {}
    setShowSavedList(false);
    handleSearch(saved.query || "");
  };

  const handleDeleteSavedSearch = (id: string) => {
    // ✅ confirm() → ConfirmDialog
    openConfirm({
      title: "저장된 검색 삭제",
      message: "저장된 검색을 삭제하시겠습니까?",
      confirmLabel: "삭제",
      variant: "danger",
      onConfirm: async () => {
        try {
          const res = await fetch(`/api/search/saved/${id}`, { method: "DELETE" });
          if (res.ok) {
            fetchSavedSearches();
            toast.success("삭제되었습니다");
          }
        } catch {}
      },
    });
  };

  if (status === "loading") {
    return <div className="min-h-screen flex items-center justify-center">로딩 중...</div>;
  }
  if (!session) return null;

  return (
    <div className="min-h-screen bg-gray-50">
      {confirmDialog}

      <header className="bg-white shadow">
        <div className="max-w-4xl mx-auto px-4 py-4 flex justify-between items-center">
          <h1 className="text-xl font-bold">🔍 검색</h1>
          <Link href="/dashboard" className="text-sm text-blue-600 hover:text-blue-700">
            ← 대시보드
          </Link>
        </div>
      </header>

      <main className="max-w-4xl mx-auto px-4 py-6">
        {/* 검색창 */}
        <div className="bg-white shadow rounded-lg p-5 mb-4">
          <div className="flex gap-2 mb-3">
            <input
              type="text"
              value={query}
              onChange={(e) => setQuery(e.target.value)}
              onKeyDown={(e) => e.key === "Enter" && handleSearch()}
              placeholder="파일명, 게시글 제목으로 검색..."
              className="flex-1 px-4 py-2.5 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm text-gray-900"
            />
            <button
              onClick={() => handleSearch()}
              disabled={loading}
              className="px-5 py-2.5 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:bg-gray-400 text-sm font-medium"
            >
              {loading ? "검색 중..." : "검색"}
            </button>
          </div>

          <div className="flex items-center gap-2">
            <button
              onClick={() => setShowFilters(!showFilters)}
              className={`flex items-center gap-1.5 px-3 py-1.5 rounded-md text-sm border transition ${
                showFilters
                  ? "bg-blue-50 border-blue-300 text-blue-700"
                  : "bg-gray-50 border-gray-300 text-gray-600 hover:bg-gray-100"
              }`}
            >
              <span>⚙️ 필터</span>
              {activeFilterCount > 0 && (
                <span className="bg-blue-600 text-white text-xs rounded-full w-4 h-4 flex items-center justify-center">
                  {activeFilterCount}
                </span>
              )}
            </button>

            {activeFilterCount > 0 && (
              <button
                onClick={handleResetFilters}
                className="px-3 py-1.5 text-xs text-red-500 hover:text-red-700 border border-red-200 rounded-md hover:bg-red-50"
              >
                필터 초기화
              </button>
            )}

            <div className="ml-auto flex gap-2">
              {hasSearched && (
                <button
                  onClick={() => setShowSaveModal(true)}
                  className="px-3 py-1.5 text-xs text-green-600 border border-green-300 rounded-md hover:bg-green-50"
                >
                  💾 검색 저장
                </button>
              )}
              {savedSearches.length > 0 && (
                <button
                  onClick={() => setShowSavedList(!showSavedList)}
                  className="px-3 py-1.5 text-xs text-purple-600 border border-purple-300 rounded-md hover:bg-purple-50"
                >
                  📋 저장된 검색 ({savedSearches.length})
                </button>
              )}
            </div>
          </div>

          {/* 필터 패널 */}
          {showFilters && (
            <div className="mt-4 pt-4 border-t space-y-4">
              <div>
                <p className="text-xs font-semibold text-gray-500 uppercase mb-2">검색 대상</p>
                <div className="flex gap-2">
                  {(["ALL", "FILE", "POST"] as const).map((type) => (
                    <button
                      key={type}
                      onClick={() => setFilterType(type)}
                      className={`px-3 py-1.5 text-sm rounded-full border transition ${
                        filterType === type
                          ? "bg-blue-600 text-white border-blue-600"
                          : "bg-white text-gray-600 border-gray-300 hover:bg-gray-50"
                      }`}
                    >
                      {type === "ALL" ? "전체" : type === "FILE" ? "📄 파일만" : "📝 게시글만"}
                    </button>
                  ))}
                </div>
              </div>

              {(filterType === "ALL" || filterType === "FILE") && (
                <div>
                  <p className="text-xs font-semibold text-gray-500 uppercase mb-2">파일 타입</p>
                  <div className="flex flex-wrap gap-2">
                    {[
                      { label: "전체", value: "" },
                      { label: "🖼️ 이미지", value: "image" },
                      { label: "📹 동영상", value: "video" },
                      { label: "📄 PDF", value: "pdf" },
                      { label: "📊 문서", value: "document" },
                      { label: "🗜️ 압축", value: "zip" },
                    ].map((opt) => (
                      <button
                        key={opt.value}
                        onClick={() => setFilterMimeType(opt.value)}
                        className={`px-3 py-1.5 text-sm rounded-full border transition ${
                          filterMimeType === opt.value
                            ? "bg-green-600 text-white border-green-600"
                            : "bg-white text-gray-600 border-gray-300 hover:bg-gray-50"
                        }`}
                      >
                        {opt.label}
                      </button>
                    ))}
                  </div>
                </div>
              )}

              {allTags.length > 0 && (
                <div>
                  <p className="text-xs font-semibold text-gray-500 uppercase mb-2">
                    태그 필터
                    {filterTagIds.length > 0 && (
                      <span className="ml-2 text-blue-600 normal-case font-normal">
                        {filterTagIds.length}개 선택됨
                      </span>
                    )}
                  </p>
                  <div className="flex flex-wrap gap-2 max-h-24 overflow-y-auto">
                    {allTags.map((tag) => (
                      <button
                        key={tag.id}
                        onClick={() => handleToggleTag(tag.id)}
                        className={`px-3 py-1 text-sm rounded-full border transition ${
                          filterTagIds.includes(tag.id)
                            ? "bg-orange-500 text-white border-orange-500"
                            : "bg-white text-gray-600 border-gray-300 hover:bg-gray-50"
                        }`}
                      >
                        🏷️ {tag.name}
                      </button>
                    ))}
                  </div>
                </div>
              )}

              <div>
                <p className="text-xs font-semibold text-gray-500 uppercase mb-2">업로드 날짜</p>
                <div className="flex items-center gap-2">
                  <input
                    type="date"
                    value={filterDateFrom}
                    onChange={(e) => setFilterDateFrom(e.target.value)}
                    className="px-3 py-1.5 border border-gray-300 rounded-md text-sm"
                  />
                  <span className="text-gray-400 text-sm">~</span>
                  <input
                    type="date"
                    value={filterDateTo}
                    onChange={(e) => setFilterDateTo(e.target.value)}
                    className="px-3 py-1.5 border border-gray-300 rounded-md text-sm"
                  />
                  {(filterDateFrom || filterDateTo) && (
                    <button
                      onClick={() => { setFilterDateFrom(""); setFilterDateTo(""); }}
                      className="text-xs text-red-400 hover:text-red-600"
                    >
                      ✕
                    </button>
                  )}
                </div>
              </div>

              <button
                onClick={() => handleSearch()}
                className="w-full py-2 bg-blue-600 text-white rounded-md text-sm font-medium hover:bg-blue-700"
              >
                🔍 필터 적용해서 검색
              </button>
            </div>
          )}

          {/* 저장된 검색 목록 */}
          {showSavedList && savedSearches.length > 0 && (
            <div className="mt-4 pt-4 border-t">
              <p className="text-xs font-semibold text-gray-500 uppercase mb-2">저장된 검색</p>
              <div className="space-y-2 max-h-48 overflow-y-auto">
                {savedSearches.map((saved) => (
                  <div key={saved.id} className="flex items-center justify-between p-2.5 bg-gray-50 rounded-md">
                    <button onClick={() => handleLoadSavedSearch(saved)} className="flex-1 text-left">
                      <p className="text-sm font-medium text-blue-600 hover:text-blue-800">{saved.name}</p>
                      {saved.query && <p className="text-xs text-gray-400">"{saved.query}"</p>}
                    </button>
                    <button
                      onClick={() => handleDeleteSavedSearch(saved.id)}
                      className="ml-2 text-xs text-red-400 hover:text-red-600"
                    >
                      삭제
                    </button>
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>

        {/* 검색 결과 */}
        {hasSearched && !loading && (
          <div className="bg-white shadow rounded-lg p-5">
            {results.total === 0 ? (
              <div className="text-center py-8">
                <p className="text-gray-500 text-lg mb-2">검색 결과가 없습니다</p>
                <p className="text-gray-400 text-sm">다른 검색어나 필터를 사용해보세요</p>
              </div>
            ) : (
              <>
                <div className="flex items-center justify-between mb-4">
                  <h2 className="font-semibold">
                    검색 결과 <span className="text-blue-600">({results.total}개)</span>
                  </h2>
                  <div className="flex gap-2 text-xs text-gray-500">
                    {results.files.length > 0 && <span>📄 파일 {results.files.length}개</span>}
                    {results.posts.length > 0 && <span>📝 게시글 {results.posts.length}개</span>}
                  </div>
                </div>

                {results.files.length > 0 && (
                  <div className="mb-5">
                    <h3 className="text-sm font-semibold text-gray-600 mb-2">📄 파일 ({results.files.length})</h3>
                    <div className="space-y-2">
                      {results.files.map((file: any) => (
                        <div
                          key={file.id}
                          className="flex items-center gap-3 p-3 border rounded-md hover:bg-gray-50 cursor-pointer"
                          onClick={() => router.push("/dashboard")}
                        >
                          <div className="w-10 h-10 rounded bg-gray-100 flex-shrink-0 overflow-hidden">
                            {file.thumbnailUrl ? (
                              <img src={file.thumbnailUrl} alt="" className="w-full h-full object-cover" />
                            ) : (
                              <div className="w-full h-full flex items-center justify-center text-lg">
                                {file.mimeType?.startsWith("image/") ? "🖼️" :
                                 file.mimeType?.startsWith("video/") ? "🎥" :
                                 file.mimeType === "application/pdf" ? "📕" : "📄"}
                              </div>
                            )}
                          </div>
                          <div className="flex-1 min-w-0">
                            <p className="font-medium text-sm truncate">{file.originalName}</p>
                            <div className="flex items-center gap-2 mt-0.5">
                              <span className="text-xs text-gray-400">
                                {(parseInt(file.size) / 1024 / 1024).toFixed(2)} MB
                              </span>
                              <span className="text-xs text-gray-300">•</span>
                              <span className="text-xs text-gray-400">
                                {new Date(file.createdAt).toLocaleDateString("ko-KR")}
                              </span>
                              {file.fileTags?.map((ft: any) => (
                                <span key={ft.tag.id} className="px-1.5 py-0.5 text-xs bg-blue-100 text-blue-600 rounded-full">
                                  {ft.tag.name}
                                </span>
                              ))}
                            </div>
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}

                {results.posts.length > 0 && (
                  <div>
                    <h3 className="text-sm font-semibold text-gray-600 mb-2">📝 게시글 ({results.posts.length})</h3>
                    <div className="space-y-2">
                      {results.posts.map((post: any) => (
                        <Link key={post.id} href={`/posts/${post.id}`} className="block p-3 border rounded-md hover:bg-gray-50">
                          <div className="flex items-start justify-between">
                            <div className="flex-1 min-w-0">
                              <p className="font-medium text-sm">{post.title}</p>
                              <p className="text-xs text-gray-500 mt-0.5 line-clamp-1">{post.content}</p>
                            </div>
                            <span className={`ml-2 px-2 py-0.5 text-xs rounded-full flex-shrink-0 ${
                              post.visibility === "PUBLIC" ? "bg-green-100 text-green-700" :
                              post.visibility === "SHARED" ? "bg-blue-100 text-blue-700" :
                              "bg-gray-100 text-gray-600"
                            }`}>
                              {post.visibility === "PUBLIC" ? "공개" :
                               post.visibility === "SHARED" ? "공유" : "비공개"}
                            </span>
                          </div>
                          <div className="flex items-center gap-2 mt-1">
                            <span className="text-xs text-gray-400">
                              {new Date(post.createdAt).toLocaleDateString("ko-KR")}
                            </span>
                            {post.postTags?.map((pt: any) => (
                              <span key={pt.tag.id} className="px-1.5 py-0.5 text-xs bg-orange-100 text-orange-600 rounded-full">
                                {pt.tag.name}
                              </span>
                            ))}
                          </div>
                        </Link>
                      ))}
                    </div>
                  </div>
                )}
              </>
            )}
          </div>
        )}
      </main>

      {/* 검색 저장 모달 */}
      {showSaveModal && (
        <div
          className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 p-4"
          onClick={() => setShowSaveModal(false)}
        >
          <div className="bg-white rounded-lg shadow-xl max-w-sm w-full p-5" onClick={(e) => e.stopPropagation()}>
            <h3 className="text-base font-semibold mb-3">💾 검색 저장</h3>
            <input
              type="text"
              value={saveSearchName}
              onChange={(e) => setSaveSearchName(e.target.value)}
              onKeyDown={(e) => e.key === "Enter" && handleSaveSearch()}
              placeholder="저장할 검색 이름 (예: 태국여행 이미지)"
              className="w-full px-3 py-2 border rounded-md text-sm mb-3 text-gray-900"
              autoFocus
            />
            <div className="text-xs text-gray-500 mb-4 space-y-0.5">
              {query && <p>검색어: "{query}"</p>}
              {filterType !== "ALL" && <p>대상: {filterType}</p>}
              {filterMimeType && <p>타입: {filterMimeType}</p>}
              {filterTagIds.length > 0 && <p>태그: {filterTagIds.length}개</p>}
              {(filterDateFrom || filterDateTo) && <p>날짜: {filterDateFrom} ~ {filterDateTo}</p>}
            </div>
            <div className="flex justify-end gap-2">
              <button
                onClick={() => setShowSaveModal(false)}
                className="px-3 py-1.5 text-sm text-gray-600 hover:bg-gray-100 rounded-md"
              >
                취소
              </button>
              <button
                onClick={handleSaveSearch}
                className="px-3 py-1.5 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700"
              >
                저장
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/app/settings/2fa/page.tsx">
"use client";

import { useState } from "react";
import Link from "next/link";
import Image from "next/image";
import { ChevronLeft, Shield, ShieldCheck, ShieldOff, Copy, Eye, EyeOff, AlertTriangle } from "lucide-react";
import { toast } from "@/components/Toast";

type Step = "idle" | "qr" | "verify" | "backup" | "disable";

interface SetupData {
  qrCode: string;
  manualKey: string;
}

export default function TwoFactorPage() {
  const [isEnabled, setIsEnabled] = useState(false); // 실제론 API에서 가져와야 함
  const [step, setStep] = useState<Step>("idle");
  const [setupData, setSetupData] = useState<SetupData | null>(null);
  const [otp, setOtp] = useState("");
  const [backupCodes, setBackupCodes] = useState<string[]>([]);
  const [showManualKey, setShowManualKey] = useState(false);
  const [loading, setLoading] = useState(false);
  const [disableCode, setDisableCode] = useState("");

  // 초기 상태 로드
  useState(() => {
    fetch("/api/users/me")
      .then((r) => r.json())
      .then((d) => setIsEnabled(d.twoFactorEnabled ?? false))
      .catch(() => {});
  });

  // QR코드 생성 요청
  const startSetup = async () => {
    setLoading(true);
    try {
      const res = await fetch("/api/auth/2fa/setup", { method: "POST" });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error);
      setSetupData({ qrCode: data.qrCode, manualKey: data.manualKey });
      setStep("qr");
    } catch (e: any) {
      toast.error(e.message || "QR코드 생성에 실패했습니다");
    } finally {
      setLoading(false);
    }
  };

  // OTP 검증 및 활성화
  const verifyAndActivate = async () => {
    if (otp.replace(/\s/g, "").length !== 6) {
      toast.error("6자리 코드를 입력해주세요");
      return;
    }
    setLoading(true);
    try {
      const res = await fetch("/api/auth/2fa/setup", {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ code: otp }),
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error);
      setBackupCodes(data.backupCodes);
      setIsEnabled(true);
      setStep("backup");
      setOtp("");
    } catch (e: any) {
      toast.error(e.message || "코드가 올바르지 않습니다");
    } finally {
      setLoading(false);
    }
  };

  // 2FA 비활성화
  const disable2FA = async () => {
    setLoading(true);
    try {
      const res = await fetch("/api/auth/2fa/disable", {
        method: "DELETE",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ code: disableCode }),
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error);
      setIsEnabled(false);
      setStep("idle");
      setDisableCode("");
      toast.success("2단계 인증이 비활성화되었습니다");
    } catch (e: any) {
      toast.error(e.message || "코드가 올바르지 않습니다");
    } finally {
      setLoading(false);
    }
  };

  const copyToClipboard = (text: string) => {
    navigator.clipboard.writeText(text);
    toast.success("복사되었습니다");
  };

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900">
      {/* 헤더 */}
      <div className="bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700 sticky top-0 z-10">
        <div className="max-w-2xl mx-auto px-4 py-3 flex items-center gap-3">
          <Link href="/profile" className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
            <ChevronLeft size={20} className="text-gray-600 dark:text-slate-400" />
          </Link>
          <Shield size={20} className="text-gray-800 dark:text-slate-200" />
          <h1 className="text-lg font-semibold text-gray-900 dark:text-slate-100 flex-1">
            2단계 인증
          </h1>
          {isEnabled && (
            <span className="flex items-center gap-1 text-xs font-semibold text-green-600 bg-green-50 dark:bg-green-900/30 px-2 py-1 rounded-full">
              <ShieldCheck size={12} /> 활성화됨
            </span>
          )}
        </div>
      </div>

      <div className="max-w-2xl mx-auto px-4 py-6 space-y-4">

        {/* ── IDLE: 현재 상태 + 시작 버튼 ── */}
        {step === "idle" && (
          <>
            <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-6">
              <div className="flex items-start gap-4">
                <div className={`w-12 h-12 rounded-full flex items-center justify-center shrink-0 ${
                  isEnabled ? "bg-green-50 dark:bg-green-900/30" : "bg-gray-100 dark:bg-slate-700"
                }`}>
                  {isEnabled
                    ? <ShieldCheck size={24} className="text-green-600" />
                    : <Shield size={24} className="text-gray-500 dark:text-slate-400" />
                  }
                </div>
                <div>
                  <p className="font-semibold text-gray-900 dark:text-slate-100">
                    {isEnabled ? "2단계 인증 활성화됨" : "2단계 인증 비활성화"}
                  </p>
                  <p className="text-sm text-gray-500 dark:text-slate-400 mt-1">
                    {isEnabled
                      ? "로그인 시 인증 앱의 6자리 코드가 필요합니다."
                      : "TOTP 인증 앱(Google Authenticator, Authy 등)을 사용해 계정을 더욱 안전하게 보호하세요."}
                  </p>
                </div>
              </div>
            </div>

            {!isEnabled ? (
              <button
                onClick={startSetup}
                disabled={loading}
                className="w-full py-3 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 disabled:opacity-50 rounded-xl transition"
              >
                {loading ? "준비 중..." : "2단계 인증 설정 시작"}
              </button>
            ) : (
              <button
                onClick={() => setStep("disable")}
                className="w-full py-3 text-sm font-semibold text-red-600 bg-red-50 dark:bg-red-900/20 hover:bg-red-100 dark:hover:bg-red-900/30 rounded-xl border border-red-200 dark:border-red-800 transition"
              >
                2단계 인증 비활성화
              </button>
            )}
          </>
        )}

        {/* ── QR코드 단계 ── */}
        {step === "qr" && setupData && (
          <div className="space-y-4">
            <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-6 space-y-4">
              <h2 className="font-semibold text-gray-900 dark:text-slate-100">① 앱으로 QR코드 스캔</h2>
              <p className="text-sm text-gray-500 dark:text-slate-400">
                Google Authenticator, Authy, Microsoft Authenticator 등의 앱을 열고 아래 QR코드를 스캔하세요.
              </p>
              <div className="flex justify-center">
                <div className="p-3 bg-white rounded-xl shadow">
                  <img src={setupData.qrCode} alt="QR Code" className="w-48 h-48" />
                </div>
              </div>

              {/* 수동 입력 키 */}
              <div>
                <button
                  onClick={() => setShowManualKey(!showManualKey)}
                  className="flex items-center gap-1.5 text-xs text-blue-600 dark:text-blue-400 hover:underline"
                >
                  {showManualKey ? <EyeOff size={12} /> : <Eye size={12} />}
                  QR코드 스캔이 안 된다면 (수동 입력)
                </button>
                {showManualKey && (
                  <div className="mt-2 flex items-center gap-2 p-3 bg-gray-50 dark:bg-slate-900 rounded-lg">
                    <code className="text-xs font-mono text-gray-700 dark:text-slate-300 flex-1 break-all">
                      {setupData.manualKey}
                    </code>
                    <button
                      onClick={() => copyToClipboard(setupData.manualKey)}
                      className="p-1.5 hover:bg-gray-200 dark:hover:bg-slate-700 rounded"
                    >
                      <Copy size={12} className="text-gray-500" />
                    </button>
                  </div>
                )}
              </div>
            </div>

            <button
              onClick={() => setStep("verify")}
              className="w-full py-3 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-xl transition"
            >
              다음 → 코드 확인
            </button>
            <button onClick={() => setStep("idle")} className="w-full py-2 text-sm text-gray-500 dark:text-slate-400">
              취소
            </button>
          </div>
        )}

        {/* ── OTP 검증 단계 ── */}
        {step === "verify" && (
          <div className="space-y-4">
            <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-6 space-y-4">
              <h2 className="font-semibold text-gray-900 dark:text-slate-100">② 인증 코드 확인</h2>
              <p className="text-sm text-gray-500 dark:text-slate-400">
                앱에 표시된 6자리 코드를 입력하여 설정을 완료하세요.
              </p>
              <input
                type="text"
                inputMode="numeric"
                pattern="[0-9]*"
                maxLength={6}
                value={otp}
                onChange={(e) => setOtp(e.target.value.replace(/\D/g, ""))}
                placeholder="6자리 코드"
                className="w-full text-center text-2xl font-mono tracking-[0.5em] border border-gray-200 dark:border-slate-600 rounded-xl px-4 py-3 focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-slate-700 dark:text-slate-100"
              />
            </div>
            <button
              onClick={verifyAndActivate}
              disabled={loading || otp.length !== 6}
              className="w-full py-3 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 disabled:opacity-50 rounded-xl transition"
            >
              {loading ? "확인 중..." : "인증 완료"}
            </button>
            <button onClick={() => setStep("qr")} className="w-full py-2 text-sm text-gray-500 dark:text-slate-400">
              ← 이전
            </button>
          </div>
        )}

        {/* ── 백업 코드 단계 ── */}
        {step === "backup" && (
          <div className="space-y-4">
            <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-6 space-y-4">
              <div className="flex items-center gap-2">
                <ShieldCheck size={20} className="text-green-600" />
                <h2 className="font-semibold text-green-700 dark:text-green-400">2단계 인증 활성화 완료!</h2>
              </div>

              <div className="p-3 bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-700 rounded-xl flex items-start gap-2">
                <AlertTriangle size={16} className="text-amber-600 shrink-0 mt-0.5" />
                <p className="text-xs text-amber-700 dark:text-amber-400">
                  아래 백업 코드를 안전한 곳에 저장하세요. 인증 앱을 잃어버렸을 때 사용할 수 있으며 각 코드는 1회만 사용 가능합니다.
                </p>
              </div>

              <div className="grid grid-cols-2 gap-2">
                {backupCodes.map((code) => (
                  <div key={code} className="font-mono text-sm text-center py-2 px-3 bg-gray-50 dark:bg-slate-900 rounded-lg text-gray-700 dark:text-slate-300 border border-gray-200 dark:border-slate-700">
                    {code}
                  </div>
                ))}
              </div>

              <button
                onClick={() => copyToClipboard(backupCodes.join("\n"))}
                className="w-full flex items-center justify-center gap-2 py-2 text-sm text-blue-600 dark:text-blue-400 hover:bg-blue-50 dark:hover:bg-blue-900/20 rounded-lg transition"
              >
                <Copy size={14} /> 전체 복사
              </button>
            </div>

            <button
              onClick={() => setStep("idle")}
              className="w-full py-3 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-xl transition"
            >
              완료
            </button>
          </div>
        )}

        {/* ── 비활성화 단계 ── */}
        {step === "disable" && (
          <div className="space-y-4">
            <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-6 space-y-4">
              <div className="flex items-center gap-2">
                <ShieldOff size={20} className="text-red-500" />
                <h2 className="font-semibold text-gray-900 dark:text-slate-100">2단계 인증 비활성화</h2>
              </div>
              <p className="text-sm text-gray-500 dark:text-slate-400">
                인증 앱의 6자리 코드 또는 백업 코드를 입력하세요.
              </p>
              <input
                type="text"
                value={disableCode}
                onChange={(e) => setDisableCode(e.target.value.replace(/\s/g, "").toUpperCase())}
                placeholder="코드 입력"
                className="w-full text-center text-xl font-mono tracking-widest border border-gray-200 dark:border-slate-600 rounded-xl px-4 py-3 focus:outline-none focus:ring-2 focus:ring-red-400 bg-white dark:bg-slate-700 dark:text-slate-100"
              />
            </div>
            <button
              onClick={disable2FA}
              disabled={loading || disableCode.length < 6}
              className="w-full py-3 text-sm font-semibold text-white bg-red-500 hover:bg-red-600 disabled:opacity-50 rounded-xl transition"
            >
              {loading ? "처리 중..." : "비활성화 확인"}
            </button>
            <button onClick={() => setStep("idle")} className="w-full py-2 text-sm text-gray-500 dark:text-slate-400">
              취소
            </button>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/app/settings/api-keys/page.tsx">
"use client";
// src/app/settings/api-keys/page.tsx

import { useState, useEffect, useCallback } from "react";
import Link from "next/link";
import { ChevronLeft, Key, Plus, Trash2, Copy, Eye, EyeOff, AlertTriangle, RefreshCw } from "lucide-react";
import { toast } from "@/components/Toast";
import { useConfirm } from "@/components/ConfirmDialog";

interface ApiKey {
  id: string; name: string; keyPrefix: string;
  scopes: string[]; lastUsedAt: string | null;
  expiresAt: string | null; createdAt: string;
}

const ALL_SCOPES = [
  { value: "read:files",   label: "파일 읽기" },
  { value: "write:files",  label: "파일 쓰기" },
  { value: "read:posts",   label: "게시글 읽기" },
  { value: "write:posts",  label: "게시글 쓰기" },
  { value: "read:profile", label: "프로필 읽기" },
];

const EXPIRY_OPTIONS = [
  { label: "만료 없음", value: 0 },
  { label: "30일",      value: 30 },
  { label: "90일",      value: 90 },
  { label: "1년",       value: 365 },
];

function timeAgo(d: string | null) {
  if (!d) return "사용된 적 없음";
  const diff = Date.now() - new Date(d).getTime();
  const m = Math.floor(diff / 60000);
  if (m < 1) return "방금 전";
  if (m < 60) return `${m}분 전`;
  const h = Math.floor(m / 60);
  if (h < 24) return `${h}시간 전`;
  return new Date(d).toLocaleDateString("ko-KR");
}

export default function ApiKeysPage() {
  const { confirmDialog, openConfirm } = useConfirm();
  const [keys, setKeys] = useState<ApiKey[]>([]);
  const [loading, setLoading] = useState(true);
  const [creating, setCreating] = useState(false);
  const [newKey, setNewKey] = useState<{ rawKey: string; name: string } | null>(null);
  const [showRawKey, setShowRawKey] = useState(false);

  // 폼 상태
  const [form, setForm] = useState({ name: "", scopes: [] as string[], expiresInDays: 0 });
  const [showForm, setShowForm] = useState(false);

  const fetchKeys = useCallback(async () => {
    setLoading(true);
    try {
      const res = await fetch("/api/users/me/api-keys");
      const data = await res.json();
      setKeys(data.keys ?? []);
    } catch { toast.error("API 키를 불러오지 못했습니다"); }
    finally { setLoading(false); }
  }, []);

  useEffect(() => { fetchKeys(); }, [fetchKeys]);

  const createKey = async () => {
    if (!form.name.trim()) { toast.error("키 이름을 입력해주세요"); return; }
    if (form.scopes.length === 0) { toast.error("권한을 하나 이상 선택해주세요"); return; }
    setCreating(true);
    try {
      const res = await fetch("/api/users/me/api-keys", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(form),
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error);
      setNewKey({ rawKey: data.rawKey, name: data.key.name });
      setKeys((k) => [data.key, ...k]);
      setShowForm(false);
      setForm({ name: "", scopes: [], expiresInDays: 0 });
    } catch (e: any) { toast.error(e.message); }
    finally { setCreating(false); }
  };

  const deleteKey = async (id: string, name: string) => {
    const ok = await openConfirm({
      title: "API 키 삭제", message: `"${name}" 키를 삭제하면 이 키로 연동된 서비스가 작동을 멈춥니다.`,
      confirmText: "삭제", confirmVariant: "danger",
    });
    if (!ok) return;
    await fetch(`/api/users/me/api-keys/${id}`, { method: "DELETE" });
    setKeys((k) => k.filter((x) => x.id !== id));
    toast.success("API 키가 삭제되었습니다");
  };

  const toggleScope = (scope: string) =>
    setForm((f) => ({
      ...f,
      scopes: f.scopes.includes(scope) ? f.scopes.filter((s) => s !== scope) : [...f.scopes, scope],
    }));

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900">
      {confirmDialog}

      {/* 헤더 */}
      <div className="bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700 sticky top-0 z-10">
        <div className="max-w-2xl mx-auto px-4 py-3 flex items-center gap-3">
          <Link href="/profile" className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
            <ChevronLeft size={20} className="text-gray-600 dark:text-slate-400" />
          </Link>
          <Key size={20} className="text-gray-800 dark:text-slate-200" />
          <h1 className="text-lg font-semibold text-gray-900 dark:text-slate-100 flex-1">API 키 관리</h1>
          <button onClick={fetchKeys} className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700"><RefreshCw size={16} className="text-gray-500 dark:text-slate-400" /></button>
          <button onClick={() => setShowForm(true)}
            className="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-xl transition">
            <Plus size={14} /> 새 키
          </button>
        </div>
      </div>

      <div className="max-w-2xl mx-auto px-4 py-6 space-y-4">

        {/* 생성된 키 표시 */}
        {newKey && (
          <div className="bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-xl p-4 space-y-3">
            <div className="flex items-center gap-2">
              <AlertTriangle size={16} className="text-amber-600 shrink-0" />
              <p className="text-sm font-bold text-amber-700 dark:text-amber-400">지금 복사하지 않으면 다시 볼 수 없습니다!</p>
            </div>
            <p className="text-xs text-gray-600 dark:text-slate-400">"{newKey.name}" API 키가 생성되었습니다.</p>
            <div className="flex items-center gap-2 bg-white dark:bg-slate-800 rounded-xl border border-gray-200 dark:border-slate-700 px-3 py-2">
              <code className="flex-1 text-xs font-mono text-gray-800 dark:text-slate-200 break-all">
                {showRawKey ? newKey.rawKey : newKey.rawKey.slice(0, 16) + "•".repeat(20)}
              </code>
              <button onClick={() => setShowRawKey(!showRawKey)} className="text-gray-400 hover:text-gray-600 shrink-0">
                {showRawKey ? <EyeOff size={14} /> : <Eye size={14} />}
              </button>
              <button onClick={() => { navigator.clipboard.writeText(newKey.rawKey); toast.success("복사됨"); }}
                className="text-blue-600 hover:text-blue-700 shrink-0"><Copy size={14} /></button>
            </div>
            <button onClick={() => setNewKey(null)} className="text-xs text-gray-500 hover:text-gray-700 dark:hover:text-slate-300">
              확인했습니다 ×
            </button>
          </div>
        )}

        {/* 생성 폼 */}
        {showForm && (
          <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-5 space-y-4">
            <h3 className="text-sm font-bold text-gray-900 dark:text-slate-100">새 API 키 생성</h3>
            <input type="text" value={form.name} onChange={(e) => setForm((f) => ({ ...f, name: e.target.value }))}
              placeholder="키 이름 (예: 내 앱)"
              className="w-full px-4 py-2.5 text-sm border border-gray-200 dark:border-slate-600 rounded-xl bg-white dark:bg-slate-700 dark:text-slate-100 focus:outline-none focus:ring-2 focus:ring-blue-500" />
            <div>
              <p className="text-xs font-semibold text-gray-500 dark:text-slate-400 mb-2">권한</p>
              <div className="grid grid-cols-2 gap-2">
                {ALL_SCOPES.map((s) => (
                  <label key={s.value} className="flex items-center gap-2 cursor-pointer">
                    <input type="checkbox" checked={form.scopes.includes(s.value)} onChange={() => toggleScope(s.value)}
                      className="w-4 h-4 rounded accent-blue-600" />
                    <span className="text-xs text-gray-700 dark:text-slate-300">{s.label}</span>
                  </label>
                ))}
              </div>
            </div>
            <div>
              <p className="text-xs font-semibold text-gray-500 dark:text-slate-400 mb-2">만료</p>
              <div className="flex gap-2 flex-wrap">
                {EXPIRY_OPTIONS.map((o) => (
                  <button key={o.value} onClick={() => setForm((f) => ({ ...f, expiresInDays: o.value }))}
                    className={`px-3 py-1.5 text-xs font-medium rounded-lg transition ${
                      form.expiresInDays === o.value
                        ? "bg-blue-600 text-white"
                        : "bg-gray-100 dark:bg-slate-700 text-gray-600 dark:text-slate-400 hover:bg-gray-200"
                    }`}>{o.label}
                  </button>
                ))}
              </div>
            </div>
            <div className="flex gap-2">
              <button onClick={() => setShowForm(false)}
                className="flex-1 py-2.5 text-sm text-gray-600 dark:text-slate-400 bg-gray-100 dark:bg-slate-700 hover:bg-gray-200 rounded-xl transition">취소</button>
              <button onClick={createKey} disabled={creating}
                className="flex-1 py-2.5 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-xl transition disabled:opacity-50">
                {creating ? "생성 중..." : "키 생성"}
              </button>
            </div>
          </div>
        )}

        {/* 키 목록 */}
        {loading ? (
          <div className="space-y-2">{[...Array(3)].map((_, i) => (
            <div key={i} className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-4 animate-pulse h-20" />
          ))}</div>
        ) : keys.length === 0 ? (
          <div className="flex flex-col items-center py-20 text-center">
            <Key size={32} className="text-gray-300 dark:text-slate-600 mb-3" />
            <p className="text-gray-500 dark:text-slate-400 font-medium">API 키가 없습니다</p>
            <p className="text-xs text-gray-400 dark:text-slate-500 mt-1">외부 서비스와 연동할 API 키를 만드세요</p>
          </div>
        ) : (
          <div className="space-y-2">
            {keys.map((k) => (
              <div key={k.id} className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-4 flex items-start gap-3">
                <div className="w-9 h-9 rounded-xl bg-blue-50 dark:bg-blue-900/30 flex items-center justify-center shrink-0">
                  <Key size={16} className="text-blue-600 dark:text-blue-400" />
                </div>
                <div className="flex-1 min-w-0">
                  <p className="text-sm font-semibold text-gray-900 dark:text-slate-100">{k.name}</p>
                  <code className="text-xs text-gray-400 dark:text-slate-500 font-mono">{k.keyPrefix}••••••••••••••••</code>
                  <div className="flex flex-wrap gap-1 mt-1.5">
                    {k.scopes.map((s) => (
                      <span key={s} className="text-[9px] font-semibold bg-gray-100 dark:bg-slate-700 text-gray-500 dark:text-slate-400 px-1.5 py-0.5 rounded">{s}</span>
                    ))}
                  </div>
                  <p className="text-[10px] text-gray-400 dark:text-slate-500 mt-1">
                    마지막 사용: {timeAgo(k.lastUsedAt)}
                    {k.expiresAt && ` · 만료: ${new Date(k.expiresAt).toLocaleDateString("ko-KR")}`}
                  </p>
                </div>
                <button onClick={() => deleteKey(k.id, k.name)} className="p-2 text-gray-400 hover:text-red-500 hover:bg-red-50 dark:hover:bg-red-900/20 rounded-lg transition">
                  <Trash2 size={14} />
                </button>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/app/settings/sessions/page.tsx">
"use client";
// src/app/settings/sessions/page.tsx

import { useState, useEffect, useCallback } from "react";
import Link from "next/link";
import { ChevronLeft, Monitor, Smartphone, Tablet, LogOut, RefreshCw, Shield } from "lucide-react";
import { toast } from "@/components/Toast";
import { useConfirm } from "@/components/ConfirmDialog";

interface SessionInfo {
  id: string;
  userAgent: string | null;
  ip: string | null;
  lastActive: string;
  createdAt: string;
  isCurrent: boolean;
}

function parseDevice(ua: string | null): { icon: typeof Monitor; label: string; detail: string } {
  if (!ua) return { icon: Monitor, label: "알 수 없는 기기", detail: "" };
  const isMobile = /Mobile|Android|iPhone/i.test(ua);
  const isTablet = /iPad|Tablet/i.test(ua);
  const browser =
    ua.includes("Chrome") ? "Chrome" :
    ua.includes("Firefox") ? "Firefox" :
    ua.includes("Safari") ? "Safari" :
    ua.includes("Edge") ? "Edge" : "브라우저";
  const os =
    ua.includes("Windows") ? "Windows" :
    ua.includes("Mac") ? "macOS" :
    ua.includes("Linux") ? "Linux" :
    ua.includes("Android") ? "Android" :
    ua.includes("iOS") ? "iOS" : "";

  return {
    icon: isTablet ? Tablet : isMobile ? Smartphone : Monitor,
    label: `${browser}${os ? ` on ${os}` : ""}`,
    detail: isTablet ? "태블릿" : isMobile ? "모바일" : "데스크톱",
  };
}

function timeAgo(d: string) {
  const diff = Date.now() - new Date(d).getTime();
  const m = Math.floor(diff / 60000);
  if (m < 1) return "방금 전";
  if (m < 60) return `${m}분 전`;
  const h = Math.floor(m / 60);
  if (h < 24) return `${h}시간 전`;
  return new Date(d).toLocaleDateString("ko-KR");
}

export default function SessionsPage() {
  const { confirmDialog, openConfirm } = useConfirm();
  const [sessions, setSessions] = useState<SessionInfo[]>([]);
  const [loading, setLoading] = useState(true);

  const fetchSessions = useCallback(async () => {
    setLoading(true);
    try {
      const res = await fetch("/api/users/me/sessions");
      const data = await res.json();
      setSessions(data.sessions ?? []);
    } catch {
      toast.error("세션 정보를 불러오지 못했습니다");
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => { fetchSessions(); }, [fetchSessions]);

  const revokeSession = async (id: string) => {
    const ok = await openConfirm({
      title: "세션 종료",
      message: "이 기기에서 로그아웃시킬까요?",
      confirmText: "로그아웃", confirmVariant: "danger",
    });
    if (!ok) return;
    const res = await fetch("/api/users/me/sessions", {
      method: "DELETE",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ sessionId: id }),
    });
    if (res.ok) {
      setSessions((s) => s.filter((x) => x.id !== id));
      toast.success("세션이 종료되었습니다");
    }
  };

  const revokeAll = async () => {
    const other = sessions.filter((s) => !s.isCurrent);
    if (other.length === 0) { toast.error("종료할 다른 세션이 없습니다"); return; }
    const ok = await openConfirm({
      title: "모든 기기 로그아웃",
      message: `현재 기기를 제외한 ${other.length}개 기기에서 로그아웃합니다.`,
      confirmText: "모두 로그아웃", confirmVariant: "danger",
    });
    if (!ok) return;
    const res = await fetch("/api/users/me/sessions", {
      method: "DELETE",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ revokeAll: true }),
    });
    if (res.ok) {
      setSessions((s) => s.filter((x) => x.isCurrent));
      toast.success("다른 모든 기기에서 로그아웃되었습니다");
    }
  };

  const otherCount = sessions.filter((s) => !s.isCurrent).length;

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900">
      {confirmDialog}

      {/* 헤더 */}
      <div className="bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700 sticky top-0 z-10">
        <div className="max-w-2xl mx-auto px-4 py-3 flex items-center gap-3">
          <Link href="/profile" className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
            <ChevronLeft size={20} className="text-gray-600 dark:text-slate-400" />
          </Link>
          <Shield size={20} className="text-gray-800 dark:text-slate-200" />
          <h1 className="text-lg font-semibold text-gray-900 dark:text-slate-100 flex-1">로그인된 기기</h1>
          <button onClick={fetchSessions} className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
            <RefreshCw size={16} className="text-gray-500 dark:text-slate-400" />
          </button>
        </div>
      </div>

      <div className="max-w-2xl mx-auto px-4 py-6 space-y-4">
        {/* 전체 로그아웃 */}
        {otherCount > 0 && (
          <button
            onClick={revokeAll}
            className="w-full flex items-center justify-center gap-2 py-3 text-sm font-semibold text-red-600 bg-red-50 dark:bg-red-900/20 hover:bg-red-100 dark:hover:bg-red-900/30 rounded-xl border border-red-200 dark:border-red-800 transition"
          >
            <LogOut size={15} /> 다른 모든 기기 로그아웃 ({otherCount}개)
          </button>
        )}

        {/* 세션 목록 */}
        {loading ? (
          <div className="space-y-3">
            {[...Array(3)].map((_, i) => (
              <div key={i} className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-4 animate-pulse flex gap-3">
                <div className="w-10 h-10 rounded-xl bg-gray-200 dark:bg-slate-700" />
                <div className="flex-1 space-y-2">
                  <div className="h-3.5 bg-gray-200 dark:bg-slate-700 rounded w-1/2" />
                  <div className="h-3 bg-gray-100 dark:bg-slate-700/50 rounded w-1/3" />
                </div>
              </div>
            ))}
          </div>
        ) : (
          <div className="space-y-2">
            {sessions.map((s) => {
              const device = parseDevice(s.userAgent);
              const Icon = device.icon;
              return (
                <div key={s.id} className={`bg-white dark:bg-slate-800 rounded-xl border transition-all p-4 flex items-center gap-3 ${
                  s.isCurrent
                    ? "border-blue-200 dark:border-blue-700 shadow-sm"
                    : "border-gray-100 dark:border-slate-700"
                }`}>
                  <div className={`w-10 h-10 rounded-xl flex items-center justify-center shrink-0 ${
                    s.isCurrent ? "bg-blue-50 dark:bg-blue-900/30" : "bg-gray-100 dark:bg-slate-700"
                  }`}>
                    <Icon size={20} className={s.isCurrent ? "text-blue-600 dark:text-blue-400" : "text-gray-500 dark:text-slate-400"} />
                  </div>
                  <div className="flex-1 min-w-0">
                    <div className="flex items-center gap-2">
                      <p className="text-sm font-semibold text-gray-900 dark:text-slate-100">{device.label}</p>
                      {s.isCurrent && (
                        <span className="text-[10px] font-bold bg-blue-100 dark:bg-blue-900/50 text-blue-600 dark:text-blue-400 px-1.5 py-0.5 rounded-full">현재 기기</span>
                      )}
                    </div>
                    <div className="flex items-center gap-2 mt-0.5">
                      <span className="text-xs text-gray-400 dark:text-slate-500">{device.detail}</span>
                      {s.ip && <><span className="text-gray-300 dark:text-slate-600">·</span><span className="text-xs text-gray-400 dark:text-slate-500 font-mono">{s.ip}</span></>}
                    </div>
                    <p className="text-[10px] text-gray-400 dark:text-slate-500 mt-0.5">
                      마지막 활동: {timeAgo(s.lastActive)} · 로그인: {new Date(s.createdAt).toLocaleDateString("ko-KR")}
                    </p>
                  </div>
                  {!s.isCurrent && (
                    <button
                      onClick={() => revokeSession(s.id)}
                      className="p-2 rounded-lg hover:bg-red-50 dark:hover:bg-red-900/20 text-gray-400 hover:text-red-500 transition-colors shrink-0"
                      title="이 기기 로그아웃"
                    >
                      <LogOut size={15} />
                    </button>
                  )}
                </div>
              );
            })}
          </div>
        )}

        <p className="text-xs text-center text-gray-400 dark:text-slate-500 pb-4">
          의심스러운 기기가 있다면 즉시 로그아웃하고 비밀번호를 변경하세요.
        </p>
      </div>
    </div>
  );
}
</file>

<file path="src/app/share/[token]/page.tsx">
"use client";
// src/app/share/[token]/page.tsx — 공개 공유 링크 페이지 (비로그인 접근)

import { useState, useEffect } from "react";
import { useParams } from "next/navigation";
import Link from "next/link";
import { Download, File, Cloud, AlertCircle } from "lucide-react";
import { getFileIcon, formatFileSize } from "@/lib/client-utils";

interface ShareMeta {
  originalName: string;
  mimeType: string;
  size: string;
  thumbnailUrl: string | null;
  createdAt: string;
  ownerName: string;
}

export default function SharePage() {
  const { token } = useParams<{ token: string }>();
  const [meta, setMeta] = useState<ShareMeta | null>(null);
  const [error, setError] = useState(false);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch(`/api/share/${token}`)
      .then((r) => { if (!r.ok) throw new Error(); return r.json(); })
      .then(setMeta)
      .catch(() => setError(true))
      .finally(() => setLoading(false));
  }, [token]);

  const isImage = meta?.mimeType.startsWith("image/");
  const isVideo = meta?.mimeType.startsWith("video/");
  const isAudio = meta?.mimeType.startsWith("audio/");

  return (
    <div className="min-h-screen bg-[#0f0c29] flex flex-col items-center justify-center px-4 text-white">
      {/* 배경 */}
      <div className="fixed inset-0 -z-10 overflow-hidden pointer-events-none">
        <div className="absolute top-1/4 left-1/4 w-96 h-96 bg-purple-700/15 rounded-full blur-[100px]" />
        <div className="absolute bottom-1/4 right-1/4 w-80 h-80 bg-blue-700/10 rounded-full blur-[80px]" />
      </div>

      {/* 로고 */}
      <Link href="/" className="flex items-center gap-2 mb-10">
        <div className="w-8 h-8 rounded-xl bg-gradient-to-br from-purple-500 to-blue-600 flex items-center justify-center">
          <Cloud size={16} className="text-white" />
        </div>
        <span className="text-lg font-black">이음</span>
      </Link>

      {loading && (
        <div className="w-10 h-10 border-4 border-purple-500/20 border-t-purple-500 rounded-full animate-spin" />
      )}

      {error && (
        <div className="text-center max-w-sm">
          <div className="w-16 h-16 rounded-full bg-red-500/10 border border-red-500/20 flex items-center justify-center mx-auto mb-4">
            <AlertCircle size={28} className="text-red-400" />
          </div>
          <h2 className="text-xl font-bold mb-2">파일을 찾을 수 없습니다</h2>
          <p className="text-white/40 text-sm">링크가 만료되었거나 삭제된 파일입니다.</p>
        </div>
      )}

      {meta && !error && (
        <div className="w-full max-w-lg">
          <div className="bg-white/5 border border-white/10 rounded-[28px] overflow-hidden">
            {/* 미리보기 */}
            <div className="bg-black/20 min-h-48 flex items-center justify-center p-6">
              {isImage && (
                <img
                  src={`/api/share/${token}?download=1`}
                  alt={meta.originalName}
                  className="max-h-72 max-w-full rounded-xl object-contain shadow-2xl"
                />
              )}
              {isVideo && (
                <video
                  src={`/api/share/${token}?download=1`}
                  controls
                  className="max-h-72 max-w-full rounded-xl"
                />
              )}
              {isAudio && (
                <div className="text-center space-y-4">
                  <div className="text-6xl">{getFileIcon(meta.mimeType)}</div>
                  <audio src={`/api/share/${token}?download=1`} controls className="w-full" />
                </div>
              )}
              {!isImage && !isVideo && !isAudio && (
                <div className="text-center">
                  <span className="text-7xl">{getFileIcon(meta.mimeType)}</span>
                </div>
              )}
            </div>

            {/* 파일 정보 */}
            <div className="p-6 space-y-4">
              <div>
                <h1 className="text-lg font-bold break-all">{meta.originalName}</h1>
                <p className="text-sm text-white/40 mt-1">
                  {formatFileSize(meta.size)} · {meta.ownerName}이 공유 · {new Date(meta.createdAt).toLocaleDateString("ko-KR")}
                </p>
              </div>

              {/* 다운로드 버튼 */}
              <a
                href={`/api/share/${token}?download=1`}
                className="flex items-center justify-center gap-2 w-full py-3.5 bg-white text-black font-bold rounded-2xl hover:bg-purple-50 transition-all"
              >
                <Download size={18} />
                파일 다운로드
              </a>

              <p className="text-center text-xs text-white/20">
                이음 퍼스널 클라우드로 공유됨 ·{" "}
                <Link href="/register" className="hover:text-white/50 underline">
                  무료로 시작하기
                </Link>
              </p>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/app/shared/page.tsx">
"use client";

import { useState, useEffect, useCallback } from "react";
import Link from "next/link";
import {
  ChevronLeft, Share2, Search, Download,
  LayoutGrid, List, RefreshCw, Eye,
} from "lucide-react";
import { getFileIcon, getFileColor, formatFileSize } from "@/lib/client-utils";
import FilePreviewModal from "@/components/FilePreviewModal";
import { toast } from "@/components/Toast";

interface SharedFile {
  id: string;
  filename: string;
  originalName: string;
  size: string;
  mimeType: string;
  thumbnailUrl: string | null;
  createdAt: string;
  sharedBy: string;
  sharedByEmail: string;
  permission: "VIEW" | "EDIT" | "ADMIN";
  sharedAt: string;
}

function timeAgo(d: string) {
  const diff = Date.now() - new Date(d).getTime();
  const days = Math.floor(diff / 86400000);
  if (days === 0) return "오늘";
  if (days < 7) return `${days}일 전`;
  return new Date(d).toLocaleDateString("ko-KR");
}

export default function SharedPage() {
  const [files, setFiles] = useState<SharedFile[]>([]);
  const [loading, setLoading] = useState(true);
  const [search, setSearch] = useState("");
  const [viewMode, setViewMode] = useState<"grid" | "list">("grid");
  const [sortBy, setSortBy] = useState<"sharedAt" | "name" | "size">("sharedAt");
  const [preview, setPreview] = useState<SharedFile | null>(null);

  const fetch_ = useCallback(async () => {
    setLoading(true);
    try {
      const res = await fetch("/api/files/shared");
      if (!res.ok) throw new Error();
      const data = await res.json();
      setFiles(data.files ?? []);
    } catch {
      toast.error("공유 파일을 불러오지 못했습니다");
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => { fetch_(); }, [fetch_]);

  const filtered = files
    .filter((f) =>
      f.originalName.toLowerCase().includes(search.toLowerCase()) ||
      f.sharedBy.toLowerCase().includes(search.toLowerCase())
    )
    .sort((a, b) => {
      if (sortBy === "name") return a.originalName.localeCompare(b.originalName);
      if (sortBy === "size") return Number(b.size) - Number(a.size);
      return new Date(b.sharedAt).getTime() - new Date(a.sharedAt).getTime();
    });

  const permColor = {
    VIEW: "bg-blue-50 dark:bg-blue-900/20 text-blue-700 dark:text-blue-400",
    EDIT: "bg-green-50 dark:bg-green-900/20 text-green-700 dark:text-green-400",
    ADMIN: "bg-red-50 dark:bg-red-900/20 text-red-700 dark:text-red-400",
  };
  const permLabel = { VIEW: "읽기", EDIT: "편집", ADMIN: "관리" };

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900">
      <FilePreviewModal
        file={preview ? { id: preview.id, originalName: preview.originalName, mimeType: preview.mimeType, size: preview.size } : null}
        onClose={() => setPreview(null)}
      />

      {/* 헤더 */}
      <div className="bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700 sticky top-0 z-10">
        <div className="max-w-4xl mx-auto px-4 py-3 flex items-center gap-3">
          <Link href="/dashboard" className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
            <ChevronLeft size={20} className="text-gray-600 dark:text-slate-400" />
          </Link>
          <Share2 size={20} className="text-gray-800 dark:text-slate-200" />
          <h1 className="text-lg font-semibold text-gray-900 dark:text-slate-100 flex-1">
            공유받은 파일
            {files.length > 0 && <span className="ml-2 text-sm font-normal text-gray-400 dark:text-slate-500">({files.length})</span>}
          </h1>
          <button onClick={fetch_} className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
            <RefreshCw size={16} className="text-gray-500 dark:text-slate-400" />
          </button>
        </div>

        {/* 검색 + 정렬 + 뷰 */}
        <div className="max-w-4xl mx-auto px-4 pb-3 flex gap-2 flex-wrap">
          <div className="relative flex-1 min-w-48">
            <Search size={14} className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400" />
            <input
              type="text"
              placeholder="파일명 또는 공유자 검색"
              value={search}
              onChange={(e) => setSearch(e.target.value)}
              className="w-full pl-8 pr-3 py-2 text-sm border border-gray-200 dark:border-slate-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-slate-700 dark:text-slate-100"
            />
          </div>
          <select
            value={sortBy}
            onChange={(e) => setSortBy(e.target.value as any)}
            className="text-sm border border-gray-200 dark:border-slate-600 rounded-lg px-3 py-2 bg-white dark:bg-slate-700 dark:text-slate-100 focus:outline-none"
          >
            <option value="sharedAt">최신순</option>
            <option value="name">이름순</option>
            <option value="size">크기순</option>
          </select>
          <div className="flex gap-1 bg-gray-100 dark:bg-slate-800 p-1 rounded-lg">
            <button onClick={() => setViewMode("grid")} className={`p-1.5 rounded ${viewMode === "grid" ? "bg-white dark:bg-slate-700 shadow-sm" : ""}`}>
              <LayoutGrid size={15} className="text-gray-600 dark:text-slate-400" />
            </button>
            <button onClick={() => setViewMode("list")} className={`p-1.5 rounded ${viewMode === "list" ? "bg-white dark:bg-slate-700 shadow-sm" : ""}`}>
              <List size={15} className="text-gray-600 dark:text-slate-400" />
            </button>
          </div>
        </div>
      </div>

      <div className="max-w-4xl mx-auto px-4 py-6">
        {loading ? (
          <div className={viewMode === "grid" ? "grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3" : "space-y-2"}>
            {[...Array(8)].map((_, i) => (
              <div key={i} className="bg-white dark:bg-slate-800 rounded-xl p-4 animate-pulse aspect-square" />
            ))}
          </div>
        ) : filtered.length === 0 ? (
          <div className="flex flex-col items-center justify-center py-32 text-center">
            <div className="w-16 h-16 rounded-full bg-gray-100 dark:bg-slate-800 flex items-center justify-center mb-4">
              <Share2 size={28} className="text-gray-400 dark:text-slate-500" />
            </div>
            <p className="text-gray-500 dark:text-slate-400 font-medium">공유받은 파일이 없습니다</p>
            <p className="text-xs text-gray-400 dark:text-slate-500 mt-1">다른 사람이 파일을 공유하면 여기에 표시됩니다</p>
          </div>
        ) : viewMode === "grid" ? (
          /* 그리드 뷰 */
          <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3">
            {filtered.map((f) => (
              <div key={f.id} className="group bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 overflow-hidden hover:shadow-md transition-all">
                {/* 썸네일 */}
                <div
                  className={`aspect-square flex items-center justify-center cursor-pointer ${
                    f.thumbnailUrl ? "bg-gray-50 dark:bg-slate-900" : getFileColor(f.mimeType)
                  }`}
                  onClick={() => setPreview(f)}
                >
                  {f.thumbnailUrl
                    ? <img src={f.thumbnailUrl} className="w-full h-full object-cover" alt={f.originalName} />
                    : <span className="text-4xl">{getFileIcon(f.mimeType)}</span>
                  }
                  <div className="absolute inset-0 bg-black/0 group-hover:bg-black/10 transition-colors flex items-center justify-center opacity-0 group-hover:opacity-100">
                    <Eye size={20} className="text-white drop-shadow" />
                  </div>
                </div>
                {/* 정보 */}
                <div className="p-2.5">
                  <p className="text-xs font-medium text-gray-900 dark:text-slate-100 truncate">{f.originalName}</p>
                  <p className="text-[10px] text-gray-400 dark:text-slate-500 mt-0.5">{f.sharedBy} · {timeAgo(f.sharedAt)}</p>
                  <div className="flex items-center justify-between mt-1.5">
                    <span className={`text-[9px] font-bold px-1.5 py-0.5 rounded-full ${permColor[f.permission]}`}>
                      {permLabel[f.permission]}
                    </span>
                    <a
                      href={`/api/files/${f.id}/download`}
                      className="p-1 rounded hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors"
                      title="다운로드"
                    >
                      <Download size={12} className="text-gray-500 dark:text-slate-400" />
                    </a>
                  </div>
                </div>
              </div>
            ))}
          </div>
        ) : (
          /* 리스트 뷰 */
          <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 overflow-hidden">
            <table className="w-full text-sm">
              <thead>
                <tr className="border-b border-gray-100 dark:border-slate-700 bg-gray-50 dark:bg-slate-800/80">
                  <th className="text-left px-4 py-3 text-xs font-semibold text-gray-500 dark:text-slate-400">파일</th>
                  <th className="text-left px-4 py-3 text-xs font-semibold text-gray-500 dark:text-slate-400 hidden md:table-cell">공유자</th>
                  <th className="text-left px-4 py-3 text-xs font-semibold text-gray-500 dark:text-slate-400 hidden sm:table-cell">크기</th>
                  <th className="text-left px-4 py-3 text-xs font-semibold text-gray-500 dark:text-slate-400">권한</th>
                  <th className="text-left px-4 py-3 text-xs font-semibold text-gray-500 dark:text-slate-400 hidden lg:table-cell">공유일</th>
                  <th className="px-4 py-3" />
                </tr>
              </thead>
              <tbody>
                {filtered.map((f) => (
                  <tr key={f.id} className="border-b border-gray-50 dark:border-slate-700 hover:bg-gray-50 dark:hover:bg-slate-700/50 transition-colors">
                    <td className="px-4 py-3">
                      <div className="flex items-center gap-2.5">
                        <span className="text-xl shrink-0">{getFileIcon(f.mimeType)}</span>
                        <div className="min-w-0">
                          <p className="font-medium text-gray-900 dark:text-slate-100 truncate max-w-[160px]">{f.originalName}</p>
                        </div>
                      </div>
                    </td>
                    <td className="px-4 py-3 hidden md:table-cell text-sm text-gray-600 dark:text-slate-400">{f.sharedBy}</td>
                    <td className="px-4 py-3 hidden sm:table-cell text-xs text-gray-500 dark:text-slate-400">{formatFileSize(f.size)}</td>
                    <td className="px-4 py-3">
                      <span className={`text-[10px] font-bold px-2 py-1 rounded-full ${permColor[f.permission]}`}>{permLabel[f.permission]}</span>
                    </td>
                    <td className="px-4 py-3 hidden lg:table-cell text-xs text-gray-400 dark:text-slate-500">{timeAgo(f.sharedAt)}</td>
                    <td className="px-4 py-3">
                      <div className="flex items-center gap-1">
                        <button onClick={() => setPreview(f)} className="p-1.5 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors" title="미리보기">
                          <Eye size={14} className="text-gray-500 dark:text-slate-400" />
                        </button>
                        <a href={`/api/files/${f.id}/download`} className="p-1.5 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors" title="다운로드">
                          <Download size={14} className="text-gray-500 dark:text-slate-400" />
                        </a>
                      </div>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/app/trash/page.tsx">
"use client";
// src/app/trash/page.tsx

import { useState, useEffect, useCallback } from "react";
import Link from "next/link";
import { ChevronLeft, Trash2, RotateCcw, AlertTriangle, RefreshCw } from "lucide-react";
import { getFileIcon, formatFileSize } from "@/lib/client-utils";
import { toast } from "@/components/Toast";
import { useConfirm } from "@/components/ConfirmDialog";

interface TrashFile {
  id: string;
  originalName: string;
  mimeType: string;
  size: string;
  thumbnailUrl: string | null;
  deletedAt: string;
  createdAt: string;
}

function daysLeft(deletedAt: string) {
  const deleted = new Date(deletedAt).getTime();
  const expiry = deleted + 30 * 24 * 60 * 60 * 1000; // 30일 후 자동 삭제 정책
  const remaining = Math.ceil((expiry - Date.now()) / 86400000);
  return Math.max(0, remaining);
}

export default function TrashPage() {
  const { confirmDialog, openConfirm } = useConfirm();
  const [files, setFiles] = useState<TrashFile[]>([]);
  const [loading, setLoading] = useState(true);
  const [selected, setSelected] = useState<Set<string>>(new Set());

  const fetchTrash = useCallback(async () => {
    setLoading(true);
    try {
      const res = await fetch("/api/files/trash");
      const data = await res.json();
      setFiles(data.files ?? []);
    } catch {
      toast.error("휴지통을 불러오지 못했습니다");
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => { fetchTrash(); }, [fetchTrash]);

  const restore = async (id: string) => {
    const res = await fetch(`/api/files/${id}/restore`, { method: "POST" });
    if (res.ok) {
      setFiles((f) => f.filter((x) => x.id !== id));
      toast.success("파일이 복구되었습니다");
    } else toast.error("복구에 실패했습니다");
  };

  const permanentDelete = async (id: string) => {
    const ok = await openConfirm({
      title: "영구 삭제", message: "이 파일을 영구 삭제할까요? 복구할 수 없습니다.",
      confirmText: "영구 삭제", confirmVariant: "danger",
    });
    if (!ok) return;
    const res = await fetch(`/api/files/${id}`, { method: "DELETE" });
    if (res.ok) {
      setFiles((f) => f.filter((x) => x.id !== id));
      toast.success("영구 삭제되었습니다");
    }
  };

  const emptyTrash = async () => {
    const ok = await openConfirm({
      title: "휴지통 비우기",
      message: `${files.length}개 파일을 모두 영구 삭제할까요? 복구할 수 없습니다.`,
      confirmText: "모두 삭제", confirmVariant: "danger",
    });
    if (!ok) return;
    const res = await fetch("/api/files/trash", { method: "DELETE" });
    if (res.ok) { setFiles([]); toast.success("휴지통을 비웠습니다"); }
  };

  const restoreSelected = async () => {
    await Promise.all([...selected].map((id) => fetch(`/api/files/${id}/restore`, { method: "POST" })));
    setFiles((f) => f.filter((x) => !selected.has(x.id)));
    setSelected(new Set());
    toast.success(`${selected.size}개 파일이 복구되었습니다`);
  };

  const toggleSelect = (id: string) =>
    setSelected((s) => { const n = new Set(s); n.has(id) ? n.delete(id) : n.add(id); return n; });
  const toggleAll = () =>
    setSelected(selected.size === files.length ? new Set() : new Set(files.map((f) => f.id)));

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900">
      {confirmDialog}

      {/* 헤더 */}
      <div className="bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700 sticky top-0 z-10">
        <div className="max-w-4xl mx-auto px-4 py-3 flex items-center gap-3">
          <Link href="/dashboard" className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
            <ChevronLeft size={20} className="text-gray-600 dark:text-slate-400" />
          </Link>
          <Trash2 size={20} className="text-gray-800 dark:text-slate-200" />
          <h1 className="text-lg font-semibold text-gray-900 dark:text-slate-100 flex-1">
            휴지통 {files.length > 0 && <span className="text-sm font-normal text-gray-400 dark:text-slate-500">({files.length})</span>}
          </h1>
          <button onClick={fetchTrash} className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700">
            <RefreshCw size={16} className="text-gray-500 dark:text-slate-400" />
          </button>
          {files.length > 0 && (
            <button onClick={emptyTrash} className="flex items-center gap-1.5 px-3 py-1.5 text-xs font-semibold text-red-600 bg-red-50 dark:bg-red-900/20 hover:bg-red-100 dark:hover:bg-red-900/30 rounded-lg border border-red-200 dark:border-red-800 transition">
              <Trash2 size={12} /> 비우기
            </button>
          )}
        </div>

        {/* 선택 액션 바 */}
        {selected.size > 0 && (
          <div className="max-w-4xl mx-auto px-4 pb-2 flex items-center gap-3">
            <span className="text-xs text-blue-600 dark:text-blue-400 font-semibold">{selected.size}개 선택됨</span>
            <button onClick={restoreSelected} className="flex items-center gap-1 text-xs text-green-600 dark:text-green-400 hover:underline">
              <RotateCcw size={11} /> 선택 복구
            </button>
          </div>
        )}
      </div>

      {/* 안내 배너 */}
      <div className="max-w-4xl mx-auto px-4 pt-4">
        <div className="flex items-center gap-2 px-4 py-3 bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-800 rounded-xl mb-4">
          <AlertTriangle size={15} className="text-amber-600 dark:text-amber-400 shrink-0" />
          <p className="text-xs text-amber-700 dark:text-amber-400">
            휴지통의 파일은 삭제 후 <strong>30일</strong>이 지나면 자동으로 영구 삭제됩니다.
          </p>
        </div>
      </div>

      <div className="max-w-4xl mx-auto px-4 pb-8">
        {loading ? (
          <div className="space-y-2">
            {[...Array(5)].map((_, i) => (
              <div key={i} className="bg-white dark:bg-slate-800 rounded-xl p-4 animate-pulse flex gap-3">
                <div className="w-10 h-10 bg-gray-200 dark:bg-slate-700 rounded-xl shrink-0" />
                <div className="flex-1 space-y-2">
                  <div className="h-3.5 bg-gray-200 dark:bg-slate-700 rounded w-1/3" />
                  <div className="h-3 bg-gray-100 dark:bg-slate-700/50 rounded w-1/4" />
                </div>
              </div>
            ))}
          </div>
        ) : files.length === 0 ? (
          <div className="flex flex-col items-center justify-center py-32">
            <div className="w-20 h-20 rounded-full bg-gray-100 dark:bg-slate-800 flex items-center justify-center mb-4">
              <Trash2 size={32} className="text-gray-300 dark:text-slate-600" />
            </div>
            <p className="text-gray-500 dark:text-slate-400 font-medium">휴지통이 비어있습니다</p>
          </div>
        ) : (
          <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 overflow-hidden">
            {/* 전체 선택 */}
            <div className="px-4 py-2.5 border-b border-gray-100 dark:border-slate-700 flex items-center gap-3">
              <input type="checkbox" checked={selected.size === files.length} onChange={toggleAll}
                className="w-4 h-4 rounded accent-blue-600" />
              <span className="text-xs text-gray-500 dark:text-slate-400">전체 선택</span>
            </div>

            <div className="divide-y divide-gray-100 dark:divide-slate-700">
              {files.map((f) => {
                const days = daysLeft(f.deletedAt);
                return (
                  <div key={f.id} className={`flex items-center gap-3 px-4 py-3 hover:bg-gray-50 dark:hover:bg-slate-700/50 transition-colors ${selected.has(f.id) ? "bg-blue-50 dark:bg-blue-900/20" : ""}`}>
                    <input type="checkbox" checked={selected.has(f.id)} onChange={() => toggleSelect(f.id)}
                      className="w-4 h-4 rounded accent-blue-600 shrink-0" />
                    <span className="text-2xl shrink-0">{getFileIcon(f.mimeType)}</span>
                    <div className="flex-1 min-w-0">
                      <p className="text-sm font-medium text-gray-900 dark:text-slate-100 truncate">{f.originalName}</p>
                      <div className="flex items-center gap-2 mt-0.5">
                        <span className="text-xs text-gray-400 dark:text-slate-500">{formatFileSize(f.size)}</span>
                        <span className="text-xs text-gray-300 dark:text-slate-600">·</span>
                        <span className={`text-xs font-medium ${days <= 3 ? "text-red-500" : "text-gray-400 dark:text-slate-500"}`}>
                          {days > 0 ? `${days}일 후 자동 삭제` : "곧 삭제됨"}
                        </span>
                      </div>
                    </div>
                    <div className="flex items-center gap-1 shrink-0">
                      <button onClick={() => restore(f.id)}
                        className="flex items-center gap-1 px-2.5 py-1.5 text-xs font-medium text-green-700 dark:text-green-400 bg-green-50 dark:bg-green-900/20 hover:bg-green-100 dark:hover:bg-green-900/30 rounded-lg transition">
                        <RotateCcw size={11} /> 복구
                      </button>
                      <button onClick={() => permanentDelete(f.id)}
                        className="p-1.5 text-gray-400 hover:text-red-500 hover:bg-red-50 dark:hover:bg-red-900/20 rounded-lg transition">
                        <Trash2 size={14} />
                      </button>
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/app/users/[id]/page.tsx">
"use client";

import { useState, useEffect, useCallback } from "react";
import { useSession } from "next-auth/react";
import { useParams, useRouter } from "next/navigation";
import Link from "next/link";
import { ChevronLeft, UserCheck, UserPlus, Users, FileText, MessageSquare } from "lucide-react";
import { toast } from "@/components/Toast";

interface PublicUser {
  id: string;
  name: string;
  email: string;
  role: "USER" | "ADMIN";
  isOnline: boolean;
  createdAt: string;
  _count: { files: number; posts: number; comments: number };
}

interface FollowInfo {
  followerCount: number;
  followingCount: number;
  isFollowing: boolean;
}

interface FollowUser {
  id: string;
  name: string;
  email: string;
  isOnline: boolean;
  followedAt: string;
}

export default function UserProfilePage() {
  const { id } = useParams<{ id: string }>();
  const { data: session } = useSession();
  const router = useRouter();

  const [user, setUser] = useState<PublicUser | null>(null);
  const [followInfo, setFollowInfo] = useState<FollowInfo | null>(null);
  const [tab, setTab] = useState<"followers" | "following">("followers");
  const [tabUsers, setTabUsers] = useState<FollowUser[]>([]);
  const [loading, setLoading] = useState(true);
  const [followLoading, setFollowLoading] = useState(false);
  const [showTab, setShowTab] = useState(false);

  const isSelf = session?.user?.id === id;

  const fetchUser = useCallback(async () => {
    try {
      const [uRes, fRes] = await Promise.all([
        fetch(`/api/users/${id}/public`),
        fetch(`/api/users/${id}/follow`),
      ]);
      if (uRes.ok) setUser(await uRes.json());
      if (fRes.ok) setFollowInfo(await fRes.json());
    } catch {
      toast.error("사용자 정보를 불러오지 못했습니다");
    } finally {
      setLoading(false);
    }
  }, [id]);

  const fetchTabUsers = useCallback(async () => {
    const res = await fetch(`/api/users/${id}/followers?type=${tab}`);
    if (res.ok) setTabUsers((await res.json()).users);
  }, [id, tab]);

  useEffect(() => { fetchUser(); }, [fetchUser]);
  useEffect(() => { if (showTab) fetchTabUsers(); }, [showTab, fetchTabUsers]);

  const toggleFollow = async () => {
    if (!session) { router.push("/login"); return; }
    if (!followInfo) return;
    setFollowLoading(true);
    try {
      const method = followInfo.isFollowing ? "DELETE" : "POST";
      const res = await fetch(`/api/users/${id}/follow`, { method });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error);
      setFollowInfo((f) => f ? {
        ...f,
        isFollowing: data.following,
        followerCount: f.followerCount + (data.following ? 1 : -1),
      } : f);
      toast.success(data.following ? "팔로우했습니다" : "팔로우를 취소했습니다");
    } catch (e: any) {
      toast.error(e.message || "오류가 발생했습니다");
    } finally {
      setFollowLoading(false);
    }
  };

  if (loading) return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900 flex items-center justify-center">
      <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600" />
    </div>
  );

  if (!user) return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900 flex flex-col items-center justify-center gap-3">
      <p className="text-gray-500 dark:text-slate-400">사용자를 찾을 수 없습니다</p>
      <Link href="/dashboard" className="text-blue-600 text-sm hover:underline">대시보드로</Link>
    </div>
  );

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900">
      {/* 헤더 */}
      <div className="bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700 sticky top-0 z-10">
        <div className="max-w-2xl mx-auto px-4 py-3 flex items-center gap-3">
          <button onClick={() => router.back()} className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
            <ChevronLeft size={20} className="text-gray-600 dark:text-slate-400" />
          </button>
          <h1 className="text-lg font-semibold text-gray-900 dark:text-slate-100 flex-1 truncate">
            {user.name}
          </h1>
        </div>
      </div>

      <div className="max-w-2xl mx-auto px-4 py-6 space-y-4">
        {/* 프로필 카드 */}
        <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-6">
          <div className="flex items-start gap-4">
            {/* 아바타 */}
            <div className="relative shrink-0">
              <div className="w-16 h-16 rounded-full bg-gradient-to-br from-blue-400 to-purple-500 flex items-center justify-center text-white text-2xl font-bold">
                {user.name[0]}
              </div>
              <span className={`absolute bottom-0.5 right-0.5 w-3.5 h-3.5 rounded-full border-2 border-white dark:border-slate-800 ${
                user.isOnline ? "bg-green-500" : "bg-gray-300"
              }`} />
            </div>

            {/* 정보 */}
            <div className="flex-1 min-w-0">
              <div className="flex items-center gap-2 flex-wrap">
                <h2 className="text-xl font-bold text-gray-900 dark:text-slate-100">{user.name}</h2>
                {user.role === "ADMIN" && (
                  <span className="text-xs font-semibold bg-yellow-100 dark:bg-yellow-900/30 text-yellow-700 dark:text-yellow-400 px-2 py-0.5 rounded-full">👑 관리자</span>
                )}
              </div>
              <p className="text-sm text-gray-500 dark:text-slate-400 mt-0.5">{user.email}</p>
              <p className="text-xs text-gray-400 dark:text-slate-500 mt-1">
                {user.isOnline ? "🟢 온라인" : "⚫ 오프라인"} · {new Date(user.createdAt).toLocaleDateString("ko-KR")} 가입
              </p>
            </div>

            {/* 팔로우 버튼 */}
            {!isSelf && session && (
              <button
                onClick={toggleFollow}
                disabled={followLoading}
                className={`flex items-center gap-1.5 px-4 py-2 rounded-xl text-sm font-semibold transition shrink-0 ${
                  followInfo?.isFollowing
                    ? "bg-gray-100 dark:bg-slate-700 text-gray-700 dark:text-slate-300 hover:bg-red-50 dark:hover:bg-red-900/20 hover:text-red-600"
                    : "bg-blue-600 text-white hover:bg-blue-700"
                } disabled:opacity-50`}
              >
                {followInfo?.isFollowing
                  ? <><UserCheck size={15} /> 팔로잉</>
                  : <><UserPlus size={15} /> 팔로우</>
                }
              </button>
            )}
          </div>

          {/* 통계 */}
          <div className="grid grid-cols-4 gap-2 mt-5 pt-5 border-t border-gray-100 dark:border-slate-700">
            {[
              { label: "팔로워", value: followInfo?.followerCount ?? 0, onClick: () => { setTab("followers"); setShowTab(true); } },
              { label: "팔로잉", value: followInfo?.followingCount ?? 0, onClick: () => { setTab("following"); setShowTab(true); } },
              { label: "게시글", value: user._count.posts, onClick: undefined },
              { label: "파일",   value: user._count.files, onClick: undefined },
            ].map(({ label, value, onClick }) => (
              <button
                key={label}
                onClick={onClick}
                disabled={!onClick}
                className={`text-center ${onClick ? "cursor-pointer hover:bg-gray-50 dark:hover:bg-slate-700 rounded-lg p-1 transition-colors" : "cursor-default"}`}
              >
                <p className="text-lg font-bold text-gray-900 dark:text-slate-100">{value.toLocaleString()}</p>
                <p className="text-xs text-gray-500 dark:text-slate-400">{label}</p>
              </button>
            ))}
          </div>
        </div>

        {/* 팔로워/팔로잉 목록 */}
        {showTab && (
          <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700">
            <div className="flex border-b border-gray-100 dark:border-slate-700">
              {(["followers", "following"] as const).map((t) => (
                <button
                  key={t}
                  onClick={() => setTab(t)}
                  className={`flex-1 py-3 text-sm font-semibold transition-colors ${
                    tab === t
                      ? "text-blue-600 border-b-2 border-blue-600"
                      : "text-gray-500 dark:text-slate-400 hover:text-gray-700 dark:hover:text-slate-300"
                  }`}
                >
                  {t === "followers" ? `팔로워 ${followInfo?.followerCount ?? 0}` : `팔로잉 ${followInfo?.followingCount ?? 0}`}
                </button>
              ))}
              <button onClick={() => setShowTab(false)} className="px-4 text-gray-400 hover:text-gray-600 text-lg">×</button>
            </div>
            <div className="divide-y divide-gray-100 dark:divide-slate-700">
              {tabUsers.length === 0 ? (
                <p className="text-center py-8 text-sm text-gray-400 dark:text-slate-500">
                  {tab === "followers" ? "팔로워가 없습니다" : "팔로잉 중인 사용자가 없습니다"}
                </p>
              ) : tabUsers.map((u) => (
                <Link key={u.id} href={`/users/${u.id}`} className="flex items-center gap-3 px-4 py-3 hover:bg-gray-50 dark:hover:bg-slate-700 transition-colors">
                  <div className="relative">
                    <div className="w-9 h-9 rounded-full bg-gradient-to-br from-blue-400 to-purple-500 flex items-center justify-center text-white text-sm font-bold">
                      {u.name[0]}
                    </div>
                    {u.isOnline && <span className="absolute bottom-0 right-0 w-2.5 h-2.5 bg-green-500 rounded-full border border-white dark:border-slate-800" />}
                  </div>
                  <div className="flex-1 min-w-0">
                    <p className="text-sm font-medium text-gray-900 dark:text-slate-100 truncate">{u.name}</p>
                    <p className="text-xs text-gray-400 dark:text-slate-500 truncate">{u.email}</p>
                  </div>
                </Link>
              ))}
            </div>
          </div>
        )}

        {/* 게시글 바로가기 */}
        <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-4">
          <Link href={`/posts?author=${id}`} className="flex items-center justify-between group">
            <div className="flex items-center gap-3">
              <FileText size={18} className="text-indigo-500" />
              <span className="text-sm font-medium text-gray-900 dark:text-slate-100">작성한 게시글</span>
            </div>
            <span className="text-sm text-blue-600 dark:text-blue-400 group-hover:underline">보기 →</span>
          </Link>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/ConfirmDialog.tsx">
"use client";
// src/components/ConfirmDialog.tsx
// ✅ 수정사항:
// 1. openConfirm이 Promise<boolean> 반환 → await 패턴 지원
// 2. confirmText / confirmLabel 둘 다 허용 (하위 호환)
// 3. confirmVariant / variant 둘 다 허용 (하위 호환)

import { useEffect, useRef, useState, useCallback } from "react";

// ── UI 컴포넌트 ──────────────────────────────────────────

interface ConfirmDialogProps {
  isOpen:         boolean;
  title:          string;
  message:        string;
  confirmLabel?:  string;
  cancelLabel?:   string;
  variant?:       "danger" | "default" | "primary";
  onConfirm:      () => void;
  onCancel:       () => void;
}

export function ConfirmDialog({
  isOpen,
  title,
  message,
  confirmLabel = "확인",
  cancelLabel  = "취소",
  variant      = "default",
  onConfirm,
  onCancel,
}: ConfirmDialogProps) {
  const confirmBtnRef = useRef<HTMLButtonElement>(null);

  useEffect(() => {
    if (isOpen) setTimeout(() => confirmBtnRef.current?.focus(), 50);
  }, [isOpen]);

  useEffect(() => {
    if (!isOpen) return;
    const handle = (e: KeyboardEvent) => { if (e.key === "Escape") onCancel(); };
    window.addEventListener("keydown", handle);
    return () => window.removeEventListener("keydown", handle);
  }, [isOpen, onCancel]);

  if (!isOpen) return null;

  return (
    <div
      className="fixed inset-0 z-[200] flex items-center justify-center p-4 bg-black/50 backdrop-blur-sm"
      onClick={onCancel}
    >
      <div
        className="bg-white dark:bg-slate-800 rounded-2xl shadow-2xl w-full max-w-sm p-6 animate-in zoom-in-95 duration-150"
        onClick={(e) => e.stopPropagation()}
      >
        <h3 className="font-bold text-gray-900 dark:text-slate-100 text-base mb-2">{title}</h3>
        <p className="text-sm text-gray-500 dark:text-slate-400 mb-6">{message}</p>
        <div className="flex gap-3">
          <button
            onClick={onCancel}
            className="flex-1 py-2.5 rounded-xl border border-gray-200 dark:border-slate-600 text-gray-600 dark:text-slate-300 text-sm font-medium hover:bg-gray-50 dark:hover:bg-slate-700 transition"
          >
            {cancelLabel}
          </button>
          <button
            ref={confirmBtnRef}
            onClick={onConfirm}
            className={`flex-1 py-2.5 rounded-xl text-white text-sm font-bold transition ${
              variant === "danger"
                ? "bg-red-500 hover:bg-red-600"
                : variant === "primary"
                ? "bg-violet-600 hover:bg-violet-700"
                : "bg-blue-600 hover:bg-blue-700"
            }`}
          >
            {confirmLabel}
          </button>
        </div>
      </div>
    </div>
  );
}

// ── Hook ─────────────────────────────────────────────────

interface OpenConfirmOptions {
  title:           string;
  message:         string;
  // confirmText / confirmLabel 둘 다 허용
  confirmText?:    string;
  confirmLabel?:   string;
  cancelLabel?:    string;
  // confirmVariant / variant 둘 다 허용
  confirmVariant?: "danger" | "default" | "primary";
  variant?:        "danger" | "default" | "primary";
  // 콜백 패턴 (선택)
  onConfirm?:      () => void;
}

export function useConfirm() {
  const [state, setState] = useState<{
    isOpen:       boolean;
    title:        string;
    message:      string;
    confirmLabel: string;
    cancelLabel:  string;
    variant:      "danger" | "default" | "primary";
  }>({
    isOpen:       false,
    title:        "",
    message:      "",
    confirmLabel: "확인",
    cancelLabel:  "취소",
    variant:      "default",
  });

  // Promise resolve를 외부에서 저장
  const resolveRef = useRef<((value: boolean) => void) | null>(null);

  // ── Promise 반환 패턴 지원 ─────────────────────────────
  // await openConfirm({ ... }) → true(확인) / false(취소)
  const openConfirm = useCallback((opts: OpenConfirmOptions): Promise<boolean> => {
    return new Promise((resolve) => {
      resolveRef.current = resolve;
      setState({
        isOpen:       true,
        title:        opts.title,
        message:      opts.message,
        confirmLabel: opts.confirmText ?? opts.confirmLabel ?? "확인",
        cancelLabel:  opts.cancelLabel ?? "취소",
        variant:      opts.confirmVariant ?? opts.variant ?? "default",
      });
    });
  }, []);

  const handleConfirm = useCallback(() => {
    setState((s) => ({ ...s, isOpen: false }));
    resolveRef.current?.(true);
    resolveRef.current = null;
  }, []);

  const handleCancel = useCallback(() => {
    setState((s) => ({ ...s, isOpen: false }));
    resolveRef.current?.(false);
    resolveRef.current = null;
  }, []);

  const confirmDialog = (
    <ConfirmDialog
      isOpen={state.isOpen}
      title={state.title}
      message={state.message}
      confirmLabel={state.confirmLabel}
      cancelLabel={state.cancelLabel}
      variant={state.variant}
      onConfirm={handleConfirm}
      onCancel={handleCancel}
    />
  );

  return { confirmDialog, openConfirm };
}
</file>

<file path="src/components/DragDropUpload.tsx">
"use client";
// src/components/DragDropUpload.tsx
// 대시보드 업로드 영역을 이 컴포넌트로 교체하세요

import { useState, useRef, useCallback } from "react";
import { Upload, X, CheckCircle, AlertCircle, File } from "lucide-react";
import { getFileIcon, formatFileSize } from "@/lib/client-utils";

const MAX_FILE_SIZE = 50 * 1024 * 1024; // 50MB
const MAX_FILES = 10;

interface UploadFile {
  id: string;
  file: File;
  progress: number;
  status: "pending" | "uploading" | "done" | "error";
  error?: string;
}

interface Props {
  folderId?: string | null;
  onUploadComplete?: () => void;
}

export default function DragDropUpload({ folderId, onUploadComplete }: Props) {
  const [isDragging, setIsDragging] = useState(false);
  const [files, setFiles] = useState<UploadFile[]>([]);
  const inputRef = useRef<HTMLInputElement>(null);

  const addFiles = useCallback((newFiles: File[]) => {
    const valid = newFiles
      .slice(0, MAX_FILES - files.length)
      .filter((f) => {
        if (f.size > MAX_FILE_SIZE) return false;
        return true;
      })
      .map((f) => ({
        id: Math.random().toString(36).slice(2),
        file: f,
        progress: 0,
        status: "pending" as const,
      }));
    setFiles((prev) => [...prev, ...valid]);
  }, [files.length]);

  // 드래그 이벤트
  const onDragOver = (e: React.DragEvent) => { e.preventDefault(); setIsDragging(true); };
  const onDragLeave = (e: React.DragEvent) => { e.preventDefault(); setIsDragging(false); };
  const onDrop = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);
    const dropped = Array.from(e.dataTransfer.files);
    addFiles(dropped);
  };

  const removeFile = (id: string) => setFiles((f) => f.filter((x) => x.id !== id));

  const uploadFile = async (uploadFile: UploadFile) => {
    setFiles((prev) => prev.map((f) => f.id === uploadFile.id ? { ...f, status: "uploading" } : f));

    const formData = new FormData();
    formData.append("file", uploadFile.file);
    if (folderId) formData.append("folderId", folderId);

    try {
      const xhr = new XMLHttpRequest();
      await new Promise<void>((resolve, reject) => {
        xhr.upload.onprogress = (e) => {
          if (e.lengthComputable) {
            const pct = Math.round((e.loaded / e.total) * 100);
            setFiles((prev) => prev.map((f) => f.id === uploadFile.id ? { ...f, progress: pct } : f));
          }
        };
        xhr.onload = () => {
          if (xhr.status >= 200 && xhr.status < 300) resolve();
          else reject(new Error(JSON.parse(xhr.responseText)?.error ?? "업로드 실패"));
        };
        xhr.onerror = () => reject(new Error("네트워크 오류"));
        xhr.open("POST", "/api/files/upload");
        xhr.send(formData);
      });

      setFiles((prev) => prev.map((f) => f.id === uploadFile.id ? { ...f, status: "done", progress: 100 } : f));
    } catch (err: any) {
      setFiles((prev) => prev.map((f) => f.id === uploadFile.id ? { ...f, status: "error", error: err.message } : f));
    }
  };

  const uploadAll = async () => {
    const pending = files.filter((f) => f.status === "pending");
    await Promise.all(pending.map(uploadFile));
    if (pending.length > 0) onUploadComplete?.();
  };

  const clearDone = () => setFiles((f) => f.filter((x) => x.status !== "done"));

  const hasPending = files.some((f) => f.status === "pending");
  const allDone = files.length > 0 && files.every((f) => f.status === "done" || f.status === "error");

  return (
    <div className="space-y-3">
      {/* 드롭 영역 */}
      <div
        onDragOver={onDragOver}
        onDragLeave={onDragLeave}
        onDrop={onDrop}
        onClick={() => inputRef.current?.click()}
        className={`relative flex flex-col items-center justify-center min-h-36 rounded-2xl border-2 border-dashed cursor-pointer transition-all ${
          isDragging
            ? "border-blue-500 bg-blue-50 dark:bg-blue-900/20 scale-[1.01]"
            : "border-gray-200 dark:border-slate-700 bg-gray-50 dark:bg-slate-800/50 hover:border-blue-400 hover:bg-blue-50/50 dark:hover:bg-slate-800"
        }`}
      >
        <input
          ref={inputRef}
          type="file"
          multiple
          className="hidden"
          onChange={(e) => addFiles(Array.from(e.target.files ?? []))}
        />
        <Upload size={28} className={`mb-2 transition-colors ${isDragging ? "text-blue-500" : "text-gray-400 dark:text-slate-500"}`} />
        <p className={`text-sm font-semibold transition-colors ${isDragging ? "text-blue-600 dark:text-blue-400" : "text-gray-600 dark:text-slate-400"}`}>
          {isDragging ? "여기에 놓으세요!" : "파일을 드래그하거나 클릭하여 선택"}
        </p>
        <p className="text-xs text-gray-400 dark:text-slate-500 mt-1">최대 {MAX_FILES}개 · 파일당 50MB</p>
      </div>

      {/* 파일 목록 */}
      {files.length > 0 && (
        <div className="space-y-2">
          {files.map((f) => (
            <div key={f.id} className="flex items-center gap-3 bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 px-3 py-2.5">
              <span className="text-xl shrink-0">{getFileIcon(f.file.type)}</span>
              <div className="flex-1 min-w-0">
                <p className="text-xs font-medium text-gray-900 dark:text-slate-100 truncate">{f.file.name}</p>
                <p className="text-[10px] text-gray-400 dark:text-slate-500">{formatFileSize(f.file.size)}</p>
                {/* 진행 바 */}
                {(f.status === "uploading" || f.status === "done") && (
                  <div className="mt-1.5 h-1.5 bg-gray-100 dark:bg-slate-700 rounded-full overflow-hidden">
                    <div
                      className={`h-full rounded-full transition-all duration-200 ${f.status === "done" ? "bg-green-500" : "bg-blue-500"}`}
                      style={{ width: `${f.progress}%` }}
                    />
                  </div>
                )}
                {f.status === "error" && (
                  <p className="text-[10px] text-red-500 mt-0.5">{f.error}</p>
                )}
              </div>
              {/* 상태 아이콘 */}
              <div className="shrink-0">
                {f.status === "done" && <CheckCircle size={16} className="text-green-500" />}
                {f.status === "error" && <AlertCircle size={16} className="text-red-500" />}
                {f.status === "uploading" && (
                  <div className="w-4 h-4 border-2 border-blue-500/30 border-t-blue-500 rounded-full animate-spin" />
                )}
                {f.status === "pending" && (
                  <button onClick={(e) => { e.stopPropagation(); removeFile(f.id); }} className="text-gray-400 hover:text-red-500 transition-colors">
                    <X size={16} />
                  </button>
                )}
              </div>
            </div>
          ))}

          {/* 액션 버튼 */}
          <div className="flex gap-2">
            {hasPending && (
              <button
                onClick={uploadAll}
                className="flex-1 py-2.5 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-xl transition-colors"
              >
                업로드 시작 ({files.filter((f) => f.status === "pending").length}개)
              </button>
            )}
            {allDone && (
              <button
                onClick={clearDone}
                className="flex-1 py-2.5 text-sm font-medium text-gray-600 dark:text-slate-400 bg-gray-100 dark:bg-slate-700 hover:bg-gray-200 dark:hover:bg-slate-600 rounded-xl transition-colors"
              >
                목록 지우기
              </button>
            )}
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/ErrorBoundary.tsx">
"use client";
// src/components/ErrorBoundary.tsx
// React 에러 바운더리 — 페이지/컴포넌트 단위 크래시 격리

import React, { Component, ErrorInfo, ReactNode } from "react";
import { AlertTriangle, RefreshCw, Home, ChevronDown, ChevronUp } from "lucide-react";

interface Props {
  children:   ReactNode;
  fallback?:  ReactNode;
  level?:     "page" | "section" | "inline";
  onError?:   (error: Error, info: ErrorInfo) => void;
}

interface State {
  hasError:     boolean;
  error:        Error | null;
  showDetails:  boolean;
}

export class ErrorBoundary extends Component<Props, State> {
  state: State = { hasError: false, error: null, showDetails: false };

  static getDerivedStateFromError(error: Error): Partial<State> {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, info: ErrorInfo) {
    // 에러 로깅 (서버로 전송)
    this.props.onError?.(error, info);
    reportError(error, {
      componentStack: info.componentStack,
      level:          this.props.level ?? "section",
    });
  }

  reset = () => this.setState({ hasError: false, error: null, showDetails: false });

  render() {
    if (!this.state.hasError) return this.props.children;

    // 커스텀 fallback이 있으면 사용
    if (this.props.fallback) return this.props.fallback;

    const { level = "section", error } = { ...this.props, ...this.state };

    // ── inline (토스트/카드 수준) ─────────────────────────
    if (level === "inline") {
      return (
        <div className="flex items-center gap-2 px-3 py-2 bg-red-50 dark:bg-red-900/20 border border-red-100 dark:border-red-800 rounded-xl">
          <AlertTriangle size={14} className="text-red-500 shrink-0" />
          <p className="text-xs text-red-600 dark:text-red-400 flex-1">
            이 섹션을 불러오는 데 실패했습니다
          </p>
          <button onClick={this.reset} className="text-xs text-red-500 hover:text-red-700 font-medium">
            재시도
          </button>
        </div>
      );
    }

    // ── section (카드/패널 수준) ──────────────────────────
    if (level === "section") {
      return (
        <div className="flex flex-col items-center justify-center py-12 px-6 text-center rounded-2xl border-2 border-dashed border-red-200 dark:border-red-800 bg-red-50/50 dark:bg-red-900/10">
          <div className="w-12 h-12 rounded-full bg-red-100 dark:bg-red-900/30 flex items-center justify-center mb-3">
            <AlertTriangle size={22} className="text-red-500" />
          </div>
          <p className="text-sm font-semibold text-gray-900 dark:text-slate-100 mb-1">
            이 섹션에서 오류가 발생했습니다
          </p>
          <p className="text-xs text-gray-400 dark:text-slate-500 mb-4">
            {error?.message ?? "알 수 없는 오류"}
          </p>
          <button
            onClick={this.reset}
            className="flex items-center gap-1.5 px-4 py-2 text-sm font-semibold text-white bg-red-600 hover:bg-red-700 rounded-xl transition"
          >
            <RefreshCw size={13} /> 다시 시도
          </button>
        </div>
      );
    }

    // ── page (전체 페이지 수준) ───────────────────────────
    return (
      <div className="min-h-screen flex flex-col items-center justify-center bg-gray-50 dark:bg-slate-900 px-4">
        <div className="max-w-md w-full text-center">
          {/* 아이콘 */}
          <div className="w-20 h-20 rounded-2xl bg-red-50 dark:bg-red-900/30 flex items-center justify-center mx-auto mb-6 shadow-lg">
            <AlertTriangle size={36} className="text-red-500" />
          </div>

          <h1 className="text-2xl font-black text-gray-900 dark:text-slate-100 mb-2">
            예기치 않은 오류
          </h1>
          <p className="text-gray-500 dark:text-slate-400 mb-8">
            페이지를 불러오는 중 문제가 발생했습니다.
            <br />다시 시도하거나 홈으로 돌아가세요.
          </p>

          {/* 에러 상세 (개발 환경) */}
          {process.env.NODE_ENV === "development" && error && (
            <div className="mb-6 text-left">
              <button
                onClick={() => this.setState((s) => ({ showDetails: !s.showDetails }))}
                className="flex items-center gap-1.5 text-xs text-gray-400 hover:text-gray-600 dark:hover:text-slate-300 mb-2"
              >
                {this.state.showDetails ? <ChevronUp size={12} /> : <ChevronDown size={12} />}
                에러 상세 (개발 환경)
              </button>
              {this.state.showDetails && (
                <pre className="text-left text-[10px] bg-gray-900 text-red-300 rounded-xl p-4 overflow-auto max-h-40 whitespace-pre-wrap">
                  {error.message}{"\n\n"}{error.stack}
                </pre>
              )}
            </div>
          )}

          <div className="flex gap-3">
            <button
              onClick={this.reset}
              className="flex-1 flex items-center justify-center gap-2 py-3 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-xl transition"
            >
              <RefreshCw size={15} /> 다시 시도
            </button>
            <a
              href="/dashboard"
              className="flex-1 flex items-center justify-center gap-2 py-3 text-sm font-semibold text-gray-700 dark:text-slate-300 bg-white dark:bg-slate-800 hover:bg-gray-50 dark:hover:bg-slate-700 border border-gray-200 dark:border-slate-700 rounded-xl transition"
            >
              <Home size={15} /> 홈으로
            </a>
          </div>
        </div>
      </div>
    );
  }
}

// ── 에러 리포팅 함수 ──────────────────────────────────────
async function reportError(error: Error, context?: object) {
  if (process.env.NODE_ENV === "development") {
    console.error("[ErrorBoundary]", error, context);
    return;
  }
  // 프로덕션에서 서버로 에러 전송
  try {
    await fetch("/api/errors/report", {
      method:  "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        message: error.message,
        stack:   error.stack,
        context,
        url:     window.location.href,
        ua:      navigator.userAgent,
        ts:      new Date().toISOString(),
      }),
    });
  } catch {}
}

// ── 래퍼 컴포넌트 (편의용) ───────────────────────────────
export function PageErrorBoundary({ children }: { children: ReactNode }) {
  return <ErrorBoundary level="page">{children}</ErrorBoundary>;
}
export function SectionErrorBoundary({ children }: { children: ReactNode }) {
  return <ErrorBoundary level="section">{children}</ErrorBoundary>;
}
export function InlineErrorBoundary({ children }: { children: ReactNode }) {
  return <ErrorBoundary level="inline">{children}</ErrorBoundary>;
}
</file>

<file path="src/components/FileEncryptButton.tsx">
"use client";
// src/components/FileEncryptButton.tsx

import { useState } from "react";
import { Lock, LockOpen, Eye, EyeOff } from "lucide-react";
import { toast } from "@/components/Toast";

interface Props {
  fileId: string;
  isEncrypted: boolean;
  onStatusChange?: (encrypted: boolean) => void;
}

function PasswordModal({
  title, hint, onConfirm, onClose, loading,
}: {
  title: string; hint: string;
  onConfirm: (pw: string) => void;
  onClose: () => void; loading: boolean;
}) {
  const [pw, setPw] = useState("");
  const [show, setShow] = useState(false);
  return (
    <div className="fixed inset-0 z-[9999] flex items-center justify-center px-4" onClick={onClose}>
      <div className="absolute inset-0 bg-black/50 backdrop-blur-sm" />
      <div className="relative z-10 w-full max-w-sm bg-white dark:bg-slate-800 rounded-2xl shadow-2xl p-6 space-y-4"
        onClick={(e) => e.stopPropagation()}>
        <h3 className="text-base font-bold text-gray-900 dark:text-slate-100">{title}</h3>
        <p className="text-xs text-gray-500 dark:text-slate-400">{hint}</p>
        <div className="relative">
          <input
            autoFocus
            type={show ? "text" : "password"}
            value={pw}
            onChange={(e) => setPw(e.target.value)}
            onKeyDown={(e) => e.key === "Enter" && pw.length >= 4 && onConfirm(pw)}
            placeholder="비밀번호 입력"
            className="w-full pr-10 pl-4 py-2.5 text-sm border border-gray-200 dark:border-slate-600 rounded-xl bg-white dark:bg-slate-700 dark:text-slate-100 focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
          <button onClick={() => setShow(!show)}
            className="absolute right-3 top-1/2 -translate-y-1/2 text-gray-400">
            {show ? <EyeOff size={15} /> : <Eye size={15} />}
          </button>
        </div>
        <div className="flex gap-2 pt-1">
          <button onClick={onClose}
            className="flex-1 py-2.5 text-sm text-gray-600 dark:text-slate-400 bg-gray-100 dark:bg-slate-700 hover:bg-gray-200 dark:hover:bg-slate-600 rounded-xl transition">
            취소
          </button>
          <button onClick={() => onConfirm(pw)} disabled={pw.length < 4 || loading}
            className="flex-1 py-2.5 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-xl transition disabled:opacity-50">
            {loading ? "처리 중..." : "확인"}
          </button>
        </div>
      </div>
    </div>
  );
}

export default function FileEncryptButton({ fileId, isEncrypted: initEncrypted, onStatusChange }: Props) {
  const [isEncrypted, setIsEncrypted] = useState(initEncrypted);
  const [showModal, setShowModal] = useState(false);
  const [loading, setLoading] = useState(false);

  const handleConfirm = async (password: string) => {
    setLoading(true);
    try {
      const res = await fetch(`/api/files/${fileId}/encrypt`, {
        method: isEncrypted ? "DELETE" : "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ password }),
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error);
      const newState = !isEncrypted;
      setIsEncrypted(newState);
      onStatusChange?.(newState);
      toast.success(data.message);
      setShowModal(false);
    } catch (e: any) {
      toast.error(e.message || "오류가 발생했습니다");
    } finally {
      setLoading(false);
    }
  };

  return (
    <>
      {showModal && (
        <PasswordModal
          title={isEncrypted ? "파일 잠금 해제" : "파일 암호화"}
          hint={isEncrypted
            ? "설정했던 비밀번호를 입력해 암호화를 해제합니다."
            : "이 파일을 비밀번호로 보호합니다. 비밀번호를 잃어버리면 파일을 복구할 수 없습니다."}
          onConfirm={handleConfirm}
          onClose={() => setShowModal(false)}
          loading={loading}
        />
      )}
      <button
        onClick={() => setShowModal(true)}
        className={`flex items-center gap-1.5 px-3 py-1.5 text-xs font-semibold rounded-lg transition ${
          isEncrypted
            ? "bg-orange-50 dark:bg-orange-900/20 text-orange-600 dark:text-orange-400 hover:bg-orange-100 dark:hover:bg-orange-900/30"
            : "bg-gray-100 dark:bg-slate-700 text-gray-600 dark:text-slate-400 hover:bg-gray-200 dark:hover:bg-slate-600"
        }`}
      >
        {isEncrypted ? <><Lock size={12} /> 잠김</> : <><LockOpen size={12} /> 암호화</>}
      </button>
    </>
  );
}
</file>

<file path="src/components/FileFavoritePin.tsx">
"use client";
// src/components/FileFavoritePin.tsx
// ⚠️ 수정: PinnedFilesSection의 require("react") 버그 제거

import { useState, useEffect } from "react";
import { Star, Pin } from "lucide-react";
import { toast } from "@/components/Toast";

interface Props {
  fileId:    string;
  isStarred: boolean;
  isPinned:  boolean;
  onUpdate?: (starred: boolean, pinned: boolean) => void;
}

export default function FileFavoritePin({ fileId, isStarred: initStarred, isPinned: initPinned, onUpdate }: Props) {
  const [starred, setStarred] = useState(initStarred);
  const [pinned,  setPinned]  = useState(initPinned);
  const [loading, setLoading] = useState(false);

  async function toggleStar() {
    setLoading(true);
    try {
      const res = await fetch(`/api/files/${fileId}/favorite`, { method: "POST" });
      if (!res.ok) throw new Error();
      const { starred: s } = await res.json();
      setStarred(s);
      onUpdate?.(s, pinned);
      toast.success(s ? "즐겨찾기에 추가했습니다" : "즐겨찾기를 해제했습니다");
    } catch {
      toast.error("처리에 실패했습니다");
    } finally {
      setLoading(false);
    }
  }

  async function togglePin() {
    setLoading(true);
    try {
      const res = await fetch(`/api/files/${fileId}/favorite`, { method: "PATCH" });
      if (!res.ok) {
        const err = await res.json().catch(() => ({}));
        toast.error(err?.error ?? "처리에 실패했습니다");
        return;
      }
      const { pinned: p } = await res.json();
      setPinned(p);
      onUpdate?.(starred, p);
      toast.success(p ? "파일을 고정했습니다" : "고정을 해제했습니다");
    } catch {
      toast.error("처리에 실패했습니다");
    } finally {
      setLoading(false);
    }
  }

  return (
    <div className="flex items-center gap-1">
      <button onClick={toggleStar} disabled={loading}
        className={`p-1.5 rounded-lg transition ${starred ? "text-yellow-500 bg-yellow-50 dark:bg-yellow-900/20" : "text-gray-400 hover:text-yellow-500 hover:bg-yellow-50"}`}
        title={starred ? "즐겨찾기 해제" : "즐겨찾기"}>
        <Star size={14} fill={starred ? "currentColor" : "none"} />
      </button>
      <button onClick={togglePin} disabled={loading}
        className={`p-1.5 rounded-lg transition ${pinned ? "text-blue-500 bg-blue-50 dark:bg-blue-900/20" : "text-gray-400 hover:text-blue-500 hover:bg-blue-50"}`}
        title={pinned ? "고정 해제" : "고정"}>
        <Pin size={14} fill={pinned ? "currentColor" : "none"} />
      </button>
    </div>
  );
}

export function PinnedFilesSection() {
  const [files, setFiles] = useState<any[]>([]);

  useEffect(() => {
    fetch("/api/files?pinned=true&limit=10")
      .then((r) => r.json())
      .then((d) => setFiles(d.files ?? []))
      .catch(() => {});
  }, []);

  if (files.length === 0) return null;

  return (
    <div className="mb-6">
      <div className="flex items-center gap-2 mb-3">
        <Pin size={14} className="text-blue-500" />
        <h3 className="text-sm font-semibold text-gray-700 dark:text-slate-300">고정된 파일</h3>
      </div>
      <div className="flex gap-2 overflow-x-auto pb-2">
        {files.map((f) => (
          <div key={f.id} className="shrink-0 bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-3 w-36 hover:shadow-md transition cursor-pointer">
            <div className="text-2xl mb-2 text-center">
              {f.mimeType?.startsWith("image/") && f.thumbnailUrl
                ? <img src={f.thumbnailUrl} alt={f.originalName} className="w-full h-16 object-cover rounded-lg" />
                : <span>📄</span>}
            </div>
            <p className="text-xs font-medium text-gray-800 dark:text-slate-200 truncate">{f.originalName}</p>
          </div>
        ))}
      </div>
    </div>
  );
}
</file>

<file path="src/components/FileShareModal.tsx">
"use client";

import { useState, useEffect } from "react";
import { toast } from "@/components/Toast";

interface Share {
  id: string;
  sharedWith: { id: string; email: string; name: string };
  permission: string;
  createdAt: string;
}

interface FileShareModalProps {
  fileId: string | null;
  fileName: string;
  onClose: () => void;
}

export default function FileShareModal({ fileId, fileName, onClose }: FileShareModalProps) {
  const [email, setEmail] = useState("");
  const [permission, setPermission] = useState("VIEW");
  const [shares, setShares] = useState<Share[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  // ✅ confirm() 대체: 삭제 대기 중인 shareId 저장
  const [pendingDeleteId, setPendingDeleteId] = useState<string | null>(null);

  useEffect(() => {
    if (fileId) fetchShares();
  }, [fileId]);

  const fetchShares = async () => {
    if (!fileId) return;
    try {
      const res = await fetch(`/api/files/${fileId}/share`);
      if (res.ok) setShares((await res.json()).shares);
    } catch {}
  };

  const handleShare = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!fileId || !email) return;
    setLoading(true);
    setError("");
    try {
      const res = await fetch(`/api/files/${fileId}/share`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ sharedWithEmail: email, permission }),
      });
      const data = await res.json();
      if (!res.ok) {
        setError(data.error || "공유 실패");
        return;
      }
      // ✅ alert() → toast
      toast.success("파일이 공유되었습니다");
      setEmail("");
      fetchShares();
    } catch {
      setError("공유 중 오류가 발생했습니다");
    } finally {
      setLoading(false);
    }
  };

  const handleDeleteShare = async (shareId: string) => {
    if (!fileId) return;
    try {
      const res = await fetch(`/api/files/${fileId}/share?shareId=${shareId}`, {
        method: "DELETE",
      });
      if (res.ok) {
        toast.success("공유가 취소되었습니다");
        fetchShares();
      } else {
        toast.error("공유 취소에 실패했습니다");
      }
    } catch {
      toast.error("오류가 발생했습니다");
    } finally {
      setPendingDeleteId(null);
    }
  };

  if (!fileId) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4" onClick={onClose}>
      <div className="bg-white rounded-xl shadow-xl max-w-2xl w-full max-h-[80vh] overflow-hidden" onClick={(e) => e.stopPropagation()}>
        {/* 헤더 */}
        <div className="flex items-center justify-between p-6 border-b">
          <h3 className="text-lg font-semibold text-gray-900">파일 공유: {fileName}</h3>
          <button onClick={onClose} className="text-gray-400 hover:text-gray-600 text-2xl">×</button>
        </div>

        <div className="p-6 overflow-y-auto max-h-[60vh]">
          {/* 공유 추가 폼 */}
          <form onSubmit={handleShare} className="mb-6">
            <label className="block text-sm font-medium text-gray-700 mb-2">공유할 사용자 이메일</label>
            {error && (
              <div className="mb-3 p-3 bg-red-50 border border-red-200 rounded-md">
                <p className="text-sm text-red-800">{error}</p>
              </div>
            )}
            <div className="flex gap-2 mb-3">
              <input
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                placeholder="user@example.com"
                className="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-900"
                required
              />
              <select
                value={permission}
                onChange={(e) => setPermission(e.target.value)}
                className="px-3 py-2 border border-gray-300 rounded-md text-gray-900"
              >
                <option value="VIEW">보기</option>
                <option value="EDIT">편집</option>
              </select>
              <button
                type="submit"
                disabled={loading}
                className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:opacity-50"
              >
                {loading ? "공유 중..." : "공유"}
              </button>
            </div>
          </form>

          {/* 공유 목록 */}
          {shares.length > 0 && (
            <div>
              <h4 className="text-sm font-medium text-gray-700 mb-3">공유된 사용자</h4>
              <div className="space-y-2">
                {shares.map((share) => (
                  <div key={share.id}>
                    <div className="flex items-center justify-between p-3 bg-gray-50 rounded-md">
                      <div>
                        <p className="text-sm font-medium text-gray-900">{share.sharedWith.name}</p>
                        <p className="text-xs text-gray-500">{share.sharedWith.email}</p>
                      </div>
                      <div className="flex items-center gap-2">
                        <span className="px-2 py-1 text-xs bg-blue-100 text-blue-700 rounded">
                          {share.permission === "VIEW" ? "보기" : "편집"}
                        </span>
                        {/* ✅ confirm() → 인라인 확인 UI */}
                        {pendingDeleteId === share.id ? (
                          <div className="flex items-center gap-1">
                            <span className="text-xs text-gray-500">취소할까요?</span>
                            <button
                              onClick={() => handleDeleteShare(share.id)}
                              className="text-xs px-2 py-1 bg-red-500 text-white rounded"
                            >
                              확인
                            </button>
                            <button
                              onClick={() => setPendingDeleteId(null)}
                              className="text-xs px-2 py-1 bg-gray-200 rounded"
                            >
                              아니오
                            </button>
                          </div>
                        ) : (
                          <button
                            onClick={() => setPendingDeleteId(share.id)}
                            className="text-red-500 hover:text-red-700 text-sm"
                          >
                            취소
                          </button>
                        )}
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>

        <div className="flex justify-end p-6 border-t">
          <button
            onClick={onClose}
            className="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50"
          >
            닫기
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/FileVersionHistory.tsx">
"use client";
// src/components/FileVersionHistory.tsx
// 파일 상세/컨텍스트 메뉴에서 사용

import { useState, useEffect } from "react";
import { History, RotateCcw, Plus, X, Clock, ChevronDown, ChevronUp } from "lucide-react";
import { formatFileSize } from "@/lib/client-utils";
import { toast } from "@/components/Toast";
import { useConfirm } from "@/components/ConfirmDialog";

interface FileVersion {
  id: string;
  versionNum: number;
  size: bigint | string;
  comment: string | null;
  createdAt: string;
  user: { name: string };
}

interface Props {
  fileId: string;
  fileName: string;
  onRollback?: () => void;
}

function timeAgo(d: string) {
  const diff = Date.now() - new Date(d).getTime();
  const m = Math.floor(diff / 60000);
  if (m < 1) return "방금 전";
  if (m < 60) return `${m}분 전`;
  const h = Math.floor(m / 60);
  if (h < 24) return `${h}시간 전`;
  const days = Math.floor(h / 24);
  return `${days}일 전`;
}

export default function FileVersionHistory({ fileId, fileName, onRollback }: Props) {
  const { confirmDialog, openConfirm } = useConfirm();
  const [open, setOpen] = useState(false);
  const [versions, setVersions] = useState<FileVersion[]>([]);
  const [loading, setLoading] = useState(false);
  const [saving, setSaving] = useState(false);
  const [comment, setComment] = useState("");
  const [showCommentInput, setShowCommentInput] = useState(false);

  useEffect(() => {
    if (!open) return;
    setLoading(true);
    fetch(`/api/files/${fileId}/versions`)
      .then((r) => r.json())
      .then((d) => setVersions(d.versions ?? []))
      .catch(() => toast.error("버전 기록을 불러오지 못했습니다"))
      .finally(() => setLoading(false));
  }, [open, fileId]);

  const saveVersion = async () => {
    setSaving(true);
    try {
      const res = await fetch(`/api/files/${fileId}/versions`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ comment: comment.trim() || undefined }),
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error);
      setVersions((v) => [data.version, ...v]);
      setComment("");
      setShowCommentInput(false);
      toast.success(data.message);
    } catch (e: any) {
      toast.error(e.message || "버전 저장에 실패했습니다");
    } finally {
      setSaving(false);
    }
  };

  const rollback = async (version: FileVersion) => {
    const ok = await openConfirm({
      title: `버전 ${version.versionNum}으로 롤백`,
      message: `"${fileName}"을 버전 ${version.versionNum}으로 되돌립니다. 현재 상태는 자동으로 백업됩니다.`,
      confirmText: "롤백", confirmVariant: "danger",
    });
    if (!ok) return;
    const res = await fetch(`/api/files/${fileId}/versions/${version.id}/rollback`, { method: "POST" });
    const data = await res.json();
    if (res.ok) {
      toast.success(data.message);
      onRollback?.();
      setOpen(false);
    } else toast.error(data.error || "롤백에 실패했습니다");
  };

  return (
    <div className="border border-gray-100 dark:border-slate-700 rounded-xl overflow-hidden">
      {confirmDialog}

      {/* 헤더 토글 */}
      <button
        onClick={() => setOpen(!open)}
        className="w-full flex items-center gap-3 px-4 py-3 bg-white dark:bg-slate-800 hover:bg-gray-50 dark:hover:bg-slate-700/50 transition-colors"
      >
        <History size={16} className="text-gray-500 dark:text-slate-400 shrink-0" />
        <span className="text-sm font-semibold text-gray-900 dark:text-slate-100 flex-1 text-left">버전 기록</span>
        {versions.length > 0 && (
          <span className="text-xs bg-blue-100 dark:bg-blue-900/30 text-blue-600 dark:text-blue-400 px-2 py-0.5 rounded-full font-medium">
            {versions.length}개
          </span>
        )}
        {open ? <ChevronUp size={16} className="text-gray-400" /> : <ChevronDown size={16} className="text-gray-400" />}
      </button>

      {open && (
        <div className="border-t border-gray-100 dark:border-slate-700 bg-gray-50 dark:bg-slate-900/50">
          {/* 버전 저장 */}
          <div className="px-4 py-3 border-b border-gray-100 dark:border-slate-700">
            {showCommentInput ? (
              <div className="flex gap-2">
                <input
                  type="text"
                  value={comment}
                  onChange={(e) => setComment(e.target.value)}
                  placeholder="버전 메모 (선택)"
                  className="flex-1 text-xs border border-gray-200 dark:border-slate-600 rounded-lg px-3 py-2 bg-white dark:bg-slate-800 dark:text-slate-100 focus:outline-none focus:ring-2 focus:ring-blue-500"
                  onKeyDown={(e) => e.key === "Enter" && saveVersion()}
                />
                <button onClick={saveVersion} disabled={saving}
                  className="px-3 py-1.5 text-xs font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-lg transition disabled:opacity-50">
                  {saving ? "저장 중..." : "저장"}
                </button>
                <button onClick={() => setShowCommentInput(false)} className="p-1.5 text-gray-400 hover:text-gray-600 dark:hover:text-slate-300 rounded-lg">
                  <X size={14} />
                </button>
              </div>
            ) : (
              <button onClick={() => setShowCommentInput(true)}
                className="flex items-center gap-1.5 text-xs text-blue-600 dark:text-blue-400 hover:text-blue-700 font-medium">
                <Plus size={13} /> 현재 상태를 버전으로 저장
              </button>
            )}
          </div>

          {/* 버전 목록 */}
          <div className="max-h-64 overflow-y-auto divide-y divide-gray-100 dark:divide-slate-700">
            {loading ? (
              <div className="p-4 flex justify-center">
                <div className="w-5 h-5 border-2 border-blue-500/20 border-t-blue-500 rounded-full animate-spin" />
              </div>
            ) : versions.length === 0 ? (
              <p className="text-xs text-gray-400 dark:text-slate-500 text-center py-6">저장된 버전이 없습니다</p>
            ) : versions.map((v) => (
              <div key={v.id} className="flex items-center gap-3 px-4 py-3 hover:bg-white dark:hover:bg-slate-800 transition-colors">
                <div className="w-8 h-8 rounded-full bg-blue-50 dark:bg-blue-900/30 flex items-center justify-center text-xs font-bold text-blue-600 dark:text-blue-400 shrink-0">
                  v{v.versionNum}
                </div>
                <div className="flex-1 min-w-0">
                  <p className="text-xs font-medium text-gray-900 dark:text-slate-100">
                    {v.comment || `버전 ${v.versionNum}`}
                  </p>
                  <p className="text-[10px] text-gray-400 dark:text-slate-500 flex items-center gap-1">
                    <Clock size={9} /> {timeAgo(v.createdAt)} · {v.user.name} · {formatFileSize(String(v.size))}
                  </p>
                </div>
                <button onClick={() => rollback(v)}
                  className="flex items-center gap-1 px-2.5 py-1.5 text-[10px] font-semibold text-orange-600 dark:text-orange-400 bg-orange-50 dark:bg-orange-900/20 hover:bg-orange-100 dark:hover:bg-orange-900/30 rounded-lg transition shrink-0">
                  <RotateCcw size={10} /> 롤백
                </button>
              </div>
            ))}
          </div>
          <p className="text-[10px] text-center text-gray-400 dark:text-slate-500 py-2">최대 10개 버전 보관</p>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/FolderCreateModal.tsx">
"use client";

import { useState } from "react";
import { toast } from "@/components/Toast";

interface FolderCreateModalProps {
  parentId: string | null;
  onClose: () => void;
  onSuccess: () => void;
}

export default function FolderCreateModal({ parentId, onClose, onSuccess }: FolderCreateModalProps) {
  const [name, setName] = useState("");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!name.trim()) { setError("폴더 이름을 입력하세요"); return; }

    setLoading(true);
    setError("");

    try {
      const res = await fetch("/api/folders", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name: name.trim(), parentId }),
      });
      const data = await res.json();
      if (!res.ok) {
        setError(data.error || "폴더 생성 실패");
        return;
      }
      // ✅ alert() → toast
      toast.success("폴더가 생성되었습니다");
      onSuccess();
      onClose();
    } catch {
      setError("폴더 생성 중 오류가 발생했습니다");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4" onClick={onClose}>
      <div className="bg-white rounded-xl shadow-xl max-w-md w-full p-6" onClick={(e) => e.stopPropagation()}>
        <h3 className="text-lg font-semibold text-gray-900 mb-4">새 폴더 만들기</h3>

        <form onSubmit={handleSubmit}>
          {error && (
            <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-md">
              <p className="text-sm text-red-800">{error}</p>
            </div>
          )}
          <input
            type="text"
            value={name}
            onChange={(e) => setName(e.target.value)}
            placeholder="폴더 이름을 입력하세요"
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 mb-4 text-gray-900"
            autoFocus
          />
          <div className="flex justify-end gap-2">
            <button type="button" onClick={onClose} className="px-4 py-2 text-sm text-gray-600 hover:bg-gray-100 rounded-md">
              취소
            </button>
            <button
              type="submit"
              disabled={loading}
              className="px-4 py-2 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:opacity-50"
            >
              {loading ? "생성 중..." : "폴더 만들기"}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}
</file>

<file path="src/components/KeyboardShortcuts.tsx">
"use client";
// src/components/KeyboardShortcuts.tsx
// providers.tsx 또는 dashboard layout에 <KeyboardShortcuts /> 추가하세요

import { useEffect, useState, useCallback } from "react";
import { useRouter } from "next/navigation";
import { Keyboard } from "lucide-react";

interface Shortcut {
  keys: string[];      // ['ctrl', 'k'] 등
  description: string;
  action: () => void;
}

// ── 단축키 훅 ────────────────────────────────────────────
export function useKeyboardShortcuts(shortcuts: Shortcut[]) {
  useEffect(() => {
    const handler = (e: KeyboardEvent) => {
      // input/textarea 포커스 중에는 대부분 무시
      const tag = (e.target as HTMLElement)?.tagName;
      const isEditing = tag === "INPUT" || tag === "TEXTAREA" || (e.target as HTMLElement)?.isContentEditable;

      for (const shortcut of shortcuts) {
        const keys = shortcut.keys.map((k) => k.toLowerCase());
        const ctrl  = keys.includes("ctrl")  ? (e.ctrlKey  || e.metaKey) : !e.ctrlKey && !e.metaKey;
        const shift = keys.includes("shift") ? e.shiftKey  : !e.shiftKey;
        const alt   = keys.includes("alt")   ? e.altKey    : !e.altKey;
        const main  = keys.find((k) => !["ctrl", "shift", "alt", "meta"].includes(k));

        if (ctrl && shift && alt && main && e.key.toLowerCase() === main) {
          // Ctrl+K 같은 전역 단축키는 input 중에도 허용
          const isGlobal = keys.includes("ctrl") && !keys.includes("shift");
          if (isEditing && !isGlobal) continue;
          e.preventDefault();
          shortcut.action();
          break;
        }
      }
    };
    window.addEventListener("keydown", handler);
    return () => window.removeEventListener("keydown", handler);
  }, [shortcuts]);
}

// ── 단축키 팔레트 UI ─────────────────────────────────────
function ShortcutPalette({ onClose }: { onClose: () => void }) {
  const GROUPS = [
    {
      title: "탐색",
      shortcuts: [
        { keys: ["G", "D"], desc: "대시보드" },
        { keys: ["G", "P"], desc: "프로필" },
        { keys: ["G", "N"], desc: "알림" },
        { keys: ["G", "C"], desc: "채팅" },
        { keys: ["G", "S"], desc: "검색" },
        { keys: ["G", "T"], desc: "휴지통" },
      ],
    },
    {
      title: "파일",
      shortcuts: [
        { keys: ["U"], desc: "파일 업로드" },
        { keys: ["N"], desc: "새 폴더" },
        { keys: ["Del"], desc: "선택 삭제" },
      ],
    },
    {
      title: "전역",
      shortcuts: [
        { keys: ["Ctrl", "K"], desc: "단축키 보기" },
        { keys: ["Ctrl", "/"], desc: "검색" },
        { keys: ["?"], desc: "도움말" },
        { keys: ["Esc"], desc: "닫기 / 취소" },
      ],
    },
  ];

  return (
    <div className="fixed inset-0 z-[9999] flex items-center justify-center px-4" onClick={onClose}>
      <div className="absolute inset-0 bg-black/60 backdrop-blur-sm" />
      <div
        className="relative z-10 w-full max-w-lg bg-white dark:bg-slate-800 rounded-2xl shadow-2xl border border-gray-100 dark:border-slate-700 overflow-hidden"
        onClick={(e) => e.stopPropagation()}
      >
        <div className="px-5 py-4 border-b border-gray-100 dark:border-slate-700 flex items-center gap-2">
          <Keyboard size={18} className="text-gray-600 dark:text-slate-400" />
          <h2 className="text-sm font-semibold text-gray-900 dark:text-slate-100">키보드 단축키</h2>
          <button onClick={onClose} className="ml-auto text-gray-400 hover:text-gray-600 dark:hover:text-slate-300 text-lg leading-none">×</button>
        </div>
        <div className="p-5 space-y-5 max-h-[70vh] overflow-y-auto">
          {GROUPS.map((group) => (
            <div key={group.title}>
              <p className="text-xs font-bold text-gray-400 dark:text-slate-500 uppercase tracking-wider mb-2">{group.title}</p>
              <div className="space-y-1">
                {group.shortcuts.map(({ keys, desc }) => (
                  <div key={desc} className="flex items-center justify-between py-1.5">
                    <span className="text-sm text-gray-700 dark:text-slate-300">{desc}</span>
                    <div className="flex items-center gap-1">
                      {keys.map((k, i) => (
                        <span key={i}>
                          <kbd className="px-2 py-1 text-xs font-mono font-semibold bg-gray-100 dark:bg-slate-700 text-gray-700 dark:text-slate-300 rounded border border-gray-200 dark:border-slate-600">
                            {k}
                          </kbd>
                          {i < keys.length - 1 && <span className="text-gray-400 mx-0.5 text-xs">+</span>}
                        </span>
                      ))}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

// ── 전역 단축키 컴포넌트 ─────────────────────────────────
export default function KeyboardShortcuts() {
  const router = useRouter();
  const [showPalette, setShowPalette] = useState(false);

  // 'G + X' 시퀀스 처리
  const gPressedRef = { current: false };

  const shortcuts: Shortcut[] = [
    { keys: ["ctrl", "k"],  description: "단축키 보기",    action: () => setShowPalette((v) => !v) },
    { keys: ["ctrl", "/"],  description: "검색",           action: () => router.push("/search") },
    { keys: ["?"],          description: "단축키 도움말",  action: () => setShowPalette(true) },
  ];

  useKeyboardShortcuts(shortcuts);

  // G + 다음 키 시퀀스
  useEffect(() => {
    let gTimer: NodeJS.Timeout;
    const handler = (e: KeyboardEvent) => {
      const tag = (e.target as HTMLElement)?.tagName;
      if (tag === "INPUT" || tag === "TEXTAREA") return;
      if (e.key === "g" || e.key === "G") {
        gPressedRef.current = true;
        clearTimeout(gTimer);
        gTimer = setTimeout(() => { gPressedRef.current = false; }, 1000);
        return;
      }
      if (gPressedRef.current) {
        const map: Record<string, string> = {
          d: "/dashboard", D: "/dashboard",
          p: "/profile",   P: "/profile",
          n: "/notifications", N: "/notifications",
          c: "/chat",      C: "/chat",
          s: "/search",    S: "/search",
          t: "/trash",     T: "/trash",
        };
        if (map[e.key]) { e.preventDefault(); router.push(map[e.key]); }
        gPressedRef.current = false;
        clearTimeout(gTimer);
      }
    };
    window.addEventListener("keydown", handler);
    return () => { window.removeEventListener("keydown", handler); clearTimeout(gTimer); };
  }, [router]);

  // ESC 닫기
  useEffect(() => {
    const handler = (e: KeyboardEvent) => { if (e.key === "Escape") setShowPalette(false); };
    window.addEventListener("keydown", handler);
    return () => window.removeEventListener("keydown", handler);
  }, []);

  return showPalette ? <ShortcutPalette onClose={() => setShowPalette(false)} /> : null;
}
</file>

<file path="src/components/LikeBookmarkButtons.tsx">
"use client";
// src/components/LikeBookmarkButtons.tsx
// 게시글 상세/목록 페이지에서 사용

import { useState, useEffect } from "react";
import { Heart, Bookmark } from "lucide-react";
import { toast } from "@/components/Toast";

interface Props {
  postId: string;
  initialLiked?: boolean;
  initialLikeCount?: number;
  initialBookmarked?: boolean;
  compact?: boolean;
}

export default function LikeBookmarkButtons({
  postId, initialLiked = false, initialLikeCount = 0, initialBookmarked = false, compact = false,
}: Props) {
  const [liked, setLiked] = useState(initialLiked);
  const [likeCount, setLikeCount] = useState(initialLikeCount);
  const [bookmarked, setBookmarked] = useState(initialBookmarked);
  const [likeLoading, setLikeLoading] = useState(false);
  const [bookmarkLoading, setBookmarkLoading] = useState(false);

  // 마운트 시 최신 상태 조회
  useEffect(() => {
    Promise.all([
      fetch(`/api/posts/${postId}/like`).then((r) => r.json()),
      fetch(`/api/posts/${postId}/bookmark`).then((r) => r.json()),
    ]).then(([likeData, bookmarkData]) => {
      setLiked(likeData.liked);
      setLikeCount(likeData.count);
      setBookmarked(bookmarkData.bookmarked);
    }).catch(() => {});
  }, [postId]);

  const toggleLike = async () => {
    setLikeLoading(true);
    const prev = { liked, likeCount };
    setLiked(!liked);
    setLikeCount((c) => c + (liked ? -1 : 1));
    try {
      const res = await fetch(`/api/posts/${postId}/like`, { method: "POST" });
      const data = await res.json();
      setLiked(data.liked);
      setLikeCount(data.count);
    } catch {
      setLiked(prev.liked);
      setLikeCount(prev.likeCount);
      toast.error("오류가 발생했습니다");
    } finally {
      setLikeLoading(false);
    }
  };

  const toggleBookmark = async () => {
    setBookmarkLoading(true);
    setBookmarked(!bookmarked);
    try {
      const res = await fetch(`/api/posts/${postId}/bookmark`, { method: "POST" });
      const data = await res.json();
      setBookmarked(data.bookmarked);
      toast.success(data.bookmarked ? "북마크에 추가됐습니다" : "북마크에서 제거됐습니다");
    } catch {
      setBookmarked(bookmarked);
      toast.error("오류가 발생했습니다");
    } finally {
      setBookmarkLoading(false);
    }
  };

  if (compact) {
    return (
      <div className="flex items-center gap-3">
        <button
          onClick={toggleLike}
          disabled={likeLoading}
          className={`flex items-center gap-1 text-xs transition-colors ${
            liked ? "text-red-500" : "text-gray-400 dark:text-slate-500 hover:text-red-400"
          }`}
        >
          <Heart size={13} fill={liked ? "currentColor" : "none"} />
          {likeCount}
        </button>
        <button
          onClick={toggleBookmark}
          disabled={bookmarkLoading}
          className={`transition-colors ${
            bookmarked ? "text-yellow-500" : "text-gray-400 dark:text-slate-500 hover:text-yellow-400"
          }`}
        >
          <Bookmark size={13} fill={bookmarked ? "currentColor" : "none"} />
        </button>
      </div>
    );
  }

  return (
    <div className="flex items-center gap-2">
      {/* 좋아요 */}
      <button
        onClick={toggleLike}
        disabled={likeLoading}
        className={`flex items-center gap-2 px-4 py-2 rounded-xl text-sm font-medium transition-all ${
          liked
            ? "bg-red-50 dark:bg-red-900/20 text-red-600 dark:text-red-400 border border-red-200 dark:border-red-800"
            : "bg-gray-100 dark:bg-slate-700 text-gray-600 dark:text-slate-400 hover:bg-red-50 dark:hover:bg-red-900/20 hover:text-red-500 border border-transparent"
        } disabled:opacity-60`}
      >
        <Heart size={16} fill={liked ? "currentColor" : "none"} className="transition-transform active:scale-125" />
        좋아요 {likeCount > 0 && <span className="font-bold">{likeCount}</span>}
      </button>

      {/* 북마크 */}
      <button
        onClick={toggleBookmark}
        disabled={bookmarkLoading}
        className={`flex items-center gap-2 px-4 py-2 rounded-xl text-sm font-medium transition-all ${
          bookmarked
            ? "bg-yellow-50 dark:bg-yellow-900/20 text-yellow-600 dark:text-yellow-400 border border-yellow-200 dark:border-yellow-800"
            : "bg-gray-100 dark:bg-slate-700 text-gray-600 dark:text-slate-400 hover:bg-yellow-50 dark:hover:bg-yellow-900/20 hover:text-yellow-500 border border-transparent"
        } disabled:opacity-60`}
      >
        <Bookmark size={16} fill={bookmarked ? "currentColor" : "none"} />
        {bookmarked ? "저장됨" : "저장"}
      </button>
    </div>
  );
}
</file>

<file path="src/components/LinkPreviewCard.tsx">
"use client";
// src/components/LinkPreviewCard.tsx
// 채팅 메시지 / 게시글 내 URL 자동 감지 후 OG 카드 표시

import { useState, useEffect } from "react";
import { ExternalLink, Globe } from "lucide-react";

interface OGData {
  title:       string | null;
  description: string | null;
  image:       string | null;
  siteName:    string | null;
  url:         string;
  favicon:     string | null;
}

// 텍스트에서 첫 번째 URL 추출
const URL_REGEX = /https?:\/\/[^\s<>"{}|\\^`[\]]+/g;
export function extractFirstUrl(text: string): string | null {
  return text.match(URL_REGEX)?.[0] ?? null;
}

// 텍스트를 URL 링크로 변환 (렌더링용)
export function linkifyText(text: string): React.ReactNode {
  const parts = text.split(URL_REGEX);
  const urls  = text.match(URL_REGEX) ?? [];
  return parts.reduce<React.ReactNode[]>((acc, part, i) => {
    acc.push(part);
    if (urls[i]) {
      acc.push(
        <a key={i} href={urls[i]} target="_blank" rel="noopener noreferrer"
           className="text-blue-600 dark:text-blue-400 hover:underline break-all">
          {urls[i]}
        </a>
      );
    }
    return acc;
  }, []);
}

interface Props {
  url:       string;
  compact?:  boolean;
  className?: string;
}

export default function LinkPreviewCard({ url, compact = false, className = "" }: Props) {
  const [og, setOg]       = useState<OGData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError]    = useState(false);

  useEffect(() => {
    setLoading(true); setError(false);
    fetch(`/api/link-preview?url=${encodeURIComponent(url)}`)
      .then((r) => { if (!r.ok) throw new Error(); return r.json(); })
      .then(setOg)
      .catch(() => setError(true))
      .finally(() => setLoading(false));
  }, [url]);

  if (loading) {
    return (
      <div className={`animate-pulse bg-gray-100 dark:bg-slate-700 rounded-xl h-16 ${className}`} />
    );
  }
  if (error || !og) return null;

  if (compact) {
    return (
      <a href={url} target="_blank" rel="noopener noreferrer"
         className={`flex items-center gap-2 px-3 py-2 bg-gray-50 dark:bg-slate-700/50 hover:bg-gray-100 dark:hover:bg-slate-700 rounded-xl border border-gray-100 dark:border-slate-600 transition-colors group ${className}`}>
        {og.favicon
          ? <img src={og.favicon} alt="" className="w-4 h-4 rounded-sm shrink-0" onError={(e) => ((e.target as HTMLImageElement).style.display = "none")} />
          : <Globe size={14} className="text-gray-400 shrink-0" />
        }
        <span className="text-xs font-medium text-gray-700 dark:text-slate-300 truncate flex-1">{og.title ?? url}</span>
        <ExternalLink size={12} className="text-gray-400 shrink-0 opacity-0 group-hover:opacity-100 transition-opacity" />
      </a>
    );
  }

  return (
    <a href={url} target="_blank" rel="noopener noreferrer"
       className={`block bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 overflow-hidden hover:shadow-md transition-shadow group ${className}`}>
      {og.image && (
        <div className="h-40 overflow-hidden bg-gray-100 dark:bg-slate-700">
          <img
            src={og.image}
            alt={og.title ?? ""}
            className="w-full h-full object-cover group-hover:scale-105 transition-transform duration-300"
            onError={(e) => ((e.target as HTMLImageElement).parentElement!.style.display = "none")}
          />
        </div>
      )}
      <div className="p-3">
        <div className="flex items-center gap-1.5 mb-1">
          {og.favicon
            ? <img src={og.favicon} alt="" className="w-3.5 h-3.5 rounded-sm" onError={(e) => ((e.target as HTMLImageElement).style.display = "none")} />
            : <Globe size={12} className="text-gray-400" />
          }
          <span className="text-[10px] text-gray-400 dark:text-slate-500 uppercase tracking-wide">{og.siteName}</span>
        </div>
        {og.title && (
          <p className="text-sm font-semibold text-gray-900 dark:text-slate-100 line-clamp-2 mb-1">{og.title}</p>
        )}
        {og.description && (
          <p className="text-xs text-gray-500 dark:text-slate-400 line-clamp-2">{og.description}</p>
        )}
      </div>
    </a>
  );
}

// ──────────────────────────────────────────────────────────
// 사용 예시 (채팅 메시지 렌더링)
// ──────────────────────────────────────────────────────────
// import LinkPreviewCard, { extractFirstUrl, linkifyText } from "@/components/LinkPreviewCard";
//
// function ChatMessage({ content }: { content: string }) {
//   const previewUrl = extractFirstUrl(content);
//   return (
//     <div>
//       <p>{linkifyText(content)}</p>
//       {previewUrl && <LinkPreviewCard url={previewUrl} compact className="mt-2" />}
//     </div>
//   );
// }
</file>

<file path="src/components/MentionTextarea.tsx">
"use client";
// src/components/MentionTextarea.tsx
// @유저명 자동완성이 있는 텍스트 입력창
// 댓글 작성, 채팅 메시지 입력에 사용

import { useState, useRef, useEffect, useCallback } from "react";

interface MentionUser {
  id: string;
  name: string;
  isOnline: boolean;
}

interface Props {
  value: string;
  onChange: (value: string, mentionedUserIds: string[]) => void;
  placeholder?: string;
  rows?: number;
  className?: string;
  onSubmit?: () => void;
}

// @이후 텍스트 추출
function getMentionQuery(text: string, cursorPos: number): string | null {
  const before = text.slice(0, cursorPos);
  const match  = before.match(/@(\w*)$/);
  return match ? match[1] : null;
}

// 텍스트에서 @멘션된 사용자 ID 목록 추출
function extractMentionIds(text: string, resolvedMentions: Map<string, string>): string[] {
  const ids: string[] = [];
  const regex = /@(\S+)/g;
  let m: RegExpExecArray | null;
  while ((m = regex.exec(text)) !== null) {
    const id = resolvedMentions.get(m[1]);
    if (id) ids.push(id);
  }
  return [...new Set(ids)];
}

export default function MentionTextarea({
  value, onChange, placeholder = "댓글을 입력하세요...",
  rows = 3, className = "", onSubmit,
}: Props) {
  const [suggestions, setSuggestions]   = useState<MentionUser[]>([]);
  const [showDropdown, setShowDropdown] = useState(false);
  const [selectedIdx, setSelectedIdx]   = useState(0);
  const [mentionStart, setMentionStart] = useState<number | null>(null);
  const textareaRef  = useRef<HTMLTextAreaElement>(null);
  const resolvedRef  = useRef(new Map<string, string>()); // name → userId
  const debounceRef  = useRef<NodeJS.Timeout>();

  const fetchSuggestions = useCallback(async (q: string) => {
    clearTimeout(debounceRef.current);
    if (!q && q !== "") { setSuggestions([]); return; }
    debounceRef.current = setTimeout(async () => {
      const res  = await fetch(`/api/users/mention-search?q=${encodeURIComponent(q)}`);
      const data = await res.json();
      setSuggestions(data.users ?? []);
      setSelectedIdx(0);
    }, 200);
  }, []);

  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const newVal    = e.target.value;
    const cursor    = e.target.selectionStart;
    const query     = getMentionQuery(newVal, cursor);

    if (query !== null) {
      setMentionStart(cursor - query.length - 1); // @ 위치
      setShowDropdown(true);
      fetchSuggestions(query);
    } else {
      setShowDropdown(false);
      setMentionStart(null);
    }

    const ids = extractMentionIds(newVal, resolvedRef.current);
    onChange(newVal, ids);
  };

  const selectUser = (user: MentionUser) => {
    if (mentionStart === null) return;
    const before  = value.slice(0, mentionStart);            // @ 이전
    const cursor  = textareaRef.current?.selectionStart ?? 0;
    const after   = value.slice(cursor);                      // 커서 이후
    const newVal  = `${before}@${user.name} ${after}`;

    resolvedRef.current.set(user.name, user.id);
    const ids = extractMentionIds(newVal, resolvedRef.current);
    onChange(newVal, ids);
    setShowDropdown(false);

    // 커서를 멘션 뒤로 이동
    requestAnimationFrame(() => {
      const pos = before.length + user.name.length + 2; // @name<space>
      textareaRef.current?.setSelectionRange(pos, pos);
      textareaRef.current?.focus();
    });
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (showDropdown && suggestions.length > 0) {
      if (e.key === "ArrowDown") { e.preventDefault(); setSelectedIdx((i) => Math.min(i + 1, suggestions.length - 1)); return; }
      if (e.key === "ArrowUp")   { e.preventDefault(); setSelectedIdx((i) => Math.max(i - 1, 0)); return; }
      if (e.key === "Enter" || e.key === "Tab") { e.preventDefault(); selectUser(suggestions[selectedIdx]); return; }
      if (e.key === "Escape")    { setShowDropdown(false); return; }
    }
    if (e.key === "Enter" && !e.shiftKey && onSubmit) {
      e.preventDefault();
      onSubmit();
    }
  };

  // 텍스트 내 @멘션 하이라이트 렌더링 (미리보기용)
  const renderHighlighted = (text: string) =>
    text.replace(/@(\S+)/g, (m, name) =>
      resolvedRef.current.has(name)
        ? `<mark class="bg-blue-100 dark:bg-blue-900/30 text-blue-600 dark:text-blue-400 rounded px-0.5">${m}</mark>`
        : m
    );

  return (
    <div className="relative">
      <textarea
        ref={textareaRef}
        value={value}
        onChange={handleChange}
        onKeyDown={handleKeyDown}
        onBlur={() => setTimeout(() => setShowDropdown(false), 150)}
        placeholder={placeholder}
        rows={rows}
        className={`w-full resize-none rounded-xl border border-gray-200 dark:border-slate-600 
                    bg-white dark:bg-slate-700 dark:text-slate-100 px-4 py-3 text-sm
                    focus:outline-none focus:ring-2 focus:ring-blue-500 ${className}`}
      />

      {/* 자동완성 드롭다운 */}
      {showDropdown && suggestions.length > 0 && (
        <div className="absolute z-50 bottom-full mb-1 left-0 right-0 max-h-48 overflow-y-auto
                        bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 shadow-xl">
          {suggestions.map((u, i) => (
            <button
              key={u.id}
              onMouseDown={(e) => { e.preventDefault(); selectUser(u); }}
              className={`w-full flex items-center gap-2.5 px-3 py-2.5 text-left transition-colors ${
                i === selectedIdx
                  ? "bg-blue-50 dark:bg-blue-900/30"
                  : "hover:bg-gray-50 dark:hover:bg-slate-700/50"
              }`}
            >
              <div className="relative shrink-0">
                <div className="w-7 h-7 rounded-full bg-gradient-to-br from-blue-400 to-purple-500 flex items-center justify-center text-white text-xs font-bold">
                  {u.name[0]}
                </div>
                {u.isOnline && (
                  <span className="absolute bottom-0 right-0 w-2 h-2 bg-green-500 rounded-full border border-white dark:border-slate-800" />
                )}
              </div>
              <span className="text-sm font-medium text-gray-800 dark:text-slate-200">{u.name}</span>
              <span className="text-xs text-gray-400 dark:text-slate-500 ml-auto">@{u.name}</span>
            </button>
          ))}
          <p className="text-[10px] text-gray-400 dark:text-slate-500 text-center py-1.5 border-t border-gray-100 dark:border-slate-700">
            ↑↓ 선택 · Enter/Tab 확정 · Esc 닫기
          </p>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/MessageBubble.tsx">
"use client";

import { memo } from "react";

interface Message {
  id?: string;
  content?: string;
  type?: string;
  createdAt?: string;
  senderId?: string;
  userId?: string;
  sender?: { id: string; name: string };
  file?: { url: string; originalName?: string; name?: string };
}

interface MessageBubbleProps {
  msg: Message;
  isMe: boolean;
  senderName: string;
  showDateDivider: boolean;
  dateLabel: string;
}

// ✅ React.memo — props가 바뀌지 않으면 리렌더링 완전 차단
// 새 메시지가 와도 기존 메시지 버블은 전혀 재렌더링되지 않음
const MessageBubble = memo(function MessageBubble({
  msg,
  isMe,
  senderName,
  showDateDivider,
  dateLabel,
}: MessageBubbleProps) {
  const timeStr = (() => {
    if (!msg.createdAt) return "";
    const date = new Date(msg.createdAt);
    return isNaN(date.getTime())
      ? ""
      : date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
  })();

  return (
    <>
      {/* 날짜 구분선 */}
      {showDateDivider && (
        <div className="flex items-center gap-2 my-4">
          <div className="flex-1 h-px bg-gray-200" />
          <span className="text-xs text-gray-400 px-2">{dateLabel}</span>
          <div className="flex-1 h-px bg-gray-200" />
        </div>
      )}

      <div className={`flex ${isMe ? "justify-end" : "justify-start"}`}>
        <div className={`flex flex-col ${isMe ? "items-end" : "items-start"}`}>
          {!isMe && (
            <span className="text-[10px] text-gray-400 mb-1 ml-1">{senderName}</span>
          )}
          <div
            className={`p-3 px-4 rounded-2xl max-w-[80vw] sm:max-w-[60%] text-[14px] shadow-sm ${
              isMe
                ? "bg-blue-600 text-white rounded-tr-none"
                : "bg-white border border-gray-200 text-black rounded-tl-none"
            }`}
          >
            {msg.type === "FILE" && msg.file ? (
              <a
                href={msg.file.url}
                target="_blank"
                rel="noopener noreferrer"
                className="underline"
              >
                📎 {msg.file.originalName || msg.file.name}
              </a>
            ) : (
              <p className="whitespace-pre-wrap break-words">{msg.content}</p>
            )}
            <div
              className={`text-[9px] mt-1 opacity-60 ${isMe ? "text-right" : "text-left"}`}
            >
              {timeStr}
            </div>
          </div>
        </div>
      </div>
    </>
  );
});

export default MessageBubble;
</file>

<file path="src/components/MobileBottomNav.tsx">
"use client";
// src/components/MobileBottomNav.tsx
// 모바일에서만 보이는 하단 탭 네비게이션
// layout.tsx 또는 dashboard layout에 추가

import Link from "next/link";
import { usePathname } from "next/navigation";
import { useEffect, useState } from "react";
import {
  LayoutDashboard, MessageCircle, Bell, Search, User,
} from "lucide-react";

const TABS = [
  { href: "/dashboard",   icon: LayoutDashboard, label: "홈",    tour: "dashboard" },
  { href: "/search",      icon: Search,          label: "검색",  tour: "search" },
  { href: "/chat",        icon: MessageCircle,   label: "채팅",  tour: "chat" },
  { href: "/notifications", icon: Bell,          label: "알림",  tour: "notifications" },
  { href: "/profile",     icon: User,            label: "프로필", tour: "profile" },
];

export default function MobileBottomNav() {
  const pathname = usePathname();
  const [unread, setUnread] = useState(0);

  // 알림 뱃지
  useEffect(() => {
    fetch("/api/notifications?limit=1")
      .then((r) => r.json())
      .then((d) => setUnread(d.unreadCount ?? 0))
      .catch(() => {});
  }, [pathname]);

  // 로그인/공개 페이지에서는 숨김
  const hiddenPaths = ["/", "/login", "/register", "/share"];
  if (hiddenPaths.some((p) => pathname === p || pathname.startsWith("/share/"))) return null;

  return (
    <>
      {/* 하단 여백 (콘텐츠가 탭에 가리지 않도록) */}
      <div className="h-20 md:hidden" aria-hidden />

      <nav className="fixed bottom-0 left-0 right-0 z-50 md:hidden
                      bg-white/95 dark:bg-slate-900/95 backdrop-blur-xl
                      border-t border-gray-200 dark:border-slate-700
                      safe-area-padding-bottom">
        <div className="flex items-center justify-around px-2 py-2 pb-safe">
          {TABS.map(({ href, icon: Icon, label, tour }) => {
            const isActive = pathname === href || pathname.startsWith(href + "/");
            const isBell   = href === "/notifications";
            return (
              <Link
                key={href}
                href={href}
                data-tour={tour}
                className={`relative flex flex-col items-center gap-1 px-3 py-2 rounded-xl transition-all min-w-0 flex-1 ${
                  isActive
                    ? "text-blue-600 dark:text-blue-400"
                    : "text-gray-500 dark:text-slate-400 hover:text-gray-700 dark:hover:text-slate-300"
                }`}
              >
                {/* 활성 인디케이터 */}
                {isActive && (
                  <div className="absolute top-0 left-1/2 -translate-x-1/2 w-8 h-0.5 bg-blue-600 dark:bg-blue-400 rounded-full" />
                )}
                {/* 아이콘 */}
                <div className="relative">
                  <Icon
                    size={22}
                    strokeWidth={isActive ? 2.5 : 1.8}
                    className="transition-all"
                    fill={isActive ? "currentColor" : "none"}
                    style={{ fillOpacity: isActive ? 0.12 : 0 }}
                  />
                  {/* 알림 뱃지 */}
                  {isBell && unread > 0 && (
                    <span className="absolute -top-1 -right-1 min-w-[16px] h-4 bg-red-500 text-white text-[9px] font-bold rounded-full flex items-center justify-center px-1 leading-none">
                      {unread > 99 ? "99+" : unread}
                    </span>
                  )}
                </div>
                {/* 레이블 */}
                <span className={`text-[10px] font-semibold leading-none truncate ${
                  isActive ? "text-blue-600 dark:text-blue-400" : "text-gray-500 dark:text-slate-400"
                }`}>
                  {label}
                </span>
              </Link>
            );
          })}
        </div>
      </nav>
    </>
  );
}
</file>

<file path="src/components/Notificationsettings.tsx">
"use client";

import { useState, useEffect } from "react";
import { registerFCMToken, unregisterFCMToken } from "@/lib/firebase";
import { toast } from "@/components/Toast";

export default function NotificationSettings() {
  const [notificationsEnabled, setNotificationsEnabled] = useState(false);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if ("Notification" in window) {
      setNotificationsEnabled(Notification.permission === "granted");
    }
  }, []);

  const handleToggle = async () => {
    setLoading(true);
    if (notificationsEnabled) {
      await unregisterFCMToken();
      setNotificationsEnabled(false);
    } else {
      const success = await registerFCMToken();
      setNotificationsEnabled(success);
      if (!success) {
        // ✅ alert() → toast
        toast.error("알림 권한을 허용해주세요. 브라우저 설정에서 알림을 허용할 수 있습니다.");
      }
    }
    setLoading(false);
  };

  return (
    <div className="bg-white shadow rounded-lg p-6">
      <h3 className="text-lg font-semibold mb-4">📬 알림 설정</h3>

      <div className="flex items-center justify-between">
        <div>
          <p className="font-medium">푸시 알림</p>
          <p className="text-sm text-gray-500">새 메시지와 통화 요청을 알림으로 받습니다</p>
        </div>
        <button
          onClick={handleToggle}
          disabled={loading}
          className={`relative inline-flex h-8 w-14 items-center rounded-full transition ${
            notificationsEnabled ? "bg-blue-600" : "bg-gray-300"
          } ${loading ? "opacity-50 cursor-not-allowed" : "cursor-pointer"}`}
        >
          <span
            className={`inline-block h-6 w-6 transform rounded-full bg-white transition ${
              notificationsEnabled ? "translate-x-7" : "translate-x-1"
            }`}
          />
        </button>
      </div>

      {notificationsEnabled && (
        <div className="mt-4 p-3 bg-green-50 border border-green-200 rounded-md">
          <p className="text-sm text-green-800">
            ✅ 알림이 활성화되었습니다. 앱을 닫아도 새 메시지 알림을 받을 수 있습니다.
          </p>
        </div>
      )}

      {"Notification" in window && !notificationsEnabled && (
        <div className="mt-4 p-3 bg-yellow-50 border border-yellow-200 rounded-md">
          <p className="text-sm text-yellow-800">
            ⚠️ 알림이 비활성화되어 있습니다. 앱을 닫으면 메시지 알림을 받을 수 없습니다.
          </p>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/OnboardingTour.tsx">
"use client";
// src/components/OnboardingTour.tsx
// 첫 로그인 시 자동 표시되는 단계별 가이드
// providers.tsx 또는 dashboard layout에 추가

import { useState, useEffect, useRef } from "react";
import { useSession } from "next-auth/react";
import { X, ChevronRight, ChevronLeft, Check } from "lucide-react";

const STEPS = [
  {
    title: "🎉 이음에 오신 것을 환영합니다!",
    desc: "이음은 파일 관리, 실시간 채팅, 협업을 하나의 공간에서 제공하는 퍼스널 클라우드입니다.",
    target: null,
    position: "center" as const,
  },
  {
    title: "📁 파일 업로드",
    desc: "대시보드에서 파일을 드래그 앤 드롭하거나 클릭하여 업로드하세요. 이미지, 영상, 문서 등 모든 형식을 지원합니다.",
    target: "[data-tour='upload']",
    position: "bottom" as const,
  },
  {
    title: "💬 실시간 채팅",
    desc: "다른 사용자와 채팅하고 파일을 공유하세요. 음성·영상 통화도 지원합니다.",
    target: "[data-tour='chat']",
    position: "right" as const,
  },
  {
    title: "🔔 알림 설정",
    desc: "댓글, 공유, 메시지 등 알림을 종류별로 설정할 수 있습니다.",
    target: "[data-tour='notifications']",
    position: "bottom" as const,
  },
  {
    title: "🔒 보안",
    desc: "2단계 인증(2FA)을 설정하고, 개별 파일에 비밀번호를 걸어 더 안전하게 보호하세요.",
    target: "[data-tour='profile']",
    position: "left" as const,
  },
  {
    title: "✅ 준비 완료!",
    desc: "이음 사용을 시작할 준비가 되었습니다. 언제든지 프로필 → 도움말에서 이 가이드를 다시 볼 수 있습니다.",
    target: null,
    position: "center" as const,
  },
];

function getTargetRect(selector: string | null): DOMRect | null {
  if (!selector) return null;
  return document.querySelector(selector)?.getBoundingClientRect() ?? null;
}

export default function OnboardingTour() {
  const { data: session } = useSession();
  const [step, setStep]   = useState(0);
  const [visible, setVisible] = useState(false);
  const [rect, setRect]   = useState<DOMRect | null>(null);
  const [done, setDone]   = useState(false);

  useEffect(() => {
    if (!session?.user) return;
    const key = `onboarding_done_${session.user.id}`;
    if (localStorage.getItem(key)) { setDone(true); return; }
    // 첫 로그인이면 0.8초 후 투어 시작
    const t = setTimeout(() => setVisible(true), 800);
    return () => clearTimeout(t);
  }, [session]);

  useEffect(() => {
    if (!visible) return;
    const current = STEPS[step];
    setRect(getTargetRect(current.target));
  }, [step, visible]);

  const finish = () => {
    if (session?.user) {
      localStorage.setItem(`onboarding_done_${session.user.id}`, "1");
      // API로도 기록
      fetch("/api/users/me/onboarding", { method: "POST" }).catch(() => {});
    }
    setVisible(false);
    setDone(true);
  };

  if (!visible || done) return null;

  const current = STEPS[step];
  const isFirst = step === 0;
  const isLast  = step === STEPS.length - 1;

  // 타깃 요소가 있으면 스포트라이트, 없으면 중앙 모달
  const isCentered = current.position === "center" || !rect;

  return (
    <div className="fixed inset-0 z-[9998]">
      {/* 배경 오버레이 */}
      <div className="absolute inset-0 bg-black/60 backdrop-blur-[2px]" onClick={() => {}} />

      {/* 스포트라이트 컷아웃 */}
      {rect && (
        <div
          className="absolute rounded-xl ring-4 ring-blue-400 ring-offset-2 bg-transparent z-[9999] pointer-events-none transition-all duration-300"
          style={{
            top:    rect.top    - 8,
            left:   rect.left   - 8,
            width:  rect.width  + 16,
            height: rect.height + 16,
          }}
        />
      )}

      {/* 툴팁/모달 */}
      <div
        className={`absolute z-[9999] w-80 bg-white dark:bg-slate-800 rounded-2xl shadow-2xl border border-gray-100 dark:border-slate-700 p-5 transition-all duration-300 ${
          isCentered
            ? "top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2"
            : ""
        }`}
        style={
          !isCentered && rect
            ? current.position === "bottom"
              ? { top: rect.bottom + 16, left: Math.min(rect.left, window.innerWidth - 340) }
              : current.position === "right"
              ? { top: rect.top, left: rect.right + 16 }
              : { top: rect.top, right: window.innerWidth - rect.left + 16 }
            : {}
        }
      >
        {/* 닫기 */}
        <button onClick={finish} className="absolute top-3 right-3 text-gray-400 hover:text-gray-600 dark:hover:text-slate-300 transition-colors">
          <X size={16} />
        </button>

        {/* 진행 도트 */}
        <div className="flex gap-1.5 mb-4">
          {STEPS.map((_, i) => (
            <div key={i} className={`h-1.5 rounded-full transition-all duration-300 ${
              i === step ? "w-6 bg-blue-600" : i < step ? "w-1.5 bg-blue-300" : "w-1.5 bg-gray-200 dark:bg-slate-700"
            }`} />
          ))}
        </div>

        <h3 className="text-base font-bold text-gray-900 dark:text-slate-100 mb-2 pr-5">{current.title}</h3>
        <p className="text-sm text-gray-500 dark:text-slate-400 leading-relaxed mb-5">{current.desc}</p>

        {/* 버튼 */}
        <div className="flex items-center gap-2">
          {!isFirst && (
            <button onClick={() => setStep((s) => s - 1)}
              className="flex items-center gap-1 px-3 py-2 text-xs font-medium text-gray-500 dark:text-slate-400 hover:bg-gray-100 dark:hover:bg-slate-700 rounded-xl transition">
              <ChevronLeft size={14} /> 이전
            </button>
          )}
          <div className="flex-1" />
          <button
            onClick={() => isLast ? finish() : setStep((s) => s + 1)}
            className="flex items-center gap-1.5 px-4 py-2 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-xl transition"
          >
            {isLast ? <><Check size={14} /> 시작하기</> : <>다음 <ChevronRight size={14} /></>}
          </button>
        </div>

        <button onClick={finish} className="mt-3 w-full text-[10px] text-gray-400 hover:text-gray-600 dark:hover:text-slate-400 text-center">
          건너뛰기
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/PostShareModal.tsx">
"use client";

import { useState, useEffect } from "react";
import { toast } from "@/components/Toast";

interface Share {
  id: string;
  sharedWith: { id: string; email: string; name: string };
  permission: string;
  createdAt: string;
}

interface PostShareModalProps {
  postId: string | null;
  postTitle: string;
  onClose: () => void;
}

export default function PostShareModal({ postId, postTitle, onClose }: PostShareModalProps) {
  const [email, setEmail] = useState("");
  const [permission, setPermission] = useState("VIEW");
  const [shares, setShares] = useState<Share[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  // ✅ confirm() 대체: 삭제 대기 중인 shareId
  const [pendingDeleteId, setPendingDeleteId] = useState<string | null>(null);

  useEffect(() => {
    if (postId) fetchShares();
  }, [postId]);

  const fetchShares = async () => {
    if (!postId) return;
    try {
      const res = await fetch(`/api/posts/${postId}/share`);
      if (res.ok) setShares((await res.json()).shares);
    } catch {}
  };

  const handleShare = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!postId || !email) return;
    setLoading(true);
    setError("");
    try {
      const res = await fetch(`/api/posts/${postId}/share`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ sharedWithEmail: email, permission }),
      });
      const data = await res.json();
      if (!res.ok) {
        setError(data.error || "공유 실패");
        return;
      }
      // ✅ alert() → toast
      toast.success("게시글이 공유되었습니다");
      setEmail("");
      fetchShares();
    } catch {
      setError("공유 중 오류가 발생했습니다");
    } finally {
      setLoading(false);
    }
  };

  const handleDeleteShare = async (shareId: string) => {
    if (!postId) return;
    try {
      const res = await fetch(`/api/posts/${postId}/share?shareId=${shareId}`, {
        method: "DELETE",
      });
      if (res.ok) {
        toast.success("공유가 취소되었습니다");
        fetchShares();
      } else {
        toast.error("공유 취소에 실패했습니다");
      }
    } catch {
      toast.error("오류가 발생했습니다");
    } finally {
      setPendingDeleteId(null);
    }
  };

  if (!postId) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4" onClick={onClose}>
      <div className="bg-white rounded-xl shadow-xl max-w-2xl w-full max-h-[80vh] overflow-hidden" onClick={(e) => e.stopPropagation()}>
        <div className="flex items-center justify-between p-6 border-b">
          <h3 className="text-lg font-semibold text-gray-900">게시글 공유: {postTitle}</h3>
          <button onClick={onClose} className="text-gray-400 hover:text-gray-600 text-2xl">×</button>
        </div>

        <div className="p-6 overflow-y-auto max-h-[60vh]">
          <div className="mb-6 p-4 bg-blue-50 border border-blue-200 rounded-md">
            <p className="text-sm text-blue-800">
              💡 이메일을 입력하여 특정 사용자에게만 게시글을 공유할 수 있습니다.
              <br />공유받은 사용자는 자신의 게시판에서 이 글을 볼 수 있습니다.
            </p>
          </div>

          <form onSubmit={handleShare} className="mb-6">
            <label className="block text-sm font-medium text-gray-700 mb-2">공유할 사용자 이메일</label>
            {error && (
              <div className="mb-3 p-3 bg-red-50 border border-red-200 rounded-md">
                <p className="text-sm text-red-800">{error}</p>
              </div>
            )}
            <div className="flex gap-2">
              <input
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                placeholder="user@example.com"
                className="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-900"
                required
              />
              <select
                value={permission}
                onChange={(e) => setPermission(e.target.value)}
                className="px-3 py-2 border border-gray-300 rounded-md text-gray-900"
              >
                <option value="VIEW">보기</option>
                <option value="EDIT">편집</option>
              </select>
              <button
                type="submit"
                disabled={loading}
                className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:opacity-50"
              >
                {loading ? "공유 중..." : "공유"}
              </button>
            </div>
          </form>

          {shares.length > 0 && (
            <div>
              <h4 className="text-sm font-medium text-gray-700 mb-3">공유된 사용자</h4>
              <div className="space-y-2">
                {shares.map((share) => (
                  <div key={share.id} className="flex items-center justify-between p-3 bg-gray-50 rounded-md">
                    <div>
                      <p className="text-sm font-medium text-gray-900">{share.sharedWith.name}</p>
                      <p className="text-xs text-gray-500">{share.sharedWith.email}</p>
                    </div>
                    <div className="flex items-center gap-2">
                      <span className="px-2 py-1 text-xs bg-blue-100 text-blue-700 rounded">
                        {share.permission === "VIEW" ? "보기" : "편집"}
                      </span>
                      {/* ✅ confirm() → 인라인 확인 UI */}
                      {pendingDeleteId === share.id ? (
                        <div className="flex items-center gap-1">
                          <span className="text-xs text-gray-500">취소할까요?</span>
                          <button
                            onClick={() => handleDeleteShare(share.id)}
                            className="text-xs px-2 py-1 bg-red-500 text-white rounded"
                          >
                            확인
                          </button>
                          <button
                            onClick={() => setPendingDeleteId(null)}
                            className="text-xs px-2 py-1 bg-gray-200 rounded"
                          >
                            아니오
                          </button>
                        </div>
                      ) : (
                        <button
                          onClick={() => setPendingDeleteId(share.id)}
                          className="text-red-500 hover:text-red-700 text-sm"
                        >
                          취소
                        </button>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>

        <div className="flex justify-end p-6 border-t">
          <button
            onClick={onClose}
            className="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50"
          >
            닫기
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/ProfileImageUpload.tsx">
"use client";
// src/components/ProfileImageUpload.tsx
// 아바타 + 커버 이미지 업로드 컴포넌트

import { useState, useRef } from "react";
import { Camera, Upload, X } from "lucide-react";
import { toast } from "@/components/Toast";

type ImageType = "avatar" | "cover";

interface Props {
  currentAvatarUrl?: string | null;
  currentCoverUrl?:  string | null;
  userId: string;
  onUpdate?: (type: ImageType, url: string) => void;
  isOwnProfile?: boolean;
}

function ImageUploadButton({
  type, currentUrl, userId, onUpdate,
}: { type: ImageType; currentUrl?: string | null; userId: string; onUpdate?: (url: string) => void }) {
  const [preview, setPreview] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);
  const inputRef = useRef<HTMLInputElement>(null);

  const handleFile = async (file: File) => {
    if (!file.type.startsWith("image/")) { toast.error("이미지만 업로드 가능합니다"); return; }
    if (file.size > 5 * 1024 * 1024)    { toast.error("5MB 이하 이미지만 가능합니다"); return; }

    // 미리보기
    const reader = new FileReader();
    reader.onload = (e) => setPreview(e.target?.result as string);
    reader.readAsDataURL(file);

    setLoading(true);
    try {
      const fd = new FormData();
      fd.append("file", file);
      fd.append("type", type);

      const res  = await fetch("/api/users/me/avatar", { method: "POST", body: fd });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error);

      onUpdate?.(data.publicUrl);
      toast.success(type === "avatar" ? "프로필 사진이 변경됐습니다" : "커버 이미지가 변경됐습니다");
    } catch (e: any) {
      toast.error(e.message ?? "업로드에 실패했습니다");
      setPreview(null);
    } finally {
      setLoading(false);
    }
  };

  return (
    <>
      <input ref={inputRef} type="file" accept="image/*" className="hidden"
        onChange={(e) => { const f = e.target.files?.[0]; if (f) handleFile(f); }} />
      <button
        onClick={() => inputRef.current?.click()}
        disabled={loading}
        className={`group relative overflow-hidden ${
          type === "avatar"
            ? "w-24 h-24 rounded-full ring-4 ring-white dark:ring-slate-800"
            : "w-full h-36 rounded-2xl"
        } bg-gray-200 dark:bg-slate-700 transition-all hover:brightness-90`}
      >
        {/* 이미지 표시 */}
        {(preview ?? currentUrl) ? (
          <img
            src={preview ?? currentUrl!}
            alt={type}
            className="w-full h-full object-cover"
          />
        ) : (
          <div className="w-full h-full flex items-center justify-center">
            {type === "avatar"
              ? <span className="text-4xl text-gray-400">👤</span>
              : <span className="text-gray-400 dark:text-slate-500 text-sm">커버 이미지 없음</span>}
          </div>
        )}

        {/* 호버 오버레이 */}
        <div className="absolute inset-0 bg-black/40 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center gap-2 flex-col">
          <Camera size={type === "avatar" ? 20 : 24} className="text-white" />
          <span className="text-white text-xs font-medium">
            {loading ? "업로드 중..." : "변경"}
          </span>
        </div>

        {/* 로딩 스피너 */}
        {loading && (
          <div className="absolute inset-0 flex items-center justify-center bg-black/50">
            <div className="w-6 h-6 border-3 border-white/30 border-t-white rounded-full animate-spin" />
          </div>
        )}
      </button>
    </>
  );
}

export default function ProfileImageUpload({
  currentAvatarUrl, currentCoverUrl, userId, onUpdate, isOwnProfile = false,
}: Props) {
  const [avatarUrl, setAvatarUrl] = useState(currentAvatarUrl ?? null);
  const [coverUrl,  setCoverUrl]  = useState(currentCoverUrl  ?? null);

  if (!isOwnProfile) {
    // 읽기 전용 표시
    return (
      <div>
        <div className="relative">
          <div className="h-32 rounded-2xl overflow-hidden bg-gradient-to-br from-blue-500 to-purple-600">
            {coverUrl && <img src={coverUrl} alt="cover" className="w-full h-full object-cover" />}
          </div>
          <div className="absolute -bottom-10 left-6">
            <div className="w-20 h-20 rounded-full ring-4 ring-white dark:ring-slate-800 bg-gradient-to-br from-blue-400 to-purple-500 overflow-hidden flex items-center justify-center text-white text-2xl font-bold">
              {avatarUrl ? <img src={avatarUrl} alt="avatar" className="w-full h-full object-cover" /> : "👤"}
            </div>
          </div>
        </div>
        <div className="h-10" />
      </div>
    );
  }

  return (
    <div>
      {/* 커버 이미지 */}
      <ImageUploadButton
        type="cover"
        currentUrl={coverUrl}
        userId={userId}
        onUpdate={(url) => { setCoverUrl(url); onUpdate?.("cover", url); }}
      />

      {/* 아바타 (커버 위에 겹쳐서 표시) */}
      <div className="relative -mt-12 ml-6 inline-block">
        <ImageUploadButton
          type="avatar"
          currentUrl={avatarUrl}
          userId={userId}
          onUpdate={(url) => { setAvatarUrl(url); onUpdate?.("avatar", url); }}
        />
      </div>
      <p className="text-[10px] text-gray-400 dark:text-slate-500 mt-2 ml-2">
        클릭하여 프로필 사진 또는 커버 이미지 변경 · 최대 5MB
      </p>
    </div>
  );
}
</file>

<file path="src/components/PWAInstaller.tsx">
"use client";
// src/components/PWAInstaller.tsx
// layout.tsx에 추가하면 SW 등록 + 설치 배너 표시

import { useEffect, useState } from "react";

interface BeforeInstallPromptEvent extends Event {
  prompt: () => Promise<void>;
  userChoice: Promise<{ outcome: "accepted" | "dismissed" }>;
}

export default function PWAInstaller() {
  const [installPrompt, setInstallPrompt] = useState<BeforeInstallPromptEvent | null>(null);
  const [showBanner, setShowBanner] = useState(false);
  const [dismissed, setDismissed] = useState(false);

  useEffect(() => {
    // 서비스 워커 등록
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker
        .register("/sw.js")
        .then((reg) => console.log("SW registered:", reg.scope))
        .catch((err) => console.warn("SW registration failed:", err));
    }

    // 설치 프롬프트 이벤트 캐치
    const handler = (e: Event) => {
      e.preventDefault();
      setInstallPrompt(e as BeforeInstallPromptEvent);
      // 이미 설치됐거나 배너 닫은 경우 무시
      const wasDismissed = localStorage.getItem("pwa-dismissed");
      if (!wasDismissed) setShowBanner(true);
    };

    window.addEventListener("beforeinstallprompt", handler);
    return () => window.removeEventListener("beforeinstallprompt", handler);
  }, []);

  const install = async () => {
    if (!installPrompt) return;
    await installPrompt.prompt();
    const { outcome } = await installPrompt.userChoice;
    if (outcome === "accepted") {
      setShowBanner(false);
    }
    setInstallPrompt(null);
  };

  const dismiss = () => {
    setShowBanner(false);
    localStorage.setItem("pwa-dismissed", "true");
  };

  if (!showBanner || dismissed) return null;

  return (
    <div className="fixed bottom-20 md:bottom-6 left-4 right-4 md:left-auto md:right-6 md:w-80 z-50
                    bg-white dark:bg-slate-800 rounded-2xl shadow-2xl border border-gray-100 dark:border-slate-700
                    p-4 flex items-start gap-3 animate-slide-up">
      <div className="w-10 h-10 rounded-xl bg-gradient-to-br from-purple-500 to-blue-600 flex items-center justify-center text-white text-lg shrink-0">
        ☁️
      </div>
      <div className="flex-1 min-w-0">
        <p className="text-sm font-semibold text-gray-900 dark:text-slate-100">앱으로 설치하기</p>
        <p className="text-xs text-gray-500 dark:text-slate-400 mt-0.5">홈 화면에 추가하면 더 빠르게 이용할 수 있습니다</p>
        <div className="flex gap-2 mt-2.5">
          <button
            onClick={install}
            className="px-3 py-1.5 bg-blue-600 text-white text-xs font-semibold rounded-lg hover:bg-blue-700 transition-colors"
          >
            설치
          </button>
          <button
            onClick={dismiss}
            className="px-3 py-1.5 text-gray-500 dark:text-slate-400 text-xs hover:text-gray-700 dark:hover:text-slate-200"
          >
            나중에
          </button>
        </div>
      </div>
      <button onClick={dismiss} className="text-gray-400 hover:text-gray-600 dark:hover:text-slate-300 text-lg leading-none shrink-0">×</button>
    </div>
  );
}
</file>

<file path="src/components/SoundToggle.tsx">
"use client";
// src/components/SoundToggle.tsx
// 알림 설정 페이지 또는 헤더에 추가

import { useState, useEffect } from "react";
import { Volume2, VolumeX } from "lucide-react";
import { isSoundEnabled, setSoundEnabled, sound } from "@/lib/sound";

export default function SoundToggle({ compact = false }: { compact?: boolean }) {
  const [enabled, setEnabled] = useState(true);

  useEffect(() => { setEnabled(isSoundEnabled()); }, []);

  const toggle = () => {
    const next = !enabled;
    setSoundEnabled(next);
    setEnabled(next);
    if (next) sound.success(); // 켤 때 미리보기
  };

  if (compact) {
    return (
      <button onClick={toggle} title={enabled ? "알림 소리 끄기" : "알림 소리 켜기"}
        className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
        {enabled
          ? <Volume2 size={18} className="text-blue-600 dark:text-blue-400" />
          : <VolumeX size={18} className="text-gray-400 dark:text-slate-500" />
        }
      </button>
    );
  }

  return (
    <div className="flex items-center justify-between py-3 px-4 bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700">
      <div className="flex items-center gap-3">
        {enabled
          ? <Volume2 size={18} className="text-blue-600 dark:text-blue-400" />
          : <VolumeX size={18} className="text-gray-400 dark:text-slate-500" />
        }
        <div>
          <p className="text-sm font-semibold text-gray-900 dark:text-slate-100">알림 사운드</p>
          <p className="text-xs text-gray-400 dark:text-slate-500">메시지·알림·오류 소리</p>
        </div>
      </div>
      <button
        onClick={toggle}
        className={`w-11 h-6 rounded-full transition-colors ${enabled ? "bg-blue-600" : "bg-gray-200 dark:bg-slate-600"}`}
      >
        <span className={`block w-4.5 h-4.5 bg-white rounded-full shadow transition-transform mx-0.5 ${enabled ? "translate-x-5" : "translate-x-0"}`} />
      </button>
    </div>
  );
}
</file>

<file path="src/components/StorageQuotaBar.tsx">
"use client";
// src/components/StorageQuotaBar.tsx
// 대시보드 사이드바 또는 헤더에 삽입

import { useState, useEffect } from "react";
import { HardDrive, AlertTriangle } from "lucide-react";

function formatBytes(bytes: string | bigint): string {
  const n = typeof bytes === "string" ? parseInt(bytes) : Number(bytes);
  if (n >= 1024 ** 3) return `${(n / 1024 ** 3).toFixed(1)}GB`;
  if (n >= 1024 ** 2) return `${(n / 1024 ** 2).toFixed(1)}MB`;
  if (n >= 1024)      return `${(n / 1024).toFixed(0)}KB`;
  return `${n}B`;
}

export default function StorageQuotaBar() {
  const [data, setData] = useState<{
    storageUsed: string; storageLimit: string; percentage: number;
  } | null>(null);

  useEffect(() => {
    fetch("/api/users/me/storage")
      .then((r) => r.json())
      .then(setData)
      .catch(() => {});
  }, []);

  if (!data) return null;

  const isWarning  = data.percentage >= 80;
  const isCritical = data.percentage >= 95;

  return (
    <div className="px-3 py-2.5 rounded-xl bg-gray-50 dark:bg-slate-800 border border-gray-100 dark:border-slate-700">
      <div className="flex items-center gap-2 mb-1.5">
        {isCritical
          ? <AlertTriangle size={13} className="text-red-500 shrink-0" />
          : <HardDrive size={13} className={`shrink-0 ${isWarning ? "text-amber-500" : "text-gray-500 dark:text-slate-400"}`} />
        }
        <span className="text-[11px] font-semibold text-gray-700 dark:text-slate-300 flex-1">저장 공간</span>
        <span className={`text-[10px] font-bold ${
          isCritical ? "text-red-500" : isWarning ? "text-amber-500" : "text-gray-500 dark:text-slate-400"
        }`}>
          {data.percentage}%
        </span>
      </div>

      {/* 바 */}
      <div className="h-1.5 bg-gray-200 dark:bg-slate-700 rounded-full overflow-hidden">
        <div
          className={`h-full rounded-full transition-all ${
            isCritical ? "bg-red-500" : isWarning ? "bg-amber-500" : "bg-blue-500"
          }`}
          style={{ width: `${Math.min(data.percentage, 100)}%` }}
        />
      </div>

      <p className="text-[10px] text-gray-400 dark:text-slate-500 mt-1">
        {formatBytes(data.storageUsed)} / {formatBytes(data.storageLimit)}
      </p>

      {isCritical && (
        <p className="text-[9px] text-red-500 font-semibold mt-1">
          ⚠️ 저장 공간이 거의 가득 찼습니다. 파일을 정리하세요.
        </p>
      )}
    </div>
  );
}
</file>

<file path="src/components/SystemNoticeBanner.tsx">
"use client";
// src/components/SystemNoticeBanner.tsx
// providers.tsx에 포함 — 활성 시스템 공지를 상단에 표시

import { useState, useEffect } from "react";
import { X, AlertTriangle, Info, Wrench } from "lucide-react";

interface Notice {
  id: string; title: string; content: string; type: string;
}

const STYLES = {
  INFO:        "bg-blue-600 text-white",
  WARNING:     "bg-amber-500 text-white",
  MAINTENANCE: "bg-purple-700 text-white",
};
const ICONS = {
  INFO:        <Info size={14} className="shrink-0" />,
  WARNING:     <AlertTriangle size={14} className="shrink-0" />,
  MAINTENANCE: <Wrench size={14} className="shrink-0" />,
};

export default function SystemNoticeBanner() {
  const [notices, setNotices] = useState<Notice[]>([]);
  const [dismissed, setDismissed] = useState<Set<string>>(new Set());

  useEffect(() => {
    fetch("/api/admin/notices")
      .then((r) => r.json())
      .then((d) => setNotices(d.notices ?? []))
      .catch(() => {});
  }, []);

  const visible = notices.filter((n) => !dismissed.has(n.id));
  if (visible.length === 0) return null;

  const top = visible[0];
  const style = STYLES[top.type as keyof typeof STYLES] ?? STYLES.INFO;
  const icon  = ICONS[top.type  as keyof typeof ICONS]  ?? ICONS.INFO;

  return (
    <div className={`${style} px-4 py-2 flex items-center gap-2 text-sm font-medium z-[9990]`}>
      {icon}
      <span className="flex-1 text-center text-xs">{top.title}: {top.content}</span>
      <button onClick={() => setDismissed((s) => new Set([...s, top.id]))} className="opacity-70 hover:opacity-100 transition-opacity">
        <X size={14} />
      </button>
    </div>
  );
}
</file>

<file path="src/components/TagInput.tsx">
"use client";

import { useState, useEffect } from "react";
import { toast } from "@/components/Toast";

interface Tag { id: string; name: string; color?: string; }

interface TagInputProps {
  resourceId: string;
  resourceType: "file" | "post";
  onTagsChange?: () => void;
}

export default function TagInput({ resourceId, resourceType, onTagsChange }: TagInputProps) {
  const [tags, setTags] = useState<Tag[]>([]);
  const [allTags, setAllTags] = useState<Tag[]>([]);
  const [inputValue, setInputValue] = useState("");
  const [suggestions, setSuggestions] = useState<Tag[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    fetchTags();
    fetchAllTags();
  }, [resourceId]);

  const fetchTags = async () => {
    try {
      const res = await fetch(`/api/${resourceType}s/${resourceId}/tags`);
      if (res.ok) setTags((await res.json()).tags || []);
    } catch {}
  };

  const fetchAllTags = async () => {
    try {
      const res = await fetch("/api/tags");
      if (res.ok) setAllTags((await res.json()).tags || []);
    } catch {}
  };

  const handleAddTag = async (tagName: string) => {
    if (!tagName.trim()) return;
    setLoading(true);
    try {
      const res = await fetch(`/api/${resourceType}s/${resourceId}/tags`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ tagName: tagName.trim() }),
      });
      if (res.ok) {
        await fetchTags();
        setInputValue("");
        setSuggestions([]);
        onTagsChange?.();
      } else {
        const data = await res.json();
        // ✅ alert() → toast
        toast.error(data.error || "태그 추가에 실패했습니다");
      }
    } catch {
      toast.error("태그 추가 중 오류가 발생했습니다");
    } finally {
      setLoading(false);
    }
  };

  const handleRemoveTag = async (tagId: string) => {
    setLoading(true);
    try {
      const res = await fetch(`/api/${resourceType}s/${resourceId}/tags?tagId=${tagId}`, {
        method: "DELETE",
      });
      if (res.ok) {
        await fetchTags();
        onTagsChange?.();
      } else {
        toast.error("태그 제거에 실패했습니다");
      }
    } catch {
      toast.error("태그 제거 중 오류가 발생했습니다");
    } finally {
      setLoading(false);
    }
  };

  const handleInputChange = (value: string) => {
    setInputValue(value);
    if (value.trim()) {
      const filtered = allTags.filter(
        (tag) =>
          tag.name.toLowerCase().includes(value.toLowerCase()) &&
          !tags.some((t) => t.id === tag.id)
      );
      setSuggestions(filtered.slice(0, 5));
    } else {
      setSuggestions([]);
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === "Enter") {
      e.preventDefault();
      handleAddTag(inputValue);
    }
  };

  return (
    <div className="space-y-3">
      <div className="flex flex-wrap gap-2">
        {tags.map((tag) => (
          <span
            key={tag.id}
            className="inline-flex items-center gap-1 px-3 py-1 bg-blue-100 text-blue-800 text-sm rounded-full"
          >
            #{tag.name}
            <button
              onClick={() => handleRemoveTag(tag.id)}
              disabled={loading}
              className="hover:text-blue-900 disabled:opacity-50"
            >
              ×
            </button>
          </span>
        ))}
      </div>

      <div className="relative">
        <input
          type="text"
          value={inputValue}
          onChange={(e) => handleInputChange(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder="태그 입력 후 Enter"
          className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-900"
          disabled={loading}
        />
        {suggestions.length > 0 && (
          <div className="absolute z-10 w-full mt-1 bg-white border border-gray-300 rounded-md shadow-lg">
            {suggestions.map((tag) => (
              <button
                key={tag.id}
                onClick={() => handleAddTag(tag.name)}
                className="w-full px-3 py-2 text-left hover:bg-gray-100 text-sm text-gray-900"
              >
                #{tag.name}
              </button>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/components/ThemeToggle.tsx">
"use client";

import { useTheme } from "next-themes";
import { useEffect, useState } from "react";
import { Sun, Moon, Monitor } from "lucide-react";

interface ThemeToggleProps {
  /** 'icon' = 아이콘만, 'full' = 아이콘 + 라벨 드롭다운 */
  variant?: "icon" | "full";
  className?: string;
}

export default function ThemeToggle({ variant = "icon", className = "" }: ThemeToggleProps) {
  const { theme, setTheme, resolvedTheme } = useTheme();
  const [mounted, setMounted] = useState(false);

  // SSR hydration mismatch 방지
  useEffect(() => setMounted(true), []);
  if (!mounted) return <div className="w-9 h-9" />;

  // 단순 아이콘 토글 (light ↔ dark)
  if (variant === "icon") {
    const isDark = resolvedTheme === "dark";
    return (
      <button
        onClick={() => setTheme(isDark ? "light" : "dark")}
        className={`relative w-9 h-9 flex items-center justify-center rounded-lg 
          hover:bg-slate-100 dark:hover:bg-slate-700 
          text-slate-500 dark:text-slate-400
          transition-colors ${className}`}
        title={isDark ? "라이트 모드로 전환" : "다크 모드로 전환"}
        aria-label="테마 전환"
      >
        {/* Sun – 다크일 때 보임 (클릭하면 라이트로) */}
        <Sun
          size={18}
          className={`absolute transition-all duration-300 ${
            isDark ? "opacity-100 rotate-0 scale-100" : "opacity-0 rotate-90 scale-75"
          }`}
        />
        {/* Moon – 라이트일 때 보임 (클릭하면 다크로) */}
        <Moon
          size={18}
          className={`absolute transition-all duration-300 ${
            !isDark ? "opacity-100 rotate-0 scale-100" : "opacity-0 -rotate-90 scale-75"
          }`}
        />
      </button>
    );
  }

  // 풀 드롭다운 (light / dark / system)
  const options = [
    { value: "light", label: "라이트", icon: Sun },
    { value: "dark",  label: "다크",   icon: Moon },
    { value: "system",label: "시스템", icon: Monitor },
  ] as const;

  return (
    <div className={`flex items-center gap-1 p-1 rounded-xl bg-slate-100 dark:bg-slate-800 ${className}`}>
      {options.map(({ value, label, icon: Icon }) => (
        <button
          key={value}
          onClick={() => setTheme(value)}
          className={`flex items-center gap-1.5 px-3 py-1.5 rounded-lg text-xs font-medium transition-all ${
            theme === value
              ? "bg-white dark:bg-slate-700 text-slate-900 dark:text-slate-100 shadow-sm"
              : "text-slate-500 dark:text-slate-400 hover:text-slate-700 dark:hover:text-slate-200"
          }`}
        >
          <Icon size={13} />
          {label}
        </button>
      ))}
    </div>
  );
}
</file>

<file path="src/components/Toast.tsx">
"use client";
// src/components/Toast.tsx (개선판 — 사운드 통합)
// 기존 Toast.tsx를 이 파일로 교체하세요

import { useState, useEffect, useCallback, createContext, useContext } from "react";
import { CheckCircle, AlertCircle, Info, X, AlertTriangle } from "lucide-react";
import { sound } from "@/lib/sound";

type ToastType = "success" | "error" | "info" | "warning";

interface ToastItem {
  id: string;
  type: ToastType;
  message: string;
  duration?: number;
}

interface ToastContextValue {
  addToast: (type: ToastType, message: string, duration?: number) => void;
}

const ToastContext = createContext<ToastContextValue>({ addToast: () => {} });

const ICONS = {
  success: <CheckCircle   size={16} className="text-green-500 shrink-0" />,
  error:   <AlertCircle   size={16} className="text-red-500   shrink-0" />,
  info:    <Info           size={16} className="text-blue-500  shrink-0" />,
  warning: <AlertTriangle  size={16} className="text-amber-500 shrink-0" />,
};

const STYLES: Record<ToastType, string> = {
  success: "border-green-200 dark:border-green-800 bg-green-50 dark:bg-green-900/30",
  error:   "border-red-200   dark:border-red-800   bg-red-50   dark:bg-red-900/30",
  info:    "border-blue-200  dark:border-blue-800  bg-blue-50  dark:bg-blue-900/30",
  warning: "border-amber-200 dark:border-amber-800 bg-amber-50 dark:bg-amber-900/30",
};

let globalAddToast: ToastContextValue["addToast"] | null = null;

// ── Provider ─────────────────────────────────────────────
export function ToastProvider({ children }: { children: React.ReactNode }) {
  const [toasts, setToasts] = useState<ToastItem[]>([]);

  const addToast = useCallback((type: ToastType, message: string, duration = 3500) => {
    const id = Math.random().toString(36).slice(2);
    setToasts((t) => [...t.slice(-4), { id, type, message, duration }]);

    // 사운드 재생
    if (type === "success") sound.success();
    else if (type === "error") sound.error();
    else sound.notification();

    setTimeout(() => setToasts((t) => t.filter((x) => x.id !== id)), duration);
  }, []);

  useEffect(() => { globalAddToast = addToast; return () => { globalAddToast = null; }; }, [addToast]);

  return (
    <ToastContext.Provider value={{ addToast }}>
      {children}
      {/* 토스트 컨테이너 */}
      <div className="fixed top-4 right-4 z-[9997] flex flex-col gap-2 pointer-events-none max-w-sm w-full">
        {toasts.map((t) => (
          <div key={t.id}
            className={`pointer-events-auto flex items-start gap-2.5 px-4 py-3 rounded-xl border shadow-lg backdrop-blur-sm ${STYLES[t.type]} animate-slide-in`}>
            {ICONS[t.type]}
            <p className="text-sm font-medium text-gray-800 dark:text-slate-200 flex-1 leading-snug">{t.message}</p>
            <button onClick={() => setToasts((t2) => t2.filter((x) => x.id !== t.id))}
              className="text-gray-400 hover:text-gray-600 dark:hover:text-slate-300 shrink-0 mt-0.5">
              <X size={14} />
            </button>
          </div>
        ))}
      </div>
    </ToastContext.Provider>
  );
}

// ── 정적 API (컴포넌트 밖에서도 사용 가능) ─────────────────
export const toast = {
  success: (msg: string, dur?: number) => globalAddToast?.("success", msg, dur),
  error:   (msg: string, dur?: number) => globalAddToast?.("error",   msg, dur),
  info:    (msg: string, dur?: number) => globalAddToast?.("info",    msg, dur),
  warning: (msg: string, dur?: number) => globalAddToast?.("warning", msg, dur),
};

export function useToast() {
  return useContext(ToastContext);
}
</file>

<file path="src/components/TypingIndicator.tsx">
"use client";
// src/components/TypingIndicator.tsx
// 채팅방 하단에 배치 — 상대방 타이핑 시 표시

interface Props {
  typingUserNames: string[]; // useTypingIndicator에서 userId를 이름으로 변환한 배열
}

export default function TypingIndicator({ typingUserNames }: Props) {
  if (typingUserNames.length === 0) return null;

  const label =
    typingUserNames.length === 1
      ? `${typingUserNames[0]}님이 입력 중`
      : `${typingUserNames.slice(0, 2).join(", ")}님이 입력 중`;

  return (
    <div className="flex items-center gap-2 px-4 py-1.5 animate-fade-in">
      {/* 세 점 애니메이션 */}
      <div className="flex items-center gap-0.5">
        {[0, 1, 2].map((i) => (
          <span
            key={i}
            className="w-1.5 h-1.5 rounded-full bg-gray-400 dark:bg-slate-500 animate-bounce"
            style={{ animationDelay: `${i * 0.15}s`, animationDuration: "0.9s" }}
          />
        ))}
      </div>
      <span className="text-xs text-gray-400 dark:text-slate-500 italic">{label}...</span>
    </div>
  );
}

// ──────────────────────────────────────────────────────────
// 채팅방 페이지에서 사용 예시
// ──────────────────────────────────────────────────────────
//
// const { typingUserIds, startTyping, stopTyping } = useTypingIndicator(roomId);
//
// // roomMembers: { id, name }[] 형태로 채팅방 멤버 목록
// const typingNames = typingUserIds
//   .filter(id => id !== session.user.id)
//   .map(id => roomMembers.find(m => m.id === id)?.name ?? "사용자");
//
// // 인풋에 이벤트 연결
// <input
//   onChange={(e) => { setValue(e.target.value); startTyping(); }}
//   onBlur={stopTyping}
//   onKeyDown={(e) => { if (e.key === "Enter") stopTyping(); }}
// />
// <TypingIndicator typingUserNames={typingNames} />
</file>

<file path="src/components/UploadProgressOverlay.tsx">
"use client";
// src/components/UploadProgressOverlay.tsx
// 업로드 중인 파일 진행률을 하단 고정 오버레이로 표시
// providers.tsx에 추가 (MobileBottomNav 위에)

import { useUploadProgress } from "@/lib/socket-client";
import { X, Upload, CheckCircle } from "lucide-react";
import { useState } from "react";

export default function UploadProgressOverlay() {
  const { uploads } = useUploadProgress();
  const [dismissed, setDismissed] = useState<Set<string>>(new Set());

  const visible = uploads.filter((u) => !dismissed.has(u.fileId));
  if (visible.length === 0) return null;

  return (
    <div className="fixed bottom-20 right-4 z-[9990] space-y-2 max-w-xs w-full">
      {visible.map((u) => (
        <div
          key={u.fileId}
          className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 shadow-lg p-3"
        >
          <div className="flex items-center gap-2 mb-2">
            {u.progress >= 100
              ? <CheckCircle size={14} className="text-green-500 shrink-0" />
              : <Upload size={14} className="text-blue-500 shrink-0 animate-bounce" />
            }
            <p className="text-xs font-medium text-gray-800 dark:text-slate-200 flex-1 truncate">
              {u.filename}
            </p>
            <span className="text-[10px] font-bold text-gray-500 dark:text-slate-400">
              {u.progress}%
            </span>
            {u.progress >= 100 && (
              <button
                onClick={() => setDismissed((s) => new Set([...s, u.fileId]))}
                className="text-gray-400 hover:text-gray-600 dark:hover:text-slate-300"
              >
                <X size={12} />
              </button>
            )}
          </div>
          <div className="h-1.5 bg-gray-100 dark:bg-slate-700 rounded-full overflow-hidden">
            <div
              className={`h-full rounded-full transition-all duration-300 ${
                u.progress >= 100 ? "bg-green-500" : "bg-blue-500"
              }`}
              style={{ width: `${u.progress}%` }}
            />
          </div>
          {u.progress >= 100 && (
            <p className="text-[10px] text-green-600 dark:text-green-400 mt-1 font-medium">
              ✓ 다른 기기에도 업로드 완료됨
            </p>
          )}
        </div>
      ))}
    </div>
  );
}
</file>

<file path="src/hooks/useInfiniteScroll.ts">
// src/hooks/useInfiniteScroll.ts
import { useState, useEffect, useRef, useCallback } from "react";

interface Options<T> {
  fetcher: (page: number) => Promise<{ items: T[]; hasMore: boolean }>;
  deps?: unknown[];
}

export function useInfiniteScroll<T>({ fetcher, deps = [] }: Options<T>) {
  const [items, setItems] = useState<T[]>([]);
  const [page, setPage] = useState(1);
  const [hasMore, setHasMore] = useState(true);
  const [loading, setLoading] = useState(false);
  const [initialLoading, setInitialLoading] = useState(true);
  const observerRef = useRef<IntersectionObserver | null>(null);
  const fetchingRef = useRef(false);
  const pageRef = useRef(1);

  const reset = useCallback(() => {
    setItems([]); setPage(1); setHasMore(true); setInitialLoading(true); pageRef.current = 1;
  }, []);

  // eslint-disable-next-line react-hooks/exhaustive-deps
  useEffect(() => { reset(); }, deps);

  const loadMore = useCallback(async (targetPage: number) => {
    if (fetchingRef.current) return;
    fetchingRef.current = true;
    setLoading(true);
    try {
      const result = await fetcher(targetPage);
      setItems((prev) => targetPage === 1 ? result.items : [...prev, ...result.items]);
      setHasMore(result.hasMore);
      pageRef.current = targetPage + 1;
      setPage(targetPage + 1);
    } catch {}
    finally { setLoading(false); setInitialLoading(false); fetchingRef.current = false; }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [fetcher]);

  // eslint-disable-next-line react-hooks/exhaustive-deps
  useEffect(() => { loadMore(1); }, deps);

  const setSentinel = useCallback((el: HTMLDivElement | null) => {
    if (observerRef.current) observerRef.current.disconnect();
    if (!el) return;
    observerRef.current = new IntersectionObserver(
      ([entry]) => { if (entry.isIntersecting && !fetchingRef.current) loadMore(pageRef.current); },
      { rootMargin: "200px" }
    );
    observerRef.current.observe(el);
  }, [loadMore]);

  return { items, loading, initialLoading, hasMore, setSentinel, reload: () => { reset(); loadMore(1); } };
}
</file>

<file path="src/lib/api-key-auth.ts">
// src/lib/api-key-auth.ts
// 외부 API 요청 시 Bearer API 키 검증 미들웨어

import { NextRequest } from "next/server";
import { prisma } from "@/lib/db";
import bcrypt from "bcryptjs";

interface AuthResult {
  ok: boolean;
  userId?: string;
  scopes?: string[];
  error?: string;
}

export async function verifyApiKey(
  request: NextRequest,
  requiredScopes: string[] = []
): Promise<AuthResult> {
  const authHeader = request.headers.get("authorization");
  if (!authHeader?.startsWith("Bearer eum_"))
    return { ok: false, error: "API 키가 필요합니다" };

  const rawKey = authHeader.slice(7); // "Bearer " 제거
  const prefix = rawKey.slice(0, 12);

  // prefix로 후보 키 조회 (DB 풀스캔 방지)
  const candidates = await prisma.apiKey.findMany({
    where: { keyPrefix: prefix },
  });

  for (const key of candidates) {
    const match = await bcrypt.compare(rawKey, key.keyHash);
    if (!match) continue;

    // 만료 확인
    if (key.expiresAt && key.expiresAt < new Date())
      return { ok: false, error: "만료된 API 키입니다" };

    // 스코프 확인
    for (const scope of requiredScopes) {
      if (!key.scopes.includes(scope))
        return { ok: false, error: `'${scope}' 권한이 없습니다` };
    }

    // 마지막 사용 시각 업데이트 (비동기, 응답 대기 안 함)
    prisma.apiKey.update({
      where: { id: key.id },
      data: { lastUsedAt: new Date() },
    }).catch(() => {});

    return { ok: true, userId: key.userId, scopes: key.scopes };
  }

  return { ok: false, error: "유효하지 않은 API 키입니다" };
}
</file>

<file path="src/lib/api-response.ts">
// src/lib/api-response.ts
// 전체 API에서 사용할 표준화된 응답 형식
//
// 성공: { success: true,  data: T,      meta?: M }
// 실패: { success: false, error: string, code: ErrorCode, details?: unknown }

import { NextResponse } from "next/server";

// ── 에러 코드 체계 ────────────────────────────────────────
export const ErrorCode = {
  // 인증
  UNAUTHORIZED:        "UNAUTHORIZED",
  FORBIDDEN:           "FORBIDDEN",
  SESSION_EXPIRED:     "SESSION_EXPIRED",
  ACCOUNT_BANNED:      "ACCOUNT_BANNED",

  // 입력값
  VALIDATION_ERROR:    "VALIDATION_ERROR",
  MISSING_FIELD:       "MISSING_FIELD",
  INVALID_FORMAT:      "INVALID_FORMAT",

  // 리소스
  NOT_FOUND:           "NOT_FOUND",
  ALREADY_EXISTS:      "ALREADY_EXISTS",
  CONFLICT:            "CONFLICT",

  // 제한
  RATE_LIMITED:        "RATE_LIMITED",
  STORAGE_QUOTA:       "STORAGE_QUOTA",
  FILE_TOO_LARGE:      "FILE_TOO_LARGE",
  MAX_LIMIT_REACHED:   "MAX_LIMIT_REACHED",

  // 서버
  INTERNAL_ERROR:      "INTERNAL_ERROR",
  SERVICE_UNAVAILABLE: "SERVICE_UNAVAILABLE",
  DATABASE_ERROR:      "DATABASE_ERROR",
} as const;

export type ErrorCode = typeof ErrorCode[keyof typeof ErrorCode];

// ── 타입 정의 ─────────────────────────────────────────────
interface SuccessResponse<T, M = undefined> {
  success: true;
  data:    T;
  meta?:   M;
}
interface ErrorResponse {
  success: false;
  error:   string;
  code:    ErrorCode;
  details?: unknown;
}
interface PaginatedMeta {
  page:     number;
  limit:    number;
  total:    number;
  hasMore:  boolean;
}

// ── 응답 빌더 ─────────────────────────────────────────────
export function ok<T>(data: T, status = 200): NextResponse {
  const body: SuccessResponse<T> = { success: true, data };
  return NextResponse.json(body, { status });
}

export function created<T>(data: T): NextResponse {
  return ok(data, 201);
}

export function paginated<T>(
  items:    T[],
  meta:     PaginatedMeta,
  status = 200
): NextResponse {
  const body: SuccessResponse<T[], PaginatedMeta> = { success: true, data: items, meta };
  return NextResponse.json(body, { status });
}

export function error(
  message: string,
  code:    ErrorCode,
  status:  number,
  details?: unknown
): NextResponse {
  const body: ErrorResponse = { success: false, error: message, code, details };
  return NextResponse.json(body, { status });
}

// ── 자주 쓰는 에러 단축키 ────────────────────────────────
export const ApiError = {
  unauthorized:     (msg = "인증이 필요합니다") =>
    error(msg, ErrorCode.UNAUTHORIZED, 401),

  forbidden:        (msg = "권한이 없습니다") =>
    error(msg, ErrorCode.FORBIDDEN, 403),

  notFound:         (resource = "리소스") =>
    error(`${resource}를 찾을 수 없습니다`, ErrorCode.NOT_FOUND, 404),

  conflict:         (msg: string) =>
    error(msg, ErrorCode.CONFLICT, 409),

  validation:       (msg: string, details?: unknown) =>
    error(msg, ErrorCode.VALIDATION_ERROR, 422, details),

  rateLimited:      () =>
    error("너무 많은 요청입니다. 잠시 후 다시 시도해주세요", ErrorCode.RATE_LIMITED, 429),

  storageQuota:     () =>
    error("저장 용량이 부족합니다", ErrorCode.STORAGE_QUOTA, 413),

  internal:         (msg = "서버 오류가 발생했습니다") =>
    error(msg, ErrorCode.INTERNAL_ERROR, 500),
};

// ── 사용 예시 ─────────────────────────────────────────────
// import { ok, created, paginated, ApiError } from "@/lib/api-response";
//
// // 성공
// return ok({ file });
// return created({ file });
// return paginated(files, { page, limit, total, hasMore });
//
// // 에러
// return ApiError.unauthorized();
// return ApiError.notFound("파일");
// return ApiError.validation("이메일 형식이 올바르지 않습니다", { field: "email" });
</file>

<file path="src/lib/auth.ts">
// src/lib/auth.ts
import NextAuth, { AuthOptions } from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";
import { compare } from "bcryptjs";
import { prisma } from "@/lib/db";

export const authOptions: AuthOptions = {
  providers: [
    CredentialsProvider({
      name: "Credentials",
      credentials: {
        email:    { label: "Email",    type: "email" },
        password: { label: "Password", type: "password" },
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) return null;

        const user = await prisma.user.findUnique({
          where: { email: credentials.email },
        });
        if (!user) return null;

        const isValid = await compare(credentials.password, user.passwordHash);
        if (!isValid) return null;

        return {
          id:       user.id,
          email:    user.email,
          name:     user.name,
          role:     user.role,
          isBanned: user.isBanned,  // ← 추가
        };
      },
    }),
  ],
  session: { strategy: "jwt", maxAge: 30 * 24 * 60 * 60 },
  pages:   { signIn: "/login", signOut: "/", error: "/login" },
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.id       = user.id;
        token.role     = user.role;
        token.isBanned = user.isBanned;  // ← 추가
      }
      return token;
    },
    async session({ session, token }) {
      if (session.user) {
        session.user.id       = token.id       as string;
        session.user.role     = token.role     as string;
        session.user.isBanned = token.isBanned as boolean;  // ← 추가
      }
      return session;
    },
  },
  secret: process.env.NEXTAUTH_SECRET,
};

const handler = NextAuth(authOptions);
export { handler as GET, handler as POST };
</file>

<file path="src/lib/cache.ts">
// src/lib/cache.ts
// Redis 없이 메모리 기반 TTL 캐시
// Next.js 서버 프로세스 내에서 공유 (단일 서버 환경에 적합)

interface CacheEntry<T> {
  value: T;
  expiresAt: number;
  tags: string[];
}

class MemoryCache {
  private store = new Map<string, CacheEntry<unknown>>();
  private maxSize: number;

  constructor(maxSize = 1000) {
    this.maxSize = maxSize;
    // 1분마다 만료 항목 정리
    if (typeof setInterval !== "undefined") {
      setInterval(() => this.evictExpired(), 60_000);
    }
  }

  get<T>(key: string): T | null {
    const entry = this.store.get(key);
    if (!entry) return null;
    if (Date.now() > entry.expiresAt) {
      this.store.delete(key);
      return null;
    }
    return entry.value as T;
  }

  set<T>(key: string, value: T, ttlSeconds: number, tags: string[] = []): void {
    // LRU: 최대 크기 초과 시 가장 오래된 항목 삭제
    if (this.store.size >= this.maxSize) {
      const firstKey = this.store.keys().next().value;
      if (firstKey) this.store.delete(firstKey);
    }
    this.store.set(key, {
      value,
      expiresAt: Date.now() + ttlSeconds * 1000,
      tags,
    });
  }

  delete(key: string): void {
    this.store.delete(key);
  }

  /** 태그로 관련 캐시 일괄 무효화 */
  invalidateByTag(tag: string): void {
    for (const [key, entry] of this.store.entries()) {
      if (entry.tags.includes(tag)) this.store.delete(key);
    }
  }

  /** 패턴으로 캐시 무효화 */
  invalidateByPattern(prefix: string): void {
    for (const key of this.store.keys()) {
      if (key.startsWith(prefix)) this.store.delete(key);
    }
  }

  private evictExpired(): void {
    const now = Date.now();
    for (const [key, entry] of this.store.entries()) {
      if (now > entry.expiresAt) this.store.delete(key);
    }
  }

  get size() { return this.store.size; }
}

// 전역 싱글턴
const cache = new MemoryCache(2000);
export default cache;

// ── 편의 래퍼 ─────────────────────────────────────────────

/**
 * 캐시에서 가져오거나 fetcher 실행 후 캐시에 저장
 * @example
 *   const data = await withCache(
 *     `stats:${userId}`,
 *     () => prisma.file.count({ where: { userId } }),
 *     60,           // TTL: 60초
 *     ["user-stats"] // 태그 (invalidateByTag로 일괄 무효화)
 *   );
 */
export async function withCache<T>(
  key: string,
  fetcher: () => Promise<T>,
  ttlSeconds = 60,
  tags: string[] = []
): Promise<T> {
  const cached = cache.get<T>(key);
  if (cached !== null) return cached;

  const fresh = await fetcher();
  cache.set(key, fresh, ttlSeconds, tags);
  return fresh;
}

// ── TTL 상수 ─────────────────────────────────────────────
export const TTL = {
  SHORT:    30,   // 30초 - 자주 변하는 데이터 (알림 수)
  MEDIUM:   300,  // 5분  - 보통 (파일 목록)
  LONG:     3600, // 1시간 - 자주 안 변하는 데이터 (통계)
  VERY_LONG: 86400, // 24시간 - 거의 안 변하는 데이터 (태그 목록)
};

// ── 사용 예시 ─────────────────────────────────────────────
// API route에서:
//
// import { withCache, cache, TTL } from "@/lib/cache";
//
// export async function GET() {
//   const stats = await withCache(
//     "admin:stats",
//     () => fetchExpensiveStats(),
//     TTL.LONG,
//     ["admin-stats"]
//   );
//   return NextResponse.json(stats);
// }
//
// // 데이터 변경 시 무효화:
// cache.invalidateByTag("admin-stats");
// cache.invalidateByPattern(`user:${userId}:`);
</file>

<file path="src/lib/client-utils.ts">
/**
 * src/lib/client-utils.ts
 * 클라이언트 공통 유틸 함수 모음
 */

// ── 파일 크기 ────────────────────────────────────
export function formatFileSize(bytes: number | string): string {
  const n = typeof bytes === "string" ? parseInt(bytes) : bytes;
  if (!n || isNaN(n)) return "0 B";
  if (n < 1024) return `${n} B`;
  if (n < 1024 ** 2) return `${(n / 1024).toFixed(1)} KB`;
  if (n < 1024 ** 3) return `${(n / 1024 ** 2).toFixed(2)} MB`;
  return `${(n / 1024 ** 3).toFixed(2)} GB`;
}

// ── 상대 시간 ────────────────────────────────────
export function relativeTime(dateStr: string | Date): string {
  const now = Date.now();
  const ts = typeof dateStr === "string" ? new Date(dateStr).getTime() : dateStr.getTime();
  const diff = now - ts;
  const mins = Math.floor(diff / 60000);
  const hours = Math.floor(diff / 3600000);
  const days = Math.floor(diff / 86400000);
  if (mins < 1) return "방금 전";
  if (mins < 60) return `${mins}분 전`;
  if (hours < 24) return `${hours}시간 전`;
  if (days < 7) return `${days}일 전`;
  return new Date(dateStr).toLocaleDateString("ko-KR");
}

// ── 절대 날짜/시간 ──────────────────────────────
export function formatDate(dateStr: string | Date): string {
  const d = typeof dateStr === "string" ? new Date(dateStr) : dateStr;
  return d.toLocaleDateString("ko-KR", { year: "numeric", month: "long", day: "numeric" });
}

export function formatTime(dateStr: string | Date): string {
  const d = typeof dateStr === "string" ? new Date(dateStr) : dateStr;
  if (isNaN(d.getTime())) return "";
  return d.toLocaleTimeString("ko-KR", { hour: "2-digit", minute: "2-digit" });
}

// ── 파일 타입 아이콘 ─────────────────────────────
export function getFileIcon(mimeType: string): string {
  if (!mimeType) return "📁";
  if (mimeType.startsWith("image/")) return "🖼️";
  if (mimeType.startsWith("video/")) return "🎬";
  if (mimeType.startsWith("audio/")) return "🎵";
  if (mimeType.includes("pdf")) return "📄";
  if (mimeType.includes("word") || mimeType.includes("document")) return "📝";
  if (mimeType.includes("sheet") || mimeType.includes("excel")) return "📊";
  if (mimeType.includes("presentation") || mimeType.includes("powerpoint")) return "📑";
  if (mimeType.includes("zip") || mimeType.includes("rar") || mimeType.includes("7z") || mimeType.includes("tar")) return "🗜️";
  if (mimeType.includes("text/plain")) return "📃";
  if (mimeType.includes("html")) return "🌐";
  if (mimeType.includes("json")) return "🔧";
  if (mimeType.includes("javascript") || mimeType.includes("typescript")) return "⚙️";
  if (mimeType.includes("python")) return "🐍";
  return "📁";
}

// ── 파일 색상 (카드 배경) ──────────────────────
export function getFileColor(mimeType: string): string {
  if (!mimeType) return "bg-gray-50";
  if (mimeType.startsWith("image/")) return "bg-pink-50";
  if (mimeType.startsWith("video/")) return "bg-purple-50";
  if (mimeType.startsWith("audio/")) return "bg-yellow-50";
  if (mimeType.includes("pdf")) return "bg-red-50";
  if (mimeType.includes("word") || mimeType.includes("document")) return "bg-blue-50";
  if (mimeType.includes("sheet") || mimeType.includes("excel")) return "bg-green-50";
  if (mimeType.includes("presentation") || mimeType.includes("powerpoint")) return "bg-orange-50";
  if (mimeType.includes("zip") || mimeType.includes("rar")) return "bg-amber-50";
  return "bg-gray-50";
}

// ── 파일 확장자 추출 ─────────────────────────────
export function getFileExtension(filename: string): string {
  const parts = filename.split(".");
  return parts.length > 1 ? parts[parts.length - 1].toUpperCase() : "";
}

// ── 클립보드 복사 ────────────────────────────────
export async function copyToClipboard(text: string): Promise<boolean> {
  try {
    await navigator.clipboard.writeText(text);
    return true;
  } catch {
    // fallback
    const el = document.createElement("textarea");
    el.value = text;
    el.style.position = "fixed";
    el.style.opacity = "0";
    document.body.appendChild(el);
    el.focus();
    el.select();
    const ok = document.execCommand("copy");
    document.body.removeChild(el);
    return ok;
  }
}

// ── 바이트 → 퍼센트 (용량 제한 기준) ────────────
export function storagePercent(usedBytes: number, limitBytes: number = 5 * 1024 ** 3): number {
  return Math.min((usedBytes / limitBytes) * 100, 100);
}
</file>

<file path="src/lib/email-templates.ts">
// src/lib/email-templates.ts
// 이음 이메일 템플릿 모음 — 기존 email.ts와 함께 사용

const BASE_URL = process.env.NEXTAUTH_URL ?? "https://eum.app";

const baseLayout = (content: string, previewText = "") => `
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>이음</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { background: #f4f4f7; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; color: #333; }
    .wrapper { max-width: 580px; margin: 40px auto; }
    .card { background: #fff; border-radius: 20px; overflow: hidden; box-shadow: 0 4px 24px rgba(0,0,0,.06); }
    .header { background: linear-gradient(135deg, #5b21b6 0%, #3730a3 100%); padding: 32px 40px; text-align: center; }
    .logo { display: inline-flex; align-items: center; gap: 10px; }
    .logo-icon { width: 36px; height: 36px; background: rgba(255,255,255,.15); border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 18px; }
    .logo-text { color: #fff; font-size: 20px; font-weight: 900; letter-spacing: -.5px; }
    .body { padding: 40px; }
    .title { font-size: 22px; font-weight: 800; color: #111; margin-bottom: 12px; line-height: 1.3; }
    .text { font-size: 15px; color: #555; line-height: 1.7; margin-bottom: 16px; }
    .btn { display: inline-block; padding: 14px 32px; background: #5b21b6; color: #fff !important; font-size: 15px; font-weight: 700; border-radius: 12px; text-decoration: none; margin: 16px 0; }
    .btn:hover { background: #4c1d95; }
    .divider { height: 1px; background: #f0f0f3; margin: 24px 0; }
    .notice { background: #faf9ff; border: 1px solid #e8e3ff; border-radius: 12px; padding: 16px; font-size: 13px; color: #7c3aed; margin: 20px 0; }
    .code { font-family: 'Courier New', monospace; font-size: 28px; font-weight: 900; letter-spacing: 6px; color: #5b21b6; text-align: center; padding: 20px; background: #faf9ff; border-radius: 12px; margin: 20px 0; }
    .footer { background: #f8f7ff; padding: 24px 40px; text-align: center; }
    .footer p { font-size: 12px; color: #999; line-height: 1.8; }
    .footer a { color: #7c3aed; text-decoration: none; }
  </style>
</head>
<body>
  <div style="display:none;max-height:0;overflow:hidden;">${previewText}</div>
  <div class="wrapper">
    <div class="card">
      <div class="header">
        <div class="logo">
          <div class="logo-icon">☁️</div>
          <div class="logo-text">이음</div>
        </div>
      </div>
      <div class="body">${content}</div>
    </div>
    <div class="footer">
      <p>이 이메일은 이음 퍼스널 클라우드에서 발송되었습니다.</p>
      <p><a href="${BASE_URL}">이음 방문하기</a> · <a href="${BASE_URL}/settings">알림 설정</a></p>
      <p style="margin-top:8px;color:#bbb;">© 2026 EUM CLOUD SERVICE</p>
    </div>
  </div>
</body>
</html>`;

// ① 이메일 인증
export function emailVerificationTemplate(name: string, code: string) {
  return baseLayout(`
    <h2 class="title">이메일 인증</h2>
    <p class="text">안녕하세요, <strong>${name}</strong>님!<br/>
    아래 인증 코드를 입력해 이음 계정을 활성화하세요.</p>
    <div class="code">${code}</div>
    <p class="text" style="font-size:13px;color:#999;">이 코드는 10분 후 만료됩니다. 본인이 요청하지 않았다면 무시하세요.</p>
  `, `[이음] 이메일 인증 코드: ${code}`);
}

// ② 비밀번호 재설정
export function passwordResetTemplate(name: string, resetUrl: string) {
  return baseLayout(`
    <h2 class="title">비밀번호 재설정</h2>
    <p class="text">안녕하세요, <strong>${name}</strong>님!<br/>
    비밀번호 재설정 요청이 접수되었습니다. 아래 버튼을 눌러 새 비밀번호를 설정하세요.</p>
    <div style="text-align:center;">
      <a href="${resetUrl}" class="btn">🔑 비밀번호 재설정</a>
    </div>
    <div class="notice">⏱ 이 링크는 1시간 후 만료됩니다. 본인이 요청하지 않았다면 즉시 비밀번호를 변경하세요.</div>
    <p class="text" style="font-size:13px;color:#999;">버튼이 작동하지 않으면 아래 링크를 복사하세요:<br/>
    <a href="${resetUrl}" style="color:#7c3aed;word-break:break-all;">${resetUrl}</a></p>
  `, "이음 비밀번호 재설정 링크가 도착했습니다");
}

// ③ 파일 공유 알림
export function fileSharedTemplate(
  recipientName: string, senderName: string,
  fileName: string, shareUrl: string, permission: "VIEW" | "EDIT" | "ADMIN"
) {
  const permLabel = { VIEW: "읽기", EDIT: "편집", ADMIN: "관리" }[permission];
  return baseLayout(`
    <h2 class="title">📁 파일이 공유되었습니다</h2>
    <p class="text">안녕하세요, <strong>${recipientName}</strong>님!<br/>
    <strong>${senderName}</strong>님이 파일을 공유했습니다.</p>
    <div class="notice">
      <strong>파일명:</strong> ${fileName}<br/>
      <strong>권한:</strong> ${permLabel}
    </div>
    <div style="text-align:center;">
      <a href="${shareUrl}" class="btn">📂 파일 보기</a>
    </div>
  `, `${senderName}님이 "${fileName}"을 공유했습니다`);
}

// ④ 팔로우 알림
export function followNotificationTemplate(
  recipientName: string, followerName: string, followerProfileUrl: string
) {
  return baseLayout(`
    <h2 class="title">👤 새 팔로워</h2>
    <p class="text">안녕하세요, <strong>${recipientName}</strong>님!<br/>
    <strong>${followerName}</strong>님이 회원님을 팔로우하기 시작했습니다.</p>
    <div style="text-align:center;">
      <a href="${followerProfileUrl}" class="btn">프로필 보기</a>
    </div>
  `, `${followerName}님이 팔로우했습니다`);
}

// ⑤ 주간 요약 다이제스트
export function weeklyDigestTemplate(
  name: string,
  stats: { newFiles: number; newComments: number; newFollowers: number; storageUsed: string }
) {
  return baseLayout(`
    <h2 class="title">📊 주간 활동 요약</h2>
    <p class="text">안녕하세요, <strong>${name}</strong>님! 이번 주 이음 활동을 확인하세요.</p>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin:20px 0;">
      ${[
        { label: "📁 새 파일", value: stats.newFiles },
        { label: "💬 새 댓글", value: stats.newComments },
        { label: "👥 새 팔로워", value: stats.newFollowers },
        { label: "💾 저장 사용량", value: stats.storageUsed },
      ].map(({ label, value }) => `
        <div style="background:#faf9ff;border:1px solid #e8e3ff;border-radius:12px;padding:16px;text-align:center;">
          <p style="font-size:13px;color:#7c3aed;font-weight:600;">${label}</p>
          <p style="font-size:22px;font-weight:900;color:#111;margin-top:4px;">${value}</p>
        </div>
      `).join("")}
    </div>
    <div style="text-align:center;">
      <a href="${BASE_URL}/dashboard" class="btn">대시보드 보기</a>
    </div>
  `, `${name}님의 이번 주 이음 활동 요약`);
}

// ⑥ 계정 정지 알림
export function accountBannedTemplate(name: string, reason: string) {
  return baseLayout(`
    <h2 class="title" style="color:#dc2626;">🚫 계정이 정지되었습니다</h2>
    <p class="text">안녕하세요, <strong>${name}</strong>님.<br/>
    이음 이용 정책 위반으로 계정이 일시 정지되었습니다.</p>
    <div class="notice" style="background:#fff5f5;border-color:#fecaca;color:#dc2626;">
      <strong>사유:</strong> ${reason}
    </div>
    <p class="text">문의사항이 있으시면 <a href="mailto:support@eum.app" style="color:#7c3aed;">support@eum.app</a>으로 연락해 주세요.</p>
  `, "이음 계정 정지 안내");
}
</file>

<file path="src/lib/emit-notification.ts">
// src/lib/emit-notification.ts
import * as socketServer from "@/lib/socket-server";
import { prisma } from "@/lib/db";

type NotificationType = "COMMENT" | "SHARE" | "CHAT" | "SYSTEM" | "FILE_UPLOAD" | "CALL";

interface EmitNotificationParams {
  title: string;
  message: string;
  type: NotificationType;
  link?: string;
  metadata?: any;
}

export async function emitNotification(
  userId: string,
  params: EmitNotificationParams
) {
  try {
    // 1. DB에 알림 저장
    const notification = await prisma.notification.create({
      data: {
        userId,
        title: params.title,
        message: params.message,
        type: params.type,
        link: params.link,
        metadata: params.metadata || {},
        read: false,
      },
    });

    // 2. 실시간 소켓 전송 (안전한 방식)
    // socket-server에 emitToUser가 명시적으로 export 되지 않았을 경우를 대비해 any로 처리
    const server = socketServer as any;
    
    if (server && typeof server.emitToUser === "function") {
      server.emitToUser(userId, "notification", notification);
    } else if (server && server.io) {
      // 만약 io 객체가 직접 노출되어 있다면 해당 방식으로 전송
      server.io.to(userId).emit("notification", notification);
    } else {
      console.warn(`[Notification] Socket not connected for user ${userId}, but saved to DB.`);
    }

    return notification;
  } catch (error) {
    console.error("Emit notification error:", error);
    // 빌드 중단 방지를 위해 에러를 던지지 않고 로그만 남깁니다.
    return null;
  }
}
</file>

<file path="src/lib/image-optimizer.ts">
// src/lib/image-optimizer.ts
// sharp 기반 이미지 최적화 파이프라인
// npm install sharp && npm install --save-dev @types/sharp

import sharp from "sharp";
import path from "path";
import { writeFile, mkdir } from "fs/promises";
import { existsSync } from "fs";

const STORAGE_PATH = process.env.STORAGE_PATH ?? "./storage";
const OPTIMIZED_DIR = path.join(STORAGE_PATH, "optimized");
const THUMBNAIL_DIR = path.join(STORAGE_PATH, "thumbnails");

// 지원 입력 형식
const IMAGE_TYPES = new Set([
  "image/jpeg", "image/jpg", "image/png",
  "image/webp", "image/gif", "image/avif", "image/tiff",
]);

export function isImage(mimeType: string): boolean {
  return IMAGE_TYPES.has(mimeType);
}

export interface OptimizeResult {
  optimizedPath: string;
  thumbnailPath: string;
  originalSize:  number;
  optimizedSize: number;
  width:         number;
  height:        number;
  format:        string;
}

interface OptimizeOptions {
  maxWidth?:    number;   // 기본 2048px
  maxHeight?:   number;   // 기본 2048px
  quality?:     number;   // WebP 품질 (기본 82)
  thumbSize?:   number;   // 썸네일 크기 (기본 320px)
  keepOriginal?: boolean; // 원본 보존 여부
}

export async function optimizeImage(
  inputPath: string,
  filename:  string,
  opts: OptimizeOptions = {}
): Promise<OptimizeResult> {
  const {
    maxWidth    = 2048,
    maxHeight   = 2048,
    quality     = 82,
    thumbSize   = 320,
  } = opts;

  // 디렉토리 생성
  if (!existsSync(OPTIMIZED_DIR)) await mkdir(OPTIMIZED_DIR, { recursive: true });
  if (!existsSync(THUMBNAIL_DIR)) await mkdir(THUMBNAIL_DIR, { recursive: true });

  const baseName     = path.basename(filename, path.extname(filename));
  const optimizedPath = path.join(OPTIMIZED_DIR, `${baseName}.webp`);
  const thumbnailPath = path.join(THUMBNAIL_DIR, `${baseName}_thumb.webp`);

  // 원본 메타데이터
  const metadata = await sharp(inputPath).metadata();
  const originalSize = (await import("fs")).statSync(inputPath).size;

  // 최적화 (WebP 변환 + 리사이즈)
  await sharp(inputPath)
    .rotate()                        // EXIF orientation 자동 보정
    .resize(maxWidth, maxHeight, {
      fit:           "inside",
      withoutEnlargement: true,      // 원본보다 크게 확대 안 함
    })
    .webp({ quality, effort: 4 })   // effort: 0(빠름) ~ 6(높은 압축)
    .toFile(optimizedPath);

  // 썸네일 생성
  await sharp(inputPath)
    .rotate()
    .resize(thumbSize, thumbSize, { fit: "cover", position: "attention" })
    .webp({ quality: 75, effort: 3 })
    .toFile(thumbnailPath);

  const optimizedSize = (await import("fs")).statSync(optimizedPath).size;

  return {
    optimizedPath,
    thumbnailPath,
    originalSize,
    optimizedSize,
    width:  metadata.width  ?? 0,
    height: metadata.height ?? 0,
    format: "webp",
  };
}

/**
 * 업로드 route에 통합 예시:
 *
 * import { isImage, optimizeImage } from "@/lib/image-optimizer";
 *
 * if (isImage(file.type)) {
 *   const result = await optimizeImage(savedPath, file.name);
 *   // DB에 thumbnailUrl = result.thumbnailPath 저장
 *   // filepath = result.optimizedPath (WebP로 교체)
 *   console.log(`압축률: ${Math.round((1 - result.optimizedSize / result.originalSize) * 100)}%`);
 * }
 */

// ── 배치 재변환 (기존 이미지 일괄 처리) ─────────────────
export async function batchOptimizeExistingImages(
  userId?: string
): Promise<{ processed: number; skipped: number; savedBytes: bigint }> {
  const { prisma } = await import("@/lib/db");

  const files = await prisma.file.findMany({
    where: {
      ...(userId ? { userId } : {}),
      mimeType: { in: [...IMAGE_TYPES] },
      deletedAt: null,
    },
    select: { id: true, filepath: true, originalName: true, mimeType: true },
    take: 100, // 배치 크기
  });

  let processed = 0, skipped = 0;
  let savedBytes = BigInt(0);

  for (const file of files) {
    if (!existsSync(file.filepath)) { skipped++; continue; }
    try {
      const result = await optimizeImage(file.filepath, file.originalName);
      const saved  = BigInt(result.originalSize - result.optimizedSize);
      savedBytes  += saved > 0 ? saved : BigInt(0);

      await prisma.file.update({
        where: { id: file.id },
        data: {
          filepath:     result.optimizedPath,
          thumbnailUrl: result.thumbnailPath,
          size:         BigInt(result.optimizedSize),
        },
      });
      processed++;
    } catch { skipped++; }
  }

  return { processed, skipped, savedBytes };
}
</file>

<file path="src/lib/logger.ts">
// src/lib/logger.ts
// Winston 기반 구조화 로깅 시스템
// npm install winston winston-daily-rotate-file

import winston from "winston";
import DailyRotateFile from "winston-daily-rotate-file";
import path from "path";

const LOG_DIR  = process.env.LOG_DIR  ?? "./logs";
const LOG_LEVEL = process.env.LOG_LEVEL ?? (process.env.NODE_ENV === "production" ? "info" : "debug");

// ── 커스텀 포맷 ──────────────────────────────────────────
const prettyFormat = winston.format.combine(
  winston.format.timestamp({ format: "YYYY-MM-DD HH:mm:ss.SSS" }),
  winston.format.errors({ stack: true }),
  winston.format.colorize(),
  winston.format.printf(({ timestamp, level, message, stack, ...meta }) => {
    const metaStr = Object.keys(meta).length ? `\n  ${JSON.stringify(meta, null, 2)}` : "";
    return `${timestamp} [${level}] ${message}${stack ? `\n${stack}` : ""}${metaStr}`;
  })
);

const jsonFormat = winston.format.combine(
  winston.format.timestamp(),
  winston.format.errors({ stack: true }),
  winston.format.json()
);

// ── 트랜스포트 ───────────────────────────────────────────
const transports: winston.transport[] = [];

// 콘솔 (개발 환경)
if (process.env.NODE_ENV !== "production") {
  transports.push(new winston.transports.Console({ format: prettyFormat }));
} else {
  transports.push(new winston.transports.Console({
    format: jsonFormat,
    level: "warn",
  }));
}

// 일별 로테이션 파일
transports.push(
  new DailyRotateFile({
    dirname:      path.join(LOG_DIR, "app"),
    filename:     "%DATE%.log",
    datePattern:  "YYYY-MM-DD",
    maxSize:      "20m",
    maxFiles:     "14d",  // 14일 보관
    format:       jsonFormat,
    level:        LOG_LEVEL,
  }),
  new DailyRotateFile({
    dirname:      path.join(LOG_DIR, "errors"),
    filename:     "%DATE%-error.log",
    datePattern:  "YYYY-MM-DD",
    maxSize:      "20m",
    maxFiles:     "30d",
    format:       jsonFormat,
    level:        "error",
  })
);

// ── 로거 생성 ────────────────────────────────────────────
const logger = winston.createLogger({
  level:      LOG_LEVEL,
  transports,
  exceptionHandlers: [
    new DailyRotateFile({
      dirname:     path.join(LOG_DIR, "exceptions"),
      filename:    "%DATE%-exception.log",
      datePattern: "YYYY-MM-DD",
      maxFiles:    "30d",
      format:      jsonFormat,
    }),
  ],
  rejectionHandlers: [
    new DailyRotateFile({
      dirname:     path.join(LOG_DIR, "rejections"),
      filename:    "%DATE%-rejection.log",
      datePattern: "YYYY-MM-DD",
      maxFiles:    "30d",
      format:      jsonFormat,
    }),
  ],
});

export default logger;

// ── 컨텍스트 로거 (모듈별 prefix) ────────────────────────
export function createLogger(module: string) {
  return {
    debug: (msg: string, meta?: object) => logger.debug(msg, { module, ...meta }),
    info:  (msg: string, meta?: object) => logger.info(msg,  { module, ...meta }),
    warn:  (msg: string, meta?: object) => logger.warn(msg,  { module, ...meta }),
    error: (msg: string, meta?: object) => logger.error(msg, { module, ...meta }),
  };
}

// ── 사용 예시 ─────────────────────────────────────────────
// import { createLogger } from "@/lib/logger";
// const log = createLogger("FileUpload");
// log.info("파일 업로드 시작", { userId, filename, size });
// log.error("업로드 실패", { error: err.message, stack: err.stack });
</file>

<file path="src/lib/notification-prefs.ts">
// src/lib/notification-prefs.ts
// NotificationPreferences 타입과 기본값을 route 파일 밖으로 분리
// route.ts에서 export const/interface를 사용하면 Next.js 빌드 오류 발생

export interface NotificationPreferences {
  pushEnabled: boolean;
  comment:     boolean;
  share:       boolean;
  chat:        boolean;
  call:        boolean;
  system:      boolean;
  fileUpload:  boolean;
  emailDigest: boolean;
}

export const DEFAULT_PREFS: NotificationPreferences = {
  pushEnabled: true,
  comment:     true,
  share:       true,
  chat:        true,
  call:        true,
  system:      true,
  fileUpload:  false,
  emailDigest: false,
};
</file>

<file path="src/lib/notification.ts">
// src/lib/notification.ts
// 다른 API route에서 import해서 사용하세요.
// 예: 댓글 작성 → createNotification({ userId: post.authorId, type: "COMMENT", ... })

import { prisma } from "@/lib/db";

type NotificationType =
  | "COMMENT"
  | "SHARE"
  | "CHAT"
  | "SYSTEM"
  | "FILE_UPLOAD"
  | "CALL";

interface CreateNotificationInput {
  userId: string;      // 수신자
  type: NotificationType;
  title: string;
  body?: string;
  link?: string;       // 클릭 시 이동할 URL (예: "/posts/abc123")
}

export async function createNotification(input: CreateNotificationInput) {
  try {
    return await prisma.notification.create({
      data: {
        userId: input.userId,
        type: input.type,
        title: input.title,
        body: input.body,
        link: input.link,
      },
    });
  } catch (error) {
    // 알림 생성 실패는 조용히 처리 (주요 기능에 영향 없어야 함)
    console.error("createNotification error:", error);
  }
}

// ──────────────────────────────────────────────
// 사용 예시
// ──────────────────────────────────────────────
//
// [댓글 알림] src/app/api/posts/[id]/comments/route.ts
// await createNotification({
//   userId: post.userId,
//   type: "COMMENT",
//   title: `${commenterName}님이 댓글을 남겼습니다`,
//   body: comment.content.slice(0, 80),
//   link: `/posts/${post.id}`,
// });
//
// [공유 알림] src/app/api/files/[id]/share/route.ts
// await createNotification({
//   userId: targetUserId,
//   type: "SHARE",
//   title: `${ownerName}님이 파일을 공유했습니다`,
//   body: file.originalName,
//   link: `/dashboard`,
// });
//
// [채팅 알림] src/app/api/chat/rooms/[id]/messages 등
// await createNotification({
//   userId: recipientId,
//   type: "CHAT",
//   title: `${senderName}님의 새 메시지`,
//   body: message.content?.slice(0, 80),
//   link: `/chat/${chatRoomId}`,
// });
</file>

<file path="src/lib/optimized-queries.ts">
// src/lib/optimized-queries.ts
import { prisma } from "@/lib/db";
import { withCache, TTL } from "@/lib/cache";

export async function getFileList(userId: string, folderId: string | null = null, page = 1, limit = 20) {
  const [files, total] = await Promise.all([
    prisma.file.findMany({
      where: { userId, folderId, deletedAt: null },
      select: { id: true, originalName: true, mimeType: true, size: true, thumbnailUrl: true, createdAt: true, isEncrypted: true, publicToken: true, isStarred: true, isPinned: true, _count: { select: { fileTags: true } } },
      orderBy: { createdAt: "desc" },
      skip: (page - 1) * limit, take: limit,
    }),
    prisma.file.count({ where: { userId, folderId, deletedAt: null } }),
  ]);
  return { files, total, hasMore: page * limit < total };
}

export async function getPinnedFiles(userId: string) {
  return prisma.file.findMany({
    where: { userId, isPinned: true, deletedAt: null },
    select: { id: true, originalName: true, mimeType: true, size: true, thumbnailUrl: true },
    orderBy: { updatedAt: "desc" }, take: 10,
  });
}

export async function getPostList(viewerId: string, page = 1, limit = 20) {
  const [posts, total] = await Promise.all([
    prisma.post.findMany({
      where: { visibility: { in: ["PUBLIC", "SHARED"] } },
      select: {
        id: true, title: true, content: true, createdAt: true,
        user: { select: { id: true, name: true } },
        _count: { select: { comments: true, likes: true } },
        likes:     { where: { userId: viewerId }, select: { id: true } },
        bookmarks: { where: { userId: viewerId }, select: { id: true } },
      },
      orderBy: { createdAt: "desc" }, skip: (page - 1) * limit, take: limit,
    }),
    prisma.post.count({ where: { visibility: { in: ["PUBLIC", "SHARED"] } } }),
  ]);
  return {
    posts: posts.map((p) => ({ ...p, liked: p.likes.length > 0, bookmarked: p.bookmarks.length > 0, likes: undefined, bookmarks: undefined })),
    total, hasMore: page * limit < total,
  };
}

// ⚠️ Notification 스키마: title/body (message 필드 없음)
export async function getNotifications(userId: string, limit = 20) {
  return withCache(`notifications:${userId}:${limit}`,
    () => prisma.notification.findMany({
      where: { userId }, orderBy: { createdAt: "desc" }, take: limit,
      select: { id: true, type: true, title: true, body: true, link: true, isRead: true, createdAt: true },
    }),
    TTL.SHORT, [`user:${userId}:notifications`]
  );
}

export async function globalSearch(userId: string, q: string, limit = 30) {
  if (!q.trim()) return { files: [], posts: [], users: [] };
  const chunk = Math.floor(limit / 3);
  const [files, posts, users] = await Promise.all([
    prisma.file.findMany({ where: { userId, deletedAt: null, originalName: { contains: q, mode: "insensitive" } }, select: { id: true, originalName: true, mimeType: true, size: true, thumbnailUrl: true }, take: chunk }),
    prisma.post.findMany({ where: { visibility: { in: ["PUBLIC", "SHARED"] }, OR: [{ title: { contains: q, mode: "insensitive" } }, { content: { contains: q, mode: "insensitive" } }] }, select: { id: true, title: true, content: true, user: { select: { id: true, name: true } } }, take: chunk }),
    prisma.user.findMany({ where: { id: { not: userId }, name: { contains: q, mode: "insensitive" } }, select: { id: true, name: true, isOnline: true }, take: chunk }),
  ]);
  return { files, posts, users };
}

export async function getAdminStats() {
  return withCache("admin:stats:summary", async () => {
    const [totalUsers, totalFiles, storage] = await Promise.all([
      prisma.user.count(),
      prisma.file.count({ where: { deletedAt: null } }),
      prisma.file.aggregate({ _sum: { size: true }, where: { deletedAt: null } }),
    ]);
    return { totalUsers, totalFiles, totalStorage: storage._sum.size?.toString() ?? "0" };
  }, TTL.LONG, ["admin-stats"]);
}
</file>

<file path="src/lib/request-logger.ts">
// src/lib/request-logger.ts
// API route 요청/응답 로깅 + 슬로우 쿼리 감지 미들웨어

import { NextRequest, NextResponse } from "next/server";
import logger from "@/lib/logger";

const SLOW_THRESHOLD_MS = 1000; // 1초 이상은 경고

interface RequestLogMeta {
  method:     string;
  url:        string;
  status:     number;
  durationMs: number;
  userId?:    string;
  ip?:        string;
  userAgent?: string;
}

/**
 * API Route 핸들러를 감싸는 로깅 래퍼
 *
 * 사용법:
 * export const GET = withRequestLog(async (req) => {
 *   ...
 *   return NextResponse.json({ ... });
 * });
 */
export function withRequestLog<T extends unknown[]>(
  handler: (req: NextRequest, ...args: T) => Promise<NextResponse>
) {
  return async (req: NextRequest, ...args: T): Promise<NextResponse> => {
    const start  = Date.now();
    const method = req.method;
    const url    = req.nextUrl.pathname + req.nextUrl.search;
    const ip     = req.headers.get("x-forwarded-for") ?? req.headers.get("x-real-ip") ?? "unknown";
    const ua     = req.headers.get("user-agent") ?? "";

    let response: NextResponse;
    let status = 500;

    try {
      response = await handler(req, ...args);
      status   = response.status;
    } catch (err: any) {
      const durationMs = Date.now() - start;
      logger.error("API 핸들러 예외", {
        method, url, durationMs, ip,
        error: err?.message,
        stack: err?.stack,
      });
      // 표준 에러 응답 반환
      return NextResponse.json(
        { success: false, error: "서버 오류가 발생했습니다", code: "INTERNAL_ERROR" },
        { status: 500 }
      );
    }

    const durationMs = Date.now() - start;
    const meta: RequestLogMeta = { method, url, status, durationMs, ip, userAgent: ua };

    if (durationMs >= SLOW_THRESHOLD_MS) {
      logger.warn(`🐢 슬로우 응답 [${durationMs}ms]`, meta);
    } else if (status >= 500) {
      logger.error(`❌ 서버 에러 [${status}]`, meta);
    } else if (status >= 400) {
      logger.warn(`⚠️  클라이언트 에러 [${status}]`, meta);
    } else {
      logger.debug(`✅ ${method} ${url} [${status}] ${durationMs}ms`, meta);
    }

    return response;
  };
}

/**
 * 슬로우 DB 쿼리 감지용 Prisma 미들웨어
 * prisma/client.ts 또는 src/lib/db.ts에 추가
 *
 * prisma.$use(async (params, next) => {
 *   const before = Date.now();
 *   const result = await next(params);
 *   const after  = Date.now();
 *   const ms     = after - before;
 *   if (ms > 500) {
 *     logger.warn("🐢 슬로우 DB 쿼리", {
 *       model:  params.model,
 *       action: params.action,
 *       ms,
 *     });
 *   }
 *   return result;
 * });
 */
</file>

<file path="src/lib/socket-client.ts">
// src/lib/socket-client.ts
// 클라이언트 사이드 소켓 싱글턴 + React 훅

import { useEffect, useRef, useState, useCallback } from "react";
import { io, type Socket } from "socket.io-client";
import { useSession } from "next-auth/react";

// ── 싱글턴 소켓 ──────────────────────────────────────────
let _socket: Socket | null = null;

export function getSocket(): Socket {
  if (!_socket) {
    _socket = io({ path: "/api/socket", transports: ["websocket", "polling"], autoConnect: false });
  }
  return _socket;
}

// ── 전역 소켓 연결 훅 (providers에서 한 번만 사용) ─────────
export function useSocketConnection() {
  const { data: session, status } = useSession();
  const [connected, setConnected] = useState(false);

  useEffect(() => {
    if (status !== "authenticated") return;
    const socket = getSocket();

    if (!socket.connected) socket.connect();

    const onConnect    = () => setConnected(true);
    const onDisconnect = () => setConnected(false);

    socket.on("connect",    onConnect);
    socket.on("disconnect", onDisconnect);
    if (socket.connected) setConnected(true);

    return () => {
      socket.off("connect",    onConnect);
      socket.off("disconnect", onDisconnect);
    };
  }, [status]);

  return connected;
}

// ── 실시간 알림 훅 ────────────────────────────────────────
export function useSocketNotifications(
  onNew: (n: { type: string; message: string; createdAt: string }) => void
) {
  useEffect(() => {
    const socket = getSocket();
    socket.on("notification:new", onNew);
    return () => { socket.off("notification:new", onNew); };
  }, [onNew]);
}

// ── 채팅 타이핑 인디케이터 훅 ─────────────────────────────
interface TypingState {
  [userId: string]: boolean;
}
export function useTypingIndicator(roomId: string | null) {
  const [typingUsers, setTypingUsers] = useState<TypingState>({});
  const typingTimer = useRef<Record<string, NodeJS.Timeout>>({});

  useEffect(() => {
    if (!roomId) return;
    const socket = getSocket();
    socket.emit("chat:join", roomId);

    const handler = ({ userId, isTyping }: { userId: string; roomId: string; isTyping: boolean }) => {
      setTypingUsers((prev) => ({ ...prev, [userId]: isTyping }));
      // 5초 후 자동으로 타이핑 해제
      if (isTyping) {
        clearTimeout(typingTimer.current[userId]);
        typingTimer.current[userId] = setTimeout(() => {
          setTypingUsers((prev) => ({ ...prev, [userId]: false }));
        }, 5000);
      }
    };

    socket.on("chat:typing:update", handler);
    return () => {
      socket.emit("chat:leave", roomId);
      socket.off("chat:typing:update", handler);
    };
  }, [roomId]);

  const startTyping = useCallback(() => {
    if (!roomId) return;
    getSocket().emit("chat:typing:start", { roomId });
  }, [roomId]);

  const stopTyping = useCallback(() => {
    if (!roomId) return;
    getSocket().emit("chat:typing:stop", { roomId });
  }, [roomId]);

  const typingUserIds = Object.entries(typingUsers)
    .filter(([, v]) => v)
    .map(([k]) => k);

  return { typingUserIds, startTyping, stopTyping };
}

// ── 업로드 진행률 훅 ─────────────────────────────────────
interface UploadProgress {
  fileId: string;
  filename: string;
  progress: number;
}
export function useUploadProgress() {
  const [uploads, setUploads] = useState<Record<string, UploadProgress>>({});

  useEffect(() => {
    const socket = getSocket();
    const onProgress = ({ fileId, filename, progress }: UploadProgress) => {
      setUploads((prev) => ({ ...prev, [fileId]: { fileId, filename, progress } }));
    };
    const onDone = ({ fileId }: { fileId: string }) => {
      setUploads((prev) => {
        const next = { ...prev };
        delete next[fileId];
        return next;
      });
    };
    socket.on("upload:progress:update", onProgress);
    socket.on("upload:done:update",     onDone);
    return () => {
      socket.off("upload:progress:update", onProgress);
      socket.off("upload:done:update",     onDone);
    };
  }, []);

  const broadcastProgress = useCallback((fileId: string, filename: string, progress: number) => {
    getSocket().emit("upload:progress", { fileId, progress, filename });
    if (progress >= 100) getSocket().emit("upload:done", { fileId, filename });
  }, []);

  return { uploads: Object.values(uploads), broadcastProgress };
}

// ── 프레즌스 훅 ──────────────────────────────────────────
export function usePresence(userIds: string[]) {
  const [onlineUsers, setOnlineUsers] = useState<Set<string>>(new Set());

  useEffect(() => {
    const socket = getSocket();
    const handler = ({ userId, isOnline }: { userId: string; isOnline: boolean }) => {
      setOnlineUsers((prev) => {
        const next = new Set(prev);
        isOnline ? next.add(userId) : next.delete(userId);
        return next;
      });
    };
    socket.on("presence:update", handler);
    return () => { socket.off("presence:update", handler); };
  }, []);

  return { isOnline: (userId: string) => onlineUsers.has(userId) };
}
</file>

<file path="src/lib/sound.ts">
// src/lib/sound.ts
// Web Audio API 기반 알림 사운드 — 외부 파일 불필요
// 브라우저 내에서 직접 소리 합성

type SoundType = "message" | "notification" | "success" | "error" | "call";

let ctx: AudioContext | null = null;

function getCtx(): AudioContext {
  if (!ctx || ctx.state === "closed") {
    ctx = new (window.AudioContext || (window as any).webkitAudioContext)();
  }
  if (ctx.state === "suspended") ctx.resume();
  return ctx;
}

function playTone(
  frequency: number,
  duration: number,
  type: OscillatorType = "sine",
  volume = 0.3,
  delay = 0
): void {
  const ac  = getCtx();
  const osc = ac.createOscillator();
  const gain = ac.createGain();

  osc.connect(gain);
  gain.connect(ac.destination);

  osc.type = type;
  osc.frequency.setValueAtTime(frequency, ac.currentTime + delay);

  gain.gain.setValueAtTime(0, ac.currentTime + delay);
  gain.gain.linearRampToValueAtTime(volume, ac.currentTime + delay + 0.01);
  gain.gain.exponentialRampToValueAtTime(0.001, ac.currentTime + delay + duration);

  osc.start(ac.currentTime + delay);
  osc.stop(ac.currentTime + delay + duration + 0.01);
}

const SOUNDS: Record<SoundType, () => void> = {
  // 채팅 메시지: 맑은 두 음
  message: () => {
    playTone(880, 0.08, "sine", 0.2);
    playTone(1200, 0.1, "sine", 0.15, 0.09);
  },
  // 알림: 부드러운 핑
  notification: () => {
    playTone(660, 0.15, "sine", 0.25);
    playTone(880, 0.12, "sine", 0.2, 0.1);
  },
  // 성공: 상승 3음
  success: () => {
    playTone(523, 0.1, "sine", 0.2);
    playTone(659, 0.1, "sine", 0.2, 0.1);
    playTone(784, 0.15, "sine", 0.2, 0.2);
  },
  // 에러: 낮은 두 음
  error: () => {
    playTone(220, 0.15, "sawtooth", 0.15);
    playTone(180, 0.2, "sawtooth", 0.12, 0.12);
  },
  // 통화 수신: 반복 링 (3회)
  call: () => {
    [0, 0.6, 1.2].forEach((delay) => {
      playTone(480, 0.3, "sine", 0.3, delay);
      playTone(380, 0.3, "sine", 0.25, delay + 0.02);
    });
  },
};

// ── 설정 ──────────────────────────────────────────────────
const PREF_KEY = "eum_sound_enabled";

export function isSoundEnabled(): boolean {
  try { return localStorage.getItem(PREF_KEY) !== "false"; } catch { return true; }
}
export function setSoundEnabled(on: boolean) {
  try { localStorage.setItem(PREF_KEY, on ? "true" : "false"); } catch {}
}

// ── 공개 API ─────────────────────────────────────────────
export function playSound(type: SoundType) {
  if (typeof window === "undefined") return;
  if (!isSoundEnabled()) return;
  try { SOUNDS[type]?.(); } catch {}
}

export const sound = {
  message:      () => playSound("message"),
  notification: () => playSound("notification"),
  success:      () => playSound("success"),
  error:        () => playSound("error"),
  call:         () => playSound("call"),
};
</file>

<file path="src/lib/storage-guard.ts">
// src/lib/storage-guard.ts
import { prisma } from "@/lib/db";

export async function checkStorageLimit(userId: string, newFileSize: number) {
  // 1. 사용자의 용량 제한 및 현재 사용량 조회
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { storageLimit: true },
  });

  if (!user) throw new Error("사용자를 찾을 수 없습니다.");

  // 2. 현재 총 사용량 계산 (_sum.size는 BigInt를 반환함)
  const storageUsed = await prisma.file.aggregate({
    where: { userId },
    _sum: { size: true },
  });

  const used = storageUsed._sum.size || BigInt(0);
  const limit = user.storageLimit; // DB의 BigInt 타입
  const remaining = limit - used;

  return {
    // 모든 반환 값을 BigInt로 통일하거나, 비교 결과만 반환
    allowed: remaining >= BigInt(newFileSize),
    used: used,
    limit: limit,
    remaining: remaining,
  };
}

/**
 * 용량 단위를 사람이 읽기 편한 문자열로 변환 (BigInt 대응)
 */
export function formatBytes(bytes: bigint | number, decimals = 2) {
  const b = BigInt(bytes);
  if (b === BigInt(0)) return "0 Bytes";

  const k = BigInt(1024);
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB"];

  // BigInt 계산을 위해 숫자로 변환하여 지수 계산
  const i = Math.floor(Math.log(Number(b)) / Math.log(1024));

  return (
    parseFloat((Number(b) / Math.pow(1024, i)).toFixed(dm)) + " " + sizes[i]
  );
}
</file>

<file path="src/lib/validators.ts">
// src/lib/validators.ts
// Zod 기반 API 입력값 스키마 정의
// npm install zod

import { z } from "zod";
import { NextRequest } from "next/server";
import { ApiError } from "@/lib/api-response";
import type { NextResponse } from "next/server";

// ── 공통 스키마 ──────────────────────────────────────────
export const paginationSchema = z.object({
  page:  z.coerce.number().int().min(1).default(1),
  limit: z.coerce.number().int().min(1).max(100).default(20),
});

export const idSchema = z.string().cuid({ message: "유효하지 않은 ID입니다" });

// ── 인증 ─────────────────────────────────────────────────
export const registerSchema = z.object({
  name:     z.string().min(2, "이름은 2자 이상이어야 합니다").max(50),
  email:    z.string().email("올바른 이메일 형식이 아닙니다"),
  password: z.string()
    .min(8,  "비밀번호는 8자 이상이어야 합니다")
    .max(100)
    .regex(/[A-Z]/,  "대문자를 포함해야 합니다")
    .regex(/[0-9]/,  "숫자를 포함해야 합니다")
    .regex(/[^A-Za-z0-9]/, "특수문자를 포함해야 합니다"),
});

export const loginSchema = z.object({
  email:    z.string().email(),
  password: z.string().min(1),
});

export const changePasswordSchema = z.object({
  currentPassword: z.string().min(1, "현재 비밀번호를 입력해주세요"),
  newPassword:     z.string().min(8, "새 비밀번호는 8자 이상이어야 합니다"),
}).refine((d) => d.currentPassword !== d.newPassword, {
  message: "새 비밀번호는 현재 비밀번호와 달라야 합니다",
  path:    ["newPassword"],
});

// ── 파일 ─────────────────────────────────────────────────
export const fileUploadSchema = z.object({
  folderId: z.string().cuid().optional().nullable(),
});

export const fileEncryptSchema = z.object({
  password: z.string().min(4, "비밀번호는 4자 이상이어야 합니다").max(100),
});

export const fileVersionSchema = z.object({
  comment: z.string().max(200).optional(),
});

// ── 게시글 ───────────────────────────────────────────────
export const createPostSchema = z.object({
  title:      z.string().min(1, "제목을 입력해주세요").max(200),
  content:    z.string().min(1, "내용을 입력해주세요").max(50_000),
  visibility: z.enum(["PUBLIC", "PRIVATE", "SHARED"]).default("PUBLIC"),
  tags:       z.array(z.string().max(30)).max(10).optional(),
});

export const createCommentSchema = z.object({
  content:    z.string().min(1, "댓글을 입력해주세요").max(2000),
  mentionIds: z.array(z.string().cuid()).max(20).optional(),
});

// ── 채팅 ─────────────────────────────────────────────────
export const createRoomSchema = z.object({
  name:        z.string().min(1).max(100).optional(),
  memberIds:   z.array(z.string().cuid()).min(1).max(50),
  type:        z.enum(["DIRECT", "GROUP"]).default("DIRECT"),
});

export const sendMessageSchema = z.object({
  type:     z.enum(["TEXT", "FILE", "SYSTEM"]).default("TEXT"),
  content:  z.string().max(10_000).optional(),
  fileId:   z.string().cuid().optional(),
}).refine((d) => d.content || d.fileId, {
  message: "메시지 내용 또는 파일이 필요합니다",
});

// ── 알림 설정 ─────────────────────────────────────────────
export const notificationSettingsSchema = z.object({
  emailNotifications:  z.boolean().optional(),
  pushNotifications:   z.boolean().optional(),
  chatNotifications:   z.boolean().optional(),
  mentionNotifications: z.boolean().optional(),
});

// ── API 키 ────────────────────────────────────────────────
export const createApiKeySchema = z.object({
  name:           z.string().min(1, "이름을 입력해주세요").max(100),
  scopes:         z.array(z.string()).min(1, "권한을 하나 이상 선택해주세요"),
  expiresInDays:  z.number().int().min(0).max(365).optional(),
});

// ── 시스템 공지 ───────────────────────────────────────────
export const createNoticeSchema = z.object({
  title:    z.string().min(1).max(200),
  content:  z.string().min(1).max(5000),
  type:     z.enum(["INFO", "WARNING", "MAINTENANCE"]).default("INFO"),
  startsAt: z.string().datetime().optional(),
  endsAt:   z.string().datetime().optional(),
});

// ── 유효성 검사 헬퍼 ─────────────────────────────────────
/**
 * request body를 파싱하고 Zod 스키마로 검증
 * 실패 시 422 응답 반환 (NextResponse)
 */
export async function parseBody<T>(
  request:  NextRequest,
  schema:   z.ZodSchema<T>
): Promise<{ data: T; error: null } | { data: null; error: NextResponse }> {
  let raw: unknown;
  try {
    raw = await request.json();
  } catch {
    return { data: null, error: ApiError.validation("요청 본문이 유효한 JSON이 아닙니다") };
  }

  const result = schema.safeParse(raw);
  if (!result.success) {
    const details = result.error.errors.map((e) => ({
      field:   e.path.join("."),
      message: e.message,
    }));
    return {
      data:  null,
      error: ApiError.validation(details[0]?.message ?? "입력값이 올바르지 않습니다", details),
    };
  }

  return { data: result.data, error: null };
}

/**
 * URL 쿼리 파라미터 검증
 */
export function parseQuery<T>(
  request: NextRequest,
  schema:  z.ZodSchema<T>
): { data: T; error: null } | { data: null; error: NextResponse } {
  const params = Object.fromEntries(new URL(request.url).searchParams);
  const result = schema.safeParse(params);
  if (!result.success) {
    const details = result.error.errors.map((e) => ({
      field:   e.path.join("."),
      message: e.message,
    }));
    return { data: null, error: ApiError.validation("쿼리 파라미터가 올바르지 않습니다", details) };
  }
  return { data: result.data, error: null };
}
</file>

<file path="src/middleware.ts">
// src/middleware.ts (또는 루트의 middleware.ts)
// 로그인이 필요한 모든 페이지를 일괄 보호
// NextAuth JWT 기반 — 별도 DB 조회 없이 엣지에서 처리

import { getToken } from "next-auth/jwt";
import { NextRequest, NextResponse } from "next/server";

// ── 보호가 필요한 경로 패턴 ──────────────────────────────
const PROTECTED_PATHS = [
  "/dashboard",
  "/chat",
  "/files",
  "/profile",
  "/settings",
  "/notifications",
  "/trash",
  "/search",
  "/posts",
  "/users",
  "/admin",
  "/shared",
];

// ── 관리자 전용 경로 ─────────────────────────────────────
const ADMIN_PATHS = ["/admin"];

// ── 공개 경로 (로그인 상태에서 접근 시 대시보드 리디렉션) ─
const PUBLIC_ONLY_PATHS = ["/login", "/register"];

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;

  // 정적 파일, API 인증 엔드포인트는 스킵
  if (
    pathname.startsWith("/_next") ||
    pathname.startsWith("/api/auth") ||
    pathname.startsWith("/api/share") ||   // 공개 파일 공유
    pathname.startsWith("/share") ||
    pathname.startsWith("/offline") ||
    pathname === "/" ||
    pathname === "/favicon.ico"
  ) {
    return NextResponse.next();
  }

  const token = await getToken({
    req: request,
    secret: process.env.NEXTAUTH_SECRET,
  });

  const isAuthenticated = !!token;
  const isAdmin = token?.role === "ADMIN";

  // ── 로그인 상태에서 공개 전용 페이지 접근 → 대시보드로 ─
  if (isAuthenticated && PUBLIC_ONLY_PATHS.some((p) => pathname.startsWith(p))) {
    return NextResponse.redirect(new URL("/dashboard", request.url));
  }

  // ── 보호된 페이지 접근 ────────────────────────────────
  const isProtected = PROTECTED_PATHS.some((p) => pathname.startsWith(p));
  if (isProtected && !isAuthenticated) {
    const loginUrl = new URL("/login", request.url);
    loginUrl.searchParams.set("callbackUrl", pathname);
    return NextResponse.redirect(loginUrl);
  }

  // ── 관리자 페이지 접근 ────────────────────────────────
  const isAdminPath = ADMIN_PATHS.some((p) => pathname.startsWith(p));
  if (isAdminPath && !isAdmin) {
    return NextResponse.redirect(new URL("/dashboard?error=unauthorized", request.url));
  }

  // ── 정지된 사용자 차단 ────────────────────────────────
  // token에 isBanned 커스텀 클레임을 포함시켜야 함 (authOptions의 jwt callback에서 처리)
  if (token?.isBanned && isProtected) {
    const bannedUrl = new URL("/banned", request.url);
    return NextResponse.redirect(bannedUrl);
  }

  return NextResponse.next();
}

export const config = {
  matcher: [
    /*
     * 다음 경로를 제외한 모든 요청에 적용:
     * - api/auth (NextAuth 자체 라우트)
     * - _next/static, _next/image (정적 파일)
     * - favicon.ico
     */
    "/((?!api/auth|_next/static|_next/image|favicon.ico).*)",
  ],
};
</file>

<file path="src/types/next-auth.d.ts">
// src/types/next-auth.d.ts
import { DefaultSession } from "next-auth";

declare module "next-auth" {
  interface Session {
    user: {
      id:       string;
      role:     string;
      isBanned: boolean;
    } & DefaultSession["user"];
  }

  interface User {
    id:       string;
    email:    string;
    name:     string;
    role:     string;
    isBanned: boolean;
  }
}

declare module "next-auth/jwt" {
  interface JWT {
    id:       string;
    role:     string;
    isBanned: boolean;
  }
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ESNext",         /* 수정: 최신 JavaScript 문법 지원 */
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,             /* 유지: 기본적인 엄격함은 유지 */
    
    /* 👇 빌드 에러를 한 번에 해결하기 위해 추가해야 할 핵심 옵션 */
    "noImplicitAny": false,     /* (x), (f) 같은 인자에 타입을 안 써도 통과 */
    "strictNullChecks": false,  /* params가 null일 수 있다는 에러를 무시 */
    
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/app/api/auth/[...nextauth]/route": ["./src/lib/auth"],
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules", "e2e"]
}
</file>

<file path="src/app/api/admin/stats/route.ts">
// src/app/api/admin/stats/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function GET() {
  const session = await getServerSession(authOptions);
  if (!session?.user || session.user.role !== "ADMIN")
    return NextResponse.json({ error: "관리자 권한이 필요합니다" }, { status: 403 });

  const thirtyDaysAgo = new Date(Date.now() - 30 * 86400000);

  const [
    totalUsers, activeUsers, bannedUsers,
    totalFiles, totalStorage,
    totalPosts, totalComments,
    newUsersLast30, newFilesLast30,
    storageByUser, filesByType, dailySignups, dailyUploads,
  ] = await Promise.all([
    prisma.user.count(),
    prisma.user.count({ where: { isOnline: true } }),
    prisma.user.count({ where: { isBanned: true } }),
    prisma.file.count({ where: { deletedAt: null } }),
    prisma.file.aggregate({ _sum: { size: true }, where: { deletedAt: null } }),
    prisma.post.count(),
    prisma.comment.count(),
    prisma.user.count({ where: { createdAt: { gte: thirtyDaysAgo } } }),
    prisma.file.count({ where: { createdAt: { gte: thirtyDaysAgo }, deletedAt: null } }),
    prisma.file.groupBy({ by: ["userId"], _sum: { size: true }, orderBy: { _sum: { size: "desc" } }, take: 10 }),
    prisma.$queryRaw<{ type: string; count: bigint; size: bigint }[]>`
      SELECT CASE WHEN "mime_type" LIKE 'image/%' THEN '이미지' WHEN "mime_type" LIKE 'video/%' THEN '영상' WHEN "mime_type" LIKE 'audio/%' THEN '오디오' WHEN "mime_type" = 'application/pdf' THEN 'PDF' ELSE '기타' END AS type, COUNT(*) AS count, SUM(size) AS size FROM files WHERE deleted_at IS NULL GROUP BY type ORDER BY count DESC`,
    prisma.$queryRaw<{ date: string; count: bigint }[]>`SELECT DATE("created_at") AS date, COUNT(*) AS count FROM users WHERE "created_at" >= NOW() - INTERVAL '14 days' GROUP BY DATE("created_at") ORDER BY date`,
    prisma.$queryRaw<{ date: string; count: bigint }[]>`SELECT DATE("created_at") AS date, COUNT(*) AS count FROM files WHERE "created_at" >= NOW() - INTERVAL '14 days' AND "deleted_at" IS NULL GROUP BY DATE("created_at") ORDER BY date`,
  ]);

  const userIds = storageByUser.map((x: any) => x.userId);
  const users = await prisma.user.findMany({ where: { id: { in: userIds } }, select: { id: true, name: true, email: true } });
  const userMap = Object.fromEntries(users.map((u: any) => [u.id, u]));

  return NextResponse.json({
  summary: { 
    totalUsers, activeUsers, bannedUsers, totalFiles, 
    totalStorage: totalStorage._sum.size?.toString() ?? "0", 
    totalPosts, totalComments, newUsersLast30, newFilesLast30 
  },
  // (x)를 (x: any)로 수정하여 타입을 명시합니다.
  topStorageUsers: storageByUser.map((x: any) => ({ 
    ...userMap[x.userId], 
    storageUsed: x._sum.size?.toString() ?? "0" 
  })),
  filesByType: filesByType.map((x: any) => ({ 
    type: x.type, 
    count: Number(x.count), 
    size: x.size.toString() 
  })),
  dailySignups: dailySignups.map((x: any) => ({ 
    date: x.date, 
    count: Number(x.count) 
  })),
  dailyUploads: dailyUploads.map((x: any) => ({ 
    date: x.date, 
    count: Number(x.count) 
  })),
});
}
</file>

<file path="src/app/api/notifications/preferences/route.ts">
// src/app/api/notifications/preferences/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import {
  NotificationPreferences,
  DEFAULT_PREFS,
} from "@/lib/notification-prefs";

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { notificationPrefs: true },
    });

    // ✅ JsonValue → unknown → NotificationPreferences 변환
    const rawPrefs = user?.notificationPrefs as unknown;

    const prefs: NotificationPreferences =
      rawPrefs && typeof rawPrefs === "object"
        ? { ...DEFAULT_PREFS, ...(rawPrefs as Partial<NotificationPreferences>) }
        : DEFAULT_PREFS;

    return NextResponse.json({ prefs });
  } catch (error) {
    console.error("GET /api/notifications/preferences error:", error);
    return NextResponse.json({ error: "서버 오류" }, { status: 500 });
  }
}

export async function PATCH(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: "인증이 필요합니다" },
        { status: 401 }
      );
    }

    const body = await request.json();

    const allowedKeys = Object.keys(
      DEFAULT_PREFS
    ) as (keyof NotificationPreferences)[];

    const updatedPrefs: Partial<NotificationPreferences> = {};

    for (const key of allowedKeys) {
      if (typeof body[key] === "boolean") {
        updatedPrefs[key] = body[key];
      }
    }

    await prisma.user.update({
      where: { id: session.user.id },
      data: {
        notificationPrefs: updatedPrefs,
      },
    });

    return NextResponse.json({
      prefs: { ...DEFAULT_PREFS, ...updatedPrefs },
    });
  } catch (error) {
    console.error("PATCH /api/notifications/preferences error:", error);
    return NextResponse.json({ error: "서버 오류" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/users/me/export/route.ts">
// src/app/api/users/me/export/route.ts
// ✅ 수정: export const dynamic = 'force-dynamic' 추가

export const dynamic = 'force-dynamic';

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
    }

    const userId = session.user.id;

    const [user, files, folders, posts, comments, notifications, activityLogs] =
      await Promise.all([
        prisma.user.findUnique({
          where: { id: userId },
          select: {
            id: true, name: true, email: true, role: true,
            emailVerified: true, createdAt: true, updatedAt: true,
            isOnline: true, lastSeenAt: true,
          },
        }),
        prisma.file.findMany({
          where: { userId },
          select: {
            id: true, originalName: true, mimeType: true,
            size: true, createdAt: true, folderId: true,
          },
          orderBy: { createdAt: "desc" },
        }),
        prisma.folder.findMany({
          where: { userId },
          select: { id: true, name: true, parentId: true, createdAt: true },
        }),
        prisma.post.findMany({
          where: { userId },
          select: {
            id: true, title: true, content: true,
            visibility: true, createdAt: true,
            comments: { select: { id: true, content: true, createdAt: true } },
          },
          orderBy: { createdAt: "desc" },
        }),
        prisma.comment.findMany({
          where: { userId },
          select: {
            id: true, content: true, createdAt: true,
            post: { select: { id: true, title: true } },
          },
          orderBy: { createdAt: "desc" },
        }),
        prisma.notification.findMany({
          where: { userId },
          select: { id: true, type: true, title: true, body: true, isRead: true, createdAt: true },
          orderBy: { createdAt: "desc" },
          take: 200,
        }),
        prisma.activityLog.findMany({
          where: { userId },
          select: { id: true, action: true, target: true, createdAt: true },
          orderBy: { createdAt: "desc" },
          take: 500,
        }).catch(() => []),
      ]);

    const exportData = {
      exportedAt: new Date().toISOString(),
      exportVersion: "1.0",
      user,
      summary: {
        fileCount: files.length,
        folderCount: folders.length,
        postCount: posts.length,
        commentCount: comments.length,
        notificationCount: notifications.length,
        activityLogCount: activityLogs.length,
      },
      files, folders, posts, comments, notifications, activityLogs,
    };

    const filename = `eum-data-export-${new Date().toISOString().split("T")[0]}.json`;

    return new NextResponse(JSON.stringify(exportData, null, 2), {
      headers: {
        "Content-Type": "application/json; charset=utf-8",
        "Content-Disposition": `attachment; filename="${filename}"`,
      },
    });
  } catch (error) {
    console.error("GET /api/users/me/export error:", error);
    return NextResponse.json({ error: "내보내기 중 오류가 발생했습니다" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/users/me/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { prisma } from "@/lib/db";
import bcrypt from "bcryptjs";

// GET /api/users/me — 현재 사용자 정보 + 스토리지 통계
export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
        emailVerified: true,
        createdAt: true,
        isOnline: true,
        _count: {
          select: {
            files: true,
            posts: true,
            comments: true,
          },
        },
      },
    });

    if (!user) {
      return NextResponse.json({ error: "사용자를 찾을 수 없습니다" }, { status: 404 });
    }

    // 스토리지 합계 계산
    const storageAgg = await prisma.file.aggregate({
      where: { userId: session.user.id },
      _sum: { size: true },
    });

    const totalBytes = Number(storageAgg._sum.size ?? 0);

    return NextResponse.json({
      user,
      stats: {
        totalFiles: user._count.files,
        totalPosts: user._count.posts,
        totalComments: user._count.comments,
        storageUsedBytes: totalBytes,
        storageUsedMB: (totalBytes / 1024 / 1024).toFixed(2),
      },
    });
  } catch (error) {
    console.error("GET /api/users/me error:", error);
    return NextResponse.json({ error: "서버 오류" }, { status: 500 });
  }
}

// PATCH /api/users/me — 이름 변경 또는 비밀번호 변경
export async function PATCH(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
    }

    const body = await request.json();
    const { name, currentPassword, newPassword } = body;

    const user = await prisma.user.findUnique({ where: { id: session.user.id } });
    if (!user) {
      return NextResponse.json({ error: "사용자를 찾을 수 없습니다" }, { status: 404 });
    }

    const updateData: Record<string, unknown> = {};

    // 이름 변경
    if (name !== undefined) {
      const trimmed = name.trim();
      if (!trimmed) {
        return NextResponse.json({ error: "이름을 입력해주세요" }, { status: 400 });
      }
      if (trimmed.length > 20) {
        return NextResponse.json({ error: "이름은 20자 이하여야 합니다" }, { status: 400 });
      }
      updateData.name = trimmed;
    }

    // 비밀번호 변경
    if (newPassword !== undefined) {
      if (!currentPassword) {
        return NextResponse.json({ error: "현재 비밀번호를 입력해주세요" }, { status: 400 });
      }
      const valid = await bcrypt.compare(currentPassword, user.passwordHash);
      if (!valid) {
        return NextResponse.json({ error: "현재 비밀번호가 올바르지 않습니다" }, { status: 400 });
      }
      if (newPassword.length < 8) {
        return NextResponse.json({ error: "새 비밀번호는 8자 이상이어야 합니다" }, { status: 400 });
      }
      updateData.passwordHash = await bcrypt.hash(newPassword, 12);
    }

    if (Object.keys(updateData).length === 0) {
      return NextResponse.json({ error: "변경할 정보가 없습니다" }, { status: 400 });
    }

    const updated = await prisma.user.update({
      where: { id: session.user.id },
      data: updateData,
      select: { id: true, name: true, email: true },
    });

    return NextResponse.json({ user: updated });
  } catch (error) {
    console.error("PATCH /api/users/me error:", error);
    return NextResponse.json({ error: "서버 오류" }, { status: 500 });
  }
}

// DELETE /api/users/me — 계정 영구 삭제 (본인)
export async function DELETE() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "인증이 필요합니다" }, { status: 401 });
    }

    // 관리자 계정은 삭제 불가 (최후의 보루)
    const user = await prisma.user.findUnique({ where: { id: session.user.id } });
    if (user?.role === "ADMIN") {
      const adminCount = await prisma.user.count({ where: { role: "ADMIN" } });
      if (adminCount <= 1) {
        return NextResponse.json(
          { error: "마지막 관리자 계정은 삭제할 수 없습니다" },
          { status: 400 }
        );
      }
    }

    // CASCADE로 파일, 게시글, 댓글 등 모두 삭제됨
    await prisma.user.delete({ where: { id: session.user.id } });

    return NextResponse.json({ message: "계정이 삭제되었습니다" });
  } catch (error) {
    console.error("DELETE /api/users/me error:", error);
    return NextResponse.json({ error: "서버 오류가 발생했습니다" }, { status: 500 });
  }
}
</file>

<file path="src/app/dashboard/page.tsx">
"use client";

import { useSession, signOut } from "next-auth/react";
import { useRouter, usePathname } from "next/navigation";
import { useEffect, useState, useCallback, useMemo } from "react";
import Link from "next/link";
import { Bell } from "lucide-react";
import ThemeToggle from "@/components/ThemeToggle";
import { toast } from "@/components/Toast";
import { useConfirm } from "@/components/ConfirmDialog";
import { getFileIcon, getFileColor, formatFileSize } from "@/lib/client-utils";
import FilePreviewModal from "@/components/FilePreviewModal";

// 🔔 알림 벨 컴포넌트 (헤더용)
function NotificationBell() {
  const [unread, setUnread] = useState(0);

  useEffect(() => {
    fetch("/api/notifications?unread=true")
      .then((r) => r.json())
      .then((d) => setUnread(d.unreadCount ?? 0))
      .catch(() => {});

    // 30초마다 폴링
    const timer = setInterval(() => {
      fetch("/api/notifications?unread=true")
        .then((r) => r.json())
        .then((d) => setUnread(d.unreadCount ?? 0))
        .catch(() => {});
    }, 30000);
    return () => clearInterval(timer);
  }, []);

  return (
    <Link
      href="/notifications"
      className="relative p-2 rounded-lg hover:bg-slate-100 transition-colors"
      title="알림"
    >
      <Bell size={18} className="text-slate-600" />
      {unread > 0 && (
        <span className="absolute -top-0.5 -right-0.5 min-w-[16px] h-4 px-1 bg-red-500 text-white text-[9px] font-bold rounded-full flex items-center justify-center">
          {unread > 99 ? "99+" : unread}
        </span>
      )}
    </Link>
  );
}

interface Folder {
  id: string;
  name: string;
  userId: string;
  _count: { files: number };
}

interface Tag { id: string; name: string; color: string | null; }

interface FileItem {
  id: string;
  filename: string;
  originalName: string;
  size: string;
  mimeType: string;
  thumbnailUrl: string | null;
  createdAt: string;
  folderId: string | null;
  userId: string;
  fileTags?: { tag: Tag }[];
}

interface BreadcrumbItem { id: string | null; name: string; }

export default function DashboardPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const pathname = usePathname();
  // ✅ confirm() 대체
  const { confirmDialog, openConfirm } = useConfirm();

  const [currentFolderId, setCurrentFolderId] = useState<string | null>(null);
  const [folders, setFolders] = useState<Folder[]>([]);
  const [files, setFiles] = useState<FileItem[]>([]);
  const [breadcrumb, setBreadcrumb] = useState<BreadcrumbItem[]>([{ id: null, name: "홈" }]);
  const [loading, setLoading] = useState(true);
  const [searchQuery, setSearchQuery] = useState("");

  const [showFolderModal, setShowFolderModal] = useState(false);
  const [showFileDetail, setShowFileDetail] = useState(false);
  const [showShareModal, setShowShareModal] = useState(false);
  const [selectedFile, setSelectedFile] = useState<FileItem | null>(null);
  const [selectedFolder, setSelectedFolder] = useState<Folder | null>(null);
  const [shareType, setShareType] = useState<"FILE" | "FOLDER">("FILE");

  const [newFolderName, setNewFolderName] = useState("");
  const [shareEmail, setShareEmail] = useState("");
  const [sharePermission, setSharePermission] = useState<"VIEW" | "EDIT">("VIEW");
  const [newTagName, setNewTagName] = useState("");
  const [isSharing, setIsSharing] = useState(false);

  const [uploading, setUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);

  const fetchData = useCallback(async () => {
    setLoading(true);
    try {
      const folderUrl = currentFolderId ? `/api/folders?parentId=${currentFolderId}` : `/api/folders`;
      const fileUrl = currentFolderId ? `/api/files?folderId=${currentFolderId}` : `/api/files?folderId=null`;
      const [fRes, fileRes] = await Promise.all([fetch(folderUrl), fetch(fileUrl)]);
      if (fRes.ok) setFolders((await fRes.json()).folders || []);
      if (fileRes.ok) setFiles((await fileRes.json()).files || []);
    } catch (err) {
      console.error(err);
      toast.error("데이터를 불러오는데 실패했습니다");
    } finally {
      setLoading(false);
    }
  }, [currentFolderId]);

  useEffect(() => {
    if (status === "unauthenticated") router.push("/login");
    if (session) fetchData();
  }, [status, session, fetchData, router]);

  const displayedFiles = useMemo(
    () => files.filter((f) => f.originalName.toLowerCase().includes(searchQuery.toLowerCase())),
    [files, searchQuery]
  );

  const handleFolderClick = (f: Folder) => {
    setCurrentFolderId(f.id);
    setBreadcrumb([...breadcrumb, { id: f.id, name: f.name }]);
  };

  const handleBreadcrumbClick = (idx: number) => {
    const next = breadcrumb.slice(0, idx + 1);
    setBreadcrumb(next);
    setCurrentFolderId(next[next.length - 1].id);
  };

  const handleCreateFolder = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newFolderName.trim()) return;
    const res = await fetch("/api/folders", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ name: newFolderName, parentId: currentFolderId }),
    });
    if (res.ok) {
      setNewFolderName("");
      setShowFolderModal(false);
      fetchData();
      // ✅ alert() → toast
      toast.success("폴더가 생성되었습니다");
    } else {
      toast.error("폴더 생성에 실패했습니다");
    }
  };

  const handleFileUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;
    setUploading(true);
    const fd = new FormData();
    fd.append("file", file);
    if (currentFolderId) fd.append("folderId", currentFolderId);

    const xhr = new XMLHttpRequest();
    xhr.upload.onprogress = (ev) => setUploadProgress((ev.loaded / ev.total) * 100);
    xhr.onload = () => {
      fetchData();
      setUploading(false);
      setUploadProgress(0);
      if (xhr.status >= 200 && xhr.status < 300) {
        toast.success("파일이 업로드되었습니다");
      } else {
        toast.error("업로드에 실패했습니다");
      }
    };
    xhr.onerror = () => {
      setUploading(false);
      toast.error("업로드 중 오류가 발생했습니다");
    };
    xhr.open("POST", "/api/files/upload");
    xhr.send(fd);
    // input 초기화 (같은 파일 재업로드 가능하도록)
    e.target.value = "";
  };

  const handleDeleteFolder = (id: string) => {
    // ✅ confirm() → ConfirmDialog
    openConfirm({
      title: "폴더 삭제",
      message: "폴더를 삭제하면 되돌릴 수 없습니다. 삭제하시겠습니까?",
      confirmLabel: "삭제",
      variant: "danger",
      onConfirm: async () => {
        const res = await fetch(`/api/folders/${id}`, { method: "DELETE" });
        if (res.ok) {
          fetchData();
          toast.success("폴더가 삭제되었습니다");
        } else {
          toast.error("삭제 권한이 없거나 오류가 발생했습니다");
        }
      },
    });
  };

  const handleDeleteFile = (id: string) => {
    // ✅ confirm() → ConfirmDialog
    openConfirm({
      title: "파일 삭제",
      message: "파일을 삭제하면 되돌릴 수 없습니다. 삭제하시겠습니까?",
      confirmLabel: "삭제",
      variant: "danger",
      onConfirm: async () => {
        const res = await fetch(`/api/files/${id}`, { method: "DELETE" });
        if (res.ok) {
          setShowFileDetail(false);
          fetchData();
          toast.success("파일이 삭제되었습니다");
        } else {
          toast.error("파일 삭제에 실패했습니다");
        }
      },
    });
  };

  const handleAddTag = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!selectedFile || !newTagName.trim()) return;
    const res = await fetch(`/api/files/${selectedFile.id}/tags`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ tagName: newTagName }),
    });
    if (res.ok) {
      const tagData = await res.json();
      setSelectedFile({ ...selectedFile, fileTags: [...(selectedFile.fileTags || []), { tag: tagData }] });
      setNewTagName("");
      fetchData();
    } else {
      toast.error("태그 추가에 실패했습니다");
    }
  };

  const handleShare = async (e: React.FormEvent) => {
    e.preventDefault();
    const resourceId = shareType === "FILE" ? selectedFile?.id : selectedFolder?.id;
    if (!resourceId) return;
    setIsSharing(true);
    try {
      const res = await fetch("/api/share", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          resourceType: shareType,
          resourceId,
          sharedWithEmail: shareEmail,
          permission: sharePermission,
        }),
      });
      if (res.ok) {
        toast.success("공유가 완료되었습니다");
        setShowShareModal(false);
        setShareEmail("");
      } else {
        const data = await res.json();
        toast.error(data.error || "공유에 실패했습니다");
      }
    } catch {
      toast.error("공유 중 오류가 발생했습니다");
    } finally {
      setIsSharing(false);
    }
  };

  if (status === "loading") {
    return <div className="h-screen flex items-center justify-center font-bold">로딩 중...</div>;
  }
  if (!session) return null;

  return (
    <div className="min-h-screen bg-[#F8F9FA] dark:bg-slate-900 flex flex-col text-slate-900 dark:text-slate-100 pb-20 md:pb-0">
      {/* ConfirmDialog 렌더링 */}
      {confirmDialog}

      {/* 헤더 */}
      <header className="bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700 dark:border-slate-700 sticky top-0 z-40 px-6 h-16 flex items-center justify-between shadow-sm">
        <div className="flex items-center gap-6">
          <h1 className="text-xl font-black text-blue-600 dark:text-blue-400">이음</h1>
          <nav className="flex items-center gap-4 text-xs font-bold text-slate-400 dark:text-slate-500 dark:text-slate-400 dark:text-slate-500 dark:text-slate-400">
            <Link href="/dashboard" className={pathname === "/dashboard" ? "text-blue-600" : ""}>파일</Link>
            <Link href="/posts" className={pathname === "/posts" ? "text-blue-600" : ""}>게시판</Link>
            <Link href="/chat" className={pathname === "/chat" ? "text-blue-600" : ""}>채팅</Link>
          </nav>
        </div>
        <div className="flex items-center gap-2">
          {/* 🔔 알림 벨 */}
          <NotificationBell />
          <ThemeToggle />
          {/* ✅ 이름 클릭 → 마이페이지 */}
          <Link
            href="/profile"
            className="text-[12px] font-black text-slate-600 dark:text-slate-300 bg-slate-100 dark:bg-slate-700 px-3 py-1.5 rounded-full hover:bg-slate-200 dark:hover:bg-slate-600 transition"
          >
            {session.user?.name}님
          </Link>
          <button
            onClick={() => signOut()}
            className="text-[11px] font-black bg-slate-900 dark:bg-slate-700 text-white px-3 py-2 rounded-lg hover:bg-slate-700 dark:hover:bg-slate-600 transition"
          >
            로그아웃
          </button>
        </div>
      </header>

      {/* 모바일 하단바 */}
      <div className="md:hidden fixed bottom-0 left-0 right-0 bg-white dark:bg-slate-800 border-t dark:border-slate-700 px-6 py-2 z-50 flex justify-around items-center shadow-lg">
        <Link href="/dashboard" className={`flex flex-col items-center gap-0.5 ${pathname === "/dashboard" ? "text-blue-600" : "text-gray-400"}`}>
          <span className="text-xl">📁</span>
          <span className="text-[9px] font-medium">파일</span>
        </Link>
        <Link href="/posts" className={`flex flex-col items-center gap-0.5 ${pathname === "/posts" ? "text-blue-600" : "text-gray-400"}`}>
          <span className="text-xl">📝</span>
          <span className="text-[9px] font-medium">게시판</span>
        </Link>
        <button
          onClick={() => setShowFolderModal(true)}
          className="w-12 h-12 bg-blue-600 text-white rounded-full flex items-center justify-center text-2xl -mt-6 border-4 border-white shadow-xl"
        >+</button>
        <Link href="/chat" className={`flex flex-col items-center gap-0.5 ${pathname === "/chat" ? "text-blue-600" : "text-gray-400"}`}>
          <span className="text-xl">💬</span>
          <span className="text-[9px] font-medium">채팅</span>
        </Link>
        <Link href="/profile" className={`flex flex-col items-center gap-0.5 ${pathname === "/profile" ? "text-blue-600" : "text-gray-400"}`}>
          <span className="text-xl">👤</span>
          <span className="text-[9px] font-medium">프로필</span>
        </Link>
      </div>

      {/* 경로 안내 */}
      <div className="bg-white border-b py-2.5 px-6 text-[10px] font-black text-slate-300">
        {breadcrumb.map((c, i) => (
          <span key={i}>
            {i > 0 && <span className="mx-2">/</span>}
            <button
              onClick={() => handleBreadcrumbClick(i)}
              className={i === breadcrumb.length - 1 ? "text-slate-800" : "hover:text-slate-600"}
            >
              {c.name}
            </button>
          </span>
        ))}
      </div>

      <main className="max-w-7xl w-full mx-auto p-4 md:p-10 flex-1">
        {/* 검색 & 액션 */}
        <div className="mb-8 flex flex-wrap gap-4">
          <input
            type="text"
            placeholder="파일 검색..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="flex-1 min-w-[200px] bg-white border rounded-xl py-3 px-4 text-sm outline-none shadow-sm focus:border-blue-500"
          />
          <button
            onClick={() => setShowFolderModal(true)}
            className="bg-white border px-5 py-3 rounded-xl font-bold text-sm"
          >
            📁 새 폴더
          </button>
          <label className="bg-blue-600 text-white px-5 py-3 rounded-xl font-bold text-sm cursor-pointer shadow-lg shadow-blue-500/20">
            📤 업로드
            <input type="file" onChange={handleFileUpload} className="hidden" />
          </label>
        </div>

        {/* 업로드 진행바 */}
        {uploading && (
          <div className="mb-8 p-4 bg-blue-50 rounded-xl border border-blue-100">
            <div className="flex justify-between text-[10px] font-black text-blue-600 mb-1">
              <span>파일 전송 중...</span>
              <span>{uploadProgress.toFixed(0)}%</span>
            </div>
            <div className="w-full bg-blue-100 h-1.5 rounded-full overflow-hidden">
              <div className="bg-blue-600 h-full transition-all" style={{ width: `${uploadProgress}%` }} />
            </div>
          </div>
        )}

        {/* 폴더 섹션 */}
        {!searchQuery && folders.length > 0 && (
          <div className="mb-10">
            <h2 className="text-[11px] font-black text-slate-300 uppercase mb-4 px-1">폴더</h2>
            <div className="grid grid-cols-1 sm:grid-cols-3 lg:grid-cols-4 gap-4">
              {folders.map((f) => (
                <div
                  key={f.id}
                  className="group bg-white border p-4 rounded-2xl flex items-center justify-between hover:border-blue-500 transition-all shadow-sm"
                >
                  <div
                    className="flex items-center gap-3 truncate cursor-pointer flex-1"
                    onClick={() => handleFolderClick(f)}
                  >
                    <span className="text-2xl">📂</span>
                    <div className="truncate">
                      <p className="text-sm font-bold truncate">{f.name}</p>
                      <p className="text-[10px] font-bold text-slate-400 dark:text-slate-500 dark:text-slate-400">{f._count.files} items</p>
                    </div>
                  </div>
                  <div className="flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                    <button
                      onClick={() => { setSelectedFolder(f); setShareType("FOLDER"); setShowShareModal(true); }}
                      className="p-1.5 hover:bg-slate-50 dark:bg-slate-900 rounded-lg"
                      title="공유"
                    >🔗</button>
                    {f.userId === session.user?.id && (
                      <button
                        onClick={() => handleDeleteFolder(f.id)}
                        className="p-1.5 hover:bg-red-50 text-red-500 rounded-lg"
                        title="삭제"
                      >🗑️</button>
                    )}
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}

        {/* 파일 섹션 */}
        <div>
          <h2 className="text-[11px] font-black text-slate-300 uppercase mb-4 px-1">파일</h2>
          {loading ? (
            <div className="grid grid-cols-2 xs:grid-cols-3 md:grid-cols-5 lg:grid-cols-7 gap-6">
              {[...Array(7)].map((_, i) => (
                <div key={i} className="animate-pulse">
                  <div className="aspect-square bg-gray-200 rounded-[2rem]" />
                  <div className="h-3 bg-gray-200 rounded mt-2 mx-2" />
                </div>
              ))}
            </div>
          ) : displayedFiles.length === 0 ? (
            <div className="text-center py-16 text-slate-300">
              <p className="text-4xl mb-3">📂</p>
              <p className="font-bold text-sm">
                {searchQuery ? "검색 결과가 없습니다" : "파일이 없습니다"}
              </p>
            </div>
          ) : (
            <div className="grid grid-cols-2 xs:grid-cols-3 md:grid-cols-5 lg:grid-cols-7 gap-6">
              {displayedFiles.map((file) => (
                <div
                  key={file.id}
                  className="group cursor-pointer"
                  onClick={() => { setSelectedFile(file); setShowFileDetail(true); }}
                >
                  <div className={`aspect-square border rounded-[2rem] flex items-center justify-center overflow-hidden group-hover:shadow-xl transition-all relative ${
                    file.thumbnailUrl ? "bg-white" : getFileColor(file.mimeType)
                  }`}>
                    {file.thumbnailUrl ? (
                      <img src={file.thumbnailUrl} className="w-full h-full object-cover" alt={file.originalName} />
                    ) : (
                      <span className="text-4xl select-none">{getFileIcon(file.mimeType)}</span>
                    )}
                    {file.userId !== session.user?.id && (
                      <span className="absolute top-2 right-2 bg-blue-600 text-white text-[8px] px-1.5 py-0.5 rounded-full">
                        공유
                      </span>
                    )}
                  </div>
                  <p className="mt-2 text-[10px] font-bold text-center truncate px-2">{file.originalName}</p>
                  <div className="flex flex-wrap justify-center gap-1 mt-1">
                    {file.fileTags?.map((ft) => (
                      <span key={ft.tag.id} className="text-[8px] bg-slate-100 text-slate-500 dark:text-slate-400 px-1.5 py-0.5 rounded">
                        #{ft.tag.name}
                      </span>
                    ))}
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      </main>

      {/* 모달: 폴더 생성 */}
      {showFolderModal && (
        <div className="fixed inset-0 z-[100] bg-black/50 flex items-center justify-center p-4">
          <form
            onSubmit={handleCreateFolder}
            className="bg-white p-6 rounded-[2rem] w-full max-w-xs shadow-2xl animate-in fade-in zoom-in duration-200"
          >
            <h3 className="font-black mb-4">새 폴더 생성</h3>
            <input
              type="text"
              value={newFolderName}
              onChange={(e) => setNewFolderName(e.target.value)}
              autoFocus
              className="w-full border-2 rounded-xl p-3 mb-6 outline-none focus:border-blue-500 font-bold"
              placeholder="폴더 이름 입력"
            />
            <div className="flex gap-2">
              <button
                type="button"
                onClick={() => setShowFolderModal(false)}
                className="flex-1 font-bold text-slate-400 dark:text-slate-500 dark:text-slate-400"
              >
                취소
              </button>
              <button
                type="submit"
                className="flex-[2] py-3 bg-blue-600 text-white rounded-xl font-bold shadow-lg"
              >
                폴더 만들기
              </button>
            </div>
          </form>
        </div>
      )}

      {/* 모달: 파일 미리보기 (FilePreviewModal 컴포넌트 사용) */}
      <FilePreviewModal
        file={showFileDetail && selectedFile ? {
          id: selectedFile.id,
          originalName: selectedFile.originalName,
          mimeType: selectedFile.mimeType,
          size: selectedFile.size,
        } : null}
        onClose={() => setShowFileDetail(false)}
      />

      {/* 모달: 공유 */}
      {showShareModal && (
        <div
          className="fixed inset-0 z-[110] bg-black/50 flex items-center justify-center p-4"
          onClick={() => setShowShareModal(false)}
        >
          <div
            className="bg-white p-8 rounded-[2.5rem] w-full max-w-sm"
            onClick={(e) => e.stopPropagation()}
          >
            <h3 className="font-black text-lg mb-6">항목 공유</h3>
            <form onSubmit={handleShare} className="space-y-4">
              <input
                type="email"
                value={shareEmail}
                onChange={(e) => setShareEmail(e.target.value)}
                required
                className="w-full border-2 rounded-xl p-3 text-sm outline-none focus:border-blue-500"
                placeholder="상대방 이메일"
              />
              <select
                value={sharePermission}
                onChange={(e) => setSharePermission(e.target.value as "VIEW" | "EDIT")}
                className="w-full border-2 rounded-xl p-3 text-sm font-bold"
              >
                <option value="VIEW">읽기 가능</option>
                <option value="EDIT">편집 가능</option>
              </select>
              <div className="flex gap-2 pt-2">
                <button
                  type="button"
                  onClick={() => setShowShareModal(false)}
                  className="flex-1 font-bold text-slate-400 dark:text-slate-500 dark:text-slate-400 text-sm"
                >
                  취소
                </button>
                <button
                  type="submit"
                  disabled={isSharing}
                  className="flex-[2] py-3 bg-blue-600 text-white rounded-xl font-bold shadow-lg disabled:opacity-50"
                >
                  {isSharing ? "공유 중..." : "보내기"}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/app/error.tsx">
"use client";

import { useEffect } from "react";
import { AlertTriangle, RefreshCw, Home } from "lucide-react";

export default function ErrorPage({
  error, reset,
}: { error: Error & { digest?: string }; reset: () => void }) {
  useEffect(() => {
    // 클라이언트 에러 로깅
    fetch("/api/errors/report", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        message: error.message,
        stack:   error.stack,
        digest:  error.digest,
        url:     window.location.href,
        ts:      new Date().toISOString(),
      }),
    }).catch(() => {});
  }, [error]);

  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gray-50 dark:bg-slate-900 px-4">
      <div className="max-w-md w-full text-center space-y-6">
        <div className="w-20 h-20 rounded-2xl bg-red-50 dark:bg-red-900/30 flex items-center justify-center mx-auto">
          <AlertTriangle size={36} className="text-red-500" />
        </div>
        <div>
          <h1 className="text-2xl font-black text-gray-900 dark:text-slate-100 mb-2">페이지 오류</h1>
          <p className="text-gray-500 dark:text-slate-400">
            이 페이지를 불러오는 중 오류가 발생했습니다.
          </p>
          {process.env.NODE_ENV === "development" && (
            <pre className="mt-3 text-left text-[10px] bg-gray-900 text-red-300 rounded-xl p-4 overflow-auto max-h-32">
              {error.message}
            </pre>
          )}
        </div>
        <div className="flex gap-3">
          <button onClick={reset}
            className="flex-1 flex items-center justify-center gap-2 py-3 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-xl transition">
            <RefreshCw size={15} /> 다시 시도
          </button>
          <a href="/dashboard"
            className="flex-1 flex items-center justify-center gap-2 py-3 text-sm font-semibold text-gray-700 dark:text-slate-300 bg-white dark:bg-slate-800 border border-gray-200 dark:border-slate-700 rounded-xl transition hover:bg-gray-50 dark:hover:bg-slate-700">
            <Home size={15} /> 홈으로
          </a>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from "next";
import { Providers } from "./providers";
import PWAInstaller from "@/components/PWAInstaller";
import "./globals.css";

export const metadata: Metadata = {
  title: "이음 (Eum)",
  description: "사람과 파일을 잇다 - 나만의 퍼스널 클라우드",
  manifest: "/manifest.json",
  appleWebApp: {
    capable: true,
    statusBarStyle: "black-translucent",
    title: "이음",
  },
  other: {
    "mobile-web-app-capable": "yes",
    "apple-mobile-web-app-capable": "yes",
    "apple-mobile-web-app-status-bar-style": "black-translucent",
  },
};

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="ko" suppressHydrationWarning>
      <head>
        <link
          rel="stylesheet"
          href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css"
        />
        <link rel="manifest" href="/manifest.json" />
        <link rel="apple-touch-icon" href="/icons/icon-192.png" />
        <meta name="theme-color" content="#7c3aed" />
        <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
      </head>
      <body suppressHydrationWarning>
        <Providers>
          {children}
          <PWAInstaller />
        </Providers>
      </body>
    </html>
  );
}
</file>

<file path="src/app/not-found.tsx">
// src/app/not-found.tsx
// Next.js 14 App Router 글로벌 404 페이지

import Link from "next/link";

export default function NotFound() {
  return (
    <div className="min-h-screen bg-[#0f0c29] flex items-center justify-center px-4">
      {/* 배경 블롭 */}
      <div className="fixed inset-0 overflow-hidden pointer-events-none -z-10">
        <div className="absolute top-1/4 left-1/4 w-96 h-96 bg-purple-700/20 rounded-full blur-3xl" />
        <div className="absolute bottom-1/4 right-1/4 w-80 h-80 bg-blue-700/15 rounded-full blur-3xl" />
      </div>

      <div className="text-center max-w-md">
        {/* 404 */}
        <div className="relative mb-6 inline-block">
          <p className="text-[120px] md:text-[160px] font-black leading-none tracking-tighter
                        bg-clip-text text-transparent
                        bg-gradient-to-b from-white/80 to-white/10
                        select-none">
            404
          </p>
          <div className="absolute inset-0 flex items-center justify-center">
            <div className="w-24 h-24 rounded-full bg-purple-500/10 border border-purple-500/20 flex items-center justify-center animate-pulse">
              <span className="text-4xl">🔍</span>
            </div>
          </div>
        </div>

        <h1 className="text-2xl font-bold text-white mb-3">
          페이지를 찾을 수 없습니다
        </h1>
        <p className="text-white/40 text-sm leading-relaxed mb-10">
          요청하신 페이지가 삭제되었거나 주소가 변경되었을 수 있습니다.
          입력한 주소를 다시 확인해 주세요.
        </p>

        <div className="flex flex-col sm:flex-row items-center justify-center gap-3">
          <Link
            href="/dashboard"
            className="w-full sm:w-auto px-6 py-3 bg-white text-black font-bold rounded-xl hover:bg-purple-50 transition-all text-sm"
          >
            🏠 대시보드로 이동
          </Link>
          <Link
            href="javascript:history.back()"
            className="w-full sm:w-auto px-6 py-3 bg-white/5 text-white font-semibold rounded-xl border border-white/10 hover:bg-white/10 transition-all text-sm"
          >
            ← 이전 페이지
          </Link>
        </div>

        <p className="mt-10 text-white/10 text-[10px] font-medium tracking-[0.3em] uppercase">
          © 2026 EUM CLOUD SERVICE
        </p>
      </div>
    </div>
  );
}

// export default function NotFoundPage() {
//   return (
//     <div className="min-h-screen flex flex-col items-center justify-center bg-gray-50 dark:bg-slate-900 px-4">
//       <div className="text-center space-y-6 max-w-sm">
//         <p className="text-7xl font-black text-gray-200 dark:text-slate-700">404</p>
//         <div>
//           <h1 className="text-xl font-bold text-gray-900 dark:text-slate-100 mb-2">
//             페이지를 찾을 수 없습니다
//           </h1>
//           <p className="text-sm text-gray-500 dark:text-slate-400">
//             주소가 잘못되었거나 삭제된 페이지입니다.
//           </p>
//         </div>
//         <a href="/dashboard"
//           className="inline-flex items-center gap-2 px-6 py-3 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-xl transition">
//           <Home size={15} /> 대시보드로
//         </a>
//       </div>
//     </div>
//   );
// }
</file>

<file path="src/app/offline/page.tsx">
"use client";
// src/app/offline/page.tsx
// ✅ 수정: "use client" 추가 — onClick 핸들러가 있어 Server Component로 렌더링 불가

export default function OfflinePage() {
  return (
    <div className="min-h-screen bg-[#0f0c29] flex items-center justify-center px-4">
      <div className="fixed inset-0 overflow-hidden pointer-events-none -z-10">
        <div className="absolute top-1/3 left-1/4 w-80 h-80 bg-slate-700/30 rounded-full blur-3xl" />
      </div>

      <div className="text-center max-w-sm">
        <div className="text-7xl mb-6 animate-pulse">📡</div>
        <h1 className="text-2xl font-bold text-white mb-3">오프라인 상태입니다</h1>
        <p className="text-white/40 text-sm leading-relaxed mb-8">
          인터넷 연결을 확인해주세요.<br />
          연결이 복구되면 자동으로 새로고침됩니다.
        </p>
        <button
          onClick={() => window.location.reload()}
          className="px-6 py-3 bg-white/10 text-white font-semibold rounded-xl border border-white/10 hover:bg-white/20 transition-all text-sm"
        >
          🔄 다시 시도
        </button>
        <p className="mt-8 text-white/10 text-[10px] font-medium tracking-[0.3em] uppercase">
          © 2026 EUM CLOUD SERVICE
        </p>
      </div>
    </div>
  );
}
</file>

<file path="src/app/users/search/page.tsx">
"use client";
// src/app/users/search/page.tsx
// ✅ 수정: useSearchParams를 Suspense로 감싸는 패턴 적용

import { Suspense, useState, useEffect, useCallback, useRef } from "react";
import Link from "next/link";
import { useRouter, useSearchParams } from "next/navigation";
import { ChevronLeft, Search, Users, UserPlus, UserCheck } from "lucide-react";
import { toast } from "@/components/Toast";

interface SearchUser {
  id: string;
  name: string;
  email: string;
  role: "USER" | "ADMIN";
  isOnline: boolean;
  createdAt: string;
  isFollowing: boolean;
  _count: { files: number; posts: number };
}

// ✅ useSearchParams를 사용하는 부분을 별도 컴포넌트로 분리
function UserSearchContent() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [query, setQuery] = useState(searchParams.get("q") ?? "");
  const [users, setUsers] = useState<SearchUser[]>([]);
  const [total, setTotal] = useState(0);
  const [loading, setLoading] = useState(false);
  const [following, setFollowing] = useState<Set<string>>(new Set());
  const debounceRef = useRef<NodeJS.Timeout>();

  const search = useCallback(async (q: string) => {
    if (!q.trim()) { setUsers([]); setTotal(0); return; }
    setLoading(true);
    try {
      const res = await fetch(`/api/users/search?q=${encodeURIComponent(q)}`);
      const data = await res.json();
      setUsers(data.users ?? []);
      setTotal(data.total ?? 0);
      const init = new Set<string>(data.users.filter((u: SearchUser) => u.isFollowing).map((u: SearchUser) => u.id));
      setFollowing(init);
    } catch {
      toast.error("검색에 실패했습니다");
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    clearTimeout(debounceRef.current);
    debounceRef.current = setTimeout(() => {
      search(query);
      if (query) router.replace(`/users/search?q=${encodeURIComponent(query)}`, { scroll: false });
    }, 300);
  }, [query, search, router]);

  const toggleFollow = async (userId: string) => {
    const isNowFollowing = following.has(userId);
    const method = isNowFollowing ? "DELETE" : "POST";
    setFollowing((s) => { const n = new Set(s); isNowFollowing ? n.delete(userId) : n.add(userId); return n; });
    try {
      const res = await fetch(`/api/users/${userId}/follow`, { method });
      if (!res.ok) throw new Error();
      toast.success(isNowFollowing ? "팔로우를 취소했습니다" : "팔로우했습니다");
    } catch {
      setFollowing((s) => { const n = new Set(s); isNowFollowing ? n.add(userId) : n.delete(userId); return n; });
      toast.error("오류가 발생했습니다");
    }
  };

  return (
    <>
      {/* 헤더 */}
      <div className="bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700 sticky top-0 z-10">
        <div className="max-w-2xl mx-auto px-4 py-3 flex items-center gap-3">
          <Link href="/dashboard" className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
            <ChevronLeft size={20} className="text-gray-600 dark:text-slate-400" />
          </Link>
          <div className="flex-1 relative">
            <Search size={16} className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400" />
            <input
              type="text"
              autoFocus
              value={query}
              onChange={(e) => setQuery(e.target.value)}
              placeholder="이름 또는 이메일로 검색"
              className="w-full pl-9 pr-4 py-2 text-sm border border-gray-200 dark:border-slate-600 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-slate-700 dark:text-slate-100"
            />
          </div>
        </div>
      </div>

      <div className="max-w-2xl mx-auto px-4 py-4">
        {query && !loading && (
          <p className="text-xs text-gray-500 dark:text-slate-400 mb-3 px-1">
            {total > 0 ? `"${query}" 검색 결과 ${total}명` : `"${query}"에 해당하는 사용자가 없습니다`}
          </p>
        )}

        {loading && (
          <div className="space-y-2">
            {[...Array(4)].map((_, i) => (
              <div key={i} className="bg-white dark:bg-slate-800 rounded-xl p-4 animate-pulse flex items-center gap-3">
                <div className="w-12 h-12 rounded-full bg-gray-200 dark:bg-slate-700" />
                <div className="flex-1 space-y-2">
                  <div className="h-3.5 bg-gray-200 dark:bg-slate-700 rounded w-1/3" />
                  <div className="h-3 bg-gray-100 dark:bg-slate-700/50 rounded w-1/2" />
                </div>
              </div>
            ))}
          </div>
        )}

        {!query && !loading && (
          <div className="flex flex-col items-center justify-center py-24 text-center">
            <div className="w-16 h-16 rounded-full bg-gray-100 dark:bg-slate-800 flex items-center justify-center mb-4">
              <Users size={28} className="text-gray-400 dark:text-slate-500" />
            </div>
            <p className="text-gray-500 dark:text-slate-400 font-medium">사용자를 검색하세요</p>
            <p className="text-xs text-gray-400 dark:text-slate-500 mt-1">이름이나 이메일로 검색할 수 있습니다</p>
          </div>
        )}

        {!loading && users.length > 0 && (
          <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 overflow-hidden">
            <div className="divide-y divide-gray-100 dark:divide-slate-700">
              {users.map((u) => (
                <div key={u.id} className="flex items-center gap-3 px-4 py-3 hover:bg-gray-50 dark:hover:bg-slate-700/50 transition-colors">
                  <Link href={`/users/${u.id}`} className="relative shrink-0">
                    <div className="w-11 h-11 rounded-full bg-gradient-to-br from-blue-400 to-purple-500 flex items-center justify-center text-white font-bold">
                      {u.name[0]}
                    </div>
                    {u.isOnline && (
                      <span className="absolute bottom-0 right-0 w-3 h-3 bg-green-500 rounded-full border-2 border-white dark:border-slate-800" />
                    )}
                  </Link>
                  <Link href={`/users/${u.id}`} className="flex-1 min-w-0">
                    <div className="flex items-center gap-1.5">
                      <p className="text-sm font-semibold text-gray-900 dark:text-slate-100 truncate">{u.name}</p>
                      {u.role === "ADMIN" && (
                        <span className="text-[9px] font-bold bg-yellow-100 dark:bg-yellow-900/30 text-yellow-700 dark:text-yellow-400 px-1.5 py-0.5 rounded-full">관리자</span>
                      )}
                    </div>
                    <p className="text-xs text-gray-400 dark:text-slate-500 truncate">{u.email}</p>
                    <p className="text-[10px] text-gray-400 dark:text-slate-500 mt-0.5">
                      파일 {u._count.files} · 게시글 {u._count.posts}
                    </p>
                  </Link>
                  <button
                    onClick={() => toggleFollow(u.id)}
                    className={`flex items-center gap-1.5 px-3 py-1.5 rounded-xl text-xs font-semibold transition shrink-0 ${
                      following.has(u.id)
                        ? "bg-gray-100 dark:bg-slate-700 text-gray-700 dark:text-slate-300 hover:bg-red-50 dark:hover:bg-red-900/20 hover:text-red-600"
                        : "bg-blue-600 text-white hover:bg-blue-700"
                    }`}
                  >
                    {following.has(u.id) ? <><UserCheck size={12} /> 팔로잉</> : <><UserPlus size={12} /> 팔로우</>}
                  </button>
                </div>
              ))}
            </div>
          </div>
        )}
      </div>
    </>
  );
}

// ✅ 페이지 진입점 — Suspense로 감싸서 useSearchParams 허용
export default function UserSearchPage() {
  return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900">
      <Suspense fallback={
        <div className="flex items-center justify-center min-h-screen">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600" />
        </div>
      }>
        <UserSearchContent />
      </Suspense>
    </div>
  );
}
</file>

<file path="src/hooks/useSocket.ts">
"use client";

import { useEffect, useRef, useState } from "react";
import { io as ClientIO } from "socket.io-client";

export const useSocket = () => {
  // 소켓 인스턴스를 useRef로 관리하여 컴포넌트 리렌더링 시 재연결되는 것을 방지합니다.
  const socketRef = useRef<any>(null);
  const [isConnected, setIsConnected] = useState(false);

  useEffect(() => {
    // 소켓이 없을 때만 새로 생성 (싱글톤 패턴)
    if (!socketRef.current) {
      const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || window.location.origin;

      socketRef.current = ClientIO(siteUrl, {
        path: "/api/socket/io", // pages/api/socket/io.ts 에서 설정한 경로와 일치해야 함
        addTrailingSlash: false,
        reconnectionAttempts: 10, // 재연결 시도 횟수 증가
        reconnectionDelay: 2000,   // 재연결 간격
      });

      socketRef.current.on("connect", () => {
        console.log("🚀 소켓 연결 성공:", socketRef.current.id);
        setIsConnected(true);
      });

      socketRef.current.on("disconnect", (reason: string) => {
        console.log("🔌 소켓 연결 끊김:", reason);
        setIsConnected(false);
      });

      socketRef.current.on("connect_error", (error: any) => {
        console.error("❌ 소켓 연결 에러:", error);
        setIsConnected(false);
      });
    }

    // 컴포넌트 언마운트 시 소켓 정리
    return () => {
      if (socketRef.current) {
        // 실제 페이지 이동 시에만 연결을 끊고 싶다면 이 부분을 조정할 수 있으나,
        // 일반적으로 메모리 누수 방지를 위해 해제하는 것이 안전합니다.
        socketRef.current.disconnect();
        socketRef.current = null;
      }
    };
  }, []);

  return {
    socket: socketRef.current,
    isConnected,
  };
};
</file>

<file path="src/lib/activity-log.ts">
// src/lib/activity-log.ts
import { prisma } from "@/lib/db";
import { NextRequest } from "next/server";
import { Prisma } from "@prisma/client";

type ActivityAction =
  | "FILE_UPLOAD" | "FILE_DELETE" | "FILE_DOWNLOAD" | "FILE_SHARE"
  | "FOLDER_CREATE" | "FOLDER_DELETE"
  | "POST_CREATE" | "POST_DELETE"
  | "COMMENT_CREATE" | "COMMENT_DELETE"
  | "PROFILE_UPDATE" | "PASSWORD_CHANGE"
  | "LOGIN" | "LOGOUT"
  | "CHAT_MESSAGE" | "CALL_START" | "CALL_END";

interface LogActivityInput {
  userId:   string;
  action:   ActivityAction;
  target?:  string;
  targetId?: string;
  request?: NextRequest;
  extra?:   Record<string, unknown>;
}

export async function logActivity(input: LogActivityInput) {
  try {
    const meta: Record<string, unknown> = { ...(input.extra ?? {}) };
    if (input.request) {
      meta.ip = input.request.headers.get("x-forwarded-for")
             ?? input.request.headers.get("x-real-ip")
             ?? "unknown";
      meta.ua = input.request.headers.get("user-agent")?.slice(0, 120);
    }

    await prisma.activityLog.create({
      data: {
        userId:   input.userId,
        action:   input.action,
        target:   input.target,
        targetId: input.targetId,
        // ✅ Prisma.InputJsonValue 에러를 해결하기 위해 any로 캐스팅
        meta: Object.keys(meta).length
          ? (meta as any) 
          : undefined,
      },
    });
  } catch (err) {
    console.error("logActivity error:", err);
  }
}
</file>

<file path="package.json">
{
  "name": "personal-cloud",  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "node server.js",
    "build": "next build",
    "start": "cross-env NODE_ENV=production tsx server.js",
    "lint": "next lint",
    "db:generate": "prisma generate",
    "db:migrate": "prisma migrate dev",
    "db:push": "prisma db push",
    "db:studio": "prisma studio",
    "ai:update": "npx repomix && git add . && git commit -m \"Update code and AI context\" && git push origin master"
  },
  "dependencies": {
    "@prisma/client": "^5.22.0",
    "archiver": "^7.0.1",
    "bcryptjs": "^3.0.3",
    "date-fns": "^4.1.0",
    "firebase": "^12.9.0",
    "firebase-admin": "^13.6.1",
    "lucide-react": "^0.575.0",
    "next": "14.2.35",
    "next-auth": "^4.24.10",
    "next-themes": "^0.4.6",
    "nodemailer": "^7.0.13",
    "otpauth": "^9.5.0",
    "qrcode": "^1.5.4",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "sharp": "^0.33.5",
    "socket.io": "^4.8.3",
    "socket.io-client": "^4.8.3",
    "tsx": "^4.21.0",
    "winston": "^3.19.0",
    "winston-daily-rotate-file": "^5.0.0",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@playwright/test": "^1.58.2",
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.2",
    "@types/archiver": "^7.0.0",
    "@types/bcrypt": "^5.0.2",
    "@types/bcryptjs": "^2.4.6",
    "@types/jest": "^30.0.0",
    "@types/multer": "^1.4.12",
    "@types/node": "^20",
    "@types/nodemailer": "^7.0.9",
    "@types/qrcode": "^1.5.6",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "autoprefixer": "^10.4.20",
    "cross-env": "^10.1.0",
    "eslint": "^8",
    "eslint-config-next": "14.2.18",
    "jest": "^30.2.0",
    "jest-environment-jsdom": "^30.2.0",
    "postcss": "^8",
    "prisma": "^5.22.0",
    "tailwindcss": "^3.4.1",
    "ts-jest": "^29.4.6",
    "typescript": "^5"
  }
}
</file>

<file path="src/app/providers.tsx">
"use client";
// src/app/providers.tsx — 최종 통합본 (소켓 포함)

import { SessionProvider } from "next-auth/react";
import { ThemeProvider } from "next-themes";
import { ToastProvider } from "@/components/Toast";
import KeyboardShortcuts from "@/components/KeyboardShortcuts";
import OnboardingTour from "@/components/OnboardingTour";
import MobileBottomNav from "@/components/MobileBottomNav";
import SystemNoticeBanner from "@/components/SystemNoticeBanner";
import UploadProgressOverlay from "@/components/UploadProgressOverlay";
import { useSocketConnection, useSocketNotifications } from "@/lib/socket-client";
import { useCallback } from "react";
import { useToast } from "@/components/Toast";
import { sound } from "@/lib/sound";

// 소켓 알림 브릿지 (내부 컴포넌트)
function SocketBridge() {
  const connected = useSocketConnection();
  const { addToast } = useToast();

  const onNotification = useCallback((n: { type: string; message: string }) => {
    sound.notification();
    addToast("info", n.message);
  }, [addToast]);

  useSocketNotifications(onNotification);
  return null;
}

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <SessionProvider>
      <ThemeProvider attribute="class" defaultTheme="system" enableSystem>
        <ToastProvider>
          <SocketBridge />
          <SystemNoticeBanner />
          {children}
          <UploadProgressOverlay />
          <MobileBottomNav />
          <OnboardingTour />
          <KeyboardShortcuts />
        </ToastProvider>
      </ThemeProvider>
    </SessionProvider>
  );
}
</file>

<file path="src/lib/socket-server.ts">
// - socket-server 초기화 구조 개선
import { Server as NetServer } from "http";
import { Server as SocketIOServer } from "socket.io";
import { NextApiResponse } from "next";

export const config = {
  api: { bodyParser: false },
};

let io: SocketIOServer;

export const initSocketServer = (res: any) => {
  if (!res.socket.server.io) {
    const httpServer: NetServer = res.socket.server;
    io = new SocketIOServer(httpServer, {
      path: "/api/socket/io",
      addTrailingSlash: false,
      cors: { origin: "*" },
      pingTimeout: 60000, // 연결 안정성 향상
    });

    io.on("connection", (socket) => {
      // 룸 조인 및 WebRTC 시그널링 처리
      socket.on("join-room", (roomId) => socket.join(roomId));
      socket.on("call-user", (data) => {
        io.to(data.userToCall).emit("call-made", {
          offer: data.offer,
          socket: socket.id,
        });
      });
    });

    res.socket.server.io = io;
  }
  return res.socket.server.io;
};
</file>

<file path="src/app/chat/[id]/page.tsx">
"use client";

import React, { useEffect, useState, useCallback } from "react";
import { useParams, useRouter } from "next/navigation";
import { Loader2, ArrowLeft } from "lucide-react";

interface Post {
  id: string;
  title: string;
  content: string;
  author?: { name: string };
  createdAt: string;
}

export default function PostDetailPage() {
  const router = useRouter();
  const params = useParams();

  // [빌드 에러 해결 핵심]
  // params가 null일 수 있으므로, 옵셔널 체이닝(?.)을 사용해 id에 접근하고
  // 값이 없을 경우 빈 문자열("")을 할당하여 null 가능성을 완전히 제거합니다.
  const postId = typeof params?.id === 'string' ? params.id : "";

  const [post, setPost] = useState<Post | null>(null);
  const [loading, setLoading] = useState(true);

  const fetchPost = useCallback(async () => {
    // postId가 비어있으면 실행하지 않음
    if (!postId) return;
    
    try {
      setLoading(true);
      const response = await fetch(`/api/posts/${postId}`);
      if (response.ok) {
        const data = await response.json();
        setPost(data);
      }
    } catch (error) {
      console.error("Failed to fetch post:", error);
    } finally {
      setLoading(false);
    }
  }, [postId]);

  useEffect(() => {
    if (postId) {
      fetchPost();
    }
  }, [postId, fetchPost]);

  // 빌드 시 정적 최적화 오류를 막기 위해 postId가 없으면 로딩 화면 표시
  if (!postId || loading) {
    return (
      <div className="flex h-screen items-center justify-center dark:bg-zinc-950">
        <Loader2 className="h-8 w-8 animate-spin text-blue-500" />
      </div>
    );
  }

  if (!post) {
    return (
      <div className="flex flex-col h-screen items-center justify-center dark:bg-zinc-950 dark:text-white gap-4">
        <p>게시글을 찾을 수 없습니다.</p>
        <button 
          onClick={() => router.back()} 
          className="text-blue-500 hover:underline"
        >
          뒤로 가기
        </button>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-white dark:bg-zinc-950 transition-colors duration-300">
      <header className="p-4 border-b dark:border-zinc-800 flex items-center gap-4">
        <button 
          onClick={() => router.back()} 
          className="p-2 hover:bg-gray-100 dark:hover:bg-zinc-900 rounded-full dark:text-white"
        >
          <ArrowLeft size={20} />
        </button>
        <h1 className="font-bold text-lg dark:text-white">게시글 상세</h1>
      </header>
      
      <main className="max-w-4xl mx-auto p-6">
        <article className="space-y-4">
          <h2 className="text-3xl font-bold dark:text-white leading-tight">{post.title}</h2>
          <div className="flex items-center text-sm text-gray-500 dark:text-zinc-400 gap-2">
            <span className="font-medium">{post.author?.name || "익명"}</span>
            <span>•</span>
            <span>{new Date(post.createdAt).toLocaleDateString()}</span>
          </div>
          <hr className="dark:border-zinc-800" />
          <div className="text-gray-800 dark:text-zinc-200 leading-relaxed whitespace-pre-wrap">
            {post.content}
          </div>
        </article>
      </main>
    </div>
  );
}
</file>

<file path="src/app/profile/page.tsx">
"use client";
export const dynamic = 'force-dynamic';
// src/app/profile/page.tsx
// ✅ 수정: useSearchParams 제거(미사용), Suspense 불필요하게 됨

import { useSession, signOut } from "next-auth/react";
import { useRouter } from "next/navigation";
import { useEffect, useState } from "react";
import Link from "next/link";
import ThemeToggle from "@/components/ThemeToggle";
import { toast } from "@/components/Toast";
import { useConfirm } from "@/components/ConfirmDialog";
import { formatFileSize, storagePercent } from "@/lib/client-utils";

interface UserStats {
  totalFiles: number;
  totalPosts: number;
  totalComments: number;
  storageUsedBytes: number;
  storageUsedMB: string;
}

interface UserInfo {
  id: string;
  name: string;
  email: string;
  role: string;
  emailVerified: boolean;
  createdAt: string;
  isOnline: boolean;
}

export default function ProfilePage() {
  const { data: session, status, update: updateSession } = useSession();
  const router = useRouter();
  const { confirmDialog, openConfirm } = useConfirm();

  const [user, setUser] = useState<UserInfo | null>(null);
  const [stats, setStats] = useState<UserStats | null>(null);
  const [loading, setLoading] = useState(true);
  const [deleteConfirmText, setDeleteConfirmText] = useState("");
  const [sendingVerification, setSendingVerification] = useState(false);
  const [verificationSent, setVerificationSent] = useState(false);
  const [showDeleteSection, setShowDeleteSection] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);

  // 이름 변경 폼
  const [nameEdit, setNameEdit] = useState(false);
  const [newName, setNewName] = useState("");
  const [nameLoading, setNameLoading] = useState(false);

  // 비밀번호 변경 폼
  const [pwEdit, setPwEdit] = useState(false);
  const [currentPw, setCurrentPw] = useState("");
  const [newPw, setNewPw] = useState("");
  const [confirmPw, setConfirmPw] = useState("");
  const [pwLoading, setPwLoading] = useState(false);

  useEffect(() => {
    if (status === "unauthenticated") router.push("/login");
  }, [status, router]);

  useEffect(() => {
    if (session) fetchProfile();
  }, [session]);

  const fetchProfile = async () => {
    try {
      const res = await fetch("/api/users/me");
      if (res.ok) {
        const data = await res.json();
        setUser(data.user);
        setStats(data.stats);
        setNewName(data.user.name);
      }
    } catch {
      toast.error("프로필 로드에 실패했습니다");
    } finally {
      setLoading(false);
    }
  };

  const handleNameSave = async () => {
    if (!newName.trim() || newName.trim() === user?.name) {
      setNameEdit(false);
      return;
    }
    setNameLoading(true);
    try {
      const res = await fetch("/api/users/me", {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name: newName.trim() }),
      });
      const data = await res.json();
      if (res.ok) {
        setUser((prev) => prev ? { ...prev, name: data.user.name } : prev);
        await updateSession({ name: data.user.name });
        toast.success("이름이 변경되었습니다");
        setNameEdit(false);
      } else {
        toast.error(data.error || "이름 변경에 실패했습니다");
      }
    } catch {
      toast.error("오류가 발생했습니다");
    } finally {
      setNameLoading(false);
    }
  };

  const handlePasswordSave = async () => {
    if (!currentPw || !newPw || !confirmPw) {
      toast.warning("모든 필드를 입력해주세요");
      return;
    }
    if (newPw !== confirmPw) {
      toast.warning("새 비밀번호가 일치하지 않습니다");
      return;
    }
    if (newPw.length < 8) {
      toast.warning("새 비밀번호는 8자 이상이어야 합니다");
      return;
    }
    setPwLoading(true);
    try {
      const res = await fetch("/api/users/me", {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ currentPassword: currentPw, newPassword: newPw }),
      });
      const data = await res.json();
      if (res.ok) {
        toast.success("비밀번호가 변경되었습니다");
        setPwEdit(false);
        setCurrentPw(""); setNewPw(""); setConfirmPw("");
      } else {
        toast.error(data.error || "비밀번호 변경에 실패했습니다");
      }
    } catch {
      toast.error("오류가 발생했습니다");
    } finally {
      setPwLoading(false);
    }
  };

  const sendVerificationEmail = async () => {
    setSendingVerification(true);
    try {
      const res = await fetch("/api/auth/verify-email", { method: "POST" });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error);
      setVerificationSent(true);
      toast.success("인증 이메일을 발송했습니다. 받은편지함을 확인해주세요.");
    } catch (e: any) {
      toast.error(e.message || "이메일 발송에 실패했습니다");
    } finally {
      setSendingVerification(false);
    }
  };

  const handleDeleteAccount = async () => {
    if (deleteConfirmText !== "계정삭제") return;
    setIsDeleting(true);
    try {
      const res = await fetch("/api/users/me", { method: "DELETE" });
      if (!res.ok) throw new Error();
      await signOut({ callbackUrl: "/" });
    } catch {
      toast.error("계정 삭제에 실패했습니다. 다시 시도해주세요.");
      setIsDeleting(false);
    }
  };

  const handleLogout = () => {
    openConfirm({
      title: "로그아웃",
      message: "로그아웃 하시겠습니까?",
      confirmLabel: "로그아웃",
      onConfirm: () => signOut({ callbackUrl: "/login" }),
    });
  };

  if (status === "loading" || loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50 dark:bg-slate-900">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600" />
      </div>
    );
  }

  if (!session || !user) return null;

  const usagePercent = stats ? storagePercent(stats.storageUsedBytes) : 0;
  const storageColor =
    usagePercent > 90 ? "bg-red-500" : usagePercent > 70 ? "bg-yellow-500" : "bg-blue-500";

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900">
      {confirmDialog}

      {/* 헤더 */}
      <header className="bg-white dark:bg-slate-800 shadow dark:shadow-slate-700/30 sticky top-0 z-10 border-b border-gray-100 dark:border-slate-700">
        <div className="max-w-3xl mx-auto px-4 py-4 flex items-center justify-between">
          <Link href="/dashboard" className="text-gray-500 dark:text-slate-400 hover:text-gray-900 dark:hover:text-slate-100 flex items-center gap-2 text-sm">
            ← 대시보드
          </Link>
          <h1 className="text-lg font-bold text-gray-900 dark:text-slate-100">마이페이지</h1>
          <div className="flex items-center gap-2">
            <ThemeToggle />
            <button
              onClick={handleLogout}
              className="text-sm text-red-500 hover:text-red-700 font-medium"
            >
              로그아웃
            </button>
          </div>
        </div>
      </header>

      <main className="max-w-3xl mx-auto px-4 py-6 space-y-4">

        {/* 프로필 카드 */}
        <div className="bg-white dark:bg-slate-800 rounded-xl shadow p-6">
          <div className="flex items-center gap-4 mb-6">
            <div className="w-16 h-16 rounded-full bg-gradient-to-br from-blue-500 to-purple-600 flex items-center justify-center text-white text-2xl font-bold flex-shrink-0">
              {user.name.charAt(0).toUpperCase()}
            </div>
            <div>
              <h2 className="text-xl font-bold text-gray-900 dark:text-slate-100">{user.name}</h2>
              <p className="text-gray-500 dark:text-slate-400 text-sm">{user.email}</p>
              <span className={`inline-block mt-1 px-2 py-0.5 text-xs rounded-full font-medium ${
                user.role === "ADMIN"
                  ? "bg-purple-100 text-purple-700"
                  : "bg-gray-100 dark:bg-slate-700 text-gray-600 dark:text-slate-400"
              }`}>
                {user.role === "ADMIN" ? "관리자" : "일반 사용자"}
              </span>
            </div>
          </div>

          {stats && (
            <div className="grid grid-cols-3 gap-4 pt-4 border-t">
              {[
                { label: "파일", value: stats.totalFiles.toLocaleString() },
                { label: "게시글", value: stats.totalPosts.toLocaleString() },
                { label: "댓글", value: stats.totalComments.toLocaleString() },
              ].map(({ label, value }) => (
                <div key={label} className="text-center">
                  <p className="text-xl font-bold text-gray-900 dark:text-slate-100">{value}</p>
                  <p className="text-xs text-gray-500 dark:text-slate-400">{label}</p>
                </div>
              ))}
            </div>
          )}
        </div>

        {/* 스토리지 */}
        {stats && (
          <div className="bg-white dark:bg-slate-800 rounded-xl shadow p-6">
            <h3 className="text-sm font-semibold text-gray-700 dark:text-slate-300 mb-3">☁️ 스토리지 사용량</h3>
            <div className="flex justify-between text-sm text-gray-600 dark:text-slate-400 mb-2">
              <span>{formatFileSize(stats.storageUsedBytes)} 사용 중</span>
              <span className="text-gray-400 dark:text-slate-500">/ 5 GB</span>
            </div>
            <div className="w-full bg-gray-100 dark:bg-slate-700 rounded-full h-2.5">
              <div
                className={`h-2.5 rounded-full transition-all ${storageColor}`}
                style={{ width: `${usagePercent}%` }}
              />
            </div>
            <p className="text-xs text-gray-400 dark:text-slate-500 mt-1.5">{usagePercent.toFixed(1)}% 사용</p>
          </div>
        )}

        {/* 이름 변경 */}
        <div className="bg-white dark:bg-slate-800 rounded-xl shadow p-6">
          <div className="flex items-center justify-between mb-4">
            <h3 className="text-sm font-semibold text-gray-700 dark:text-slate-300">✏️ 이름 변경</h3>
            {!nameEdit && (
              <button
                onClick={() => { setNameEdit(true); setNewName(user.name); }}
                className="text-xs text-blue-600 hover:text-blue-800 font-medium"
              >
                변경
              </button>
            )}
          </div>
          {nameEdit ? (
            <div className="space-y-3">
              <input
                type="text"
                value={newName}
                onChange={(e) => setNewName(e.target.value)}
                maxLength={20}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-900 dark:text-slate-100 text-sm"
                placeholder="새 이름 입력"
                autoFocus
                onKeyDown={(e) => e.key === "Enter" && handleNameSave()}
              />
              <div className="flex justify-end gap-2">
                <button
                  onClick={() => { setNameEdit(false); setNewName(user.name); }}
                  className="px-4 py-1.5 text-sm text-gray-600 dark:text-slate-400 hover:bg-gray-100 dark:hover:bg-slate-700 rounded-lg"
                >취소</button>
                <button
                  onClick={handleNameSave}
                  disabled={nameLoading || !newName.trim()}
                  className="px-4 py-1.5 text-sm bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50"
                >
                  {nameLoading ? "저장 중..." : "저장"}
                </button>
              </div>
            </div>
          ) : (
            <p className="text-gray-900 dark:text-slate-100 font-medium">{user.name}</p>
          )}
        </div>

        {/* 비밀번호 변경 */}
        <div className="bg-white dark:bg-slate-800 rounded-xl shadow p-6">
          <div className="flex items-center justify-between mb-4">
            <h3 className="text-sm font-semibold text-gray-700 dark:text-slate-300">🔒 비밀번호 변경</h3>
            {!pwEdit && (
              <button onClick={() => setPwEdit(true)} className="text-xs text-blue-600 hover:text-blue-800 font-medium">
                변경
              </button>
            )}
          </div>
          {pwEdit ? (
            <div className="space-y-3">
              <div>
                <label className="text-xs text-gray-500 dark:text-slate-400 mb-1 block">현재 비밀번호</label>
                <input type="password" value={currentPw} onChange={(e) => setCurrentPw(e.target.value)}
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-900 dark:text-slate-100 text-sm"
                  placeholder="현재 비밀번호" autoFocus />
              </div>
              <div>
                <label className="text-xs text-gray-500 dark:text-slate-400 mb-1 block">새 비밀번호</label>
                <input type="password" value={newPw} onChange={(e) => setNewPw(e.target.value)}
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-900 dark:text-slate-100 text-sm"
                  placeholder="새 비밀번호 (최소 8자)" />
              </div>
              <div>
                <label className="text-xs text-gray-500 dark:text-slate-400 mb-1 block">새 비밀번호 확인</label>
                <input type="password" value={confirmPw} onChange={(e) => setConfirmPw(e.target.value)}
                  className={`w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-900 dark:text-slate-100 text-sm ${
                    confirmPw && newPw !== confirmPw ? "border-red-400" : "border-gray-300"
                  }`}
                  placeholder="새 비밀번호 재입력" />
                {confirmPw && newPw !== confirmPw && (
                  <p className="text-xs text-red-500 mt-1">비밀번호가 일치하지 않습니다</p>
                )}
              </div>
              <div className="flex justify-end gap-2">
                <button
                  onClick={() => { setPwEdit(false); setCurrentPw(""); setNewPw(""); setConfirmPw(""); }}
                  className="px-4 py-1.5 text-sm text-gray-600 dark:text-slate-400 hover:bg-gray-100 dark:hover:bg-slate-700 rounded-lg"
                >취소</button>
                <button onClick={handlePasswordSave} disabled={pwLoading}
                  className="px-4 py-1.5 text-sm bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50">
                  {pwLoading ? "변경 중..." : "변경하기"}
                </button>
              </div>
            </div>
          ) : (
            <p className="text-gray-400 dark:text-slate-500 text-sm">••••••••</p>
          )}
        </div>

        {/* 계정 정보 */}
        <div className="bg-white dark:bg-slate-800 rounded-xl shadow p-6">
          <h3 className="text-sm font-semibold text-gray-700 dark:text-slate-300 mb-4">📋 계정 정보</h3>
          <dl className="space-y-3 text-sm">
            <div className="flex justify-between">
              <dt className="text-gray-500 dark:text-slate-400">이메일</dt>
              <dd className="font-medium text-gray-900 dark:text-slate-100">{user.email}</dd>
            </div>
            <div className="flex flex-col gap-1">
              <div className="flex justify-between">
                <dt className="text-gray-500 dark:text-slate-400">이메일 인증</dt>
                <dd className="font-medium text-gray-900 dark:text-slate-100">
                  {user.emailVerified ? "✅ 인증 완료" : "⚠️ 미인증"}
                </dd>
              </div>
              {!user.emailVerified && (
                <button
                  onClick={sendVerificationEmail}
                  disabled={sendingVerification || verificationSent}
                  className="text-xs text-blue-600 dark:text-blue-400 hover:underline disabled:opacity-50 text-right"
                >
                  {verificationSent ? "발송됨 ✓" : sendingVerification ? "발송 중..." : "인증 이메일 재발송"}
                </button>
              )}
            </div>
            <div className="flex justify-between">
              <dt className="text-gray-500 dark:text-slate-400">가입일</dt>
              <dd className="font-medium text-gray-900 dark:text-slate-100">
                {new Date(user.createdAt).toLocaleDateString("ko-KR", { year: "numeric", month: "long", day: "numeric" })}
              </dd>
            </div>
          </dl>
        </div>

        {/* 바로가기 */}
        <div className="bg-white dark:bg-slate-800 rounded-xl shadow p-6">
          <h3 className="text-sm font-semibold text-gray-700 dark:text-slate-300 mb-3">🔗 바로가기</h3>
          <div className="grid grid-cols-2 gap-2">
            {[
              { href: "/dashboard", label: "📁 파일 관리", color: "bg-blue-50 text-blue-700 hover:bg-blue-100" },
              { href: "/posts", label: "📝 게시글", color: "bg-green-50 text-green-700 hover:bg-green-100" },
              { href: "/chat", label: "💬 채팅", color: "bg-purple-50 text-purple-700 hover:bg-purple-100" },
              { href: "/search", label: "🔍 검색", color: "bg-orange-50 text-orange-700 hover:bg-orange-100" },
              { href: "/notifications", label: "🔔 알림", color: "bg-gray-50 dark:bg-slate-700 text-gray-700 dark:text-slate-300 hover:bg-gray-100" },
              { href: "/settings/sessions", label: "💻 로그인 기기", color: "bg-gray-50 dark:bg-slate-700 text-gray-700 dark:text-slate-300 hover:bg-gray-100" },
              { href: "/trash", label: "🗑️ 휴지통", color: "bg-gray-50 dark:bg-slate-700 text-gray-700 dark:text-slate-300 hover:bg-gray-100" },
              { href: "/users/search", label: "👥 사용자 검색", color: "bg-gray-50 dark:bg-slate-700 text-gray-700 dark:text-slate-300 hover:bg-gray-100" },
              { href: "/settings/2fa", label: "🔐 2단계 인증", color: "bg-gray-50 dark:bg-slate-700 text-gray-700 dark:text-slate-300 hover:bg-gray-100" },
              ...(user.role === "ADMIN"
                ? [{ href: "/admin", label: "🛡️ 관리자", color: "bg-red-50 text-red-700 hover:bg-red-100" }]
                : []),
            ].map(({ href, label, color }) => (
              <Link key={href} href={href}
                className={`flex items-center justify-center py-3 px-4 rounded-lg text-sm font-medium transition ${color}`}>
                {label}
              </Link>
            ))}
          </div>
        </div>

        {/* 데이터 내보내기 */}
        <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-5">
          <h3 className="text-sm font-semibold text-gray-700 dark:text-slate-300 mb-3">📦 내 데이터</h3>
          <p className="text-xs text-gray-500 dark:text-slate-400 mb-3">
            파일 목록, 게시글, 댓글, 활동 내역 등 내 모든 데이터를 JSON 파일로 내려받을 수 있습니다.
          </p>
          <a href="/api/users/me/export" download
            className="flex items-center justify-center gap-2 w-full py-2.5 text-sm font-medium text-blue-700 dark:text-blue-400 bg-blue-50 dark:bg-blue-900/20 hover:bg-blue-100 dark:hover:bg-blue-900/30 rounded-xl border border-blue-200 dark:border-blue-800 transition">
            ⬇️ 데이터 내보내기 (JSON)
          </a>
        </div>

        {/* 로그아웃 */}
        <div>
          <button onClick={handleLogout}
            className="w-full py-3 text-sm font-medium text-red-600 bg-red-50 dark:bg-red-900/20 hover:bg-red-100 dark:hover:bg-red-900/30 rounded-xl border border-red-200 dark:border-red-800 transition">
            로그아웃
          </button>
        </div>

        {/* 계정 삭제 */}
        <div className="pb-8">
          <button
            onClick={() => setShowDeleteSection(!showDeleteSection)}
            className="w-full py-2 text-xs text-gray-400 dark:text-slate-500 hover:text-red-500 dark:hover:text-red-400 transition">
            {showDeleteSection ? "▲ 접기" : "계정 삭제..."}
          </button>
          {showDeleteSection && (
            <div className="mt-3 p-4 rounded-xl border border-red-200 dark:border-red-800 bg-red-50 dark:bg-red-900/10 space-y-3">
              <p className="text-sm font-semibold text-red-700 dark:text-red-400">⚠️ 계정 영구 삭제</p>
              <p className="text-xs text-red-600 dark:text-red-400">
                계정을 삭제하면 모든 파일, 게시글, 댓글, 채팅 내역이 <strong>영구적으로 삭제</strong>되며 복구할 수 없습니다.
              </p>
              <p className="text-xs text-gray-600 dark:text-slate-400">
                확인을 위해 아래에 <strong className="text-red-600">&quot;계정삭제&quot;</strong> 를 입력하세요.
              </p>
              <input
                type="text"
                value={deleteConfirmText}
                onChange={(e) => setDeleteConfirmText(e.target.value)}
                placeholder="계정삭제"
                className="w-full border border-red-300 dark:border-red-700 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-red-400 bg-white dark:bg-slate-800 dark:text-slate-100"
              />
              <button
                onClick={handleDeleteAccount}
                disabled={deleteConfirmText !== "계정삭제" || isDeleting}
                className="w-full py-2.5 text-sm font-bold text-white bg-red-500 hover:bg-red-600 disabled:bg-gray-300 dark:disabled:bg-slate-600 disabled:cursor-not-allowed rounded-lg transition">
                {isDeleting ? "삭제 중..." : "계정 영구 삭제"}
              </button>
            </div>
          )}
        </div>
      </main>
    </div>
  );
}
</file>

<file path="prisma/schema.prisma">
// prisma/schema.prisma
// 전체 완성본 — 기존 파일을 이것으로 교체하세요

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ── Enums ────────────────────────────────────────────────

enum Role {
  USER
  ADMIN
}

enum ResourceType {
  FILE
  FOLDER
  POST
  CHATROOM   // 기존 데이터 보존
}

enum Permission {
  VIEW
  EDIT
  ADMIN      // 기존 데이터 보존
}

enum Visibility {
  PUBLIC
  PRIVATE
  SHARED
}

enum ChatRoomType {
  DIRECT
  GROUP
}

enum MessageType {
  TEXT
  FILE
  SYSTEM
  CALL
  CALL_LOG   // 기존 데이터 보존
}

enum CallStatus {
  PENDING
  ACTIVE
  ENDED
  MISSED
  ACCEPTED   // 기존 데이터 보존
  REJECTED   // 기존 데이터 보존
}

enum CallType {
  VOICE
  VIDEO
}

enum NetworkType {
  OFFLINE
  WIFI
  CELLULAR
}

enum NotificationType {
  COMMENT
  SHARE
  CHAT
  SYSTEM
  FILE_UPLOAD
  CALL
}

enum ActivityAction {
  FILE_UPLOAD
  FILE_DELETE
  FILE_DOWNLOAD
  FILE_SHARE
  FOLDER_CREATE
  FOLDER_DELETE
  POST_CREATE
  POST_DELETE
  COMMENT_CREATE
  COMMENT_DELETE
  PROFILE_UPDATE
  PASSWORD_CHANGE
  LOGIN
  LOGOUT
  CHAT_MESSAGE
  CALL_START
  CALL_END
}

// ── Models ───────────────────────────────────────────────

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  passwordHash  String    @map("password_hash")
  name          String
  role          Role      @default(USER)
  emailVerified Boolean   @default(false) @map("email_verified")
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  isOnline      Boolean     @default(false) @map("is_online")
  lastSeenAt    DateTime?   @map("last_seen_at")
  fcmToken      String?     @map("fcm_token")
  notificationPrefs Json?   @map("notification_prefs")
  twoFactorEnabled  Boolean @default(false) @map("two_factor_enabled")
  twoFactorSecret   String? @map("two_factor_secret")
  twoFactorBackups  String[] @map("two_factor_backups")
  networkType   NetworkType @default(OFFLINE) @map("network_type")

  // 스토리지
  storageUsed   BigInt  @default(0)          @map("storage_used")
  storageLimit  BigInt  @default(5368709120) @map("storage_limit")

  // 계정 상태
  isBanned      Boolean   @default(false) @map("is_banned")
  banReason     String?   @map("ban_reason")
  bannedAt      DateTime? @map("banned_at")

  // 온보딩
  onboardingDone Boolean @default(false) @map("onboarding_done")

  // 프로필 이미지
  avatarUrl     String? @map("avatar_url")
  coverUrl      String? @map("cover_url")

  // 관계
  files                File[]
  folders              Folder[]
  posts                Post[]
  comments             Comment[]
  sharedResources      SharedResource[] @relation("SharedWith")
  ownedSharedResources SharedResource[] @relation("Owner")
  savedSearches        SavedSearch[]
  chatRoomMembers      ChatRoomMember[]
  sentMessages         ChatMessage[]
  callsInitiated       Call[] @relation("CallInitiator")
  callsReceived        Call[] @relation("CallReceiver")
  passwordResetTokens  PasswordResetToken[]
  notifications        Notification[]
  emailVerificationTokens EmailVerificationToken[]
  activityLogs         ActivityLog[]
  following            Follow[] @relation("Follower")
  followers            Follow[] @relation("Following")
  postLikes            PostLike[]
  postBookmarks        PostBookmark[]
  sessions             UserSession[]
  apiKeys              ApiKey[]
  fileVersions         FileVersion[]

  @@map("users")
}

model ChatRoom {
  id        String       @id @default(cuid())
  name      String?
  type      ChatRoomType @default(DIRECT)
  createdAt DateTime     @default(now()) @map("created_at")
  updatedAt DateTime     @updatedAt @map("updated_at")

  members  ChatRoomMember[]
  messages ChatMessage[]
  calls    Call[]

  @@map("chat_rooms")
}

model ChatRoomMember {
  id         String    @id @default(cuid())
  chatRoomId String    @map("chat_room_id")
  userId     String    @map("user_id")
  joinedAt   DateTime  @default(now()) @map("joined_at")
  lastReadAt DateTime? @map("last_read_at")

  chatRoom ChatRoom @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([chatRoomId, userId])
  @@index([chatRoomId])
  @@index([userId])
  @@map("chat_room_members")
}

model ChatMessage {
  id         String      @id @default(cuid())
  chatRoomId String      @map("chat_room_id")
  senderId   String      @map("sender_id")
  type       MessageType @default(TEXT)
  content    String?
  fileId     String?     @map("file_id")
  callId     String?     @map("call_id")
  createdAt  DateTime    @default(now()) @map("created_at")

  chatRoom ChatRoom @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)
  sender   User     @relation(fields: [senderId], references: [id], onDelete: Cascade)
  file     File?    @relation(fields: [fileId], references: [id], onDelete: SetNull)

  @@index([chatRoomId])
  @@index([senderId])
  @@index([createdAt])
  @@index([chatRoomId, createdAt(sort: Desc)])
  @@map("chat_messages")
}

model Call {
  id          String     @id @default(cuid())
  chatRoomId  String     @map("chat_room_id")
  initiatorId String     @map("initiator_id")
  receiverId  String     @map("receiver_id")
  type        CallType   @default(VOICE)
  status      CallStatus @default(PENDING)
  startedAt   DateTime?  @map("started_at")
  endedAt     DateTime?  @map("ended_at")
  duration    Int?
  createdAt   DateTime   @default(now()) @map("created_at")

  chatRoom  ChatRoom @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)
  initiator User     @relation("CallInitiator", fields: [initiatorId], references: [id], onDelete: Cascade)
  receiver  User     @relation("CallReceiver",  fields: [receiverId],  references: [id], onDelete: Cascade)

  @@index([chatRoomId])
  @@index([initiatorId])
  @@index([receiverId])
  @@index([status])
  @@map("calls")
}

model Folder {
  id        String   @id @default(cuid())
  name      String
  parentId  String?  @map("parent_id")
  userId    String   @map("user_id")
  color     String?
  icon      String?
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  parent   Folder?  @relation("FolderHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children Folder[] @relation("FolderHierarchy")
  files    File[]

  @@index([userId])
  @@index([parentId])
  @@map("folders")
}

model File {
  id              String    @id @default(cuid())
  filename        String
  originalName    String    @map("original_name")
  filepath        String
  size            BigInt
  mimeType        String    @map("mime_type")
  hash            String?   @unique
  thumbnailUrl    String?   @map("thumbnail_url")
  transcodeStatus String?   @default("PENDING") @map("transcode_status")
  transcodeJobId  String?   @map("transcode_job_id")
  transcodedPaths Json?     @map("transcoded_paths")
  userId          String    @map("user_id")
  folderId        String?   @map("folder_id")
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  // 공개 공유
  publicToken   String?  @unique @map("public_token")

  // 휴지통
  deletedAt     DateTime? @map("deleted_at")

  // 암호화
  encryptedKey  String?  @map("encrypted_key")
  isEncrypted   Boolean  @default(false) @map("is_encrypted")

  // 즐겨찾기 / 핀
  isStarred     Boolean  @default(false) @map("is_starred")
  isPinned      Boolean  @default(false) @map("is_pinned")

  // 관계
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  folder       Folder?      @relation(fields: [folderId], references: [id], onDelete: SetNull)
  fileTags     FileTag[]
  chatMessages ChatMessage[]
  fileVersions FileVersion[]

  @@index([userId])
  @@index([folderId])
  @@index([userId, deletedAt])
  @@index([userId, createdAt(sort: Desc)])
  @@index([userId, isStarred])
  @@index([userId, isPinned])
  @@index([publicToken])
  @@index([hash])
  @@map("files")
}

model Tag {
  id        String   @id @default(cuid())
  name      String   @unique
  color     String?
  createdAt DateTime @default(now()) @map("created_at")

  fileTags FileTag[]
  postTags PostTag[]

  @@map("tags")
}

model FileTag {
  id        String   @id @default(cuid())
  fileId    String   @map("file_id")
  tagId     String   @map("tag_id")
  createdAt DateTime @default(now()) @map("created_at")

  file File @relation(fields: [fileId], references: [id], onDelete: Cascade)
  tag  Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([fileId, tagId])
  @@index([fileId])
  @@index([tagId])
  @@map("file_tags")
}

model PostTag {
  id        String   @id @default(cuid())
  postId    String   @map("post_id")
  tagId     String   @map("tag_id")
  createdAt DateTime @default(now()) @map("created_at")

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  tag  Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([postId, tagId])
  @@index([postId])
  @@index([tagId])
  @@map("post_tags")
}

model SavedSearch {
  id        String   @id @default(cuid())
  name      String
  query     Json
  userId    String   @map("user_id")
  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("saved_searches")
}

model Post {
  id         String     @id @default(cuid())
  title      String
  content    String
  visibility Visibility @default(PRIVATE)
  userId     String     @map("user_id")
  createdAt  DateTime   @default(now()) @map("created_at")
  updatedAt  DateTime   @updatedAt @map("updated_at")

  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  comments  Comment[]
  postTags  PostTag[]
  likes     PostLike[]
  bookmarks PostBookmark[]

  @@index([userId])
  @@index([userId, createdAt(sort: Desc)])
  @@index([visibility, createdAt(sort: Desc)])
  @@map("posts")
}

model Comment {
  id        String   @id @default(cuid())
  content   String
  postId    String   @map("post_id")
  userId    String   @map("user_id")
  createdAt DateTime @default(now()) @map("created_at")

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([postId])
  @@index([userId])
  @@map("comments")
}

model SharedResource {
  id           String       @id @default(cuid())
  resourceType ResourceType
  resourceId   String       @map("resource_id")
  ownerId      String       @map("owner_id")
  sharedWithId String       @map("shared_with_id")
  permission   Permission   @default(VIEW)
  createdAt    DateTime     @default(now()) @map("created_at")

  owner      User @relation("Owner",      fields: [ownerId],      references: [id], onDelete: Cascade)
  sharedWith User @relation("SharedWith", fields: [sharedWithId], references: [id], onDelete: Cascade)

  @@unique([resourceType, resourceId, sharedWithId])
  @@index([ownerId])
  @@index([sharedWithId])
  @@index([resourceType, resourceId])
  @@map("shared_resources")
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  userId    String   @unique
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("password_reset_tokens")
}

model Notification {
  id        String           @id @default(cuid())
  userId    String           @map("user_id")
  type      NotificationType @default(SYSTEM)
  title     String
  message   String
  body      String?
  link      String?
  metadata  Json?
  isRead    Boolean          @default(false) @map("is_read")
  createdAt DateTime         @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([isRead])
  @@index([createdAt])
  @@index([userId, isRead])
  @@index([userId, createdAt(sort: Desc)])
  @@map("notifications")
}

model EmailVerificationToken {
  id        String   @id @default(cuid())
  userId    String   @map("user_id")
  token     String   @unique
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@map("email_verification_tokens")
}

model ActivityLog {
  id        String         @id @default(cuid())
  userId    String         @map("user_id")
  action    ActivityAction
  target    String?
  targetId  String?        @map("target_id")
  meta      Json?
  createdAt DateTime       @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt(sort: Desc)])
  @@index([action])
  @@map("activity_logs")
}

model Follow {
  id          String   @id @default(cuid())
  followerId  String   @map("follower_id")
  followingId String   @map("following_id")
  createdAt   DateTime @default(now()) @map("created_at")

  follower  User @relation("Follower",  fields: [followerId],  references: [id], onDelete: Cascade)
  following User @relation("Following", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@map("follows")
}

model PostLike {
  id        String   @id @default(cuid())
  postId    String   @map("post_id")
  userId    String   @map("user_id")
  createdAt DateTime @default(now()) @map("created_at")

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId])
  @@index([postId])
  @@index([userId])
  @@map("post_likes")
}

model PostBookmark {
  id        String   @id @default(cuid())
  postId    String   @map("post_id")
  userId    String   @map("user_id")
  createdAt DateTime @default(now()) @map("created_at")

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId])
  @@index([postId])
  @@index([userId])
  @@map("post_bookmarks")
}

model UserSession {
  id         String   @id @default(cuid())
  userId     String   @map("user_id")
  token      String   @unique
  userAgent  String?  @map("user_agent")
  ip         String?
  lastActive DateTime @default(now()) @map("last_active")
  createdAt  DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@map("user_sessions")
}

model FileVersion {
  id         String   @id @default(cuid())
  fileId     String   @map("file_id")
  versionNum Int      @map("version_num")
  filepath   String
  size       BigInt
  createdBy  String   @map("created_by")
  comment    String?
  createdAt  DateTime @default(now()) @map("created_at")

  file File @relation(fields: [fileId], references: [id], onDelete: Cascade)
  user User @relation(fields: [createdBy], references: [id], onDelete: Cascade)

  @@index([fileId])
  @@index([fileId, versionNum(sort: Desc)])
  @@map("file_versions")
}

model ApiKey {
  id         String    @id @default(cuid())
  userId     String    @map("user_id")
  name       String
  keyHash    String    @unique @map("key_hash")
  keyPrefix  String    @map("key_prefix")
  scopes     String[]
  lastUsedAt DateTime? @map("last_used_at")
  expiresAt  DateTime? @map("expires_at")
  createdAt  DateTime  @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("api_keys")
}

model SystemNotice {
  id        String    @id @default(cuid())
  title     String
  content   String
  type      String    @default("INFO")
  isActive  Boolean   @default(true) @map("is_active")
  startsAt  DateTime? @map("starts_at")
  endsAt    DateTime? @map("ends_at")
  createdBy String    @map("created_by")
  createdAt DateTime  @default(now()) @map("created_at")

  @@index([isActive])
  @@map("system_notices")
}
</file>

</files>

This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/**/*, prisma/schema.prisma, package.json, tsconfig.json, next.config.js, jest.config.ts
- Files matching these patterns are excluded: *.backup, *.backup-*, prisma/migrations/**, repomix-output.*, node_modules/**, storage/**, logs/**, .git/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
jest.config.ts
next.config.js
package.json
prisma/schema.prisma
src/__tests__/lib/api-response.test.ts
src/__tests__/lib/cache.test.ts
src/__tests__/lib/components/ErrorBoundary.test.tsx
src/__tests__/lib/components/MentionTextarea.test.tsx
src/__tests__/lib/validators.test.ts
src/app/(auth)/login/page.tsx
src/app/(auth)/signup/page.tsx
src/app/about/page.tsx
src/app/activity-log/page.tsx
src/app/admin/page.tsx
src/app/admin/stats/page.tsx
src/app/api/activity-logs/route.ts
src/app/api/admin/notices/route.ts
src/app/api/admin/stats/route.ts
src/app/api/admin/users/[id]/ban/route.ts
src/app/api/admin/users/[id]/route.ts
src/app/api/admin/users/route.ts
src/app/api/auth/[...nextauth]/route.ts
src/app/api/auth/2fa/disable/route.ts
src/app/api/auth/2fa/setup/route.ts
src/app/api/auth/find-email/route.ts
src/app/api/auth/find-email/send/route.ts
src/app/api/auth/register/route.ts
src/app/api/auth/reset-password/confirm/route.ts
src/app/api/auth/reset-password/route.ts
src/app/api/auth/verify-email/confirm/route.ts
src/app/api/auth/verify-email/route.ts
src/app/api/calls/[id]/route.ts
src/app/api/calls/route.ts
src/app/api/chat/rooms/[id]/messages/route.ts
src/app/api/chat/rooms/[id]/read/route.ts
src/app/api/chat/rooms/[id]/route.ts
src/app/api/chat/rooms/route.ts
src/app/api/comments/[id]/route.ts
src/app/api/errors/report/route.ts
src/app/api/files/[id]/download/route.ts
src/app/api/files/[id]/encrypt/route.ts
src/app/api/files/[id]/favorite/route.ts
src/app/api/files/[id]/move/route.ts
src/app/api/files/[id]/public-link/route.ts
src/app/api/files/[id]/restore/route.ts
src/app/api/files/[id]/route.ts
src/app/api/files/[id]/share/route.ts
src/app/api/files/[id]/tags/route.ts
src/app/api/files/[id]/thumbnail/route.ts
src/app/api/files/[id]/versions/[versionId]/rollback/route.ts
src/app/api/files/[id]/versions/route.ts
src/app/api/files/route.ts
src/app/api/files/shared/route.ts
src/app/api/files/thumbnail/[filename]/route.ts
src/app/api/files/trash/route.ts
src/app/api/files/upload/route.ts
src/app/api/folders/[id]/download/route.ts
src/app/api/folders/[id]/move/route.ts
src/app/api/folders/[id]/route.ts
src/app/api/folders/[id]/share/route.ts
src/app/api/folders/route.ts
src/app/api/health/route.ts
src/app/api/link-preview/route.ts
src/app/api/notifications/[id]/route.ts
src/app/api/notifications/preferences/route.ts
src/app/api/notifications/route.ts
src/app/api/posts/[id]/bookmark/route.ts
src/app/api/posts/[id]/comments/route.ts
src/app/api/posts/[id]/like/route.ts
src/app/api/posts/[id]/route.ts
src/app/api/posts/[id]/share/route.ts
src/app/api/posts/[id]/tags/route.ts
src/app/api/posts/bookmarks/route.ts
src/app/api/posts/route.ts
src/app/api/saved-searches/[id]/route.ts
src/app/api/saved-searches/route.ts
src/app/api/search/route.ts
src/app/api/share/[token]/route.ts
src/app/api/share/route.ts
src/app/api/tags/route.ts
src/app/api/users/[id]/follow/route.ts
src/app/api/users/[id]/followers/route.ts
src/app/api/users/[id]/public/route.ts
src/app/api/users/fcm-token/route.ts
src/app/api/users/me/api-keys/[keyId]/route.ts
src/app/api/users/me/api-keys/route.ts
src/app/api/users/me/avatar/route.ts
src/app/api/users/me/export/route.ts
src/app/api/users/me/onboarding/route.ts
src/app/api/users/me/route.ts
src/app/api/users/me/sessions/route.ts
src/app/api/users/mention-search/route.ts
src/app/api/users/presence/route.ts
src/app/api/users/search/route.ts
src/app/banned/page.tsx
src/app/chat/[id]/page.tsx
src/app/chat/page.tsx
src/app/dashboard/page.tsx
src/app/error.tsx
src/app/find-email/page.tsx
src/app/global-error.tsx
src/app/globals.css
src/app/layout.tsx
src/app/not-found.tsx
src/app/notifications/page.tsx
src/app/notifications/settings/page.tsx
src/app/offline/page.tsx
src/app/page.tsx
src/app/posts/[id]/page.tsx
src/app/posts/new/page.tsx
src/app/posts/page.tsx
src/app/profile/page.tsx
src/app/providers.tsx
src/app/register/page.tsx
src/app/reset-password/confirm/page.tsx
src/app/reset-password/page.tsx
src/app/search/page.tsx
src/app/settings/2fa/page.tsx
src/app/settings/api-keys/page.tsx
src/app/settings/sessions/page.tsx
src/app/share/[token]/page.tsx
src/app/shared/page.tsx
src/app/trash/page.tsx
src/app/users/[id]/page.tsx
src/app/users/search/page.tsx
src/components/Breadcrumb.tsx
src/components/ConfirmDialog.tsx
src/components/DragDropUpload.tsx
src/components/ErrorBoundary.tsx
src/components/FileDropZone.tsx
src/components/FileEncryptButton.tsx
src/components/FileFavoritePin.tsx
src/components/FileFilters.tsx
src/components/FileGridSkeleton.tsx
src/components/FilePreviewModal.tsx
src/components/FileShareModal.tsx
src/components/FileVersionHistory.tsx
src/components/FolderCreateModal.tsx
src/components/KeyboardShortcuts.tsx
src/components/LazyImage.tsx
src/components/LikeBookmarkButtons.tsx
src/components/LinkPreviewCard.tsx
src/components/MentionTextarea.tsx
src/components/MessageBubble.tsx
src/components/MobileBottomNav.tsx
src/components/Notificationsettings.tsx
src/components/OnboardingTour.tsx
src/components/PostShareModal.tsx
src/components/ProfileImageUpload.tsx
src/components/PWAInstaller.tsx
src/components/SearchBar.tsx
src/components/SoundToggle.tsx
src/components/StorageQuotaBar.tsx
src/components/SystemNoticeBanner.tsx
src/components/TagInput.tsx
src/components/ThemeToggle.tsx
src/components/Toast.tsx
src/components/TypingIndicator.tsx
src/components/UploadProgress.tsx
src/components/UploadProgressOverlay.tsx
src/hooks/useInfiniteScroll.ts
src/hooks/useSocket.ts
src/lib/activity-log.ts
src/lib/api-key-auth.ts
src/lib/api-response.ts
src/lib/auth.ts
src/lib/cache.ts
src/lib/client-utils.ts
src/lib/db.ts
src/lib/demo-mode.ts
src/lib/email-templates.ts
src/lib/email.ts
src/lib/emit-notification.ts
src/lib/fcm.ts
src/lib/firebase.ts
src/lib/image-optimizer.ts
src/lib/logger.ts
src/lib/notification-prefs.ts
src/lib/notification.ts
src/lib/optimized-queries.ts
src/lib/rate-limit.ts
src/lib/request-logger.ts
src/lib/sanitize.ts
src/lib/socket-client.ts
src/lib/socket-server.ts
src/lib/sound.ts
src/lib/storage-guard.ts
src/lib/validators.ts
src/middleware.ts
src/types/next-auth.d.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/app/(auth)/login/page.tsx">
"use client";

import { useState, Suspense } from "react";
import { signIn } from "next-auth/react";
import { useRouter, useSearchParams } from "next/navigation";
import Link from "next/link";
import { 
  Mail, 
  Lock, 
  Eye, 
  EyeOff, 
  Cloud, 
  AlertCircle, 
  Loader2,
  ChevronRight,
  Search
} from "lucide-react";

function LoginForm() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  const isSignupSuccess = searchParams.get("signup") === "success";

  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");
    setLoading(true);

    try {
      const result = await signIn("credentials", {
        email,
        password,
        redirect: false,
      });

      if (result?.error) {
        setError("ì´ë©”ì¼ ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.");
      } else {
        router.push("/dashboard");
        router.refresh();
      }
    } catch (err) {
      setError("ë¡œê·¸ì¸ ì¤‘ ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-[#0f0c29] text-white flex items-center justify-center p-6 relative overflow-hidden">
      {/* ë°°ê²½ ì¥ì‹ */}
      <div className="absolute top-[-10%] left-[-10%] w-[40%] h-[40%] bg-purple-600/20 blur-[100px] rounded-full -z-10" />
      <div className="absolute bottom-[-10%] right-[-10%] w-[40%] h-[40%] bg-blue-600/20 blur-[100px] rounded-full -z-10" />

      <div className="max-w-md w-full">
        {/* ë¡œê³  */}
        <div className="text-center mb-10 flex flex-col items-center">
          <Link href="/" className="inline-flex items-center gap-3 mb-4 group">
            <div className="w-12 h-12 bg-gradient-to-br from-purple-500 to-blue-600 rounded-2xl flex items-center justify-center shadow-xl group-hover:scale-110 transition-transform">
              <Cloud size={28} fill="currentColor" />
            </div>
            <div className="text-left">
              <h1 className="text-3xl font-black tracking-tighter italic leading-none">EUM</h1>
              <p className="text-[10px] text-white/40 uppercase tracking-[0.2em] font-bold mt-1">Personal Cloud</p>
            </div>
          </Link>
        </div>

        {/* ì¹´ë“œ */}
        <div className="bg-white/5 border border-white/10 p-8 rounded-[40px] backdrop-blur-2xl shadow-2xl relative">
          <div className="mb-8">
            <h2 className="text-2xl font-bold mb-2">ë¡œê·¸ì¸</h2>
            <p className="text-white/50 text-sm">ì´ìŒì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤ ğŸ‘‹</p>
          </div>

          {isSignupSuccess && !error && (
            <div className="mb-6 flex items-center gap-2 bg-emerald-500/10 border border-emerald-500/20 text-emerald-400 p-4 rounded-2xl text-sm animate-fade-in">
              <AlertCircle size={18} />
              <p>íšŒì›ê°€ì… ì™„ë£Œ! ìƒì„±í•œ ê³„ì •ìœ¼ë¡œ ë¡œê·¸ì¸í•˜ì„¸ìš”.</p>
            </div>
          )}

          {error && (
            <div className="mb-6 flex items-center gap-2 bg-red-500/10 border border-red-500/20 text-red-400 p-4 rounded-2xl text-sm">
              <AlertCircle size={18} />
              <p>{error}</p>
            </div>
          )}

          <form onSubmit={handleLogin} className="space-y-4">
            <div className="space-y-2">
              <label className="text-xs font-bold text-white/40 ml-1 uppercase tracking-wider">Email</label>
              <div className="relative group">
                <div className="absolute inset-y-0 left-4 flex items-center pointer-events-none text-white/20 group-focus-within:text-purple-400 transition-colors">
                  <Mail size={18} />
                </div>
                <input
                  type="email"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  placeholder="example@email.com"
                  className="w-full bg-white/5 border border-white/10 rounded-2xl py-4 pl-12 pr-4 outline-none focus:border-purple-500/50 focus:bg-white/10 transition-all placeholder:text-white/10"
                  required
                />
              </div>
            </div>

            <div className="space-y-2">
              <label className="text-xs font-bold text-white/40 ml-1 uppercase tracking-wider">Password</label>
              <div className="relative group">
                <div className="absolute inset-y-0 left-4 flex items-center pointer-events-none text-white/20 group-focus-within:text-purple-400 transition-colors">
                  <Lock size={18} />
                </div>
                <input
                  type={showPassword ? "text" : "password"}
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  placeholder="ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”"
                  className="w-full bg-white/5 border border-white/10 rounded-2xl py-4 pl-12 pr-12 outline-none focus:border-purple-500/50 focus:bg-white/10 transition-all placeholder:text-white/10"
                  required
                />
                <button
                  type="button"
                  onClick={() => setShowPassword(!showPassword)}
                  className="absolute inset-y-0 right-4 flex items-center text-white/20 hover:text-white transition-colors"
                >
                  {showPassword ? <EyeOff size={18} /> : <Eye size={18} />}
                </button>
              </div>
            </div>

            <div className="flex justify-end gap-3 px-1">
              <Link href="/find-email" className="text-xs text-white/30 hover:text-purple-400 transition-colors flex items-center gap-1">
                <Search size={12} />
                ì´ë©”ì¼ ì°¾ê¸°
              </Link>
              <span className="text-white/10 text-xs">|</span>
              <Link href="/reset-password" className="text-xs text-white/30 hover:text-purple-400 transition-colors">
                ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì •
              </Link>
            </div>

            <button
              type="submit"
              disabled={loading}
              className="w-full py-4 bg-gradient-to-r from-purple-500 to-blue-600 text-white font-bold rounded-2xl hover:opacity-90 active:scale-[0.98] transition-all flex items-center justify-center gap-2 shadow-xl shadow-purple-500/20 disabled:opacity-50 mt-2"
            >
              {loading ? (
                <Loader2 size={20} className="animate-spin" />
              ) : (
                <>
                  ë¡œê·¸ì¸
                  <ChevronRight size={20} />
                </>
              )}
            </button>
          </form>

          <div className="mt-8 pt-8 border-t border-white/5 text-center">
            <p className="text-white/40 text-sm">
              ì•„ì§ ê³„ì •ì´ ì—†ìœ¼ì‹ ê°€ìš”?{" "}
              <Link href="/register" className="text-white font-bold hover:text-purple-400 transition-colors underline underline-offset-4">
                íšŒì›ê°€ì…
              </Link>
            </p>
          </div>
        </div>
        
        <p className="text-center mt-10 text-white/10 text-[10px] font-medium tracking-[0.3em] uppercase">
          Â© 2026 EUM Cloud Service
        </p>
      </div>
    </div>
  );
}

export default function LoginPage() {
  return (
    <Suspense fallback={
      <div className="min-h-screen bg-[#0f0c29] flex items-center justify-center">
        <Loader2 size={40} className="animate-spin text-purple-500" />
      </div>
    }>
      <LoginForm />
    </Suspense>
  );
}
</file>

<file path="src/app/about/page.tsx">
"use client";

import Link from "next/link";
import { 
  Cpu, 
  Database, 
  Layers, 
  ShieldCheck, 
  Smartphone, 
  Zap, 
  ArrowLeft,
  Server,
  Code2
} from "lucide-react";

export default function AboutPage() {
  return (
    <div className="min-h-screen bg-[#0f0c29] text-white selection:bg-purple-500/30">
      {/* ìƒë‹¨ ì¥ì‹ ë¸”ëŸ¬ */}
      <div className="fixed top-0 right-0 w-[300px] h-[300px] bg-blue-600/10 blur-[100px] -z-10" />

      <div className="max-w-4xl mx-auto px-6 py-16">
        {/* ë’¤ë¡œê°€ê¸° & í—¤ë” */}
        <Link href="/" className="inline-flex items-center gap-2 text-white/40 hover:text-white transition-colors mb-12 group">
          <ArrowLeft size={18} className="group-hover:-translate-x-1 transition-transform" />
          <span>ë©”ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°</span>
        </Link>

        <section className="mb-20">
          <h1 className="text-4xl md:text-5xl font-black mb-6 tracking-tight">
            ê¸°ìˆ ë¡œ ì‡ëŠ” <br />
            <span className="text-purple-400">ë‚˜ë§Œì˜ ë””ì§€í„¸ ìƒíƒœê³„</span>
          </h1>
          <p className="text-lg text-white/60 leading-relaxed">
            EUM(ì´ìŒ)ì€ ë‹¨ìˆœí•œ ì €ì¥ì†Œë¥¼ ë„˜ì–´, ì‚¬ìš©ìì˜ ëª¨ë“  ê¸°ê¸°ì™€ ë°ì´í„°ë¥¼ <br className="hidden md:block" />
            ê°€ì¥ ë¹ ë¥´ê³  ì•ˆì „í•œ ë°©ì‹ìœ¼ë¡œ ì—°ê²°í•˜ê¸° ìœ„í•´ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤.
          </p>
        </section>

        {/* í•µì‹¬ ê¸°ìˆ  ìŠ¤íƒ ì„¹ì…˜ */}
        <div className="grid gap-12 mb-24">
          <FeatureRow 
            icon={<Cpu size={32} />}
            title="ê³ ì„±ëŠ¥ í•˜ì´ë¸Œë¦¬ë“œ ì•„í‚¤í…ì²˜"
            desc="Next.js 14ì˜ Server Actionsì™€ API Routesë¥¼ ì ì¬ì ì†Œì— ë°°ì¹˜í•˜ì—¬, ëŒ€ìš©ëŸ‰ íŒŒì¼ ì—…ë¡œë“œ ì‹œì—ë„ ë¸Œë¼ìš°ì € ë¶€í•˜ë¥¼ ìµœì†Œí™”í•˜ê³  ì„œë²„ ìì›ì„ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬í•©ë‹ˆë‹¤."
          />
          <FeatureRow 
            icon={<ShieldCheck size={32} />}
            title="ì—”í„°í”„ë¼ì´ì¦ˆê¸‰ ë³´ì•ˆ ì‹œìŠ¤í…œ"
            desc="ì‚¬ìš©ìì˜ ë¹„ë°€ë²ˆí˜¸ëŠ” Argon2 ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ í•´ì‹±ë˜ë©°, ëª¨ë“  ë°ì´í„° ì „ì†¡ì€ SSL/TLS ì•”í˜¸í™” ë ˆì´ì–´ë¥¼ í†µê³¼í•©ë‹ˆë‹¤. ë°ì´í„°ë² ì´ìŠ¤ ìˆ˜ì¤€ì—ì„œì˜ ì ‘ê·¼ ì œì–´ë¡œ ë³´ì•ˆ ì‚¬ê³ ë¥¼ ì›ì²œ ë´‰ì‡„í•©ë‹ˆë‹¤."
          />
          <FeatureRow 
            icon={<Zap size={32} />}
            title="ì‹¤ì‹œê°„ ë°ì´í„° ë™ê¸°í™”"
            desc="Socket.ioì™€ Prismaì˜ ì‹¤ì‹œê°„ ì´ë²¤íŠ¸ë¥¼ ê²°í•©í•˜ì—¬, íŒŒì¼ ì—…ë¡œë“œë‚˜ ì±„íŒ… ë©”ì‹œì§€ ì „ì†¡ ì¦‰ì‹œ ëª¨ë“  ì—°ê²°ëœ ê¸°ê¸°ì— ìƒíƒœê°€ ë°˜ì˜ë©ë‹ˆë‹¤."
          />
        </div>

        {/* ê¸°ìˆ  ìŠ¤íƒ ê·¸ë¦¬ë“œ */}
        <div className="bg-white/5 border border-white/10 rounded-[32px] p-10">
          <h3 className="text-xl font-bold mb-8 flex items-center gap-2">
            <Code2 className="text-purple-400" />
            Built with Modern Stack
          </h3>
          <div className="grid grid-cols-2 md:grid-cols-4 gap-8">
            <StackItem icon={<Layers className="text-blue-400" />} name="Next.js 14" detail="App Router" />
            <StackItem icon={<Database className="text-emerald-400" />} name="PostgreSQL" detail="Prisma ORM" />
            <StackItem icon={<Server className="text-orange-400" />} name="Node.js" detail="Runtime" />
            <StackItem icon={<Smartphone className="text-pink-400" />} name="Firebase" detail="FCM Push" />
          </div>
        </div>

        {/* CTA */}
        <div className="mt-24 text-center">
          <p className="text-white/40 mb-6">ì¤€ë¹„ê°€ ë˜ì…¨ë‚˜ìš”?</p>
          <Link
            href="/signup"
            className="inline-flex px-10 py-4 bg-gradient-to-r from-purple-500 to-blue-600 text-white font-black rounded-2xl hover:scale-105 transition-all shadow-xl shadow-purple-500/20"
          >
            ì§€ê¸ˆ ë°”ë¡œ ê³„ì • ë§Œë“¤ê¸°
          </Link>
        </div>
      </div>
    </div>
  );
}

function FeatureRow({ icon, title, desc }: { icon: React.ReactNode, title: string, desc: string }) {
  return (
    <div className="flex flex-col md:flex-row gap-6 items-start">
      <div className="w-16 h-16 shrink-0 rounded-2xl bg-white/5 flex items-center justify-center text-purple-400 border border-white/10">
        {icon}
      </div>
      <div>
        <h3 className="text-2xl font-bold mb-3">{title}</h3>
        <p className="text-white/50 leading-relaxed">{desc}</p>
      </div>
    </div>
  );
}

function StackItem({ icon, name, detail }: { icon: React.ReactNode, name: string, detail: string }) {
  return (
    <div className="text-center md:text-left">
      <div className="mb-3 flex justify-center md:justify-start">{icon}</div>
      <p className="font-bold text-sm">{name}</p>
      <p className="text-white/30 text-xs">{detail}</p>
    </div>
  );
}
</file>

<file path="src/app/api/auth/[...nextauth]/route.ts">
import NextAuth from "next-auth";
import { authOptions } from "@/lib/auth";

const handler = NextAuth(authOptions);

// authOptionsëŠ” ì ˆëŒ€ ì—¬ê¸°ì„œ exportí•˜ì§€ ì•ŠìŒ!
// ë‹¤ë¥¸ íŒŒì¼ë“¤ì€ @/lib/auth ì—ì„œ ì§ì ‘ importí•´ì•¼ í•¨
export { handler as GET, handler as POST };
</file>

<file path="src/app/api/auth/find-email/route.ts">
// =============================================
// src/app/api/auth/find-email/route.ts
// ì´ë©”ì¼ ì°¾ê¸° API - ì´ë¦„ìœ¼ë¡œ ë§ˆìŠ¤í‚¹ëœ ì´ë©”ì¼ ë°˜í™˜
// =============================================
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";

export async function POST(request: NextRequest) {
  try {
    const { name } = await request.json();
    if (!name?.trim()) {
      return NextResponse.json({ error: "ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”" }, { status: 400 });
    }

    const user = await prisma.user.findFirst({
      where: { name: { equals: name.trim(), mode: "insensitive" } },
    });

    if (!user) {
      return NextResponse.json(
        { error: "í•´ë‹¹ ì´ë¦„ìœ¼ë¡œ ê°€ì…ëœ ê³„ì •ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ì´ë©”ì¼ ë§ˆìŠ¤í‚¹: ab***@gmail.com
    const [localPart, domain] = user.email.split("@");
    const masked =
      localPart.slice(0, 2) + "*".repeat(Math.max(3, localPart.length - 2)) + "@" + domain;

    return NextResponse.json({ maskedEmail: masked });
  } catch (error) {
    console.error("Find email error:", error);
    return NextResponse.json({ error: "ì„œë²„ ì˜¤ë¥˜" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/auth/find-email/send/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { sendEmail } from "@/lib/email";

export async function POST(request: NextRequest) {
  try {
    const { name } = await request.json();

    if (!name?.trim()) {
      return NextResponse.json({ error: "ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”" }, { status: 400 });
    }

    const user = await prisma.user.findFirst({
      where: { name: { equals: name.trim(), mode: "insensitive" } },
    });

    if (!user) {
      return NextResponse.json({ error: "ê³„ì •ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 404 });
    }

    await sendEmail({
      to: user.email,
      subject: "[ì´ìŒ] ì´ë©”ì¼ ì°¾ê¸° ì•ˆë‚´",
      html: `
        <div style="font-family: sans-serif; max-width: 480px; margin: 0 auto; padding: 40px 24px;">
          <h2 style="color: #7c3aed; margin-bottom: 8px;">ì´ìŒ (Eum)</h2>
          <p style="color: #666; margin-bottom: 24px;">ì‚¬ëŒê³¼ íŒŒì¼ì„ ì‡ë‹¤</p>
          <hr style="border: none; border-top: 1px solid #eee; margin-bottom: 24px;"/>
          <h3 style="color: #111; margin-bottom: 16px;">ì´ë©”ì¼ ì°¾ê¸°</h3>
          <p style="color: #444; margin-bottom: 8px;">ì•ˆë…•í•˜ì„¸ìš”, <strong>${user.name}</strong>ë‹˜!</p>
          <p style="color: #444; margin-bottom: 24px;">
            ìš”ì²­í•˜ì‹  ì´ìŒ ê³„ì •ì˜ ì´ë©”ì¼ ì£¼ì†Œì…ë‹ˆë‹¤:
          </p>
          <div style="background: #f5f3ff; border: 1px solid #ddd6fe; border-radius: 12px; padding: 20px; text-align: center; margin-bottom: 24px;">
            <p style="font-size: 20px; font-weight: 700; color: #7c3aed; margin: 0;">${user.email}</p>
          </div>
          <p style="color: #888; font-size: 13px;">
            ë³¸ì¸ì´ ìš”ì²­í•˜ì§€ ì•Šìœ¼ì…¨ë‹¤ë©´ ì´ ë©”ì¼ì„ ë¬´ì‹œí•´ ì£¼ì„¸ìš”.
          </p>
          <hr style="border: none; border-top: 1px solid #eee; margin: 24px 0;"/>
          <p style="color: #aaa; font-size: 12px;">Â© 2025 ì´ìŒ(Eum)</p>
        </div>
      `,
    });

    return NextResponse.json({ message: "ì´ë©”ì¼ì´ ë°œì†¡ë˜ì—ˆìŠµë‹ˆë‹¤" });
  } catch (error) {
    console.error("Send email error:", error);
    return NextResponse.json({ error: "ì´ë©”ì¼ ë°œì†¡ ì‹¤íŒ¨" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/auth/reset-password/confirm/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import bcrypt from "bcryptjs";

export async function POST(request: NextRequest) {
  try {
    const { token, password } = await request.json();

    if (!token || !password) {
      return NextResponse.json({ error: "ìœ íš¨í•˜ì§€ ì•Šì€ ìš”ì²­ì…ë‹ˆë‹¤" }, { status: 400 });
    }

    if (password.length < 8 || !/(?=.*[a-zA-Z])(?=.*\d)/.test(password)) {
      return NextResponse.json(
        { error: "ë¹„ë°€ë²ˆí˜¸ëŠ” 8ì ì´ìƒ, ì˜ë¬¸+ìˆ«ì ì¡°í•©ì´ì–´ì•¼ í•©ë‹ˆë‹¤" },
        { status: 400 }
      );
    }

    // Prisma ORMìœ¼ë¡œ í† í° ì¡°íšŒ
    const tokenRecord = await prisma.passwordResetToken.findUnique({
      where: { token },
    });

    if (!tokenRecord || tokenRecord.expiresAt < new Date()) {
      return NextResponse.json(
        { error: "ë§í¬ê°€ ë§Œë£Œëê±°ë‚˜ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë‹¤ì‹œ ìš”ì²­í•´ì£¼ì„¸ìš”." },
        { status: 400 }
      );
    }

    const hashedPassword = await bcrypt.hash(password, 12);

    // ë¹„ë°€ë²ˆí˜¸ ì—…ë°ì´íŠ¸
    await prisma.user.update({
      where: { id: tokenRecord.userId },
      data: { passwordHash: hashedPassword },
    });

    // í† í° ì‚­ì œ
    await prisma.passwordResetToken.delete({
      where: { token },
    });

    return NextResponse.json({ message: "ë¹„ë°€ë²ˆí˜¸ê°€ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤" });
  } catch (error) {
    console.error("Confirm reset error:", error);
    return NextResponse.json({ error: "ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/auth/reset-password/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { sendEmail } from "@/lib/email";
import crypto from "crypto";

export async function POST(request: NextRequest) {
  try {
    const { email } = await request.json();

    if (!email?.trim()) {
      return NextResponse.json({ error: "ì´ë©”ì¼ì„ ì…ë ¥í•˜ì„¸ìš”" }, { status: 400 });
    }

    const user = await prisma.user.findUnique({
      where: { email: email.trim().toLowerCase() },
    });

    // ë³´ì•ˆ: ì‚¬ìš©ì ì¡´ì¬ ì—¬ë¶€ ë…¸ì¶œ ì•ˆ í•¨
    if (!user) {
      return NextResponse.json({ message: "ì´ë©”ì¼ì´ ë°œì†¡ë˜ì—ˆìŠµë‹ˆë‹¤" });
    }

    // í† í° ìƒì„± (15ë¶„ ìœ íš¨)
    const token = crypto.randomBytes(32).toString("hex");
    const expiresAt = new Date(Date.now() + 15 * 60 * 1000);

    // Prisma ORMìœ¼ë¡œ í† í° ì €ì¥ (upsert)
    await prisma.passwordResetToken.upsert({
      where: { userId: user.id },
      update: { token, expiresAt },
      create: { userId: user.id, token, expiresAt },
    });

    const resetUrl = `${process.env.NEXTAUTH_URL}/reset-password/confirm?token=${token}`;

    await sendEmail({
      to: user.email,
      subject: "[ì´ìŒ] ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì • ì•ˆë‚´",
      html: `
        <div style="font-family: sans-serif; max-width: 480px; margin: 0 auto; padding: 40px 24px;">
          <h2 style="color: #7c3aed; margin-bottom: 8px;">ì´ìŒ (Eum)</h2>
          <p style="color: #666; margin-bottom: 24px;">ì‚¬ëŒê³¼ íŒŒì¼ì„ ì‡ë‹¤</p>
          <hr style="border: none; border-top: 1px solid #eee; margin-bottom: 24px;"/>
          <h3 style="color: #111; margin-bottom: 16px;">ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì •</h3>
          <p style="color: #444; margin-bottom: 8px;">ì•ˆë…•í•˜ì„¸ìš”, <strong>${user.name}</strong>ë‹˜!</p>
          <p style="color: #444; margin-bottom: 24px;">
            ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì •ì„ ìš”ì²­í•˜ì…¨ìŠµë‹ˆë‹¤.<br/>
            ì•„ë˜ ë²„íŠ¼ì„ í´ë¦­í•´ ìƒˆ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì„¤ì •í•´ì£¼ì„¸ìš”.
          </p>
          <div style="text-align: center; margin-bottom: 24px;">
            <a href="${resetUrl}"
              style="display: inline-block; background: linear-gradient(135deg, #7c3aed, #2563eb); color: white; padding: 14px 32px; border-radius: 12px; text-decoration: none; font-weight: 700; font-size: 16px;">
              ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì •í•˜ê¸°
            </a>
          </div>
          <div style="background: #fef3c7; border: 1px solid #fbbf24; border-radius: 8px; padding: 12px 16px; margin-bottom: 20px;">
            <p style="color: #92400e; font-size: 13px; margin: 0;">
              â° ì´ ë§í¬ëŠ” <strong>15ë¶„</strong> í›„ ë§Œë£Œë©ë‹ˆë‹¤.
            </p>
          </div>
          <p style="color: #888; font-size: 13px;">
            ë³¸ì¸ì´ ìš”ì²­í•˜ì§€ ì•Šìœ¼ì…¨ë‹¤ë©´ ì´ ë©”ì¼ì„ ë¬´ì‹œí•´ ì£¼ì„¸ìš”.<br/>
            ë¹„ë°€ë²ˆí˜¸ëŠ” ë³€ê²½ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
          </p>
          <hr style="border: none; border-top: 1px solid #eee; margin: 24px 0;"/>
          <p style="color: #aaa; font-size: 12px;">Â© 2025 ì´ìŒ(Eum)</p>
        </div>
      `,
    });

    return NextResponse.json({ message: "ì´ë©”ì¼ì´ ë°œì†¡ë˜ì—ˆìŠµë‹ˆë‹¤" });
  } catch (error) {
    console.error("Reset password error:", error);
    return NextResponse.json({ error: "ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/calls/[id]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// í†µí™” ìƒíƒœ ì—…ë°ì´íŠ¸ (ìˆ˜ë½/ê±°ì ˆ/ì¢…ë£Œ)
export async function PATCH(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const callId = params.id;
    const body = await request.json();
    const { action } = body; // "accept", "reject", "end"

    // í†µí™” ì¡°íšŒ
    const call = await prisma.call.findUnique({
      where: { id: callId },
      include: {
        chatRoom: true,
      },
    });

    if (!call) {
      return NextResponse.json(
        { error: "í†µí™”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ê¶Œí•œ í™•ì¸ (ë°œì‹ ì ë˜ëŠ” ìˆ˜ì‹ ìë§Œ)
    if (call.initiatorId !== session.user.id && call.receiverId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    let updatedCall;
    let systemMessage = "";

    switch (action) {
      case "accept":
        // ìˆ˜ì‹ ìë§Œ ìˆ˜ë½ ê°€ëŠ¥
        if (call.receiverId !== session.user.id) {
          return NextResponse.json(
            { error: "ìˆ˜ì‹ ìë§Œ í†µí™”ë¥¼ ìˆ˜ë½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤" },
            { status: 403 }
          );
        }

        updatedCall = await prisma.call.update({
          where: { id: callId },
          data: {
            status: "ACCEPTED",
            startedAt: new Date(),
          },
        });
        systemMessage = "í†µí™”ê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.";
        break;

      case "reject":
        // ìˆ˜ì‹ ìë§Œ ê±°ì ˆ ê°€ëŠ¥
        if (call.receiverId !== session.user.id) {
          return NextResponse.json(
            { error: "ìˆ˜ì‹ ìë§Œ í†µí™”ë¥¼ ê±°ì ˆí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤" },
            { status: 403 }
          );
        }

        updatedCall = await prisma.call.update({
          where: { id: callId },
          data: {
            status: "REJECTED",
            endedAt: new Date(),
          },
        });
        systemMessage = "í†µí™”ê°€ ê±°ì ˆë˜ì—ˆìŠµë‹ˆë‹¤.";
        break;

      case "end":
        // ë°œì‹ ì ë˜ëŠ” ìˆ˜ì‹ ì ë‘˜ ë‹¤ ì¢…ë£Œ ê°€ëŠ¥
        const endedAt = new Date();
        const duration = call.startedAt
          ? Math.floor((endedAt.getTime() - call.startedAt.getTime()) / 1000)
          : 0;

        updatedCall = await prisma.call.update({
          where: { id: callId },
          data: {
            status: "ENDED",
            endedAt,
            duration,
          },
        });

        if (duration > 0) {
          const minutes = Math.floor(duration / 60);
          const seconds = duration % 60;
          systemMessage = `í†µí™”ê°€ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. (${minutes}ë¶„ ${seconds}ì´ˆ)`;
        } else {
          systemMessage = "í†µí™”ê°€ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.";
        }
        break;

      default:
        return NextResponse.json(
          { error: "ì˜ëª»ëœ ì•¡ì…˜ì…ë‹ˆë‹¤" },
          { status: 400 }
        );
    }

    // ì‹œìŠ¤í…œ ë©”ì‹œì§€ ìƒì„±
    if (systemMessage) {
      await prisma.chatMessage.create({
        data: {
          chatRoomId: call.chatRoomId,
          senderId: session.user.id,
          type: "CALL_LOG",
          callId: call.id,
          content: systemMessage,
        },
      });
    }

    return NextResponse.json({
      message: systemMessage,
      call: updatedCall,
    });
  } catch (error) {
    console.error("Call update error:", error);
    return NextResponse.json(
      { error: "í†µí™” ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// í†µí™” ìƒì„¸ ì¡°íšŒ
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const callId = params.id;

    const call = await prisma.call.findUnique({
      where: { id: callId },
      include: {
        initiator: {
          select: {
            id: true,
            name: true,
            isOnline: true,
          },
        },
        receiver: {
          select: {
            id: true,
            name: true,
            isOnline: true,
          },
        },
        chatRoom: true,
      },
    });

    if (!call) {
      return NextResponse.json(
        { error: "í†µí™”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ê¶Œí•œ í™•ì¸
    if (call.initiatorId !== session.user.id && call.receiverId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    return NextResponse.json({ call });
  } catch (error) {
    console.error("Call fetch error:", error);
    return NextResponse.json(
      { error: "í†µí™” ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/calls/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { prisma } from "@/lib/db";
import { sendCallNotification } from "@/lib/fcm";

// í†µí™” ìš”ì²­ ìƒì„±
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { chatRoomId, receiverId, callType } = body;

    // ìœ íš¨ì„± ê²€ì‚¬
    if (!chatRoomId || !receiverId || !callType) {
      return NextResponse.json(
        { error: "í•„ìˆ˜ ì •ë³´ê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤" },
        { status: 400 }
      );
    }

    // ì±„íŒ…ë°© ë©¤ë²„ì‹­ í™•ì¸
    const membership = await prisma.chatRoomMember.findFirst({
      where: {
        chatRoomId,
        userId: session.user.id,
      },
    });

    if (!membership) {
      return NextResponse.json(
        { error: "ì±„íŒ…ë°©ì— ì°¸ì—¬í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // ìˆ˜ì‹ ì ì •ë³´ ì¡°íšŒ
    const receiver = await prisma.user.findUnique({
      where: { id: receiverId },
      select: {
        id: true,
        name: true,
        fcmToken: true,
        isOnline: true,
      },
    });

    if (!receiver) {
      return NextResponse.json(
        { error: "ìˆ˜ì‹ ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // í†µí™” ê¸°ë¡ ìƒì„±
    const call = await prisma.call.create({
      data: {
        chatRoomId,
        initiatorId: session.user.id,
        receiverId,
        type: callType,
        status: "PENDING",
      },
    });

    // ========== FCM í‘¸ì‹œ ì•Œë¦¼ ì „ì†¡ ==========
    if (receiver.fcmToken) {
      try {
        // ìˆ˜ì •ëœ fcm.tsì˜ sendCallNotification í˜¸ì¶œ
        const pushResult = await sendCallNotification(
          receiver.fcmToken,
          session.user.name || "ì‚¬ìš©ì",
          callType,
          call.id,
          chatRoomId
        );
        
        if (pushResult.success) {
          console.log(`âœ… í†µí™” í‘¸ì‹œ ì„±ê³µ: ${receiver.name} (Status: ${receiver.isOnline ? 'Online' : 'Offline'})`);
        } else {
          console.error(`âŒ í†µí™” í‘¸ì‹œ ì „ì†¡ ì‹¤íŒ¨: ${pushResult.error}`);
        }
      } catch (error) {
        console.error(`âŒ í†µí™” í‘¸ì‹œ ì˜ˆì™¸ ë°œìƒ (${receiver.name}):`, error);
      }
    } else {
      console.warn(`âš ï¸ FCM í† í° ì—†ìŒ: ${receiver.name}`);
    }

    return NextResponse.json(
      {
        message: "í†µí™” ìš”ì²­ì´ ì „ì†¡ë˜ì—ˆìŠµë‹ˆë‹¤",
        call,
      },
      { status: 201 }
    );
  } catch (error) {
    console.error("Call request error:", error);
    return NextResponse.json(
      { error: "í†µí™” ìš”ì²­ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// í™œì„± í†µí™” ì¡°íšŒ
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const activeCalls = await prisma.call.findMany({
      where: {
        OR: [
          { initiatorId: session.user.id },
          { receiverId: session.user.id },
        ],
        status: { in: ["PENDING", "ACCEPTED"] },
      },
      include: {
        initiator: { select: { id: true, name: true } },
        receiver: { select: { id: true, name: true } },
      },
      orderBy: { createdAt: "desc" },
    });

    return NextResponse.json({ calls: activeCalls });
  } catch (error) {
    console.error("Active calls fetch error:", error);
    return NextResponse.json(
      { error: "í†µí™” ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/chat/rooms/[id]/read/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// ë©”ì‹œì§€ ì½ìŒ ì²˜ë¦¬
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const chatRoomId = params.id;

    // ë©¤ë²„ì‹­ ì¡°íšŒ
    const membership = await prisma.chatRoomMember.findFirst({
      where: {
        chatRoomId,
        userId: session.user.id,
      },
    });

    if (!membership) {
      return NextResponse.json(
        { error: "ì±„íŒ…ë°©ì— ì°¸ì—¬í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // lastReadAt ì—…ë°ì´íŠ¸
    await prisma.chatRoomMember.update({
      where: {
        id: membership.id,
      },
      data: {
        lastReadAt: new Date(),
      },
    });

    return NextResponse.json({
      message: "ì½ìŒ ì²˜ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤",
    });
  } catch (error) {
    console.error("Read message error:", error);
    return NextResponse.json(
      { error: "ì½ìŒ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/chat/rooms/[id]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// ì±„íŒ…ë°© ìƒì„¸ ì¡°íšŒ
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const chatRoomId = params.id;

    // ì±„íŒ…ë°© ì¡°íšŒ
    const chatRoom = await prisma.chatRoom.findUnique({
      where: { id: chatRoomId },
      include: {
        members: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
                isOnline: true,
                lastSeenAt: true,
              },
            },
          },
        },
      },
    });

    if (!chatRoom) {
      return NextResponse.json(
        { error: "ì±„íŒ…ë°©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ì°¸ì—¬ì í™•ì¸
    const isMember = chatRoom.members.some(
      (member) => member.userId === session.user.id
    );

    if (!isMember) {
      return NextResponse.json(
        { error: "ì±„íŒ…ë°©ì— ì°¸ì—¬í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    return NextResponse.json({ chatRoom });
  } catch (error) {
    console.error("Chat room fetch error:", error);
    return NextResponse.json(
      { error: "ì±„íŒ…ë°© ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// ì±„íŒ…ë°© ë‚˜ê°€ê¸°
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const chatRoomId = params.id;

    // ë©¤ë²„ì‹­ í™•ì¸
    const membership = await prisma.chatRoomMember.findFirst({
      where: {
        chatRoomId,
        userId: session.user.id,
      },
    });

    if (!membership) {
      return NextResponse.json(
        { error: "ì±„íŒ…ë°©ì— ì°¸ì—¬í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // ë©¤ë²„ ì œê±°
    await prisma.chatRoomMember.delete({
      where: {
        id: membership.id,
      },
    });

    // ì‹œìŠ¤í…œ ë©”ì‹œì§€ ìƒì„±
    await prisma.chatMessage.create({
      data: {
        chatRoomId,
        senderId: session.user.id,
        type: "SYSTEM",
        content: `${session.user.name}ë‹˜ì´ ì±„íŒ…ë°©ì„ ë‚˜ê°”ìŠµë‹ˆë‹¤.`,
      },
    });

    // ë‚¨ì€ ë©¤ë²„ í™•ì¸
    const remainingMembers = await prisma.chatRoomMember.count({
      where: { chatRoomId },
    });

    // ë©¤ë²„ê°€ ì—†ìœ¼ë©´ ì±„íŒ…ë°© ì‚­ì œ
    if (remainingMembers === 0) {
      await prisma.chatRoom.delete({
        where: { id: chatRoomId },
      });
    }

    return NextResponse.json({
      message: "ì±„íŒ…ë°©ì„ ë‚˜ê°”ìŠµë‹ˆë‹¤",
    });
  } catch (error) {
    console.error("Chat room leave error:", error);
    return NextResponse.json(
      { error: "ì±„íŒ…ë°© ë‚˜ê°€ê¸° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/chat/rooms/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// ì±„íŒ…ë°© ëª©ë¡ ì¡°íšŒ
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    // ë‚´ê°€ ì°¸ì—¬í•œ ì±„íŒ…ë°© ëª©ë¡
    const chatRoomMembers = await prisma.chatRoomMember.findMany({
      where: {
        userId: session.user.id,
      },
      include: {
        chatRoom: {
          include: {
            members: {
              include: {
                user: {
                  select: {
                    id: true,
                    name: true,
                    email: true,
                    isOnline: true,
                    lastSeenAt: true,
                  },
                },
              },
            },
            messages: {
              orderBy: { createdAt: "desc" },
              take: 1, // ë§ˆì§€ë§‰ ë©”ì‹œì§€ë§Œ
              include: {
                sender: {
                  select: {
                    id: true,
                    name: true,
                  },
                },
              },
            },
            _count: {
              select: {
                messages: true,
              },
            },
          },
        },
      },
      orderBy: {
        chatRoom: {
          updatedAt: "desc",
        },
      },
    });

    // ì½ì§€ ì•Šì€ ë©”ì‹œì§€ ê°œìˆ˜ ê³„ì‚°
    const chatRooms = await Promise.all(
      chatRoomMembers.map(async (member) => {
        const unreadCount = await prisma.chatMessage.count({
          where: {
            chatRoomId: member.chatRoomId,
            createdAt: {
              gt: member.lastReadAt || new Date(0),
            },
            senderId: {
              not: session.user.id, // ë³¸ì¸ ë©”ì‹œì§€ ì œì™¸
            },
          },
        });

        return {
          ...member.chatRoom,
          unreadCount,
          myMembership: {
            lastReadAt: member.lastReadAt,
          },
        };
      })
    );

    return NextResponse.json({ chatRooms });
  } catch (error) {
    console.error("Chat rooms fetch error:", error);
    return NextResponse.json(
      { error: "ì±„íŒ…ë°© ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// ì±„íŒ…ë°© ìƒì„±
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { type, memberIds, name } = body;

    // ìœ íš¨ì„± ê²€ì‚¬
    if (!type || !memberIds || !Array.isArray(memberIds)) {
      return NextResponse.json(
        { error: "ì˜ëª»ëœ ìš”ì²­ì…ë‹ˆë‹¤" },
        { status: 400 }
      );
    }

    // 1:1 ì±„íŒ…ì¸ ê²½ìš° ê¸°ì¡´ ì±„íŒ…ë°© í™•ì¸
    if (type === "DIRECT") {
      if (memberIds.length !== 1) {
        return NextResponse.json(
          { error: "1:1 ì±„íŒ…ì€ ìƒëŒ€ë°© 1ëª…ë§Œ ì§€ì •í•´ì•¼ í•©ë‹ˆë‹¤" },
          { status: 400 }
        );
      }

      const otherUserId = memberIds[0];

      // ì´ë¯¸ ì¡´ì¬í•˜ëŠ” 1:1 ì±„íŒ…ë°© ì°¾ê¸°
      const existingChatRoom = await prisma.chatRoom.findFirst({
        where: {
          type: "DIRECT",
          members: {
            every: {
              userId: {
                in: [session.user.id, otherUserId],
              },
            },
          },
        },
        include: {
          members: {
            include: {
              user: {
                select: {
                  id: true,
                  name: true,
                  email: true,
                  isOnline: true,
                },
              },
            },
          },
        },
      });

      if (existingChatRoom) {
        return NextResponse.json({
          message: "ê¸°ì¡´ ì±„íŒ…ë°©ì„ ë°˜í™˜í•©ë‹ˆë‹¤",
          chatRoom: existingChatRoom,
        });
      }
    }

    // ê·¸ë£¹ ì±„íŒ…ì¸ ê²½ìš° ì´ë¦„ í•„ìˆ˜
    if (type === "GROUP" && !name) {
      return NextResponse.json(
        { error: "ê·¸ë£¹ ì±„íŒ…ë°© ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”" },
        { status: 400 }
      );
    }

    // ì±„íŒ…ë°© ìƒì„±
    const chatRoom = await prisma.chatRoom.create({
      data: {
        type,
        name: type === "GROUP" ? name : null,
        members: {
          create: [
            // ë³¸ì¸ ì¶”ê°€
            {
              userId: session.user.id,
            },
            // ë‹¤ë¥¸ ë©¤ë²„ë“¤ ì¶”ê°€
            ...memberIds.map((userId: string) => ({
              userId,
            })),
          ],
        },
      },
      include: {
        members: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
                isOnline: true,
                lastSeenAt: true,
              },
            },
          },
        },
      },
    });

    // ì‹œìŠ¤í…œ ë©”ì‹œì§€ ìƒì„± (ê·¸ë£¹ ì±„íŒ…)
    if (type === "GROUP") {
      await prisma.chatMessage.create({
        data: {
          chatRoomId: chatRoom.id,
          senderId: session.user.id,
          type: "SYSTEM",
          content: `${session.user.name}ë‹˜ì´ ì±„íŒ…ë°©ì„ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤.`,
        },
      });
    }

    return NextResponse.json(
      {
        message: "ì±„íŒ…ë°©ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤",
        chatRoom,
      },
      { status: 201 }
    );
  } catch (error) {
    console.error("Chat room create error:", error);
    return NextResponse.json(
      { error: "ì±„íŒ…ë°© ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/comments/[id]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// ëŒ“ê¸€ ì‚­ì œ
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const commentId = params.id;

    const comment = await prisma.comment.findUnique({
      where: { id: commentId },
    });

    if (!comment) {
      return NextResponse.json(
        { error: "ëŒ“ê¸€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    if (comment.userId !== session.user.id) {
      return NextResponse.json(
        { error: "ì‚­ì œ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    await prisma.comment.delete({
      where: { id: commentId },
    });

    return NextResponse.json({
      message: "ëŒ“ê¸€ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤",
    });

  } catch (error) {
    console.error("Comment delete error:", error);
    return NextResponse.json(
      { error: "ëŒ“ê¸€ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/files/[id]/download/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import { createReadStream } from "fs";
import { stat } from "fs/promises";

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const fileId = params.id;

    // íŒŒì¼ ì¡°íšŒ
    const file = await prisma.file.findUnique({
      where: { id: fileId },
    });

    if (!file) {
      return NextResponse.json(
        { error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ê¶Œí•œ í™•ì¸ (ì†Œìœ ì ë˜ëŠ” ê³µìœ ë°›ì€ ì‚¬ìš©ì)
    const isOwner = file.userId === session.user.id;
    
    if (!isOwner) {
      const sharedResource = await prisma.sharedResource.findFirst({
        where: {
          resourceType: "FILE",
          resourceId: fileId,
          sharedWithId: session.user.id,
        },
      });

      if (!sharedResource) {
        return NextResponse.json(
          { error: "íŒŒì¼ì— ì ‘ê·¼í•  ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
          { status: 403 }
        );
      }
    }

    // íŒŒì¼ ì¡´ì¬ í™•ì¸
    try {
      await stat(file.filepath);
    } catch (error) {
      return NextResponse.json(
        { error: "íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // íŒŒì¼ ìŠ¤íŠ¸ë¦¼ ì½ê¸°
    const fileStream = createReadStream(file.filepath);
    const chunks: Buffer[] = [];

    for await (const chunk of fileStream) {
      chunks.push(Buffer.from(chunk));
    }

    const buffer = Buffer.concat(chunks);

    // íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì‘ë‹µ
    return new NextResponse(buffer, {
      status: 200,
      headers: {
        "Content-Type": file.mimeType,
        "Content-Disposition": `attachment; filename="${encodeURIComponent(file.originalName)}"`,
        "Content-Length": buffer.length.toString(),
      },
    });
  } catch (error) {
    console.error("File download error:", error);
    return NextResponse.json(
      { error: "íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/files/[id]/move/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// íŒŒì¼ ì´ë™
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const fileId = params.id;
    const body = await request.json();
    const { folderId } = body; // nullì´ë©´ ë£¨íŠ¸ë¡œ ì´ë™

    // íŒŒì¼ í™•ì¸
    const file = await prisma.file.findUnique({
      where: { id: fileId },
    });

    if (!file) {
      return NextResponse.json(
        { error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    if (file.userId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // ëŒ€ìƒ í´ë” í™•ì¸ (ìˆëŠ” ê²½ìš°)
    if (folderId) {
      const targetFolder = await prisma.folder.findUnique({
        where: { id: folderId },
      });

      if (!targetFolder) {
        return NextResponse.json(
          { error: "ëŒ€ìƒ í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
          { status: 404 }
        );
      }

      if (targetFolder.userId !== session.user.id) {
        return NextResponse.json(
          { error: "ëŒ€ìƒ í´ë”ì— ëŒ€í•œ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
          { status: 403 }
        );
      }
    }

    // íŒŒì¼ ì´ë™
    const updatedFile = await prisma.file.update({
      where: { id: fileId },
      data: {
        folderId: folderId || null,
      },
    });

    return NextResponse.json({
      message: "íŒŒì¼ì´ ì´ë™ë˜ì—ˆìŠµë‹ˆë‹¤",
      file: {
        ...updatedFile,
        size: updatedFile.size.toString(),
      },
    });

  } catch (error) {
    console.error("File move error:", error);
    return NextResponse.json(
      { error: "íŒŒì¼ ì´ë™ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/files/[id]/share/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// íŒŒì¼ ê³µìœ  ìƒì„±
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const fileId = params.id;
    const body = await request.json();
    const { sharedWithEmail, permission = "VIEW" } = body;

    if (!sharedWithEmail) {
      return NextResponse.json(
        { error: "ê³µìœ í•  ì‚¬ìš©ì ì´ë©”ì¼ì„ ì…ë ¥í•˜ì„¸ìš”" },
        { status: 400 }
      );
    }

    // íŒŒì¼ í™•ì¸
    const file = await prisma.file.findUnique({
      where: { id: fileId },
    });

    if (!file) {
      return NextResponse.json(
        { error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ì†Œìœ ì í™•ì¸
    if (file.userId !== session.user.id) {
      return NextResponse.json(
        { error: "íŒŒì¼ ì†Œìœ ìë§Œ ê³µìœ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // ê³µìœ  ëŒ€ìƒ ì‚¬ìš©ì í™•ì¸
    const sharedWithUser = await prisma.user.findUnique({
      where: { email: sharedWithEmail },
    });

    if (!sharedWithUser) {
      return NextResponse.json(
        { error: "í•´ë‹¹ ì´ë©”ì¼ì˜ ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ë³¸ì¸ì—ê²Œ ê³µìœ  ë°©ì§€
    if (sharedWithUser.id === session.user.id) {
      return NextResponse.json(
        { error: "ë³¸ì¸ì—ê²ŒëŠ” ê³µìœ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 400 }
      );
    }

    // ì´ë¯¸ ê³µìœ ëœ ê²½ìš° í™•ì¸
    const existingShare = await prisma.sharedResource.findFirst({
      where: {
        resourceType: "FILE",
        resourceId: fileId,
        sharedWithId: sharedWithUser.id,
      },
    });

    if (existingShare) {
      return NextResponse.json(
        { error: "ì´ë¯¸ ê³µìœ ëœ íŒŒì¼ì…ë‹ˆë‹¤" },
        { status: 409 }
      );
    }

    // ê³µìœ  ìƒì„±
    const share = await prisma.sharedResource.create({
      data: {
        resourceType: "FILE",
        resourceId: fileId,
        ownerId: session.user.id,
        sharedWithId: sharedWithUser.id,
        permission,
      },
      include: {
        sharedWith: {
          select: {
            id: true,
            email: true,
            name: true,
          },
        },
      },
    });

    return NextResponse.json(
      {
        message: "íŒŒì¼ì´ ê³µìœ ë˜ì—ˆìŠµë‹ˆë‹¤",
        share,
      },
      { status: 201 }
    );

  } catch (error) {
    console.error("File share error:", error);
    return NextResponse.json(
      { error: "íŒŒì¼ ê³µìœ  ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// íŒŒì¼ ê³µìœ  ëª©ë¡ ì¡°íšŒ
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const fileId = params.id;

    // íŒŒì¼ í™•ì¸ ë° ê¶Œí•œ ì²´í¬
    const file = await prisma.file.findUnique({
      where: { id: fileId },
    });

    if (!file) {
      return NextResponse.json(
        { error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    if (file.userId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // ê³µìœ  ëª©ë¡ ì¡°íšŒ
    const shares = await prisma.sharedResource.findMany({
      where: {
        resourceType: "FILE",
        resourceId: fileId,
      },
      include: {
        sharedWith: {
          select: {
            id: true,
            email: true,
            name: true,
          },
        },
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    return NextResponse.json({ shares });

  } catch (error) {
    console.error("Share list error:", error);
    return NextResponse.json(
      { error: "ê³µìœ  ëª©ë¡ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// ê³µìœ  ì‚­ì œ
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const shareId = searchParams.get("shareId");

    if (!shareId) {
      return NextResponse.json(
        { error: "ê³µìœ  IDê°€ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 400 }
      );
    }

    // ê³µìœ  í™•ì¸
    const share = await prisma.sharedResource.findUnique({
      where: { id: shareId },
    });

    if (!share) {
      return NextResponse.json(
        { error: "ê³µìœ  ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ì†Œìœ ì í™•ì¸
    if (share.ownerId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // ê³µìœ  ì‚­ì œ
    await prisma.sharedResource.delete({
      where: { id: shareId },
    });

    return NextResponse.json({
      message: "ê³µìœ ê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤",
    });

  } catch (error) {
    console.error("Share delete error:", error);
    return NextResponse.json(
      { error: "ê³µìœ  ì·¨ì†Œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/files/[id]/tags/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// íŒŒì¼ íƒœê·¸ ëª©ë¡ ì¡°íšŒ
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const file = await prisma.file.findUnique({
      where: { id: params.id },
      include: {
        fileTags: { include: { tag: true } },
      },
    });

    if (!file) {
      return NextResponse.json(
        { error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    return NextResponse.json({ tags: file.fileTags.map((ft) => ft.tag) });
  } catch (error) {
    console.error("Tag GET error:", error);
    return NextResponse.json(
      { error: "íƒœê·¸ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// íŒŒì¼ íƒœê·¸ ì¶”ê°€
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const body = await request.json();
    const { tagName } = body;

    if (!tagName || !tagName.trim()) {
      return NextResponse.json(
        { error: "íƒœê·¸ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”" },
        { status: 400 }
      );
    }

    // íŒŒì¼ í™•ì¸
    const file = await prisma.file.findUnique({ where: { id: params.id } });
    if (!file) {
      return NextResponse.json(
        { error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ì†Œìœ ì í™•ì¸
    if (file.userId !== session.user.id) {
      return NextResponse.json(
        { error: "íƒœê·¸ë¥¼ ì¶”ê°€í•  ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    const normalizedName = tagName.trim().toLowerCase();

    // íƒœê·¸ upsert (ì—†ìœ¼ë©´ ìƒì„±, ìˆìœ¼ë©´ ê¸°ì¡´ ì‚¬ìš©)
    const tag = await prisma.tag.upsert({
      where: { name: normalizedName },
      update: {},
      create: { name: normalizedName },
    });

    // ì´ë¯¸ ì—°ê²°ëëŠ”ì§€ í™•ì¸
    const existing = await prisma.fileTag.findUnique({
      where: {
        fileId_tagId: { fileId: params.id, tagId: tag.id },
      },
    });

    if (existing) {
      return NextResponse.json(
        { error: "ì´ë¯¸ ì¶”ê°€ëœ íƒœê·¸ì…ë‹ˆë‹¤" },
        { status: 400 }
      );
    }

    // íŒŒì¼-íƒœê·¸ ì—°ê²°
    await prisma.fileTag.create({
      data: { fileId: params.id, tagId: tag.id },
    });

    // íƒœê·¸ê°€ ì¶”ê°€ëœ íŒŒì¼ ì „ì²´ ë°˜í™˜ (í”„ë¡ íŠ¸ì—ì„œ ì¦‰ì‹œ ë°˜ì˜)
    const updatedFile = await prisma.file.findUnique({
      where: { id: params.id },
      include: {
        fileTags: { include: { tag: true } },
      },
    });

    // BigIntë¥¼ Stringìœ¼ë¡œ ë³€í™˜
    const serializedFile = updatedFile ? {
      ...updatedFile,
      size: updatedFile.size.toString(),
    } : null;

    return NextResponse.json(
      { message: "íƒœê·¸ê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤", tag, file: serializedFile },
      { status: 201 }
    );
  } catch (error) {
    console.error("Tag POST error:", error);
    return NextResponse.json(
      { error: "íƒœê·¸ ì¶”ê°€ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// íŒŒì¼ íƒœê·¸ ì‚­ì œ
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const body = await request.json();
    const { tagId } = body;

    if (!tagId) {
      return NextResponse.json(
        { error: "tagIdë¥¼ ì œê³µí•˜ì„¸ìš”" },
        { status: 400 }
      );
    }

    // íŒŒì¼ í™•ì¸ + ì†Œìœ ì í™•ì¸
    const file = await prisma.file.findUnique({ where: { id: params.id } });
    if (!file) {
      return NextResponse.json(
        { error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }
    if (file.userId !== session.user.id) {
      return NextResponse.json(
        { error: "íƒœê·¸ë¥¼ ì‚­ì œí•  ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // íŒŒì¼-íƒœê·¸ ì—°ê²° ì‚­ì œ
    await prisma.fileTag.delete({
      where: {
        fileId_tagId: { fileId: params.id, tagId },
      },
    });

    // ì—…ë°ì´íŠ¸ëœ íŒŒì¼ ë°˜í™˜
    const updatedFile = await prisma.file.findUnique({
      where: { id: params.id },
      include: {
        fileTags: { include: { tag: true } },
      },
    });

    // BigIntë¥¼ Stringìœ¼ë¡œ ë³€í™˜
    const serializedFile = updatedFile ? {
      ...updatedFile,
      size: updatedFile.size.toString(),
    } : null;

    return NextResponse.json({
      message: "íƒœê·¸ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤",
      file: serializedFile,
    });
  } catch (error) {
    console.error("Tag DELETE error:", error);
    return NextResponse.json(
      { error: "íƒœê·¸ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/files/thumbnail/[filename]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { readFile } from "fs/promises";
import { join } from "path";
import { existsSync } from "fs";

const STORAGE_PATH = process.env.STORAGE_PATH || "./storage";

export async function GET(
  request: NextRequest,
  { params }: { params: { filename: string } }
) {
  try {
    const thumbnailPath = join(STORAGE_PATH, "thumbnails", params.filename);

    if (!existsSync(thumbnailPath)) {
      return NextResponse.json(
        { error: "ì¸ë„¤ì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    const fileBuffer = await readFile(thumbnailPath);

    return new NextResponse(fileBuffer, {
      headers: {
        "Content-Type": "image/jpeg",
        "Cache-Control": "public, max-age=31536000, immutable",
      },
    });
  } catch (error) {
    console.error("Thumbnail serve error:", error);
    return NextResponse.json(
      { error: "ì¸ë„¤ì¼ ë¡œë”© ì‹¤íŒ¨" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/folders/[id]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// í´ë” ìƒì„¸ ì¡°íšŒ
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const folderId = params.id;

    const folder = await prisma.folder.findUnique({
      where: { id: folderId },
      include: {
        _count: {
          select: {
            children: true,
            files: true,
          },
        },
        parent: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

    if (!folder) {
      return NextResponse.json(
        { error: "í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    if (folder.userId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    return NextResponse.json({ folder });

  } catch (error) {
    console.error("Folder fetch error:", error);
    return NextResponse.json(
      { error: "í´ë” ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// í´ë” ìˆ˜ì • (ì´ë¦„ ë³€ê²½)
export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const folderId = params.id;
    const body = await request.json();
    const { name, color, icon } = body;

    const folder = await prisma.folder.findUnique({
      where: { id: folderId },
    });

    if (!folder) {
      return NextResponse.json(
        { error: "í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    if (folder.userId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // ì´ë¦„ ë³€ê²½ ì‹œ ì¤‘ë³µ í™•ì¸
    if (name && name !== folder.name) {
      const existingFolder = await prisma.folder.findFirst({
        where: {
          userId: session.user.id,
          parentId: folder.parentId,
          name: name.trim(),
          id: { not: folderId },
        },
      });

      if (existingFolder) {
        return NextResponse.json(
          { error: "ê°™ì€ ì´ë¦„ì˜ í´ë”ê°€ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤" },
          { status: 409 }
        );
      }
    }

    // í´ë” ìˆ˜ì •
    const updatedFolder = await prisma.folder.update({
      where: { id: folderId },
      data: {
        name: name?.trim() || folder.name,
        color: color !== undefined ? color : folder.color,
        icon: icon !== undefined ? icon : folder.icon,
      },
      include: {
        _count: {
          select: {
            children: true,
            files: true,
          },
        },
      },
    });

    return NextResponse.json({
      message: "í´ë”ê°€ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤",
      folder: updatedFolder,
    });

  } catch (error) {
    console.error("Folder update error:", error);
    return NextResponse.json(
      { error: "í´ë” ìˆ˜ì • ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// í´ë” ì‚­ì œ
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const folderId = params.id;

    const folder = await prisma.folder.findUnique({
      where: { id: folderId },
      include: {
        _count: {
          select: {
            children: true,
            files: true,
          },
        },
      },
    });

    if (!folder) {
      return NextResponse.json(
        { error: "í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    if (folder.userId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // í•˜ìœ„ í´ë”ë‚˜ íŒŒì¼ì´ ìˆìœ¼ë©´ ê²½ê³ 
    if (folder._count.children > 0 || folder._count.files > 0) {
      return NextResponse.json(
        { 
          error: "í´ë”ê°€ ë¹„ì–´ìˆì§€ ì•ŠìŠµë‹ˆë‹¤",
          info: `í•˜ìœ„ í´ë” ${folder._count.children}ê°œ, íŒŒì¼ ${folder._count.files}ê°œ`
        },
        { status: 400 }
      );
    }

    // í´ë” ì‚­ì œ
    await prisma.folder.delete({
      where: { id: folderId },
    });

    return NextResponse.json({
      message: "í´ë”ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤",
    });

  } catch (error) {
    console.error("Folder delete error:", error);
    return NextResponse.json(
      { error: "í´ë” ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/folders/[id]/share/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// í´ë” ê³µìœ  ìƒì„±
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const folderId = params.id;
    const body = await request.json();
    const { sharedWithEmail, permission = "VIEW" } = body;

    if (!sharedWithEmail) {
      return NextResponse.json(
        { error: "ê³µìœ í•  ì‚¬ìš©ì ì´ë©”ì¼ì„ ì…ë ¥í•˜ì„¸ìš”" },
        { status: 400 }
      );
    }

    // í´ë” í™•ì¸
    const folder = await prisma.folder.findUnique({
      where: { id: folderId },
    });

    if (!folder) {
      return NextResponse.json(
        { error: "í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ì†Œìœ ì í™•ì¸
    if (folder.userId !== session.user.id) {
      return NextResponse.json(
        { error: "í´ë” ì†Œìœ ìë§Œ ê³µìœ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // ê³µìœ  ëŒ€ìƒ ì‚¬ìš©ì í™•ì¸
    const sharedWithUser = await prisma.user.findUnique({
      where: { email: sharedWithEmail },
    });

    if (!sharedWithUser) {
      return NextResponse.json(
        { error: "í•´ë‹¹ ì´ë©”ì¼ì˜ ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ë³¸ì¸ì—ê²Œ ê³µìœ  ë°©ì§€
    if (sharedWithUser.id === session.user.id) {
      return NextResponse.json(
        { error: "ë³¸ì¸ì—ê²ŒëŠ” ê³µìœ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 400 }
      );
    }

    // ì´ë¯¸ ê³µìœ ëœ ê²½ìš° í™•ì¸
    const existingShare = await prisma.sharedResource.findFirst({
      where: {
        resourceType: "FOLDER",
        resourceId: folderId,
        sharedWithId: sharedWithUser.id,
      },
    });

    if (existingShare) {
      return NextResponse.json(
        { error: "ì´ë¯¸ ê³µìœ ëœ í´ë”ì…ë‹ˆë‹¤" },
        { status: 409 }
      );
    }

    // ê³µìœ  ìƒì„±
    const share = await prisma.sharedResource.create({
      data: {
        resourceType: "FOLDER",
        resourceId: folderId,
        ownerId: session.user.id,
        sharedWithId: sharedWithUser.id,
        permission,
      },
    });

    // ê³µìœ  ëŒ€ìƒ ì •ë³´ ìˆ˜ë™ ì¡°íšŒ
    const shareWithUser = await prisma.user.findUnique({
      where: { id: share.sharedWithId },
      select: {
        id: true,
        email: true,
        name: true,
      },
    });

    return NextResponse.json(
      {
        message: "í´ë”ê°€ ê³µìœ ë˜ì—ˆìŠµë‹ˆë‹¤",
        share: {
          ...share,
          sharedWith: shareWithUser,
        },
      },
      { status: 201 }
    );

  } catch (error) {
    console.error("Folder share error:", error);
    return NextResponse.json(
      { error: "í´ë” ê³µìœ  ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// í´ë” ê³µìœ  ëª©ë¡ ì¡°íšŒ
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const folderId = params.id;

    // í´ë” í™•ì¸
    const folder = await prisma.folder.findUnique({
      where: { id: folderId },
    });

    if (!folder) {
      return NextResponse.json(
        { error: "í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    if (folder.userId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // ê³µìœ  ëª©ë¡ ì¡°íšŒ
    const shares = await prisma.sharedResource.findMany({
      where: {
        resourceType: "FOLDER",
        resourceId: folderId,
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    // ê° ê³µìœ ì˜ ì‚¬ìš©ì ì •ë³´ ìˆ˜ë™ ì¡°íšŒ
    const sharesWithUsers = await Promise.all(
      shares.map(async (share) => {
        const sharedWith = await prisma.user.findUnique({
          where: { id: share.sharedWithId },
          select: {
            id: true,
            email: true,
            name: true,
          },
        });

        return {
          ...share,
          sharedWith,
        };
      })
    );

    return NextResponse.json({ shares: sharesWithUsers });

  } catch (error) {
    console.error("Share list error:", error);
    return NextResponse.json(
      { error: "ê³µìœ  ëª©ë¡ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// ê³µìœ  ì‚­ì œ
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const shareId = searchParams.get("shareId");

    if (!shareId) {
      return NextResponse.json(
        { error: "ê³µìœ  IDê°€ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 400 }
      );
    }

    // ê³µìœ  í™•ì¸
    const share = await prisma.sharedResource.findUnique({
      where: { id: shareId },
    });

    if (!share) {
      return NextResponse.json(
        { error: "ê³µìœ  ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ì†Œìœ ì í™•ì¸
    if (share.ownerId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // ê³µìœ  ì‚­ì œ
    await prisma.sharedResource.delete({
      where: { id: shareId },
    });

    return NextResponse.json({
      message: "ê³µìœ ê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤",
    });

  } catch (error) {
    console.error("Share delete error:", error);
    return NextResponse.json(
      { error: "ê³µìœ  ì·¨ì†Œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/folders/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// í´ë” ëª©ë¡ ì¡°íšŒ
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const parentId = searchParams.get("parentId");

    // íŠ¹ì • í´ë”ì˜ í•˜ìœ„ í•­ëª© ì¡°íšŒ
    const folders = await prisma.folder.findMany({
      where: {
        userId: session.user.id,
        parentId: parentId || null,
      },
      orderBy: {
        name: "asc",
      },
      include: {
        _count: {
          select: {
            children: true,
            files: true,
          },
        },
      },
    });

    // íŒŒì¼ë„ í•¨ê»˜ ì¡°íšŒ
    const files = await prisma.file.findMany({
      where: {
        userId: session.user.id,
        folderId: parentId || null,
      },
      orderBy: {
        originalName: "asc",
      },
      select: {
        id: true,
        filename: true,
        originalName: true,
        size: true,
        mimeType: true,
        thumbnailUrl: true,
        createdAt: true,
        updatedAt: true,
      },
    });

    return NextResponse.json({
      folders,
      files: files.map(f => ({
        ...f,
        size: f.size.toString(),
      })),
    });

  } catch (error) {
    console.error("Folders fetch error:", error);
    return NextResponse.json(
      { error: "í´ë” ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// í´ë” ìƒì„±
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { name, parentId, color, icon } = body;

    if (!name || name.trim().length === 0) {
      return NextResponse.json(
        { error: "í´ë” ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”" },
        { status: 400 }
      );
    }

    // ë¶€ëª¨ í´ë” í™•ì¸ (ìˆëŠ” ê²½ìš°)
    if (parentId) {
      const parentFolder = await prisma.folder.findUnique({
        where: { id: parentId },
      });

      if (!parentFolder) {
        return NextResponse.json(
          { error: "ë¶€ëª¨ í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
          { status: 404 }
        );
      }

      if (parentFolder.userId !== session.user.id) {
        return NextResponse.json(
          { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
          { status: 403 }
        );
      }
    }

    // ê°™ì€ ì´ë¦„ì˜ í´ë” í™•ì¸
    const existingFolder = await prisma.folder.findFirst({
      where: {
        userId: session.user.id,
        parentId: parentId || null,
        name: name.trim(),
      },
    });

    if (existingFolder) {
      return NextResponse.json(
        { error: "ê°™ì€ ì´ë¦„ì˜ í´ë”ê°€ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤" },
        { status: 409 }
      );
    }

    // í´ë” ìƒì„±
    const folder = await prisma.folder.create({
      data: {
        name: name.trim(),
        parentId: parentId || null,
        userId: session.user.id,
        color: color || null,
        icon: icon || null,
      },
      include: {
        _count: {
          select: {
            children: true,
            files: true,
          },
        },
      },
    });

    return NextResponse.json(
      {
        message: "í´ë”ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤",
        folder,
      },
      { status: 201 }
    );

  } catch (error) {
    console.error("Folder create error:", error);
    return NextResponse.json(
      { error: "í´ë” ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/posts/[id]/comments/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// ëŒ“ê¸€ ì‘ì„±
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const postId = params.id;
    const body = await request.json();
    const { content } = body;

    if (!content || content.trim() === "") {
      return NextResponse.json(
        { error: "ëŒ“ê¸€ ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”" },
        { status: 400 }
      );
    }

    // ê²Œì‹œê¸€ ì¡´ì¬ í™•ì¸
    const post = await prisma.post.findUnique({
      where: { id: postId },
    });

    if (!post) {
      return NextResponse.json(
        { error: "ê²Œì‹œê¸€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ëŒ“ê¸€ ì‘ì„±
    const comment = await prisma.comment.create({
      data: {
        content,
        postId,
        userId: session.user.id,
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

    return NextResponse.json(
      {
        message: "ëŒ“ê¸€ì´ ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤",
        comment,
      },
      { status: 201 }
    );

  } catch (error) {
    console.error("Comment create error:", error);
    return NextResponse.json(
      { error: "ëŒ“ê¸€ ì‘ì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/posts/[id]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// ê²Œì‹œê¸€ ìƒì„¸ ì¡°íšŒ
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const postId = params.id;

    const post = await prisma.post.findUnique({
      where: { id: postId },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
        comments: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
              },
            },
          },
          orderBy: {
            createdAt: "asc",
          },
        },
      },
    });

    if (!post) {
      return NextResponse.json(
        { error: "ê²Œì‹œê¸€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ê¶Œí•œ í™•ì¸
    const isOwner = post.userId === session.user.id;
    const isPublic = post.visibility === "PUBLIC";

    // ê³µìœ  í™•ì¸
    let isShared = false;
    if (!isOwner && !isPublic && post.visibility === "SHARED") {
      const shareCheck = await prisma.sharedResource.findFirst({
        where: {
          resourceType: "POST",
          resourceId: postId,
          sharedWithId: session.user.id,
        },
      });
      isShared = !!shareCheck;
    }

    // ì ‘ê·¼ ê¶Œí•œ í™•ì¸
    const canView = isOwner || isPublic || isShared;

    console.log("=== ê²Œì‹œê¸€ ì ‘ê·¼ í™•ì¸ ===");
    console.log("ì‚¬ìš©ì ID:", session.user.id);
    console.log("ê²Œì‹œê¸€ ì†Œìœ ì:", post.userId);
    console.log("ê³µê°œ ì„¤ì •:", post.visibility);
    console.log("ì†Œìœ ì:", isOwner);
    console.log("ê³µê°œ ê¸€:", isPublic);
    console.log("ê³µìœ ë°›ìŒ:", isShared);
    console.log("ì ‘ê·¼ ê°€ëŠ¥:", canView);

    if (!canView) {
      return NextResponse.json(
        { error: "ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    return NextResponse.json({ post });

  } catch (error) {
    console.error("Post fetch error:", error);
    return NextResponse.json(
      { error: "ê²Œì‹œê¸€ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// ê²Œì‹œê¸€ ìˆ˜ì •
export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const postId = params.id;
    const body = await request.json();

    const post = await prisma.post.findUnique({
      where: { id: postId },
    });

    if (!post) {
      return NextResponse.json(
        { error: "ê²Œì‹œê¸€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    if (post.userId !== session.user.id) {
      return NextResponse.json(
        { error: "ìˆ˜ì • ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    const updatedPost = await prisma.post.update({
      where: { id: postId },
      data: {
        title: body.title,
        content: body.content,
        visibility: body.visibility,
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

    return NextResponse.json({
      message: "ê²Œì‹œê¸€ì´ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤",
      post: updatedPost,
    });

  } catch (error) {
    console.error("Post update error:", error);
    return NextResponse.json(
      { error: "ê²Œì‹œê¸€ ìˆ˜ì • ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// ê²Œì‹œê¸€ ì‚­ì œ
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const postId = params.id;

    const post = await prisma.post.findUnique({
      where: { id: postId },
    });

    if (!post) {
      return NextResponse.json(
        { error: "ê²Œì‹œê¸€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    if (post.userId !== session.user.id) {
      return NextResponse.json(
        { error: "ì‚­ì œ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    await prisma.post.delete({
      where: { id: postId },
    });

    return NextResponse.json({
      message: "ê²Œì‹œê¸€ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤",
    });

  } catch (error) {
    console.error("Post delete error:", error);
    return NextResponse.json(
      { error: "ê²Œì‹œê¸€ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/posts/[id]/tags/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// ê²Œì‹œê¸€ì˜ íƒœê·¸ ëª©ë¡ ì¡°íšŒ
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const postId = params.id;

    // ê²Œì‹œê¸€ í™•ì¸
    const post = await prisma.post.findUnique({
      where: { id: postId },
    });

    if (!post) {
      return NextResponse.json(
        { error: "ê²Œì‹œê¸€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // íƒœê·¸ ì¡°íšŒ
    const postTags = await prisma.postTag.findMany({
      where: { postId },
      include: {
        tag: true,
      },
    });

    return NextResponse.json({
      tags: postTags.map((pt) => pt.tag),
    });
  } catch (error) {
    console.error("Post tags fetch error:", error);
    return NextResponse.json(
      { error: "íƒœê·¸ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// ê²Œì‹œê¸€ì— íƒœê·¸ ì¶”ê°€
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const postId = params.id;
    const body = await request.json();
    const { tagName } = body;

    if (!tagName) {
      return NextResponse.json(
        { error: "íƒœê·¸ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”" },
        { status: 400 }
      );
    }

    // ê²Œì‹œê¸€ í™•ì¸
    const post = await prisma.post.findUnique({
      where: { id: postId },
    });

    if (!post) {
      return NextResponse.json(
        { error: "ê²Œì‹œê¸€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    if (post.userId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // íƒœê·¸ ì°¾ê¸° ë˜ëŠ” ìƒì„±
    let tag = await prisma.tag.findUnique({
      where: { name: tagName.trim().toLowerCase() },
    });

    if (!tag) {
      tag = await prisma.tag.create({
        data: { name: tagName.trim().toLowerCase() },
      });
    }

    // ì´ë¯¸ ì¶”ê°€ëœ íƒœê·¸ì¸ì§€ í™•ì¸
    const existingPostTag = await prisma.postTag.findUnique({
      where: {
        postId_tagId: {
          postId,
          tagId: tag.id,
        },
      },
    });

    if (existingPostTag) {
      return NextResponse.json(
        { error: "ì´ë¯¸ ì¶”ê°€ëœ íƒœê·¸ì…ë‹ˆë‹¤" },
        { status: 409 }
      );
    }

    // íƒœê·¸ ì¶”ê°€
    await prisma.postTag.create({
      data: {
        postId,
        tagId: tag.id,
      },
    });

    return NextResponse.json(
      {
        message: "íƒœê·¸ê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤",
        tag,
      },
      { status: 201 }
    );
  } catch (error) {
    console.error("Post tag add error:", error);
    return NextResponse.json(
      { error: "íƒœê·¸ ì¶”ê°€ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// ê²Œì‹œê¸€ì—ì„œ íƒœê·¸ ì œê±°
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const postId = params.id;
    const { searchParams } = new URL(request.url);
    const tagId = searchParams.get("tagId");

    if (!tagId) {
      return NextResponse.json(
        { error: "íƒœê·¸ IDê°€ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 400 }
      );
    }

    // ê²Œì‹œê¸€ í™•ì¸
    const post = await prisma.post.findUnique({
      where: { id: postId },
    });

    if (!post) {
      return NextResponse.json(
        { error: "ê²Œì‹œê¸€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    if (post.userId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // íƒœê·¸ ì œê±°
    await prisma.postTag.delete({
      where: {
        postId_tagId: {
          postId,
          tagId,
        },
      },
    });

    return NextResponse.json({
      message: "íƒœê·¸ê°€ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤",
    });
  } catch (error) {
    console.error("Post tag remove error:", error);
    return NextResponse.json(
      { error: "íƒœê·¸ ì œê±° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/posts/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import { z } from "zod";

const postSchema = z.object({
  title: z.string().min(1, "ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”").max(200),
  content: z.string().min(1, "ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”"),
  visibility: z.enum(["PRIVATE", "SHARED", "PUBLIC"]).optional(),
});

// ê²Œì‹œê¸€ ëª©ë¡ ì¡°íšŒ
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get("page") || "1");
    const limit = parseInt(searchParams.get("limit") || "20");
    const visibility = searchParams.get("visibility");
    const search = searchParams.get("search") || "";

    const skip = (page - 1) * limit;

    // 1. ë‚˜ì—ê²Œ ê³µìœ ëœ ê²Œì‹œê¸€ ID ëª©ë¡
    const sharedPosts = await prisma.sharedResource.findMany({
      where: {
        resourceType: "POST",
        sharedWithId: session.user.id,
      },
      select: {
        resourceId: true,
      },
    });

    const sharedPostIds = sharedPosts.map((sr) => sr.resourceId);

    // 2. ì¡°íšŒ ì¡°ê±´ êµ¬ì„±
    let where: any = {};
    
    if (visibility === "my") {
      // ë‚´ ê¸€ë§Œ
      where.userId = session.user.id;
    } else if (visibility === "public") {
      // ê³µê°œ ê¸€ë§Œ
      where.visibility = "PUBLIC";
    } else if (visibility === "shared") {
      // ë‚˜ì—ê²Œ ê³µìœ ëœ ê¸€ë§Œ
      where.id = { in: sharedPostIds };
    } else {
      // ì „ì²´ (ê¸°ë³¸)
      where.OR = [
        { userId: session.user.id },           // ë‚´ê°€ ì‘ì„±í•œ ê¸€
        { visibility: "PUBLIC" },              // ê³µê°œ ê¸€
        { id: { in: sharedPostIds } },         // ë‚˜ì—ê²Œ ê³µìœ ëœ ê¸€
      ];
    }

    // ê²€ìƒ‰ì–´ í•„í„°
    if (search) {
      const searchCondition = {
        OR: [
          { title: { contains: search, mode: "insensitive" } },
          { content: { contains: search, mode: "insensitive" } },
        ],
      };

      if (where.OR) {
        where.AND = [
          { OR: where.OR },
          searchCondition,
        ];
        delete where.OR;
      } else {
        where.AND = [searchCondition];
      }
    }

    const [posts, total] = await Promise.all([
      prisma.post.findMany({
        where,
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true,
            },
          },
          _count: {
            select: {
              comments: true,
            },
          },
        },
        orderBy: { createdAt: "desc" },
        skip,
        take: limit,
      }),
      prisma.post.count({ where }),
    ]);

    // 3. ê° ê²Œì‹œê¸€ì— ê³µìœ  ì •ë³´ ì¶”ê°€
    const postsWithShareInfo = await Promise.all(
      posts.map(async (post) => {
        const isShared = sharedPostIds.includes(post.id);
        let sharedBy = null;

        if (isShared && post.userId !== session.user.id) {
          // ê³µìœ ë°›ì€ ê²Œì‹œê¸€ì¸ ê²½ìš° ê³µìœ ì ì •ë³´ ì¡°íšŒ
          const shareInfo = await prisma.sharedResource.findFirst({
            where: {
              resourceType: "POST",
              resourceId: post.id,
              sharedWithId: session.user.id,
            },
            include: {
              owner: {
                select: {
                  id: true,
                  name: true,
                  email: true,
                },
              },
            },
          });

          if (shareInfo) {
            sharedBy = shareInfo.owner.name;
          }
        }

        return {
          ...post,
          isOwner: post.userId === session.user.id,
          isShared: isShared && post.userId !== session.user.id,
          sharedBy,
        };
      })
    );

    return NextResponse.json({
      posts: postsWithShareInfo,
      pagination: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    });

  } catch (error) {
    console.error("Posts fetch error:", error);
    return NextResponse.json(
      { error: "ê²Œì‹œê¸€ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// ê²Œì‹œê¸€ ìƒì„±
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const body = await request.json();
    const validation = postSchema.safeParse(body);

    if (!validation.success) {
      return NextResponse.json(
        { error: validation.error.errors[0].message },
        { status: 400 }
      );
    }

    const { title, content, visibility = "PRIVATE" } = validation.data;

    const post = await prisma.post.create({
      data: {
        title,
        content,
        visibility,
        userId: session.user.id,
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
      },
    });

    return NextResponse.json(
      {
        message: "ê²Œì‹œê¸€ì´ ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤",
        post,
      },
      { status: 201 }
    );

  } catch (error) {
    console.error("Post create error:", error);
    return NextResponse.json(
      { error: "ê²Œì‹œê¸€ ì‘ì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/saved-searches/[id]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// ì €ì¥ëœ ê²€ìƒ‰ ì‚­ì œ
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const searchId = params.id;

    const savedSearch = await prisma.savedSearch.findUnique({
      where: { id: searchId },
    });

    if (!savedSearch) {
      return NextResponse.json(
        { error: "ì €ì¥ëœ ê²€ìƒ‰ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    if (savedSearch.userId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    await prisma.savedSearch.delete({
      where: { id: searchId },
    });

    return NextResponse.json({
      message: "ì €ì¥ëœ ê²€ìƒ‰ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤",
    });
  } catch (error) {
    console.error("Saved search delete error:", error);
    return NextResponse.json(
      { error: "ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/saved-searches/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// ì €ì¥ëœ ê²€ìƒ‰ ëª©ë¡
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const savedSearches = await prisma.savedSearch.findMany({
      where: {
        userId: session.user.id,
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    return NextResponse.json({ savedSearches });
  } catch (error) {
    console.error("Saved searches fetch error:", error);
    return NextResponse.json(
      { error: "ì €ì¥ëœ ê²€ìƒ‰ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// ê²€ìƒ‰ ì €ì¥
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { name, query } = body;

    if (!name || !query) {
      return NextResponse.json(
        { error: "ì´ë¦„ê³¼ ê²€ìƒ‰ ì¡°ê±´ì„ ì…ë ¥í•˜ì„¸ìš”" },
        { status: 400 }
      );
    }

    const savedSearch = await prisma.savedSearch.create({
      data: {
        name,
        query,
        userId: session.user.id,
      },
    });

    return NextResponse.json(
      {
        message: "ê²€ìƒ‰ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤",
        savedSearch,
      },
      { status: 201 }
    );
  } catch (error) {
    console.error("Save search error:", error);
    return NextResponse.json(
      { error: "ê²€ìƒ‰ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/search/route.ts">
export const dynamic = 'force-dynamic';

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const q = searchParams.get("q") || "";
    const type = searchParams.get("type") || "ALL";       // ALL | FILE | POST
    const mimeType = searchParams.get("mimeType") || "";   // image | video | pdf | document | zip
    const tagsParam = searchParams.get("tags") || "";       // "tagId1,tagId2"
    const dateFrom = searchParams.get("dateFrom") || "";
    const dateTo = searchParams.get("dateTo") || "";

    const tagIds = tagsParam ? tagsParam.split(",").filter(Boolean) : [];

    let files: any[] = [];
    let posts: any[] = [];

    // ===== íŒŒì¼ ê²€ìƒ‰ =====
    if (type === "ALL" || type === "FILE") {
      const fileWhere: any = {
        userId: session.user.id,
      };

      // í‚¤ì›Œë“œ
      if (q.trim()) {
        fileWhere.originalName = {
          contains: q.trim(),
          mode: "insensitive",
        };
      }

      // MIME íƒ€ì… í•„í„°
      if (mimeType) {
        const mimeMap: Record<string, any> = {
          image: { startsWith: "image/" },
          video: { startsWith: "video/" },
          pdf: { equals: "application/pdf" },
          document: {
            in: [
              "application/msword",
              "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
              "application/vnd.ms-excel",
              "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
              "application/vnd.ms-powerpoint",
              "application/vnd.openxmlformats-officedocument.presentationml.presentation",
              "text/plain",
            ],
          },
          zip: {
            in: [
              "application/zip",
              "application/x-rar-compressed",
              "application/x-7z-compressed",
            ],
          },
        };

        if (mimeMap[mimeType]) {
          fileWhere.mimeType = mimeMap[mimeType];
        }
      }

      // ë‚ ì§œ í•„í„°
      if (dateFrom || dateTo) {
        fileWhere.createdAt = {};
        if (dateFrom) fileWhere.createdAt.gte = new Date(dateFrom);
        if (dateTo) {
          const to = new Date(dateTo);
          to.setHours(23, 59, 59, 999);
          fileWhere.createdAt.lte = to;
        }
      }

      // íƒœê·¸ í•„í„°
      if (tagIds.length > 0) {
        fileWhere.fileTags = {
          some: {
            tagId: { in: tagIds },
          },
        };
      }

      files = await prisma.file.findMany({
        where: fileWhere,
        include: {
          fileTags: {
            include: { tag: true },
          },
        },
        orderBy: { createdAt: "desc" },
        take: 50,
      });

      // BigInt ì§ë ¬í™”
      files = files.map(file => ({
        ...file,
        size: file.size.toString(),
      }));
    }

    // ===== ê²Œì‹œê¸€ ê²€ìƒ‰ =====
    if (type === "ALL" || type === "POST") {
      // ë¨¼ì € ê³µìœ ë°›ì€ ê²Œì‹œê¸€ ID ëª©ë¡ ì¡°íšŒ
      const sharedPostIds = await prisma.sharedResource.findMany({
        where: {
          resourceType: "POST",
          sharedWithId: session.user.id,
        },
        select: { resourceId: true },
      });

      const postWhere: any = {
        OR: [
          { userId: session.user.id },
          { visibility: "PUBLIC" },
          {
            visibility: "SHARED",
            id: { in: sharedPostIds.map(sr => sr.resourceId) },
          },
        ],
      };

      // í‚¤ì›Œë“œ
      if (q.trim()) {
        postWhere.AND = [
          {
            OR: [
              { title: { contains: q.trim(), mode: "insensitive" } },
              { content: { contains: q.trim(), mode: "insensitive" } },
            ],
          },
        ];
      }

      // ë‚ ì§œ í•„í„°
      if (dateFrom || dateTo) {
        const dateFilter: any = {};
        if (dateFrom) dateFilter.gte = new Date(dateFrom);
        if (dateTo) {
          const to = new Date(dateTo);
          to.setHours(23, 59, 59, 999);
          dateFilter.lte = to;
        }

        if (postWhere.AND) {
          postWhere.AND.push({ createdAt: dateFilter });
        } else {
          postWhere.AND = [{ createdAt: dateFilter }];
        }
      }

      // íƒœê·¸ í•„í„°
      if (tagIds.length > 0) {
        const tagFilter = {
          postTags: { some: { tagId: { in: tagIds } } },
        };
        if (postWhere.AND) {
          postWhere.AND.push(tagFilter);
        } else {
          postWhere.AND = [tagFilter];
        }
      }

      posts = await prisma.post.findMany({
        where: postWhere,
        include: {
          user: { select: { id: true, name: true } },
          postTags: { include: { tag: true } },
          _count: { select: { comments: true } },
        },
        orderBy: { createdAt: "desc" },
        take: 50,
      });
    }

    return NextResponse.json({
      files,
      posts,
      total: files.length + posts.length,
      query: q,
      filters: { type, mimeType, tagIds, dateFrom, dateTo },
    });
  } catch (error) {
    console.error("Search error:", error);
    return NextResponse.json(
      { error: "ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/tags/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// íƒœê·¸ ëª©ë¡ ì¡°íšŒ
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const search = searchParams.get("search") || "";

    // ëª¨ë“  íƒœê·¸ ì¡°íšŒ (ì‚¬ìš© íšŸìˆ˜ í¬í•¨)
    const tags = await prisma.tag.findMany({
      where: search
        ? {
            name: {
              contains: search,
              mode: "insensitive",
            },
          }
        : {},
      include: {
        _count: {
          select: {
            fileTags: true,
            postTags: true,
          },
        },
      },
      orderBy: {
        name: "asc",
      },
    });

    return NextResponse.json({
      tags: tags.map((tag) => ({
        ...tag,
        usageCount: tag._count.fileTags + tag._count.postTags,
      })),
    });
  } catch (error) {
    console.error("Tags fetch error:", error);
    return NextResponse.json(
      { error: "íƒœê·¸ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// íƒœê·¸ ìƒì„±
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { name, color } = body;

    if (!name || name.trim().length === 0) {
      return NextResponse.json(
        { error: "íƒœê·¸ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”" },
        { status: 400 }
      );
    }

    // ì¤‘ë³µ í™•ì¸
    const existingTag = await prisma.tag.findUnique({
      where: { name: name.trim().toLowerCase() },
    });

    if (existingTag) {
      return NextResponse.json(
        { error: "ì´ë¯¸ ì¡´ì¬í•˜ëŠ” íƒœê·¸ì…ë‹ˆë‹¤", tag: existingTag },
        { status: 409 }
      );
    }

    // íƒœê·¸ ìƒì„±
    const tag = await prisma.tag.create({
      data: {
        name: name.trim().toLowerCase(),
        color: color || null,
      },
    });

    return NextResponse.json(
      {
        message: "íƒœê·¸ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤",
        tag,
      },
      { status: 201 }
    );
  } catch (error) {
    console.error("Tag create error:", error);
    return NextResponse.json(
      { error: "íƒœê·¸ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/users/fcm-token/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// FCM í† í° ë“±ë¡
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { fcmToken } = body;

    if (!fcmToken) {
      return NextResponse.json(
        { error: "FCM í† í°ì„ ì œê³µí•˜ì„¸ìš”" },
        { status: 400 }
      );
    }

    // í† í° ì €ì¥
    await prisma.user.update({
      where: { id: session.user.id },
      data: { fcmToken },
    });

    return NextResponse.json({
      message: "FCM í† í°ì´ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤",
    });
  } catch (error) {
    console.error("FCM token registration error:", error);
    return NextResponse.json(
      { error: "í† í° ë“±ë¡ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// FCM í† í° ì‚­ì œ (ë¡œê·¸ì•„ì›ƒ ì‹œ)
export async function DELETE(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    await prisma.user.update({
      where: { id: session.user.id },
      data: { fcmToken: null },
    });

    return NextResponse.json({
      message: "FCM í† í°ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤",
    });
  } catch (error) {
    console.error("FCM token deletion error:", error);
    return NextResponse.json(
      { error: "í† í° ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/users/presence/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// ì˜¨ë¼ì¸ ìƒíƒœ ì—…ë°ì´íŠ¸
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { isOnline, networkType } = body;

    await prisma.user.update({
      where: { id: session.user.id },
      data: {
        isOnline: isOnline !== undefined ? isOnline : true,
        lastSeenAt: new Date(),
        networkType: networkType || "WIFI",
      },
    });

    return NextResponse.json({
      message: "ì˜¨ë¼ì¸ ìƒíƒœê°€ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤",
    });
  } catch (error) {
    console.error("Presence update error:", error);
    return NextResponse.json(
      { error: "ìƒíƒœ ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/find-email/page.tsx">
// =============================================
// íŒŒì¼ 1: src/app/find-email/page.tsx
// ì´ë©”ì¼(ì•„ì´ë””) ì°¾ê¸° í˜ì´ì§€
// =============================================
"use client";

import { useState } from "react";
import Link from "next/link";

export default function FindEmailPage() {
  const [name, setName] = useState("");
  const [loading, setLoading] = useState(false);
  const [result, setResult] = useState<{ maskedEmail: string } | null>(null);
  const [sent, setSent] = useState(false);
  const [error, setError] = useState("");

  const handleFind = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");
    setLoading(true);
    try {
      const res = await fetch("/api/auth/find-email", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name }),
      });
      const data = await res.json();
      if (res.ok) {
        setResult(data);
      } else {
        setError(data.error || "ì´ë©”ì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤");
      }
    } catch {
      setError("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  };

  const handleSendFull = async () => {
    setLoading(true);
    try {
      const res = await fetch("/api/auth/find-email/send", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name }),
      });
      if (res.ok) setSent(true);
      else setError("ì´ë©”ì¼ ë°œì†¡ ì‹¤íŒ¨");
    } catch {
      setError("ë°œì†¡ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="eum-root">
      <div className="eum-bg"><div className="eum-blob b1"/><div className="eum-blob b2"/></div>
      <div className="eum-container">
        <Link href="/login" className="eum-back">â† ë¡œê·¸ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°</Link>

        <div className="eum-card">
          <div className="eum-icon-wrap">ğŸ“§</div>
          <h2 className="eum-title">ì´ë©”ì¼ ì°¾ê¸°</h2>
          <p className="eum-sub">ê°€ì… ì‹œ ì…ë ¥í•œ ì´ë¦„ìœ¼ë¡œ ì´ë©”ì¼ì„ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤</p>

          {!result && !sent && (
            <form onSubmit={handleFind} className="eum-form">
              {error && <div className="eum-error">âš ï¸ {error}</div>}
              <div className="eum-field">
                <label className="eum-label">ì´ë¦„</label>
                <input type="text" value={name} onChange={(e) => setName(e.target.value)}
                  placeholder="ê°€ì… ì‹œ ì…ë ¥í•œ ì´ë¦„" className="eum-input" required />
              </div>
              <button type="submit" disabled={loading} className="eum-btn">
                {loading ? "ì°¾ëŠ” ì¤‘..." : "ì´ë©”ì¼ ì°¾ê¸°"}
              </button>
            </form>
          )}

          {result && !sent && (
            <div className="eum-result">
              <p className="eum-result-label">ê°€ì…ëœ ì´ë©”ì¼</p>
              <p className="eum-result-email">{result.maskedEmail}</p>
              <p className="eum-result-desc">ì „ì²´ ì´ë©”ì¼ ì£¼ì†Œë¥¼ ë°›ìœ¼ì‹œê² ìŠµë‹ˆê¹Œ?</p>
              <button onClick={handleSendFull} disabled={loading} className="eum-btn">
                {loading ? "ë°œì†¡ ì¤‘..." : "ì´ë©”ì¼ë¡œ ì „ì²´ ì£¼ì†Œ ë°›ê¸°"}
              </button>
              <Link href="/login" className="eum-link-btn">ë¡œê·¸ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°</Link>
            </div>
          )}

          {sent && (
            <div className="eum-success">
              <div className="eum-success-icon">âœ…</div>
              <p className="eum-success-msg">ì´ë©”ì¼ì´ ë°œì†¡ë˜ì—ˆìŠµë‹ˆë‹¤!</p>
              <p className="eum-success-sub">ë°›ì€ ë©”ì¼í•¨ì„ í™•ì¸í•´ì£¼ì„¸ìš”<br/>(ìŠ¤íŒ¸í•¨ë„ í™•ì¸í•´ë³´ì„¸ìš”)</p>
              <Link href="/login" className="eum-btn" style={{display:"block",textAlign:"center",textDecoration:"none",marginTop:"16px"}}>
                ë¡œê·¸ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°
              </Link>
            </div>
          )}
        </div>
      </div>
      <style>{EUM_FIND_STYLE}</style>
    </div>
  );
}

const EUM_FIND_STYLE = `
  * { box-sizing: border-box; margin: 0; padding: 0; }
  .eum-root { min-height: 100vh; min-height: 100dvh; background: #0f0c29; display: flex; align-items: center; justify-content: center; padding: 24px 20px; position: relative; overflow: hidden; font-family: 'Pretendard','Apple SD Gothic Neo',-apple-system,sans-serif; }
  .eum-bg { position: fixed; inset: 0; pointer-events: none; z-index: 0; }
  .eum-blob { position: absolute; border-radius: 50%; filter: blur(80px); opacity: 0.25; }
  .b1 { width: 380px; height: 380px; background: #7c3aed; top: -100px; left: -100px; }
  .b2 { width: 320px; height: 320px; background: #2563eb; bottom: -80px; right: -80px; }
  .eum-container { position: relative; z-index: 1; width: 100%; max-width: 400px; display: flex; flex-direction: column; gap: 16px; }
  .eum-back { font-size: 13px; color: rgba(255,255,255,0.4); text-decoration: none; display: inline-flex; align-items: center; gap: 4px; transition: color 0.2s; }
  .eum-back:hover { color: rgba(255,255,255,0.7); }
  .eum-card { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); border-radius: 24px; padding: 36px 28px; backdrop-filter: blur(20px); box-shadow: 0 25px 50px rgba(0,0,0,0.4); }
  .eum-icon-wrap { font-size: 40px; text-align: center; margin-bottom: 16px; }
  .eum-title { font-size: 22px; font-weight: 700; color: white; text-align: center; margin-bottom: 8px; }
  .eum-sub { font-size: 14px; color: rgba(255,255,255,0.5); text-align: center; line-height: 1.6; margin-bottom: 24px; }
  .eum-form { display: flex; flex-direction: column; gap: 16px; }
  .eum-field { display: flex; flex-direction: column; gap: 7px; }
  .eum-label { font-size: 13px; font-weight: 600; color: rgba(255,255,255,0.7); }
  .eum-input { background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12); border-radius: 12px; padding: 13px 16px; color: white; font-size: 16px; transition: all 0.2s; outline: none; width: 100%; -webkit-appearance: none; }
  .eum-input::placeholder { color: rgba(255,255,255,0.25); }
  .eum-input:focus { border-color: #7c3aed; background: rgba(124,58,237,0.1); box-shadow: 0 0 0 3px rgba(124,58,237,0.2); }
  .eum-error { background: rgba(239,68,68,0.15); border: 1px solid rgba(239,68,68,0.3); color: #fca5a5; font-size: 13px; padding: 12px 14px; border-radius: 12px; }
  .eum-btn { width: 100%; padding: 14px; background: linear-gradient(135deg, #7c3aed, #2563eb); border: none; border-radius: 12px; color: white; font-size: 15px; font-weight: 700; cursor: pointer; transition: all 0.2s; min-height: 50px; box-shadow: 0 4px 20px rgba(124,58,237,0.35); -webkit-tap-highlight-color: transparent; }
  .eum-btn:disabled { opacity: 0.5; cursor: not-allowed; }
  .eum-result { text-align: center; display: flex; flex-direction: column; gap: 12px; }
  .eum-result-label { font-size: 12px; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 1px; }
  .eum-result-email { font-size: 22px; font-weight: 700; color: #a78bfa; letter-spacing: 1px; }
  .eum-result-desc { font-size: 13px; color: rgba(255,255,255,0.5); }
  .eum-link-btn { text-align: center; font-size: 13px; color: rgba(255,255,255,0.35); text-decoration: none; margin-top: 4px; display: block; }
  .eum-success { text-align: center; display: flex; flex-direction: column; align-items: center; gap: 10px; }
  .eum-success-icon { font-size: 52px; }
  .eum-success-msg { font-size: 20px; font-weight: 700; color: white; }
  .eum-success-sub { font-size: 14px; color: rgba(255,255,255,0.5); line-height: 1.7; }
  .eum-expire { font-size: 12px; color: rgba(255,165,0,0.8); }
`;
</file>

<file path="src/app/register/page.tsx">
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import Link from "next/link";
import { 
  Mail, 
  Lock, 
  User, 
  Eye, 
  EyeOff, 
  Cloud, 
  AlertCircle, 
  Loader2, 
  CheckCircle2, 
  ChevronRight,
  ShieldCheck,
  FileText
} from "lucide-react";

interface PrivacyConsent {
  terms: boolean;
  privacy: boolean;
  age: boolean;
  marketing: boolean;
}

export default function RegisterPage() {
  const router = useRouter();

  // ì…ë ¥ ìƒíƒœ
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [passwordConfirm, setPasswordConfirm] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const [showPasswordConfirm, setShowPasswordConfirm] = useState(false);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  // ê°œì¸ì •ë³´ ë™ì˜ ìƒíƒœ
  const [showPrivacyModal, setShowPrivacyModal] = useState(false);
  const [showFullText, setShowFullText] = useState<"terms" | "privacy" | null>(null);
  const [consent, setConsent] = useState<PrivacyConsent>({
    terms: false, privacy: false, age: false, marketing: false,
  });
  const [consentDone, setConsentDone] = useState(false);

  // ìœ íš¨ì„± ê²€ì‚¬ ë¡œì§
  const passwordRules = {
    length: password.length >= 8,
    combo: /(?=.*[a-zA-Z])(?=.*\d)/.test(password),
  };
  const passwordMatch = password === passwordConfirm && passwordConfirm.length > 0;
  const emailValid = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  const allRequiredConsent = consent.terms && consent.privacy && consent.age;

  const handleAllConsent = (checked: boolean) => {
    setConsent({ terms: checked, privacy: checked, age: checked, marketing: checked });
  };

  const handleConsentSubmit = () => {
    if (!allRequiredConsent) return;
    setConsentDone(true);
    setShowPrivacyModal(false);
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");

    if (!consentDone) {
      setShowPrivacyModal(true);
      return;
    }

    if (!passwordRules.length || !passwordRules.combo || !passwordMatch) {
      setError("ì…ë ¥í•˜ì‹  ì •ë³´ë¥¼ ë‹¤ì‹œ í™•ì¸í•´ì£¼ì„¸ìš”.");
      return;
    }

    setLoading(true);
    try {
      // ğŸ’¡ ì˜¤ë¥˜ í•´ê²° í¬ì¸íŠ¸: API ê²½ë¡œê°€ /api/auth/register ì¸ì§€ /api/register ì¸ì§€ í™•ì¸ í•„ìš”
      // í˜„ì¬ í”„ë¡œì íŠ¸ êµ¬ì¡°ì— ë§ì¶° ì—”ë“œí¬ì¸íŠ¸ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.
      const res = await fetch("/api/auth/register", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ 
          name, 
          email, 
          password, 
          marketingConsent: consent.marketing 
        }),
      });

      const data = await res.json();

      if (res.ok) {
        // ì„±ê³µ ì‹œ ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ ì´ë™í•˜ë©° ì„±ê³µ ë©”ì‹œì§€ ì „ë‹¬
        router.push("/login?signup=success");
      } else {
        setError(data.error || "ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ ì´ë©”ì¼ì´ê±°ë‚˜ ê°€ì… ì •ë³´ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.");
      }
    } catch (err) {
      setError("ì„œë²„ì™€ì˜ í†µì‹  ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-[#0f0c29] text-white flex items-center justify-center p-6 relative overflow-hidden font-sans">
      {/* ë°°ê²½ ì¥ì‹ */}
      <div className="absolute top-[-10%] left-[-10%] w-[40%] h-[40%] bg-purple-600/20 blur-[100px] rounded-full -z-10" />
      <div className="absolute bottom-[-10%] right-[-10%] w-[40%] h-[40%] bg-blue-600/20 blur-[100px] rounded-full -z-10" />

      <div className="max-w-md w-full relative z-10">
        {/* ë¡œê³  ì˜ì—­ */}
        <div className="text-center mb-8 flex flex-col items-center">
          <Link href="/" className="inline-flex items-center gap-3 group">
            <div className="w-12 h-12 bg-gradient-to-br from-purple-500 to-blue-600 rounded-2xl flex items-center justify-center shadow-xl group-hover:scale-110 transition-transform">
              <Cloud size={28} fill="currentColor" />
            </div>
            <div className="text-left">
              <h1 className="text-3xl font-black tracking-tighter italic leading-none">EUM</h1>
              <p className="text-[10px] text-white/40 uppercase tracking-[0.2em] font-bold mt-1">Personal Cloud</p>
            </div>
          </Link>
        </div>

        {/* íšŒì›ê°€ì… ì¹´ë“œ */}
        <div className="bg-white/5 border border-white/10 p-8 rounded-[40px] backdrop-blur-2xl shadow-2xl">
          <div className="mb-6">
            <h2 className="text-2xl font-bold mb-1">íšŒì›ê°€ì…</h2>
            <p className="text-white/50 text-sm">ì´ìŒì˜ ìƒˆ ê°€ì¡±ì´ ë˜ì–´ì£¼ì„¸ìš” âœ¨</p>
          </div>

          {error && (
            <div className="mb-6 flex items-center gap-2 bg-red-500/10 border border-red-500/20 text-red-400 p-4 rounded-2xl text-sm">
              <AlertCircle size={18} />
              <p>{error}</p>
            </div>
          )}

          <form onSubmit={handleSubmit} className="space-y-4">
            {/* ì´ë¦„ ì…ë ¥ */}
            <div className="space-y-1.5">
              <label className="text-xs font-bold text-white/40 ml-1 uppercase tracking-wider">Name</label>
              <div className="relative group">
                <div className="absolute inset-y-0 left-4 flex items-center text-white/20 group-focus-within:text-purple-400 transition-colors">
                  <User size={18} />
                </div>
                <input
                  type="text"
                  value={name}
                  onChange={(e) => setName(e.target.value)}
                  placeholder="í™ê¸¸ë™"
                  className="w-full bg-white/5 border border-white/10 rounded-2xl py-3.5 pl-12 pr-4 outline-none focus:border-purple-500/50 focus:bg-white/10 transition-all"
                  required
                />
              </div>
            </div>

            {/* ì´ë©”ì¼ ì…ë ¥ */}
            <div className="space-y-1.5">
              <label className="text-xs font-bold text-white/40 ml-1 uppercase tracking-wider">Email</label>
              <div className="relative group">
                <div className="absolute inset-y-0 left-4 flex items-center text-white/20 group-focus-within:text-purple-400 transition-colors">
                  <Mail size={18} />
                </div>
                <input
                  type="email"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  placeholder="example@email.com"
                  className={`w-full bg-white/5 border border-white/10 rounded-2xl py-3.5 pl-12 pr-4 outline-none focus:border-purple-500/50 focus:bg-white/10 transition-all ${email && !emailValid ? "border-red-500/50" : emailValid ? "border-emerald-500/50" : ""}`}
                  required
                />
              </div>
            </div>

            {/* ë¹„ë°€ë²ˆí˜¸ ì…ë ¥ */}
            <div className="space-y-1.5">
              <label className="text-xs font-bold text-white/40 ml-1 uppercase tracking-wider">Password</label>
              <div className="relative group">
                <div className="absolute inset-y-0 left-4 flex items-center text-white/20 group-focus-within:text-purple-400 transition-colors">
                  <Lock size={18} />
                </div>
                <input
                  type={showPassword ? "text" : "password"}
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  placeholder="8ì ì´ìƒ, ì˜ë¬¸+ìˆ«ì"
                  className="w-full bg-white/5 border border-white/10 rounded-2xl py-3.5 pl-12 pr-12 outline-none focus:border-purple-500/50 focus:bg-white/10 transition-all"
                  required
                />
                <button
                  type="button"
                  onClick={() => setShowPassword(!showPassword)}
                  className="absolute inset-y-0 right-4 flex items-center text-white/20 hover:text-white"
                >
                  {showPassword ? <EyeOff size={18} /> : <Eye size={18} />}
                </button>
              </div>
              {/* ë¹„ë°€ë²ˆí˜¸ ê·œì¹™ ì²´í¬ í‘œì‹œ */}
              {password && (
                <div className="flex gap-3 px-1 mt-1">
                  <div className={`flex items-center gap-1 text-[11px] ${passwordRules.length ? "text-emerald-400" : "text-white/20"}`}>
                    <CheckCircle2 size={12} /> 8ì ì´ìƒ
                  </div>
                  <div className={`flex items-center gap-1 text-[11px] ${passwordRules.combo ? "text-emerald-400" : "text-white/20"}`}>
                    <CheckCircle2 size={12} /> ì˜ë¬¸+ìˆ«ì
                  </div>
                </div>
              )}
            </div>

            {/* ë¹„ë°€ë²ˆí˜¸ í™•ì¸ */}
            <div className="space-y-1.5">
              <label className="text-xs font-bold text-white/40 ml-1 uppercase tracking-wider">Confirm Password</label>
              <div className="relative group">
                <div className="absolute inset-y-0 left-4 flex items-center text-white/20 group-focus-within:text-purple-400 transition-colors">
                  <Lock size={18} />
                </div>
                <input
                  type={showPasswordConfirm ? "text" : "password"}
                  value={passwordConfirm}
                  onChange={(e) => setPasswordConfirm(e.target.value)}
                  placeholder="ë¹„ë°€ë²ˆí˜¸ ì¬ì…ë ¥"
                  className={`w-full bg-white/5 border border-white/10 rounded-2xl py-3.5 pl-12 pr-12 outline-none focus:border-purple-500/50 focus:bg-white/10 transition-all ${passwordConfirm && !passwordMatch ? "border-red-500/50" : passwordMatch ? "border-emerald-500/50" : ""}`}
                  required
                />
                <button
                  type="button"
                  onClick={() => setShowPasswordConfirm(!showPasswordConfirm)}
                  className="absolute inset-y-0 right-4 flex items-center text-white/20 hover:text-white"
                >
                  {showPasswordConfirm ? <EyeOff size={18} /> : <Eye size={18} />}
                </button>
              </div>
            </div>

            {/* ì•½ê´€ ë™ì˜ ì„¹ì…˜ */}
            <div className="pt-2">
              {consentDone ? (
                <button 
                  type="button" 
                  onClick={() => setShowPrivacyModal(true)}
                  className="w-full bg-emerald-500/10 border border-emerald-500/30 rounded-2xl p-3 flex items-center justify-between group"
                >
                  <div className="flex items-center gap-2 text-emerald-400 text-sm font-medium">
                    <ShieldCheck size={18} />
                    <span>ì•½ê´€ ë™ì˜ ì™„ë£Œ</span>
                  </div>
                  <span className="text-[10px] text-white/20 group-hover:text-white/40">ë³€ê²½í•˜ê¸°</span>
                </button>
              ) : (
                <button
                  type="button"
                  onClick={() => setShowPrivacyModal(true)}
                  className="w-full bg-white/5 border border-dashed border-white/20 rounded-2xl p-3 text-white/40 text-sm hover:bg-white/10 hover:border-white/40 transition-all flex items-center justify-center gap-2"
                >
                  <FileText size={18} />
                  ê°œì¸ì •ë³´ ìˆ˜ì§‘ ë™ì˜ (í•„ìˆ˜)
                </button>
              )}
            </div>

            <button
              type="submit"
              disabled={loading || !consentDone}
              className="w-full py-4 bg-gradient-to-r from-purple-500 to-blue-600 text-white font-bold rounded-2xl hover:opacity-90 active:scale-[0.98] transition-all flex items-center justify-center gap-2 shadow-xl shadow-purple-500/20 disabled:opacity-30 mt-4"
            >
              {loading ? <Loader2 size={20} className="animate-spin" /> : <>íšŒì›ê°€ì… <ChevronRight size={20} /></>}
            </button>
          </form>

          <div className="mt-6 text-center">
            <p className="text-white/40 text-sm">
              ì´ë¯¸ ê³„ì •ì´ ìˆìœ¼ì‹ ê°€ìš”?{" "}
              <Link href="/login" className="text-white font-bold hover:text-purple-400 underline underline-offset-4">
                ë¡œê·¸ì¸
              </Link>
            </p>
          </div>
        </div>
      </div>

      {/* ë™ì˜ ëª¨ë‹¬ (ìƒëµ: ê¸°ì¡´ ë¡œì§ê³¼ ë™ì¼í•˜ë‚˜ ë””ìì¸ì„ EUM ìŠ¤íƒ€ì¼ë¡œ ì¡°ì •) */}
      {showPrivacyModal && (
        <div className="fixed inset-0 z-[100] flex items-end sm:items-center justify-center p-0 sm:p-4 bg-black/80 backdrop-blur-sm animate-in fade-in duration-200">
          <div className="bg-[#1a1735] w-full max-w-lg rounded-t-[32px] sm:rounded-[32px] p-8 border border-white/10 shadow-2xl overflow-y-auto max-h-[90vh]">
            <h3 className="text-xl font-bold mb-2">ì„œë¹„ìŠ¤ ì´ìš© ë™ì˜</h3>
            <p className="text-white/40 text-sm mb-6">ì›í™œí•œ ì„œë¹„ìŠ¤ ì œê³µì„ ìœ„í•´ í•„ìˆ˜ í•­ëª©ì— ë™ì˜ê°€ í•„ìš”í•©ë‹ˆë‹¤.</p>
            
            <div className="space-y-1">
              <label className="flex items-center gap-3 p-4 bg-white/5 rounded-2xl cursor-pointer hover:bg-white/10 transition-colors mb-4">
                <input 
                  type="checkbox" 
                  className="w-5 h-5 rounded-lg accent-purple-500"
                  checked={consent.terms && consent.privacy && consent.age && consent.marketing}
                  onChange={(e) => handleAllConsent(e.target.checked)}
                />
                <span className="font-bold">ì „ì²´ ë™ì˜í•˜ê¸°</span>
              </label>
              
              <div className="space-y-1 px-1">
                {[
                  { key: "terms", label: "[í•„ìˆ˜] ì„œë¹„ìŠ¤ ì´ìš©ì•½ê´€", type: "terms" },
                  { key: "privacy", label: "[í•„ìˆ˜] ê°œì¸ì •ë³´ ì²˜ë¦¬ë°©ì¹¨", type: "privacy" },
                  { key: "age", label: "[í•„ìˆ˜] ë§Œ 14ì„¸ ì´ìƒì…ë‹ˆë‹¤", type: null },
                  { key: "marketing", label: "[ì„ íƒ] ë§ˆì¼€íŒ… ì •ë³´ ìˆ˜ì‹ ", type: null },
                ].map((item) => (
                  <div key={item.key} className="flex items-center justify-between py-3 border-b border-white/5 last:border-0">
                    <label className="flex items-center gap-3 cursor-pointer">
                      <input 
                        type="checkbox" 
                        className="w-4 h-4 rounded accent-purple-500"
                        checked={consent[item.key as keyof PrivacyConsent]}
                        onChange={(e) => setConsent({ ...consent, [item.key]: e.target.checked })}
                      />
                      <span className={`text-sm ${item.key === 'marketing' ? 'text-white/40' : 'text-white/70'}`}>{item.label}</span>
                    </label>
                    {item.type && (
                      <button 
                        onClick={() => setShowFullText(item.type as "terms" | "privacy")}
                        className="text-[11px] text-white/30 underline"
                      >ì „ë¬¸ë³´ê¸°</button>
                    )}
                  </div>
                ))}
              </div>
            </div>

            <div className="mt-8 flex gap-3">
              <button 
                onClick={() => setShowPrivacyModal(false)}
                className="flex-1 py-4 bg-white/5 rounded-2xl font-bold hover:bg-white/10 transition-colors"
              >ì·¨ì†Œ</button>
              <button 
                onClick={handleConsentSubmit}
                disabled={!allRequiredConsent}
                className="flex-[2] py-4 bg-gradient-to-r from-purple-500 to-blue-600 rounded-2xl font-bold disabled:opacity-30"
              >ë™ì˜í•˜ê³  ê³„ì†í•˜ê¸°</button>
            </div>
          </div>
        </div>
      )}

      {/* ì•½ê´€ ì „ë¬¸ ëª¨ë‹¬ (ê¸°ì¡´ ë¡œì§ ìœ ì§€) */}
      {showFullText && (
        <div className="fixed inset-0 z-[110] flex items-center justify-center p-4 bg-black/90">
          <div className="bg-[#1a1735] w-full max-w-2xl rounded-[32px] p-8 border border-white/10 flex flex-col max-h-[80vh]">
            <h4 className="text-lg font-bold mb-4">{showFullText === "terms" ? "ì´ìš©ì•½ê´€" : "ê°œì¸ì •ë³´ ì²˜ë¦¬ë°©ì¹¨"}</h4>
            <div className="flex-1 overflow-y-auto bg-black/20 rounded-2xl p-6 text-sm text-white/60 leading-relaxed whitespace-pre-wrap">
              {showFullText === "terms" ? TERMS_TEXT : PRIVACY_TEXT}
            </div>
            <button 
              onClick={() => setShowFullText(null)}
              className="mt-6 w-full py-4 bg-white/10 rounded-2xl font-bold"
            >í™•ì¸</button>
          </div>
        </div>
      )}
    </div>
  );
}

// ì•½ê´€ í…ìŠ¤íŠ¸ ë°ì´í„° (ìƒëµ - ê¸°ì¡´ ë°ì´í„° ì‚¬ìš©)
const TERMS_TEXT = `...`;
const PRIVACY_TEXT = `...`;
</file>

<file path="src/app/reset-password/confirm/page.tsx">
"use client";

import { useState, useEffect, Suspense } from "react";
import { useSearchParams, useRouter } from "next/navigation";
import Link from "next/link";

function ResetPasswordContent() {
  const searchParams = useSearchParams();
  const router = useRouter();
  const token = searchParams.get("token");

  const [password, setPassword] = useState("");
  const [confirm, setConfirm] = useState("");
  const [loading, setLoading] = useState(false);
  const [done, setDone] = useState(false);
  const [error, setError] = useState("");

  useEffect(() => {
    if (!token) {
      setError("ìœ íš¨í•˜ì§€ ì•Šì€ ë§í¬ì…ë‹ˆë‹¤");
    }
  }, [token]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");

    if (password !== confirm) {
      setError("ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤");
      return;
    }
    if (password.length < 8 || !/(?=.*[a-zA-Z])(?=.*\d)/.test(password)) {
      setError("ë¹„ë°€ë²ˆí˜¸ëŠ” 8ì ì´ìƒ, ì˜ë¬¸+ìˆ«ì ì¡°í•©ì´ì–´ì•¼ í•©ë‹ˆë‹¤");
      return;
    }

    setLoading(true);
    try {
      const res = await fetch("/api/auth/reset-password/confirm", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ token, password }),
      });
      const data = await res.json();
      if (res.ok) {
        setDone(true);
        setTimeout(() => router.push("/login"), 3000);
      } else {
        setError(data.error || "ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
      }
    } catch {
      setError("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="eum-card">
      <div className="eum-icon-wrap">ğŸ”‘</div>
      <h2 className="eum-title">ìƒˆ ë¹„ë°€ë²ˆí˜¸ ì„¤ì •</h2>

      {done ? (
        <div className="eum-success">
          <div className="eum-success-icon">âœ…</div>
          <p className="eum-success-msg">ë¹„ë°€ë²ˆí˜¸ê°€ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤!</p>
          <p className="eum-success-sub">3ì´ˆ í›„ ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ ì´ë™í•©ë‹ˆë‹¤</p>
          <Link
            href="/login"
            className="eum-btn"
            style={{
              display: "block",
              textAlign: "center",
              textDecoration: "none",
              marginTop: "16px",
            }}
          >
            ë¡œê·¸ì¸í•˜ëŸ¬ ê°€ê¸°
          </Link>
        </div>
      ) : (
        <>
          <p className="eum-sub">ìƒˆë¡œ ì‚¬ìš©í•  ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”</p>
          <form onSubmit={handleSubmit} className="eum-form">
            {error && <div className="eum-error">âš ï¸ {error}</div>}
            <div className="eum-field">
              <label className="eum-label">ìƒˆ ë¹„ë°€ë²ˆí˜¸</label>
              <input
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                placeholder="8ì ì´ìƒ, ì˜ë¬¸+ìˆ«ì"
                className="eum-input"
                required
              />
            </div>
            <div className="eum-field">
              <label className="eum-label">ë¹„ë°€ë²ˆí˜¸ í™•ì¸</label>
              <input
                type="password"
                value={confirm}
                onChange={(e) => setConfirm(e.target.value)}
                placeholder="ë¹„ë°€ë²ˆí˜¸ë¥¼ ë‹¤ì‹œ ì…ë ¥í•˜ì„¸ìš”"
                className="eum-input"
                required
              />
              {confirm && (
                <span
                  style={{
                    fontSize: "12px",
                    marginTop: "4px",
                    color: password === confirm ? "#4ade80" : "#f87171",
                  }}
                >
                  {password === confirm ? "âœ… ì¼ì¹˜í•©ë‹ˆë‹¤" : "âŒ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤"}
                </span>
              )}
            </div>
            <button
              type="submit"
              disabled={loading || !token}
              className="eum-btn"
            >
              {loading ? "ë³€ê²½ ì¤‘..." : "ë¹„ë°€ë²ˆí˜¸ ë³€ê²½í•˜ê¸°"}
            </button>
          </form>
        </>
      )}
    </div>
  );
}

export default function ResetPasswordConfirmPage() {
  return (
    <div className="eum-root">
      <div className="eum-bg">
        <div className="eum-blob b1" />
        <div className="eum-blob b2" />
      </div>
      <div className="eum-container">
        <Suspense fallback={<div className="eum-card" style={{ color: 'white', textAlign: 'center' }}>ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>}>
          <ResetPasswordContent />
        </Suspense>
      </div>
      <style>{EUM_FIND_STYLE}</style>
    </div>
  );
}

const EUM_FIND_STYLE = `
  * { box-sizing: border-box; margin: 0; padding: 0; }
  .eum-root { min-height: 100vh; min-height: 100dvh; background: #0f0c29; display: flex; align-items: center; justify-content: center; padding: 24px 20px; position: relative; overflow: hidden; font-family: 'Pretendard','Apple SD Gothic Neo',-apple-system,sans-serif; }
  .eum-bg { position: fixed; inset: 0; pointer-events: none; z-index: 0; }
  .eum-blob { position: absolute; border-radius: 50%; filter: blur(80px); opacity: 0.25; }
  .b1 { width: 380px; height: 380px; background: #7c3aed; top: -100px; left: -100px; }
  .b2 { width: 320px; height: 320px; background: #2563eb; bottom: -80px; right: -80px; }
  .eum-container { position: relative; z-index: 1; width: 100%; max-width: 400px; }
  .eum-card { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); border-radius: 24px; padding: 36px 28px; backdrop-filter: blur(20px); box-shadow: 0 25px 50px rgba(0,0,0,0.4); }
  .eum-icon-wrap { font-size: 40px; text-align: center; margin-bottom: 16px; }
  .eum-title { font-size: 22px; font-weight: 700; color: white; text-align: center; margin-bottom: 8px; }
  .eum-sub { font-size: 14px; color: rgba(255,255,255,0.5); text-align: center; line-height: 1.6; margin-bottom: 24px; }
  .eum-form { display: flex; flex-direction: column; gap: 16px; }
  .eum-field { display: flex; flex-direction: column; gap: 7px; }
  .eum-label { font-size: 13px; font-weight: 600; color: rgba(255,255,255,0.7); }
  .eum-input { background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12); border-radius: 12px; padding: 13px 16px; color: white; font-size: 16px; transition: all 0.2s; outline: none; width: 100%; -webkit-appearance: none; }
  .eum-input::placeholder { color: rgba(255,255,255,0.25); }
  .eum-input:focus { border-color: #7c3aed; background: rgba(124,58,237,0.1); box-shadow: 0 0 0 3px rgba(124,58,237,0.2); }
  .eum-error { background: rgba(239,68,68,0.15); border: 1px solid rgba(239,68,68,0.3); color: #fca5a5; font-size: 13px; padding: 12px 14px; border-radius: 12px; }
  .eum-btn { width: 100%; padding: 14px; background: linear-gradient(135deg, #7c3aed, #2563eb); border: none; border-radius: 12px; color: white; font-size: 15px; font-weight: 700; cursor: pointer; transition: all 0.2s; min-height: 50px; box-shadow: 0 4px 20px rgba(124,58,237,0.35); -webkit-tap-highlight-color: transparent; }
  .eum-btn:disabled { opacity: 0.5; cursor: not-allowed; }
  .eum-success { text-align: center; display: flex; flex-direction: column; align-items: center; gap: 10px; }
  .eum-success-icon { font-size: 52px; }
  .eum-success-msg { font-size: 20px; font-weight: 700; color: white; }
  .eum-success-sub { font-size: 14px; color: rgba(255,255,255,0.5); line-height: 1.7; }
`;
</file>

<file path="src/app/reset-password/page.tsx">
"use client";

import { useState } from "react";
import Link from "next/link";

export default function ResetPasswordPage() {
  const [email, setEmail] = useState("");
  const [loading, setLoading] = useState(false);
  const [sent, setSent] = useState(false);
  const [error, setError] = useState("");

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");
    setLoading(true);
    try {
      const res = await fetch("/api/auth/reset-password", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email }),
      });
      const data = await res.json();
      if (res.ok) setSent(true);
      else setError(data.error || "ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } catch {
      setError("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="eum-root">
      <div className="eum-bg">
        <div className="eum-blob b1" />
        <div className="eum-blob b2" />
      </div>
      <div className="eum-container">
        <Link href="/login" className="eum-back">â† ë¡œê·¸ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°</Link>
        <div className="eum-card">
          <div className="eum-icon-wrap">ğŸ”</div>
          <h2 className="eum-title">ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì •</h2>
          {!sent ? (
            <>
              <p className="eum-sub">
                ê°€ì…í•œ ì´ë©”ì¼ ì£¼ì†Œë¥¼ ì…ë ¥í•˜ë©´<br />
                ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì • ë§í¬ë¥¼ ë³´ë‚´ë“œë¦½ë‹ˆë‹¤
              </p>
              <form onSubmit={handleSubmit} className="eum-form">
                {error && <div className="eum-error">âš ï¸ {error}</div>}
                <div className="eum-field">
                  <label className="eum-label">ì´ë©”ì¼</label>
                  <input
                    type="email"
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                    placeholder="ê°€ì…í•œ ì´ë©”ì¼ ì£¼ì†Œ"
                    className="eum-input"
                    required
                  />
                </div>
                <button type="submit" disabled={loading} className="eum-btn">
                  {loading ? "ì „ì†¡ ì¤‘..." : "ì¬ì„¤ì • ë§í¬ ë°›ê¸°"}
                </button>
              </form>
            </>
          ) : (
            <div className="eum-success">
              <div className="eum-success-icon">ğŸ“¨</div>
              <p className="eum-success-msg">ë©”ì¼ì„ ë°œì†¡í–ˆìŠµë‹ˆë‹¤!</p>
              <p className="eum-success-sub">
                <strong>{email}</strong>ë¡œ ì „ì†¡ëœ<br />
                ë§í¬ë¥¼ í´ë¦­í•´ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì¬ì„¤ì •í•˜ì„¸ìš”<br />
                <span className="eum-expire">ë§í¬ëŠ” 15ë¶„ê°„ ìœ íš¨í•©ë‹ˆë‹¤</span>
              </p>
              <Link
                href="/login"
                className="eum-btn"
                style={{ display: "block", textAlign: "center", textDecoration: "none", marginTop: "16px" }}
              >
                ë¡œê·¸ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°
              </Link>
            </div>
          )}
        </div>
      </div>
      <style>{EUM_FIND_STYLE}</style>
    </div>
  );
}

const EUM_FIND_STYLE = `
  * { box-sizing: border-box; margin: 0; padding: 0; }
  .eum-root { min-height: 100vh; min-height: 100dvh; background: #0f0c29; display: flex; align-items: center; justify-content: center; padding: 24px 20px; position: relative; overflow: hidden; font-family: 'Pretendard','Apple SD Gothic Neo',-apple-system,sans-serif; }
  .eum-bg { position: fixed; inset: 0; pointer-events: none; z-index: 0; }
  .eum-blob { position: absolute; border-radius: 50%; filter: blur(80px); opacity: 0.25; }
  .b1 { width: 380px; height: 380px; background: #7c3aed; top: -100px; left: -100px; }
  .b2 { width: 320px; height: 320px; background: #2563eb; bottom: -80px; right: -80px; }
  .eum-container { position: relative; z-index: 1; width: 100%; max-width: 400px; display: flex; flex-direction: column; gap: 16px; }
  .eum-back { font-size: 13px; color: rgba(255,255,255,0.4); text-decoration: none; display: inline-flex; align-items: center; gap: 4px; transition: color 0.2s; }
  .eum-back:hover { color: rgba(255,255,255,0.7); }
  .eum-card { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); border-radius: 24px; padding: 36px 28px; backdrop-filter: blur(20px); box-shadow: 0 25px 50px rgba(0,0,0,0.4); }
  .eum-icon-wrap { font-size: 40px; text-align: center; margin-bottom: 16px; }
  .eum-title { font-size: 22px; font-weight: 700; color: white; text-align: center; margin-bottom: 8px; }
  .eum-sub { font-size: 14px; color: rgba(255,255,255,0.5); text-align: center; line-height: 1.6; margin-bottom: 24px; }
  .eum-form { display: flex; flex-direction: column; gap: 16px; }
  .eum-field { display: flex; flex-direction: column; gap: 7px; }
  .eum-label { font-size: 13px; font-weight: 600; color: rgba(255,255,255,0.7); }
  .eum-input { background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12); border-radius: 12px; padding: 13px 16px; color: white; font-size: 16px; transition: all 0.2s; outline: none; width: 100%; -webkit-appearance: none; }
  .eum-input::placeholder { color: rgba(255,255,255,0.25); }
  .eum-input:focus { border-color: #7c3aed; background: rgba(124,58,237,0.1); box-shadow: 0 0 0 3px rgba(124,58,237,0.2); }
  .eum-error { background: rgba(239,68,68,0.15); border: 1px solid rgba(239,68,68,0.3); color: #fca5a5; font-size: 13px; padding: 12px 14px; border-radius: 12px; }
  .eum-btn { width: 100%; padding: 14px; background: linear-gradient(135deg, #7c3aed, #2563eb); border: none; border-radius: 12px; color: white; font-size: 15px; font-weight: 700; cursor: pointer; transition: all 0.2s; min-height: 50px; box-shadow: 0 4px 20px rgba(124,58,237,0.35); -webkit-tap-highlight-color: transparent; }
  .eum-btn:disabled { opacity: 0.5; cursor: not-allowed; }
  .eum-success { text-align: center; display: flex; flex-direction: column; align-items: center; gap: 10px; }
  .eum-success-icon { font-size: 52px; }
  .eum-success-msg { font-size: 20px; font-weight: 700; color: white; }
  .eum-success-sub { font-size: 14px; color: rgba(255,255,255,0.5); line-height: 1.7; }
  .eum-expire { font-size: 12px; color: rgba(255,165,0,0.8); }
`;
</file>

<file path="src/components/Breadcrumb.tsx">
"use client";

interface BreadcrumbItem {
  id: string | null;
  name: string;
}

interface BreadcrumbProps {
  path: BreadcrumbItem[];
  onNavigate: (folderId: string | null) => void;
}

export default function Breadcrumb({ path, onNavigate }: BreadcrumbProps) {
  return (
    <div className="flex items-center gap-2 text-sm text-gray-600 mb-4">
      {path.map((item, index) => (
        <div key={item.id || "root"} className="flex items-center gap-2">
          <button
            onClick={() => onNavigate(item.id)}
            className={`hover:text-blue-600 ${
              index === path.length - 1
                ? "font-semibold text-gray-900"
                : "text-gray-600"
            }`}
          >
            {item.name}
          </button>
          {index < path.length - 1 && (
            <span className="text-gray-400">/</span>
          )}
        </div>
      ))}
    </div>
  );
}
</file>

<file path="src/components/FileDropZone.tsx">
"use client";

import { useState, DragEvent } from "react";

interface FileDropZoneProps {
  onFileSelect: (file: File) => void;
  uploading: boolean;
}

export default function FileDropZone({ onFileSelect, uploading }: FileDropZoneProps) {
  const [isDragging, setIsDragging] = useState(false);

  const handleDragEnter = (e: DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(true);
  };

  const handleDragLeave = (e: DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);
  };

  const handleDragOver = (e: DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
  };

  const handleDrop = (e: DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);

    const files = Array.from(e.dataTransfer.files);
    if (files.length > 0) {
      onFileSelect(files[0]);
    }
  };

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (files && files.length > 0) {
      onFileSelect(files[0]);
    }
  };

  return (
    <div
      className={`relative border-2 border-dashed rounded-lg p-8 text-center transition ${
        isDragging
          ? "border-blue-500 bg-blue-50"
          : "border-gray-300 bg-gray-50 hover:border-gray-400"
      } ${uploading ? "opacity-50 pointer-events-none" : ""}`}
      onDragEnter={handleDragEnter}
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
    >
      <input
        type="file"
        onChange={handleFileChange}
        disabled={uploading}
        className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
      />

      <div className="pointer-events-none">
        <div className="text-4xl mb-4">
          {uploading ? "â³" : "ğŸ“¤"}
        </div>
        <p className="text-lg font-medium text-gray-700 mb-2">
          {uploading ? "ì—…ë¡œë“œ ì¤‘..." : "íŒŒì¼ì„ ë“œë˜ê·¸í•˜ê±°ë‚˜ í´ë¦­í•˜ì„¸ìš”"}
        </p>
        <p className="text-sm text-gray-500">
          ì´ë¯¸ì§€, ë™ì˜ìƒ, ë¬¸ì„œ (ìµœëŒ€ 2GB)
        </p>
      </div>
    </div>
  );
}
</file>

<file path="src/components/FileFilters.tsx">
"use client";

interface FileFiltersProps {
  fileType: string;
  onFileTypeChange: (type: string) => void;
  sortBy: string;
  onSortByChange: (sort: string) => void;
}

export default function FileFilters({
  fileType,
  onFileTypeChange,
  sortBy,
  onSortByChange,
}: FileFiltersProps) {
  return (
    <div className="flex flex-wrap gap-4 items-center">
      {/* íŒŒì¼ íƒ€ì… í•„í„° */}
      <div>
        <label className="text-sm text-gray-600 mr-2">íƒ€ì…:</label>
        <select
          value={fileType}
          onChange={(e) => onFileTypeChange(e.target.value)}
          className="px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
        >
          <option value="">ì „ì²´</option>
          <option value="image">ì´ë¯¸ì§€</option>
          <option value="video">ë™ì˜ìƒ</option>
          <option value="document">ë¬¸ì„œ</option>
        </select>
      </div>

      {/* ì •ë ¬ */}
      <div>
        <label className="text-sm text-gray-600 mr-2">ì •ë ¬:</label>
        <select
          value={sortBy}
          onChange={(e) => onSortByChange(e.target.value)}
          className="px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
        >
          <option value="createdAt-desc">ìµœì‹ ìˆœ</option>
          <option value="createdAt-asc">ì˜¤ë˜ëœìˆœ</option>
          <option value="originalName-asc">ì´ë¦„ (ê°€ë‚˜ë‹¤ìˆœ)</option>
          <option value="originalName-desc">ì´ë¦„ (ì—­ìˆœ)</option>
          <option value="size-desc">í¬ê¸° (í° ìˆœ)</option>
          <option value="size-asc">í¬ê¸° (ì‘ì€ ìˆœ)</option>
        </select>
      </div>
    </div>
  );
}
</file>

<file path="src/components/FileGridSkeleton.tsx">
export default function FileGridSkeleton({ count = 8 }: { count?: number }) {
  return (
    <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
      {Array.from({ length: count }).map((_, i) => (
        <div key={i} className="border rounded-lg overflow-hidden animate-pulse">
          <div className="aspect-square bg-gray-200" />
          <div className="p-3 space-y-2">
            <div className="h-4 bg-gray-200 rounded w-3/4" />
            <div className="h-3 bg-gray-200 rounded w-1/2" />
          </div>
        </div>
      ))}
    </div>
  );
}
</file>

<file path="src/components/FilePreviewModal.tsx">
"use client";

import { useEffect } from "react";

interface FilePreviewModalProps {
  file: {
    id: string;
    originalName: string;
    mimeType: string;
    size: string;
  } | null;
  onClose: () => void;
}

export default function FilePreviewModal({ file, onClose }: FilePreviewModalProps) {
  // ESC í‚¤ë¡œ ë‹«ê¸°
  useEffect(() => {
    const handleEsc = (e: KeyboardEvent) => {
      if (e.key === "Escape") onClose();
    };
    window.addEventListener("keydown", handleEsc);
    return () => window.removeEventListener("keydown", handleEsc);
  }, [onClose]);

  if (!file) return null;

  const isImage = file.mimeType.startsWith("image/");
  const isVideo = file.mimeType.startsWith("video/");
  const isPdf = file.mimeType.includes("pdf");

  const formatFileSize = (bytes: string) => {
    const size = parseInt(bytes);
    if (size < 1024) return `${size} B`;
    if (size < 1024 * 1024) return `${(size / 1024).toFixed(2)} KB`;
    if (size < 1024 * 1024 * 1024) return `${(size / (1024 * 1024)).toFixed(2)} MB`;
    return `${(size / (1024 * 1024 * 1024)).toFixed(2)} GB`;
  };

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-75 p-4"
      onClick={onClose}
    >
      <div
        className="relative bg-white rounded-lg shadow-xl max-w-4xl w-full max-h-[90vh] overflow-hidden"
        onClick={(e) => e.stopPropagation()}
      >
        {/* í—¤ë” */}
        <div className="flex items-center justify-between p-4 border-b">
          <div>
            <h3 className="text-lg font-semibold text-gray-900">
              {file.originalName}
            </h3>
            <p className="text-sm text-gray-500">
              {formatFileSize(file.size)} â€¢ {file.mimeType}
            </p>
          </div>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-gray-600 text-2xl font-bold"
          >
            Ã—
          </button>
        </div>

        {/* ë¯¸ë¦¬ë³´ê¸° ì˜ì—­ */}
        <div className="p-4 flex items-center justify-center bg-gray-100 min-h-[400px] max-h-[60vh] overflow-auto">
          {isImage && (
            <img
              src={`/api/files/${file.id}/download`}
              alt={file.originalName}
              className="max-w-full max-h-full object-contain"
            />
          )}

          {isVideo && (
            <video
              controls
              className="max-w-full max-h-full"
              src={`/api/files/${file.id}/download`}
            >
              ë¹„ë””ì˜¤ë¥¼ ì¬ìƒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
            </video>
          )}

          {isPdf && (
            <iframe
              src={`/api/files/${file.id}/download`}
              className="w-full h-[60vh]"
              title={file.originalName}
            />
          )}

          {!isImage && !isVideo && !isPdf && (
            <div className="text-center text-gray-500">
              <p className="text-4xl mb-4">ğŸ“„</p>
              <p>ë¯¸ë¦¬ë³´ê¸°ë¥¼ ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤</p>
              <p className="text-sm mt-2">ë‹¤ìš´ë¡œë“œí•˜ì—¬ í™•ì¸í•˜ì„¸ìš”</p>
            </div>
          )}
        </div>

        {/* í‘¸í„° */}
        <div className="flex items-center justify-end gap-2 p-4 border-t bg-gray-50">
          <a
            href={`/api/files/${file.id}/download`}
            download={file.originalName}
            className="px-4 py-2 text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 rounded-md"
          >
            ë‹¤ìš´ë¡œë“œ
          </a>
          <button
            onClick={onClose}
            className="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 hover:bg-gray-50 rounded-md"
          >
            ë‹«ê¸°
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/LazyImage.tsx">
"use client";

import { useState, useEffect, useRef } from "react";

interface LazyImageProps {
  src: string;
  alt: string;
  className?: string;
}

export default function LazyImage({ src, alt, className = "" }: LazyImageProps) {
  const [isLoaded, setIsLoaded] = useState(false);
  const [isInView, setIsInView] = useState(false);
  const imgRef = useRef<HTMLImageElement>(null);

  useEffect(() => {
    if (!imgRef.current) return;

    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsInView(true);
          observer.disconnect();
        }
      },
      { rootMargin: "50px" }
    );

    observer.observe(imgRef.current);

    return () => observer.disconnect();
  }, []);

  return (
    <div className={`relative ${className}`} ref={imgRef}>
      {!isLoaded && (
        <div className="absolute inset-0 bg-gray-200 animate-pulse" />
      )}
      {isInView && (
        <img
          src={src}
          alt={alt}
          className={`${className} ${isLoaded ? "opacity-100" : "opacity-0"} transition-opacity duration-300`}
          onLoad={() => setIsLoaded(true)}
          onError={(e) => {
            e.currentTarget.style.display = "none";
          }}
        />
      )}
    </div>
  );
}
</file>

<file path="src/components/SearchBar.tsx">
"use client";

import { useState } from "react";

interface SearchBarProps {
  onSearch: (query: string) => void;
  placeholder?: string;
}

export default function SearchBar({ onSearch, placeholder = "ê²€ìƒ‰..." }: SearchBarProps) {
  const [query, setQuery] = useState("");

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    onSearch(query);
  };

  return (
    <form onSubmit={handleSubmit} className="flex gap-2">
      <input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder={placeholder}
        className="flex-1 px-4 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
      />
      <button
        type="submit"
        className="px-6 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
      >
        ê²€ìƒ‰
      </button>
      {query && (
        <button
          type="button"
          onClick={() => {
            setQuery("");
            onSearch("");
          }}
          className="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300"
        >
          ì´ˆê¸°í™”
        </button>
      )}
    </form>
  );
}
</file>

<file path="src/components/UploadProgress.tsx">
"use client";

interface UploadProgressProps {
  fileName: string;
  progress: number;
  onCancel?: () => void;
}

export default function UploadProgress({ fileName, progress, onCancel }: UploadProgressProps) {
  return (
    <div className="bg-white border border-gray-200 rounded-lg p-4 shadow-sm">
      <div className="flex items-center justify-between mb-2">
        <div className="flex-1 mr-4">
          <p className="text-sm font-medium text-gray-900 truncate">{fileName}</p>
          <p className="text-xs text-gray-500">{progress}% ì™„ë£Œ</p>
        </div>
        {onCancel && (
          <button
            onClick={onCancel}
            className="text-gray-400 hover:text-gray-600"
          >
            âœ•
          </button>
        )}
      </div>
      <div className="w-full bg-gray-200 rounded-full h-2">
        <div
          className="bg-blue-600 h-2 rounded-full transition-all duration-300"
          style={{ width: `${progress}%` }}
        />
      </div>
    </div>
  );
}
</file>

<file path="src/lib/db.ts">
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
  });

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;

export default prisma;
</file>

<file path="src/lib/demo-mode.ts">
/**
 * ë°ëª¨ ëª¨ë“œ ì„¤ì •
 * ì•±ìŠ¤í† ì–´ ì‹¬ì‚¬ìš© ë°ëª¨ ê³„ì • ë° ìƒ˜í”Œ ë°ì´í„°
 */

export const DEMO_MODE = process.env.NEXT_PUBLIC_DEMO_MODE === 'true';

// ì‹¬ì‚¬ê´€ìš© ë°ëª¨ ê³„ì •
export const DEMO_USERS = [
  {
    id: 'demo-reviewer-001',
    email: 'reviewer@appstore.com',
    password: 'Demo2024!Review',
    name: 'App Store Reviewer',
    role: 'USER' as const,
  },
  {
    id: 'demo-user-001',
    email: 'testuser@demo.com',
    password: 'Demo2024!Test',
    name: 'Test User',
    role: 'USER' as const,
  },
];

// ë°ëª¨ ìœ ì €ì¸ì§€ í™•ì¸
export function isDemoUser(email: string): boolean {
  return DEMO_USERS.some((user) => user.email === email);
}

// ë°ëª¨ ê³„ì • ì •ë³´ ê°€ì ¸ì˜¤ê¸°
export function getDemoUser(email: string) {
  return DEMO_USERS.find((user) => user.email === email);
}
</file>

<file path="src/lib/email.ts">
import nodemailer from "nodemailer";

interface EmailOptions {
  to: string;
  subject: string;
  html: string;
}

export async function sendEmail({ to, subject, html }: EmailOptions) {
  const transporter = nodemailer.createTransport({
    service: "gmail",
    auth: {
      user: process.env.EMAIL_USER,
      pass: process.env.EMAIL_PASS,
    },
  });

  await transporter.sendMail({
    from: `"ì´ìŒ (Eum)" <${process.env.EMAIL_USER}>`,
    to,
    subject,
    html,
  });
}
</file>

<file path="src/lib/fcm.ts">
import * as admin from "firebase-admin";

/**
 * Firebase Admin SDK ì´ˆê¸°í™” (ì‹±ê¸€í†¤ íŒ¨í„´)
 */
function initFirebase() {
  if (admin.apps.length > 0) return true;

  const serviceAccountVar = process.env.FIREBASE_SERVICE_ACCOUNT_KEY;
  if (!serviceAccountVar) {
    console.warn("âš ï¸ FIREBASE_SERVICE_ACCOUNT_KEY ë¯¸ì„¤ì •");
    return false;
  }

  try {
    let configStr = serviceAccountVar.trim();
    if (configStr.startsWith("'") && configStr.endsWith("'")) configStr = configStr.slice(1, -1);
    if (configStr.startsWith('"') && configStr.endsWith('"')) configStr = configStr.slice(1, -1);

    const serviceAccount = JSON.parse(configStr);
    if (serviceAccount.private_key) {
      serviceAccount.private_key = serviceAccount.private_key.replace(/\\n/g, '\n');
    }

    admin.initializeApp({
      credential: admin.credential.cert(serviceAccount),
    });
    console.log("âœ… Firebase Admin ì´ˆê¸°í™” ì„±ê³µ!");
    return true;
  } catch (error: any) {
    console.error("âŒ Firebase ì´ˆê¸°í™” ì—ëŸ¬:", error.message);
    return false;
  }
}

/**
 * í•µì‹¬ í‘¸ì‹œ ì „ì†¡ ë¡œì§
 */
export async function sendPushNotification(
  fcmToken: string,
  payload: { title: string; body: string; data?: Record<string, string> }
) {
  if (!initFirebase()) return { success: false, error: "Initialization failed" };

  try {
    const message: admin.messaging.Message = {
      token: fcmToken,
      notification: {
        title: payload.title,
        body: payload.body,
      },
      data: payload.data || {},
      webpush: {
        headers: { Urgency: "high" },
        notification: {
          icon: "/icon-192x192.png",
          badge: "/badge-72x72.png",
          requireInteraction: payload.data?.type === "call_request",
        },
        fcmOptions: {
          link: payload.data?.click_action || "/chat",
        },
      },
      android: { 
        priority: "high",
        notification: {
          sound: "default",
          clickAction: "FLUTTER_NOTIFICATION_CLICK"
        }
      },
      apns: { 
        payload: { 
          aps: { 
            sound: "default", 
            badge: 1,
            contentAvailable: true 
          } 
        } 
      },
    };

    const response = await admin.messaging().send(message);
    return { success: true, messageId: response };
  } catch (error: any) {
    console.error("FCM Send Error:", error);
    return { success: false, error: error.code || error.message };
  }
}

/**
 * í†µí™” ìš”ì²­ ì•Œë¦¼ ì „ì†¡ (ì¶”ê°€ëœ ë¶€ë¶„)
 */
export async function sendCallNotification(
  token: string, 
  senderName: string, 
  callType: string, 
  callId: string, 
  chatRoomId: string
) {
  const isVideo = callType === "VIDEO";
  return sendPushNotification(token, {
    title: `ğŸ“ ${senderName}ë‹˜ìœ¼ë¡œë¶€í„° í†µí™” ìš”ì²­`,
    body: `${isVideo ? "ì˜ìƒ í†µí™”" : "ìŒì„± í†µí™”"} ìš”ì²­ì´ ì™”ìŠµë‹ˆë‹¤.`,
    data: {
      type: "call_request",
      callId,
      chatRoomId,
      callType,
      click_action: `/chat/${chatRoomId}?callId=${callId}`
    },
  });
}

/**
 * ì±„íŒ… ë©”ì‹œì§€ ì•Œë¦¼ ì „ì†¡
 */
export async function sendChatMessageNotification(token: string, senderName: string, content: string, chatRoomId: string) {
  return sendPushNotification(token, {
    title: senderName,
    body: content || "ìƒˆ ë©”ì‹œì§€ê°€ ë„ì°©í–ˆìŠµë‹ˆë‹¤.",
    data: { 
      type: "chat_message", 
      chatRoomId, 
      click_action: `/chat/${chatRoomId}` 
    },
  });
}

/**
 * íŒŒì¼ ê³µìœ  ì•Œë¦¼ ì „ì†¡
 */
export async function sendFileSharedNotification(token: string, senderName: string, fileName: string, chatRoomId: string) {
  return sendPushNotification(token, {
    title: `ğŸ“ ${senderName}ë‹˜ì˜ íŒŒì¼ ê³µìœ `,
    body: fileName,
    data: { 
      type: "file_shared", 
      chatRoomId, 
      click_action: `/chat/${chatRoomId}` 
    },
  });
}

export { admin };
</file>

<file path="src/lib/firebase.ts">
import { initializeApp, getApps, getApp } from "firebase/app";
import { getMessaging, getToken, onMessage, Messaging } from "firebase/messaging";

const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
};

// Firebase ì•± ì´ˆê¸°í™” (ì„œë²„ ì‚¬ì´ë“œ ì—ëŸ¬ ë°©ì§€)
const app = getApps().length === 0 ? initializeApp(firebaseConfig) : getApp();

let messaging: Messaging | null = null;

/**
 * ë©”ì‹œì§• ê°ì²´ ì´ˆê¸°í™”
 */
export const getFirebaseMessaging = () => {
  if (typeof window !== "undefined" && "serviceWorker" in navigator) {
    if (!messaging) {
      try {
        messaging = getMessaging(app);
      } catch (error) {
        console.error("Firebase Messaging ì´ˆê¸°í™” ì‹¤íŒ¨:", error);
      }
    }
  }
  return messaging;
};

/**
 * FCM í† í° ìš”ì²­
 */
export async function requestNotificationPermission(): Promise<string | null> {
  try {
    if (typeof window === "undefined") return null;

    const permission = await Notification.requestPermission();
    if (permission !== "granted") {
      console.warn("âš ï¸ ì•Œë¦¼ ê¶Œí•œì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤.");
      return null;
    }

    const messaging = getFirebaseMessaging();
    if (!messaging) return null;

    // 1. ì„œë¹„ìŠ¤ ì›Œì»¤ ë“±ë¡ ë° 'ì¤€ë¹„' ìƒíƒœ ëŒ€ê¸°
    // ê²½ë¡œê°€ ì •í™•íˆ /firebase-messaging-sw.js ì¸ì§€ í™•ì¸í•˜ì„¸ìš”.
    const registration = await navigator.serviceWorker.register("/firebase-messaging-sw.js");
    
    // ì„œë¹„ìŠ¤ ì›Œì»¤ê°€ í™œì„±í™”ë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ëŠ” ë¡œì§ ì¶”ê°€ (ì¤‘ìš”)
    while (registration.active?.state !== 'activated') {
      await new Promise(resolve => setTimeout(resolve, 100)); // 100msì”© ëŒ€ê¸°
      if (registration.installing?.state === 'redundant') break; 
    }

    console.log("âœ… ì„œë¹„ìŠ¤ ì›Œì»¤ í™œì„±í™” í™•ì¸ë¨");

    // 2. í† í° ê°€ì ¸ì˜¤ê¸° (registration ê°ì²´ë¥¼ ì§ì ‘ ì „ë‹¬)
    const token = await getToken(messaging, {
      vapidKey: process.env.NEXT_PUBLIC_FIREBASE_VAPID_KEY,
      serviceWorkerRegistration: registration,
    });

    if (token) {
      console.log("âœ… FCM í† í° ìƒì„± ì„±ê³µ:", token);
      return token;
    } 
    
    return null;
  } catch (error) {
    console.error("âŒ FCM í† í° ìš”ì²­ ì‹¤íŒ¨:", error);
    return null;
  }
}

/**
 * í¬ê·¸ë¼ìš´ë“œ ë©”ì‹œì§€ ìˆ˜ì‹  ë¦¬ìŠ¤ë„ˆ (ì•±ì„ ì¼œë†“ê³  ìˆì„ ë•Œ)
 */
export function onForegroundMessage(callback: (payload: any) => void) {
  const messaging = getFirebaseMessaging();
  if (!messaging) return () => {};

  // ë¸Œë¼ìš°ì € íƒ­ì´ í™œì„±í™”ëœ ìƒíƒœì—ì„œ í‘¸ì‹œê°€ ì˜¤ë©´ ì´ ë¡œì§ì´ ì‹¤í–‰ë©ë‹ˆë‹¤.
  return onMessage(messaging, (payload) => {
    console.log("ğŸ“¬ í¬ê·¸ë¼ìš´ë“œ ë©”ì‹œì§€ ìˆ˜ì‹ :", payload);
    callback(payload);
  });
}

/**
 * FCM í† í° ì„œë²„ ë“±ë¡
 */
export async function registerFCMToken() {
  const token = await requestNotificationPermission();
  
  if (token) {
    try {
      const res = await fetch("/api/users/fcm-token", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ fcmToken: token }),
      });

      if (res.ok) {
        console.log("âœ… FCM í† í° ì„œë²„ ë“±ë¡ ì„±ê³µ");
        return true;
      }
    } catch (error) {
      console.error("FCM í† í° ì„œë²„ ì „ì†¡ ì˜¤ë¥˜:", error);
    }
  }
  return false;
}

/**
 * FCM í† í° ì‚­ì œ
 */
export async function unregisterFCMToken() {
  try {
    const res = await fetch("/api/users/fcm-token", {
      method: "DELETE",
    });
    return res.ok;
  } catch (error) {
    console.error("FCM í† í° ì‚­ì œ ì˜¤ë¥˜:", error);
    return false;
  }
}
</file>

<file path="src/lib/rate-limit.ts">
import { NextRequest } from "next/server";

interface RateLimitStore {
  [key: string]: {
    count: number;
    resetTime: number;
  };
}

const store: RateLimitStore = {};

export function rateLimit(
  limit: number = 100, // ìš”ì²­ íšŸìˆ˜
  windowMs: number = 60 * 1000 // ì‹œê°„ ìœˆë„ìš° (1ë¶„)
) {
  return async (request: NextRequest): Promise<{ success: boolean; remaining: number }> => {
    // IP ì£¼ì†Œ ë˜ëŠ” ì‚¬ìš©ì IDë¡œ ì‹ë³„
    const identifier = request.headers.get("x-forwarded-for") || 
                      request.headers.get("x-real-ip") || 
                      "unknown";
    
    const now = Date.now();
    const record = store[identifier];

    // ì²« ìš”ì²­ì´ê±°ë‚˜ ìœˆë„ìš°ê°€ ë§Œë£Œëœ ê²½ìš°
    if (!record || now > record.resetTime) {
      store[identifier] = {
        count: 1,
        resetTime: now + windowMs,
      };
      return { success: true, remaining: limit - 1 };
    }

    // ì œí•œ ì´ˆê³¼
    if (record.count >= limit) {
      return { success: false, remaining: 0 };
    }

    // ì¹´ìš´íŠ¸ ì¦ê°€
    record.count++;
    return { success: true, remaining: limit - record.count };
  };
}

// ì£¼ê¸°ì ìœ¼ë¡œ ë§Œë£Œëœ í•­ëª© ì •ë¦¬
setInterval(() => {
  const now = Date.now();
  for (const key in store) {
    if (store[key].resetTime < now) {
      delete store[key];
    }
  }
}, 60 * 1000); // 1ë¶„ë§ˆë‹¤
</file>

<file path="src/lib/sanitize.ts">
/**
 * XSS ë°©ì§€ë¥¼ ìœ„í•œ HTML ì´ìŠ¤ì¼€ì´í”„
 */
export function escapeHtml(text: string): string {
  const map: { [key: string]: string } = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;',
  };
  
  return text.replace(/[&<>"']/g, (char) => map[char]);
}

/**
 * íŒŒì¼ëª… sanitize (ê²½ë¡œ ì¡°ì‘ ë°©ì§€)
 */
export function sanitizeFilename(filename: string): string {
  // ìœ„í—˜í•œ ë¬¸ì ì œê±°
  return filename
    .replace(/[\/\\]/g, '_')      // ìŠ¬ë˜ì‹œ ì œê±°
    .replace(/\.\./g, '_')         // ìƒìœ„ ë””ë ‰í† ë¦¬ ì ‘ê·¼ ë°©ì§€
    .replace(/[<>:"|?*]/g, '_')    // íŒŒì¼ì‹œìŠ¤í…œ ì˜ˆì•½ ë¬¸ì
    .slice(0, 255);                // ê¸¸ì´ ì œí•œ
}

/**
 * URL íŒŒë¼ë¯¸í„° ê²€ì¦
 */
export function validateUrlParam(param: string, type: 'id' | 'email' | 'string'): boolean {
  switch (type) {
    case 'id':
      // CUID í˜•ì‹ ê²€ì¦
      return /^c[a-z0-9]{24}$/.test(param);
    case 'email':
      return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(param);
    case 'string':
      return param.length > 0 && param.length <= 1000;
    default:
      return false;
  }
}
</file>

<file path="jest.config.ts">
// jest.config.ts
// npm install --save-dev jest @types/jest ts-jest jest-environment-jsdom @testing-library/react @testing-library/jest-dom

import type { Config } from "jest";
import nextJest from "next/jest.js";

const createJestConfig = nextJest({ dir: "./" });

const config: Config = {
  coverageProvider: "v8",
  testEnvironment:  "jest-environment-jsdom",
  setupFilesAfterEnv: ["<rootDir>/jest.setup.ts"],

  // ê²½ë¡œ ë§¤í•‘ (tsconfig pathsì™€ ë™ê¸°í™”)
  moduleNameMapper: {
    "^@/(.*)$": "<rootDir>/src/$1",
  },

  // í…ŒìŠ¤íŠ¸ íŒŒì¼ íŒ¨í„´
  testMatch: [
    "**/__tests__/**/*.test.ts",
    "**/__tests__/**/*.test.tsx",
    "**/*.spec.ts",
    "**/*.spec.tsx",
  ],

  // ì»¤ë²„ë¦¬ì§€ ìˆ˜ì§‘ ëŒ€ìƒ
  collectCoverageFrom: [
    "src/lib/**/*.ts",
    "src/app/api/**/*.ts",
    "src/components/**/*.tsx",
    "!src/**/*.d.ts",
    "!src/**/index.ts",
  ],

  // ì»¤ë²„ë¦¬ì§€ ì„ê³„ê°’
  coverageThreshold: {
    global: {
      branches:   60,
      functions:  60,
      lines:      60,
      statements: 60,
    },
  },
};

export default createJestConfig(config);
</file>

<file path="next.config.js">
// next.config.js (ë˜ëŠ” next.config.mjs)
// Docker standalone ë¹Œë“œ + ë³´ì•ˆ í—¤ë” ì„¤ì •

/** @type {import('next').NextConfig} */
const nextConfig = {
  // Docker ë©€í‹°ìŠ¤í…Œì´ì§€ ë¹Œë“œìš© â€” ìµœì†Œ íŒŒì¼ë§Œ í¬í•¨
  output: "standalone",

  // ì´ë¯¸ì§€ ìµœì í™” ë„ë©”ì¸
  images: {
    remotePatterns: [
      { protocol: "https", hostname: "**" },
    ],
    formats: ["image/avif", "image/webp"],
  },

  // ì‹¤í—˜ì  ê¸°ëŠ¥
  experimental: {
    serverComponentsExternalPackages: ["sharp", "winston", "socket.io"],
  },

  // â”€â”€ ë³´ì•ˆ í—¤ë” (Nginxê°€ ì—†ëŠ” í™˜ê²½ ëŒ€ë¹„) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  async headers() {
    return [
      {
        source: "/:path*",
        headers: [
          { key: "X-Frame-Options",        value: "SAMEORIGIN" },
          { key: "X-Content-Type-Options",  value: "nosniff" },
          { key: "Referrer-Policy",         value: "strict-origin-when-cross-origin" },
          { key: "Permissions-Policy",      value: "camera=(), microphone=(), geolocation=()" },
        ],
      },
      // ì •ì  íŒŒì¼ ì¥ê¸° ìºì‹œ
      {
        source: "/_next/static/:path*",
        headers: [
          { key: "Cache-Control", value: "public, max-age=31536000, immutable" },
        ],
      },
    ];
  },

  // â”€â”€ ë¦¬ë””ë ‰ì…˜ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  async redirects() {
    return [
      {
        source:      "/home",
        destination: "/dashboard",
        permanent:   true,
      },
    ];
  },

  // BigInt JSON ì§ë ¬í™” ê²½ê³  ì–µì œ
  webpack(config) {
    config.resolve.fallback = { fs: false, path: false };
    return config;
  },
};

module.exports = nextConfig;
</file>

<file path="src/__tests__/lib/api-response.test.ts">
import { ok, created, paginated, ApiError, ErrorCode } from "@/lib/api-response";

describe("API ì‘ë‹µ ë¹Œë”", () => {
  it("ok()ëŠ” success: trueì™€ dataë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤", async () => {
    const res  = ok({ id: "1", name: "íŒŒì¼" });
    const body = await res.json();
    expect(res.status).toBe(200);
    expect(body.success).toBe(true);
    expect(body.data).toEqual({ id: "1", name: "íŒŒì¼" });
  });

  it("created()ëŠ” 201 ìƒíƒœ ì½”ë“œë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤", async () => {
    const res = created({ id: "new" });
    expect(res.status).toBe(201);
  });

  it("paginated()ëŠ” metaë¥¼ í¬í•¨í•´ì•¼ í•œë‹¤", async () => {
    const res  = paginated(["a", "b"], { page: 1, limit: 10, total: 2, hasMore: false });
    const body = await res.json();
    expect(body.data).toHaveLength(2);
    expect(body.meta.total).toBe(2);
    expect(body.meta.hasMore).toBe(false);
  });

  it("ApiError.unauthorized()ëŠ” 401ê³¼ ì˜¬ë°”ë¥¸ ì½”ë“œë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤", async () => {
    const res  = ApiError.unauthorized();
    const body = await res.json();
    expect(res.status).toBe(401);
    expect(body.success).toBe(false);
    expect(body.code).toBe(ErrorCode.UNAUTHORIZED);
  });

  it("ApiError.notFound()ëŠ” ë¦¬ì†ŒìŠ¤ëª…ì„ í¬í•¨í•´ì•¼ í•œë‹¤", async () => {
    const res  = ApiError.notFound("íŒŒì¼");
    const body = await res.json();
    expect(res.status).toBe(404);
    expect(body.error).toContain("íŒŒì¼");
  });

  it("ApiError.validation()ì€ detailsë¥¼ í¬í•¨í•´ì•¼ í•œë‹¤", async () => {
    const res  = ApiError.validation("ì´ë©”ì¼ í˜•ì‹ ì˜¤ë¥˜", [{ field: "email", message: "invalid" }]);
    const body = await res.json();
    expect(res.status).toBe(422);
    expect(body.details).toBeDefined();
  });
});
</file>

<file path="src/__tests__/lib/cache.test.ts">
import cache, { withCache } from "@/lib/cache";

describe("MemoryCache", () => {
  beforeEach(() => {
    // ìºì‹œ í´ë¦¬ì–´ (ë‚´ë¶€ map ì´ˆê¸°í™” ëŒ€ì‹  ë§Œë£Œëœ í‚¤ ì œê±° ë°©ì‹)
    jest.useFakeTimers();
  });
  afterEach(() => jest.useRealTimers());

  it("ê°’ì„ ì €ì¥í•˜ê³  ì¡°íšŒí•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤", () => {
    cache.set("test:1", { name: "ì´ìŒ" }, 60);
    expect(cache.get("test:1")).toEqual({ name: "ì´ìŒ" });
  });

  it("TTL ë§Œë£Œ í›„ nullì„ ë°˜í™˜í•´ì•¼ í•œë‹¤", () => {
    cache.set("test:ttl", "value", 1); // 1ì´ˆ
    jest.advanceTimersByTime(2000);    // 2ì´ˆ ê²½ê³¼
    expect(cache.get("test:ttl")).toBeNull();
  });

  it("íƒœê·¸ë¡œ ê´€ë ¨ ìºì‹œë¥¼ ì¼ê´„ ë¬´íš¨í™”í•´ì•¼ í•œë‹¤", () => {
    cache.set("a", 1, 60, ["tag:x"]);
    cache.set("b", 2, 60, ["tag:x"]);
    cache.set("c", 3, 60, ["tag:y"]);
    cache.invalidateByTag("tag:x");
    expect(cache.get("a")).toBeNull();
    expect(cache.get("b")).toBeNull();
    expect(cache.get("c")).toBe(3);
  });

  it("íŒ¨í„´ìœ¼ë¡œ ìºì‹œë¥¼ ë¬´íš¨í™”í•´ì•¼ í•œë‹¤", () => {
    cache.set("user:1:files", [], 60);
    cache.set("user:1:posts", [], 60);
    cache.set("user:2:files", [], 60);
    cache.invalidateByPattern("user:1:");
    expect(cache.get("user:1:files")).toBeNull();
    expect(cache.get("user:1:posts")).toBeNull();
    expect(cache.get("user:2:files")).toEqual([]);
  });
});

describe("withCache", () => {
  it("fetcherë¥¼ ì²˜ìŒì—ë§Œ ì‹¤í–‰í•˜ê³  ì´í›„ì—ëŠ” ìºì‹œë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤", async () => {
    const fetcher = jest.fn().mockResolvedValue({ data: 42 });
    const key = `test:withcache:${Date.now()}`;

    const first  = await withCache(key, fetcher, 60);
    const second = await withCache(key, fetcher, 60);

    expect(first).toEqual({ data: 42 });
    expect(second).toEqual({ data: 42 });
    expect(fetcher).toHaveBeenCalledTimes(1); // í•œ ë²ˆë§Œ ì‹¤í–‰
  });
});
</file>

<file path="src/__tests__/lib/components/ErrorBoundary.test.tsx">
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import { ErrorBoundary, SectionErrorBoundary } from "@/components/ErrorBoundary";

// ì—ëŸ¬ë¥¼ ë˜ì§€ëŠ” í…ŒìŠ¤íŠ¸ìš© ì»´í¬ë„ŒíŠ¸
function Bomb({ shouldThrow }: { shouldThrow: boolean }) {
  if (shouldThrow) throw new Error("í…ŒìŠ¤íŠ¸ ì—ëŸ¬ì…ë‹ˆë‹¤");
  return <div>ì •ìƒ ë Œë”ë§</div>;
}

// console.error ì–µì œ (ì—ëŸ¬ ë°”ìš´ë”ë¦¬ í…ŒìŠ¤íŠ¸ ì‹œ ë…¸ì´ì¦ˆ ë°©ì§€)
beforeEach(() => { jest.spyOn(console, "error").mockImplementation(() => {}); });
afterEach(() => jest.restoreAllMocks());

describe("ErrorBoundary", () => {
  it("ì—ëŸ¬ ì—†ìœ¼ë©´ childrenì„ ë Œë”ë§í•´ì•¼ í•œë‹¤", () => {
    render(
      <ErrorBoundary level="section">
        <Bomb shouldThrow={false} />
      </ErrorBoundary>
    );
    expect(screen.getByText("ì •ìƒ ë Œë”ë§")).toBeInTheDocument();
  });

  it("ì—ëŸ¬ ë°œìƒ ì‹œ fallback UIë¥¼ ë³´ì—¬ì¤˜ì•¼ í•œë‹¤", () => {
    render(
      <ErrorBoundary level="section">
        <Bomb shouldThrow={true} />
      </ErrorBoundary>
    );
    expect(screen.getByText(/ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤/)).toBeInTheDocument();
  });

  it("'ë‹¤ì‹œ ì‹œë„' í´ë¦­ ì‹œ ë¦¬ì…‹ë˜ì–´ì•¼ í•œë‹¤", () => {
    const { rerender } = render(
      <ErrorBoundary level="section">
        <Bomb shouldThrow={true} />
      </ErrorBoundary>
    );
    fireEvent.click(screen.getByText("ë‹¤ì‹œ ì‹œë„"));
    rerender(
      <ErrorBoundary level="section">
        <Bomb shouldThrow={false} />
      </ErrorBoundary>
    );
    expect(screen.getByText("ì •ìƒ ë Œë”ë§")).toBeInTheDocument();
  });

  it("ì»¤ìŠ¤í…€ fallbackì„ ì‚¬ìš©í•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤", () => {
    render(
      <ErrorBoundary level="section" fallback={<div>ì»¤ìŠ¤í…€ ì—ëŸ¬ UI</div>}>
        <Bomb shouldThrow={true} />
      </ErrorBoundary>
    );
    expect(screen.getByText("ì»¤ìŠ¤í…€ ì—ëŸ¬ UI")).toBeInTheDocument();
  });

  it("inline ë ˆë²¨ì—ì„œ ì¬ì‹œë„ ë²„íŠ¼ì´ ìˆì–´ì•¼ í•œë‹¤", () => {
    render(
      <ErrorBoundary level="inline">
        <Bomb shouldThrow={true} />
      </ErrorBoundary>
    );
    expect(screen.getByText("ì¬ì‹œë„")).toBeInTheDocument();
  });
});
</file>

<file path="src/__tests__/lib/components/MentionTextarea.test.tsx">
import { render as rtlRender, screen as rtlScreen, fireEvent as rtlFireEvent, waitFor } from "@testing-library/react";
import MentionTextarea from "@/components/MentionTextarea";

describe("MentionTextarea", () => {
  beforeEach(() => {
    (global.fetch as jest.Mock).mockResolvedValue({
      json: () => Promise.resolve({ users: [
        { id: "u1", name: "í™ê¸¸ë™", isOnline: true },
        { id: "u2", name: "í™ì² ìˆ˜", isOnline: false },
      ]}),
    });
  });

  it("ê¸°ë³¸ í…ìŠ¤íŠ¸ ì…ë ¥ì´ ë™ì‘í•´ì•¼ í•œë‹¤", () => {
    const onChange = jest.fn();
    rtlRender(<MentionTextarea value="" onChange={onChange} />);
    const ta = rtlScreen.getByPlaceholderText("ëŒ“ê¸€ì„ ì…ë ¥í•˜ì„¸ìš”...");
    rtlFireEvent.change(ta, { target: { value: "ì•ˆë…•í•˜ì„¸ìš”" } });
    expect(onChange).toHaveBeenCalledWith("ì•ˆë…•í•˜ì„¸ìš”", []);
  });

  it("@ë¥¼ ì…ë ¥í•˜ë©´ ì‚¬ìš©ì ëª©ë¡ì´ í‘œì‹œë˜ì–´ì•¼ í•œë‹¤", async () => {
    const onChange = jest.fn();
    rtlRender(<MentionTextarea value="" onChange={onChange} />);
    const ta = rtlScreen.getByPlaceholderText("ëŒ“ê¸€ì„ ì…ë ¥í•˜ì„¸ìš”...");
    rtlFireEvent.change(ta, { target: { value: "@í™", selectionStart: 2 } });
    await waitFor(() => {
      expect(rtlScreen.getByText("í™ê¸¸ë™")).toBeInTheDocument();
    });
  });
});
</file>

<file path="src/__tests__/lib/validators.test.ts">
import { registerSchema, createPostSchema, createCommentSchema } from "@/lib/validators";

describe("registerSchema", () => {
  const valid = { name: "í™ê¸¸ë™", email: "test@eum.app", password: "Secure1!" };

  it("ìœ íš¨í•œ ë°ì´í„°ë¥¼ í†µê³¼ì‹œì¼œì•¼ í•œë‹¤", () => {
    expect(registerSchema.safeParse(valid).success).toBe(true);
  });

  it("ì´ë¦„ì´ 1ìì´ë©´ ì‹¤íŒ¨í•´ì•¼ í•œë‹¤", () => {
    const r = registerSchema.safeParse({ ...valid, name: "í™" });
    expect(r.success).toBe(false);
  });

  it("ì´ë©”ì¼ í˜•ì‹ì´ ì˜ëª»ë˜ë©´ ì‹¤íŒ¨í•´ì•¼ í•œë‹¤", () => {
    const r = registerSchema.safeParse({ ...valid, email: "not-an-email" });
    expect(r.success).toBe(false);
  });

  it("ë¹„ë°€ë²ˆí˜¸ì— íŠ¹ìˆ˜ë¬¸ìê°€ ì—†ìœ¼ë©´ ì‹¤íŒ¨í•´ì•¼ í•œë‹¤", () => {
    const r = registerSchema.safeParse({ ...valid, password: "Secure123" });
    expect(r.success).toBe(false);
  });

  it("ë¹„ë°€ë²ˆí˜¸ì— ëŒ€ë¬¸ìê°€ ì—†ìœ¼ë©´ ì‹¤íŒ¨í•´ì•¼ í•œë‹¤", () => {
    const r = registerSchema.safeParse({ ...valid, password: "secure1!" });
    expect(r.success).toBe(false);
  });
});

describe("createPostSchema", () => {
  it("ì œëª©ì´ ë¹„ì–´ìˆìœ¼ë©´ ì‹¤íŒ¨í•´ì•¼ í•œë‹¤", () => {
    const r = createPostSchema.safeParse({ title: "", content: "ë‚´ìš©" });
    expect(r.success).toBe(false);
  });

  it("visibility ê¸°ë³¸ê°’ì€ PUBLICì´ì–´ì•¼ í•œë‹¤", () => {
    const r = createPostSchema.safeParse({ title: "ì œëª©", content: "ë‚´ìš©" });
    expect(r.success).toBe(true);
    if (r.success) expect(r.data.visibility).toBe("PUBLIC");
  });

  it("í—ˆìš©ë˜ì§€ ì•Šì€ visibility ê°’ì€ ì‹¤íŒ¨í•´ì•¼ í•œë‹¤", () => {
    const r = createPostSchema.safeParse({ title: "ì œëª©", content: "ë‚´ìš©", visibility: "INVALID" });
    expect(r.success).toBe(false);
  });
});

describe("createCommentSchema", () => {
  it("ë¹ˆ ëŒ“ê¸€ì€ ì‹¤íŒ¨í•´ì•¼ í•œë‹¤", () => {
    const r = createCommentSchema.safeParse({ content: "" });
    expect(r.success).toBe(false);
  });

  it("2000ì ì´ˆê³¼ ëŒ“ê¸€ì€ ì‹¤íŒ¨í•´ì•¼ í•œë‹¤", () => {
    const r = createCommentSchema.safeParse({ content: "a".repeat(2001) });
    expect(r.success).toBe(false);
  });

  it("mentionIds ì—†ì´ë„ ìœ íš¨í•´ì•¼ í•œë‹¤", () => {
    const r = createCommentSchema.safeParse({ content: "ì¢‹ì€ ê¸€ì´ë„¤ìš”!" });
    expect(r.success).toBe(true);
  });
});
</file>

<file path="src/app/(auth)/signup/page.tsx">
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import Link from "next/link";

export default function SignupPage() {
  const router = useRouter();
  const [formData, setFormData] = useState({ name: "", email: "", password: "" });
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");
    setLoading(true);

    try {
      const res = await fetch("/api/auth/signup", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(formData),
      });
      const data = await res.json();
      if (!res.ok) {
        setError(data.error || "íšŒì›ê°€ì…ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
        setLoading(false);
        return;
      }
      // âœ… alert() ì œê±° â†’ ë¡œê·¸ì¸ í˜ì´ì§€ê°€ ?signup=success ì¿¼ë¦¬ ì²˜ë¦¬
      router.push("/login?signup=success");
    } catch {
      setError("ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">â˜ï¸ Personal Cloud</h2>
          <p className="mt-2 text-center text-sm text-gray-600">ìƒˆ ê³„ì • ë§Œë“¤ê¸°</p>
        </div>

        <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
          {error && (
            <div className="rounded-md bg-red-50 p-4">
              <p className="text-sm text-red-800">{error}</p>
            </div>
          )}

          <div className="rounded-md shadow-sm -space-y-px">
            <div>
              <label htmlFor="name" className="sr-only">ì´ë¦„</label>
              <input
                id="name" type="text" required
                value={formData.name}
                onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-t-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm"
                placeholder="ì´ë¦„"
              />
            </div>
            <div>
              <label htmlFor="email" className="sr-only">ì´ë©”ì¼</label>
              <input
                id="email" type="email" required
                value={formData.email}
                onChange={(e) => setFormData({ ...formData, email: e.target.value })}
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm"
                placeholder="ì´ë©”ì¼ ì£¼ì†Œ"
              />
            </div>
            <div>
              <label htmlFor="password" className="sr-only">ë¹„ë°€ë²ˆí˜¸</label>
              <input
                id="password" type="password" required
                value={formData.password}
                onChange={(e) => setFormData({ ...formData, password: e.target.value })}
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-b-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm"
                placeholder="ë¹„ë°€ë²ˆí˜¸ (ìµœì†Œ 8ì)"
              />
            </div>
          </div>

          <button
            type="submit" disabled={loading}
            className="w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400"
          >
            {loading ? "ì²˜ë¦¬ ì¤‘..." : "íšŒì›ê°€ì…"}
          </button>

          <div className="text-center">
            <p className="text-sm text-gray-600">
              ì´ë¯¸ ê³„ì •ì´ ìˆìœ¼ì‹ ê°€ìš”?{" "}
              <Link href="/login" className="font-medium text-blue-600 hover:text-blue-500">ë¡œê·¸ì¸</Link>
            </p>
          </div>
        </form>
      </div>
    </div>
  );
}
</file>

<file path="src/app/activity-log/page.tsx">
"use client";

import { useState, useEffect, useCallback } from "react";
import Link from "next/link";
import {
  ChevronLeft, Activity, FileUp, Trash2, Download, Share2,
  FolderPlus, FolderMinus, FileText, MessageSquare, User,
  Lock, LogIn, LogOut, MessageCircle, Phone, PhoneOff,
  RefreshCw, ChevronLeft as Prev, ChevronRight as Next,
  Filter,
} from "lucide-react";
import { toast } from "@/components/Toast";
import { useConfirm } from "@/components/ConfirmDialog";

type ActivityAction =
  | "FILE_UPLOAD" | "FILE_DELETE" | "FILE_DOWNLOAD" | "FILE_SHARE"
  | "FOLDER_CREATE" | "FOLDER_DELETE"
  | "POST_CREATE" | "POST_DELETE"
  | "COMMENT_CREATE" | "COMMENT_DELETE"
  | "PROFILE_UPDATE" | "PASSWORD_CHANGE"
  | "LOGIN" | "LOGOUT"
  | "CHAT_MESSAGE" | "CALL_START" | "CALL_END";

interface ActivityLog {
  id: string;
  action: ActivityAction;
  target?: string;
  targetId?: string;
  meta?: Record<string, string>;
  createdAt: string;
}

const ACTION_META: Record<ActivityAction, { label: string; icon: React.ElementType; color: string; bg: string }> = {
  FILE_UPLOAD:    { label: "íŒŒì¼ ì—…ë¡œë“œ",    icon: FileUp,       color: "text-blue-600",   bg: "bg-blue-50 dark:bg-blue-900/30" },
  FILE_DELETE:    { label: "íŒŒì¼ ì‚­ì œ",      icon: Trash2,       color: "text-red-600",    bg: "bg-red-50 dark:bg-red-900/30" },
  FILE_DOWNLOAD:  { label: "íŒŒì¼ ë‹¤ìš´ë¡œë“œ",  icon: Download,     color: "text-green-600",  bg: "bg-green-50 dark:bg-green-900/30" },
  FILE_SHARE:     { label: "íŒŒì¼ ê³µìœ ",      icon: Share2,       color: "text-purple-600", bg: "bg-purple-50 dark:bg-purple-900/30" },
  FOLDER_CREATE:  { label: "í´ë” ìƒì„±",      icon: FolderPlus,   color: "text-yellow-600", bg: "bg-yellow-50 dark:bg-yellow-900/30" },
  FOLDER_DELETE:  { label: "í´ë” ì‚­ì œ",      icon: FolderMinus,  color: "text-red-600",    bg: "bg-red-50 dark:bg-red-900/30" },
  POST_CREATE:    { label: "ê²Œì‹œê¸€ ì‘ì„±",    icon: FileText,     color: "text-indigo-600", bg: "bg-indigo-50 dark:bg-indigo-900/30" },
  POST_DELETE:    { label: "ê²Œì‹œê¸€ ì‚­ì œ",    icon: Trash2,       color: "text-red-600",    bg: "bg-red-50 dark:bg-red-900/30" },
  COMMENT_CREATE: { label: "ëŒ“ê¸€ ì‘ì„±",      icon: MessageSquare,color: "text-cyan-600",   bg: "bg-cyan-50 dark:bg-cyan-900/30" },
  COMMENT_DELETE: { label: "ëŒ“ê¸€ ì‚­ì œ",      icon: Trash2,       color: "text-red-600",    bg: "bg-red-50 dark:bg-red-900/30" },
  PROFILE_UPDATE: { label: "í”„ë¡œí•„ ìˆ˜ì •",    icon: User,         color: "text-gray-600",   bg: "bg-gray-50 dark:bg-gray-800" },
  PASSWORD_CHANGE:{ label: "ë¹„ë°€ë²ˆí˜¸ ë³€ê²½",  icon: Lock,         color: "text-orange-600", bg: "bg-orange-50 dark:bg-orange-900/30" },
  LOGIN:          { label: "ë¡œê·¸ì¸",         icon: LogIn,        color: "text-green-600",  bg: "bg-green-50 dark:bg-green-900/30" },
  LOGOUT:         { label: "ë¡œê·¸ì•„ì›ƒ",       icon: LogOut,       color: "text-gray-600",   bg: "bg-gray-50 dark:bg-gray-800" },
  CHAT_MESSAGE:   { label: "ì±„íŒ… ë©”ì‹œì§€",    icon: MessageCircle,color: "text-purple-600", bg: "bg-purple-50 dark:bg-purple-900/30" },
  CALL_START:     { label: "í†µí™” ì‹œì‘",      icon: Phone,        color: "text-blue-600",   bg: "bg-blue-50 dark:bg-blue-900/30" },
  CALL_END:       { label: "í†µí™” ì¢…ë£Œ",      icon: PhoneOff,     color: "text-gray-600",   bg: "bg-gray-50 dark:bg-gray-800" },
};

const ACTION_GROUPS = [
  { label: "ì „ì²´", value: "" },
  { label: "íŒŒì¼", value: "FILE_UPLOAD" },
  { label: "ê³µìœ ", value: "FILE_SHARE" },
  { label: "ê²Œì‹œê¸€", value: "POST_CREATE" },
  { label: "ë¡œê·¸ì¸", value: "LOGIN" },
];

function timeAgo(dateStr: string) {
  const diff = Date.now() - new Date(dateStr).getTime();
  const m = Math.floor(diff / 60000);
  if (m < 1) return "ë°©ê¸ˆ ì „";
  if (m < 60) return `${m}ë¶„ ì „`;
  const h = Math.floor(m / 60);
  if (h < 24) return `${h}ì‹œê°„ ì „`;
  return new Date(dateStr).toLocaleDateString("ko-KR", { month: "short", day: "numeric", hour: "2-digit", minute: "2-digit" });
}

export default function ActivityLogPage() {
  const { confirmDialog, openConfirm } = useConfirm();
  const [logs, setLogs] = useState<ActivityLog[]>([]);
  const [loading, setLoading] = useState(true);
  const [page, setPage] = useState(1);
  const [totalPages, setTotalPages] = useState(1);
  const [total, setTotal] = useState(0);
  const [filter, setFilter] = useState("");

  const fetchLogs = useCallback(async () => {
    setLoading(true);
    try {
      const params = new URLSearchParams({ page: String(page), limit: "30" });
      if (filter) params.set("action", filter);
      const res = await fetch(`/api/activity-logs?${params}`);
      if (!res.ok) throw new Error();
      const data = await res.json();
      setLogs(data.logs);
      setTotalPages(data.totalPages);
      setTotal(data.total);
    } catch {
      toast.error("í™œë™ ë¡œê·¸ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  }, [page, filter]);

  useEffect(() => { fetchLogs(); }, [fetchLogs]);
  useEffect(() => { setPage(1); }, [filter]);

  const clearLogs = async () => {
    const ok = await openConfirm({
      title: "í™œë™ ë¡œê·¸ ì „ì²´ ì‚­ì œ",
      message: "ëª¨ë“  í™œë™ ë‚´ì—­ì„ ì‚­ì œí• ê¹Œìš”? ë³µêµ¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      confirmText: "ì‚­ì œ",
      confirmVariant: "danger",
    });
    if (!ok) return;
    await fetch("/api/activity-logs", { method: "DELETE" });
    setLogs([]);
    setTotal(0);
    toast.success("í™œë™ ë¡œê·¸ë¥¼ ì‚­ì œí–ˆìŠµë‹ˆë‹¤");
  };

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900">
      {confirmDialog}

      {/* í—¤ë” */}
      <div className="bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700 sticky top-0 z-10">
        <div className="max-w-2xl mx-auto px-4 py-3 flex items-center gap-3">
          <Link href="/profile" className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
            <ChevronLeft size={20} className="text-gray-600 dark:text-slate-400" />
          </Link>
          <Activity size={20} className="text-gray-800 dark:text-slate-200" />
          <h1 className="text-lg font-semibold text-gray-900 dark:text-slate-100 flex-1">
            í™œë™ ë‚´ì—­
            {total > 0 && <span className="ml-2 text-sm font-normal text-gray-500 dark:text-slate-400">({total}ê±´)</span>}
          </h1>
          <button onClick={fetchLogs} className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
            <RefreshCw size={16} className="text-gray-500 dark:text-slate-400" />
          </button>
        </div>

        {/* í•„í„° íƒ­ */}
        <div className="max-w-2xl mx-auto px-4 pb-2 flex gap-1 overflow-x-auto">
          {ACTION_GROUPS.map((g) => (
            <button
              key={g.value}
              onClick={() => setFilter(g.value)}
              className={`px-3 py-1.5 rounded-full text-xs font-medium whitespace-nowrap transition-colors ${
                filter === g.value
                  ? "bg-blue-600 text-white"
                  : "text-gray-500 dark:text-slate-400 hover:bg-gray-100 dark:hover:bg-slate-700"
              }`}
            >
              {g.label}
            </button>
          ))}
        </div>
      </div>

      <div className="max-w-2xl mx-auto px-4 py-4">
        {/* ì „ì²´ ì‚­ì œ */}
        {logs.length > 0 && (
          <div className="flex justify-end mb-3">
            <button
              onClick={clearLogs}
              className="flex items-center gap-1.5 text-xs text-red-500 hover:text-red-600 font-medium px-3 py-1.5 rounded-lg hover:bg-red-50 dark:hover:bg-red-900/20 transition-colors"
            >
              <Trash2 size={12} /> ì „ì²´ ì‚­ì œ
            </button>
          </div>
        )}

        {/* ë¡œê·¸ ëª©ë¡ */}
        {loading ? (
          <div className="space-y-2">
            {[...Array(8)].map((_, i) => (
              <div key={i} className="bg-white dark:bg-slate-800 rounded-xl p-4 animate-pulse flex gap-3">
                <div className="w-9 h-9 rounded-full bg-gray-200 dark:bg-slate-700 shrink-0" />
                <div className="flex-1 space-y-2">
                  <div className="h-3.5 bg-gray-200 dark:bg-slate-700 rounded w-1/3" />
                  <div className="h-3 bg-gray-100 dark:bg-slate-700/50 rounded w-1/2" />
                </div>
              </div>
            ))}
          </div>
        ) : logs.length === 0 ? (
          <div className="flex flex-col items-center justify-center py-24 text-center">
            <div className="w-16 h-16 rounded-full bg-gray-100 dark:bg-slate-800 flex items-center justify-center mb-4">
              <Activity size={28} className="text-gray-400 dark:text-slate-500" />
            </div>
            <p className="text-gray-500 dark:text-slate-400 font-medium">í™œë™ ë‚´ì—­ì´ ì—†ìŠµë‹ˆë‹¤</p>
          </div>
        ) : (
          <>
            <div className="space-y-2">
              {logs.map((log) => {
                const meta = ACTION_META[log.action];
                const Icon = meta.icon;
                return (
                  <div key={log.id} className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 px-4 py-3 flex items-center gap-3">
                    <div className={`w-9 h-9 rounded-full flex items-center justify-center shrink-0 ${meta.bg}`}>
                      <Icon size={15} className={meta.color} />
                    </div>
                    <div className="flex-1 min-w-0">
                      <p className="text-sm font-medium text-gray-900 dark:text-slate-100">{meta.label}</p>
                      {log.target && (
                        <p className="text-xs text-gray-500 dark:text-slate-400 truncate">{log.target}</p>
                      )}
                      {log.meta?.ip && (
                        <p className="text-[10px] text-gray-400 dark:text-slate-500 mt-0.5">IP: {log.meta.ip}</p>
                      )}
                    </div>
                    <span className="text-xs text-gray-400 dark:text-slate-500 shrink-0">{timeAgo(log.createdAt)}</span>
                  </div>
                );
              })}
            </div>

            {/* í˜ì´ì§€ë„¤ì´ì…˜ */}
            {totalPages > 1 && (
              <div className="flex items-center justify-center gap-3 mt-6">
                <button
                  onClick={() => setPage((p) => Math.max(1, p - 1))}
                  disabled={page === 1}
                  className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 disabled:opacity-30 transition-colors"
                >
                  <Prev size={16} className="text-gray-600 dark:text-slate-400" />
                </button>
                <span className="text-sm text-gray-600 dark:text-slate-400">
                  {page} / {totalPages}
                </span>
                <button
                  onClick={() => setPage((p) => Math.min(totalPages, p + 1))}
                  disabled={page === totalPages}
                  className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 disabled:opacity-30 transition-colors"
                >
                  <Next size={16} className="text-gray-600 dark:text-slate-400" />
                </button>
              </div>
            )}
          </>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/app/admin/page.tsx">
"use client";

import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import { useEffect, useState, useCallback } from "react";
import Link from "next/link";
import {
  Users,
  Files,
  MessageSquare,
  BarChart2,
  ShieldAlert,
  ChevronLeft,
  Search,
  UserX,
  UserCheck,
  Trash2,
  RefreshCw,
  Crown,
  User,
} from "lucide-react";
import { toast } from "@/components/Toast";
import { useConfirm } from "@/components/ConfirmDialog";

interface UserRow {
  id: string;
  name: string;
  email: string;
  role: "USER" | "ADMIN";
  emailVerified: boolean;
  isOnline: boolean;
  createdAt: string;
  _count: { files: number; posts: number; comments: number };
}

interface Stats {
  totalUsers: number;
  totalFiles: number;
  totalPosts: number;
  totalComments: number;
  onlineUsers: number;
  adminCount: number;
}

export default function AdminPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const { confirmDialog, openConfirm } = useConfirm();

  const [users, setUsers] = useState<UserRow[]>([]);
  const [stats, setStats] = useState<Stats | null>(null);
  const [loading, setLoading] = useState(true);
  const [search, setSearch] = useState("");
  const [roleFilter, setRoleFilter] = useState<"ALL" | "USER" | "ADMIN">("ALL");
  const [actionLoading, setActionLoading] = useState<string | null>(null);

  // ê¶Œí•œ ì²´í¬
  useEffect(() => {
    if (status === "loading") return;
    if (!session?.user || (session.user as any).role !== "ADMIN") {
      router.replace("/dashboard");
    }
  }, [session, status, router]);

  const fetchData = useCallback(async () => {
    setLoading(true);
    try {
      const [usersRes, statsRes] = await Promise.all([
        fetch("/api/admin/users"),
        fetch("/api/admin/stats"),
      ]);
      if (usersRes.ok) setUsers(await usersRes.json());
      if (statsRes.ok) setStats(await statsRes.json());
    } catch {
      toast.error("ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  // ì—­í•  ë³€ê²½ (USER â†” ADMIN)
  const toggleRole = async (user: UserRow) => {
    const newRole = user.role === "ADMIN" ? "USER" : "ADMIN";
    const confirmed = await openConfirm({
      title: "ì—­í•  ë³€ê²½",
      message: `${user.name}ë‹˜ì„ ${newRole === "ADMIN" ? "ê´€ë¦¬ì" : "ì¼ë°˜ ì‚¬ìš©ì"}ë¡œ ë³€ê²½í• ê¹Œìš”?`,
      confirmText: "ë³€ê²½",
      confirmVariant: "primary",
    });
    if (!confirmed) return;

    setActionLoading(user.id);
    try {
      const res = await fetch(`/api/admin/users/${user.id}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ role: newRole }),
      });
      if (!res.ok) throw new Error();
      setUsers((prev) =>
        prev.map((u) => (u.id === user.id ? { ...u, role: newRole } : u))
      );
      toast.success(`ì—­í• ì„ ${newRole === "ADMIN" ? "ê´€ë¦¬ì" : "ì¼ë°˜ ì‚¬ìš©ì"}ë¡œ ë³€ê²½í–ˆìŠµë‹ˆë‹¤`);
    } catch {
      toast.error("ì—­í•  ë³€ê²½ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
    } finally {
      setActionLoading(null);
    }
  };

  // ê³„ì • ì‚­ì œ
  const deleteUser = async (user: UserRow) => {
    if (user.id === session?.user?.id) {
      toast.error("ìì‹ ì˜ ê³„ì •ì€ ì‚­ì œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤");
      return;
    }
    const confirmed = await openConfirm({
      title: "ê³„ì • ì‚­ì œ",
      message: `${user.name}ë‹˜ì˜ ê³„ì •ì„ ì‚­ì œí• ê¹Œìš”? ëª¨ë“  ë°ì´í„°ê°€ ì˜êµ¬ ì‚­ì œë©ë‹ˆë‹¤.`,
      confirmText: "ì‚­ì œ",
      confirmVariant: "danger",
    });
    if (!confirmed) return;

    setActionLoading(user.id);
    try {
      const res = await fetch(`/api/admin/users/${user.id}`, { method: "DELETE" });
      if (!res.ok) throw new Error();
      setUsers((prev) => prev.filter((u) => u.id !== user.id));
      if (stats) setStats({ ...stats, totalUsers: stats.totalUsers - 1 });
      toast.success("ê³„ì •ì„ ì‚­ì œí–ˆìŠµë‹ˆë‹¤");
    } catch {
      toast.error("ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
    } finally {
      setActionLoading(null);
    }
  };

  const filtered = users.filter((u) => {
    const matchSearch =
      u.name.toLowerCase().includes(search.toLowerCase()) ||
      u.email.toLowerCase().includes(search.toLowerCase());
    const matchRole = roleFilter === "ALL" || u.role === roleFilter;
    return matchSearch && matchRole;
  });

  if (status === "loading" || (session && (session.user as any)?.role !== "ADMIN")) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600" />
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900 dark:bg-slate-900">
      {confirmDialog}

      {/* í—¤ë” */}
      <div className="bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700 dark:border-slate-700 sticky top-0 z-10">
        <div className="max-w-6xl mx-auto px-4 py-3 flex items-center gap-3">
          <Link href="/dashboard" className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 dark:bg-slate-700 transition-colors">
            <ChevronLeft size={20} className="text-gray-600 dark:text-slate-400" />
          </Link>
          <ShieldAlert size={20} className="text-red-500" />
          <h1 className="text-lg font-semibold text-gray-900 dark:text-slate-100 flex-1">ê´€ë¦¬ì ëŒ€ì‹œë³´ë“œ</h1>
          <button
            onClick={fetchData}
            className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 dark:bg-slate-700 transition-colors"
          >
            <RefreshCw size={16} className="text-gray-500 dark:text-slate-400" />
          </button>
        </div>
      </div>

      <div className="max-w-6xl mx-auto px-4 py-6 space-y-6">
        {/* í†µê³„ ì¹´ë“œ */}
        {stats && (
          <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-3">
            {[
              { label: "ì „ì²´ ì‚¬ìš©ì", value: stats.totalUsers, icon: Users, color: "text-blue-600", bg: "bg-blue-50" },
              { label: "ì ‘ì† ì¤‘", value: stats.onlineUsers, icon: UserCheck, color: "text-green-600", bg: "bg-green-50" },
              { label: "ê´€ë¦¬ì", value: stats.adminCount, icon: Crown, color: "text-yellow-600", bg: "bg-yellow-50" },
              { label: "íŒŒì¼ ìˆ˜", value: stats.totalFiles, icon: Files, color: "text-purple-600", bg: "bg-purple-50" },
              { label: "ê²Œì‹œê¸€ ìˆ˜", value: stats.totalPosts, icon: BarChart2, color: "text-orange-600", bg: "bg-orange-50" },
              { label: "ëŒ“ê¸€ ìˆ˜", value: stats.totalComments, icon: MessageSquare, color: "text-pink-600", bg: "bg-pink-50" },
            ].map((s) => {
              const Icon = s.icon;
              return (
                <div key={s.label} className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 dark:border-slate-700 p-4">
                  <div className={`w-8 h-8 rounded-lg ${s.bg} flex items-center justify-center mb-2`}>
                    <Icon size={16} className={s.color} />
                  </div>
                  <p className="text-2xl font-bold text-gray-900 dark:text-slate-100">{s.value.toLocaleString()}</p>
                  <p className="text-xs text-gray-500 dark:text-slate-400 mt-0.5">{s.label}</p>
                </div>
              );
            })}
          </div>
        )}

        {/* ì‚¬ìš©ì ê´€ë¦¬ */}
        <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 dark:border-slate-700">
          <div className="p-4 border-b border-gray-100 dark:border-slate-700">
            <h2 className="font-semibold text-gray-900 dark:text-slate-100 mb-3">ì‚¬ìš©ì ê´€ë¦¬</h2>
            <div className="flex gap-2 flex-wrap">
              {/* ê²€ìƒ‰ */}
              <div className="relative flex-1 min-w-48">
                <Search size={14} className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400 dark:text-slate-500" />
                <input
                  type="text"
                  placeholder="ì´ë¦„ ë˜ëŠ” ì´ë©”ì¼ ê²€ìƒ‰"
                  value={search}
                  onChange={(e) => setSearch(e.target.value)}
                  className="w-full pl-8 pr-3 py-2 text-sm border border-gray-200 dark:border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
              </div>
              {/* ì—­í•  í•„í„° */}
              <div className="flex gap-1">
                {(["ALL", "USER", "ADMIN"] as const).map((r) => (
                  <button
                    key={r}
                    onClick={() => setRoleFilter(r)}
                    className={`px-3 py-2 text-xs font-medium rounded-lg transition-colors ${
                      roleFilter === r
                        ? "bg-blue-600 text-white"
                        : "bg-gray-100 dark:bg-slate-700 text-gray-600 dark:text-slate-400 hover:bg-gray-200"
                    }`}
                  >
                    {r === "ALL" ? "ì „ì²´" : r === "USER" ? "ì¼ë°˜" : "ê´€ë¦¬ì"}
                  </button>
                ))}
              </div>
            </div>
          </div>

          {/* í…Œì´ë¸” */}
          <div className="overflow-x-auto">
            {loading ? (
              <div className="p-8 flex justify-center">
                <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600" />
              </div>
            ) : filtered.length === 0 ? (
              <div className="p-8 text-center text-gray-400 dark:text-slate-500 text-sm">
                ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤
              </div>
            ) : (
              <table className="w-full text-sm">
                <thead>
                  <tr className="border-b border-gray-100 dark:border-slate-700 bg-gray-50 dark:bg-slate-900">
                    <th className="text-left px-4 py-3 text-xs font-semibold text-gray-500 dark:text-slate-400">ì‚¬ìš©ì</th>
                    <th className="text-left px-4 py-3 text-xs font-semibold text-gray-500 dark:text-slate-400">ì—­í• </th>
                    <th className="text-left px-4 py-3 text-xs font-semibold text-gray-500 dark:text-slate-400 hidden md:table-cell">í™œë™</th>
                    <th className="text-left px-4 py-3 text-xs font-semibold text-gray-500 dark:text-slate-400 hidden lg:table-cell">ê°€ì…ì¼</th>
                    <th className="text-left px-4 py-3 text-xs font-semibold text-gray-500 dark:text-slate-400">ìƒíƒœ</th>
                    <th className="text-right px-4 py-3 text-xs font-semibold text-gray-500 dark:text-slate-400">ì•¡ì…˜</th>
                  </tr>
                </thead>
                <tbody>
                  {filtered.map((u) => (
                    <tr key={u.id} className="border-b border-gray-50 hover:bg-gray-50 dark:hover:bg-slate-700 dark:bg-slate-900 transition-colors">
                      <td className="px-4 py-3">
                        <div className="flex items-center gap-2">
                          <div className="w-8 h-8 rounded-full bg-gradient-to-br from-blue-400 to-purple-500 flex items-center justify-center text-white text-xs font-bold shrink-0">
                            {u.name[0]}
                          </div>
                          <div>
                            <p className="font-medium text-gray-900 dark:text-slate-100 flex items-center gap-1">
                              {u.name}
                              {u.id === session?.user?.id && (
                                <span className="text-[9px] bg-blue-100 text-blue-600 px-1 rounded">ë‚˜</span>
                              )}
                            </p>
                            <p className="text-xs text-gray-400 dark:text-slate-500">{u.email}</p>
                          </div>
                        </div>
                      </td>
                      <td className="px-4 py-3">
                        <span className={`text-xs font-semibold px-2 py-1 rounded-full ${
                          u.role === "ADMIN"
                            ? "bg-yellow-100 text-yellow-700"
                            : "bg-gray-100 dark:bg-slate-700 text-gray-600 dark:text-slate-400"
                        }`}>
                          {u.role === "ADMIN" ? "ğŸ‘‘ ê´€ë¦¬ì" : "ì¼ë°˜"}
                        </span>
                      </td>
                      <td className="px-4 py-3 hidden md:table-cell">
                        <div className="text-xs text-gray-500 dark:text-slate-400 space-y-0.5">
                          <div>íŒŒì¼ {u._count.files}ê°œ</div>
                          <div>ê²Œì‹œê¸€ {u._count.posts}ê°œ</div>
                        </div>
                      </td>
                      <td className="px-4 py-3 hidden lg:table-cell text-xs text-gray-500 dark:text-slate-400">
                        {new Date(u.createdAt).toLocaleDateString("ko-KR")}
                      </td>
                      <td className="px-4 py-3">
                        <div className="flex items-center gap-1.5">
                          <span className={`w-2 h-2 rounded-full ${u.isOnline ? "bg-green-500" : "bg-gray-300"}`} />
                          <span className="text-xs text-gray-500 dark:text-slate-400">{u.isOnline ? "ì˜¨ë¼ì¸" : "ì˜¤í”„ë¼ì¸"}</span>
                        </div>
                      </td>
                      <td className="px-4 py-3">
                        <div className="flex items-center justify-end gap-1">
                          <button
                            onClick={() => toggleRole(u)}
                            disabled={actionLoading === u.id || u.id === session?.user?.id}
                            title={u.role === "ADMIN" ? "ì¼ë°˜ ì‚¬ìš©ìë¡œ ë³€ê²½" : "ê´€ë¦¬ìë¡œ ìŠ¹ê²©"}
                            className="p-1.5 rounded-lg hover:bg-yellow-50 text-yellow-600 hover:text-yellow-700 transition-colors disabled:opacity-30 disabled:cursor-not-allowed"
                          >
                            {u.role === "ADMIN" ? <User size={14} /> : <Crown size={14} />}
                          </button>
                          <button
                            onClick={() => deleteUser(u)}
                            disabled={actionLoading === u.id || u.id === session?.user?.id}
                            title="ê³„ì • ì‚­ì œ"
                            className="p-1.5 rounded-lg hover:bg-red-50 text-red-400 hover:text-red-500 transition-colors disabled:opacity-30 disabled:cursor-not-allowed"
                          >
                            <Trash2 size={14} />
                          </button>
                        </div>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            )}
          </div>

          <div className="px-4 py-3 border-t border-gray-100 dark:border-slate-700 text-xs text-gray-400 dark:text-slate-500">
            ì´ {filtered.length}ëª… / {users.length}ëª…
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/admin/stats/page.tsx">
"use client";
// src/app/admin/stats/page.tsx â€” ê´€ë¦¬ì í†µê³„ & ê´€ë¦¬ ëŒ€ì‹œë³´ë“œ

import { useState, useEffect, useCallback } from "react";
import Link from "next/link";
import {
  ChevronLeft, Users, HardDrive, FileText, MessageSquare,
  TrendingUp, Ban, Bell, RefreshCw, Plus, Trash2, X,
  AlertTriangle, CheckCircle, Info, Wrench,
} from "lucide-react";
import { formatFileSize } from "@/lib/client-utils";
import { toast } from "@/components/Toast";
import { useConfirm } from "@/components/ConfirmDialog";

interface Stats {
  summary: {
    totalUsers: number; activeUsers: number; bannedUsers: number;
    totalFiles: number; totalStorage: string;
    totalPosts: number; totalComments: number;
    newUsersLast30: number; newFilesLast30: number;
  };
  topStorageUsers: { id: string; name: string; email: string; storageUsed: string }[];
  filesByType: { type: string; count: number; size: string }[];
  dailySignups: { date: string; count: number }[];
  dailyUploads: { date: string; count: number }[];
}

interface Notice {
  id: string; title: string; content: string; type: string;
  isActive: boolean; endsAt: string | null; createdAt: string;
}

const NOTICE_ICONS = {
  INFO:        <Info size={14} className="text-blue-500" />,
  WARNING:     <AlertTriangle size={14} className="text-amber-500" />,
  MAINTENANCE: <Wrench size={14} className="text-purple-500" />,
};

// ê°„ë‹¨í•œ ë°” ì°¨íŠ¸ ì»´í¬ë„ŒíŠ¸
function MiniBarChart({ data, label }: { data: { date: string; count: number }[]; label: string }) {
  const max = Math.max(...data.map((d) => d.count), 1);
  return (
    <div>
      <p className="text-xs font-semibold text-gray-500 dark:text-slate-400 mb-3">{label}</p>
      <div className="flex items-end gap-1 h-20">
        {data.slice(-14).map((d, i) => (
          <div key={i} className="flex-1 flex flex-col items-center gap-1 group relative">
            <div
              className="w-full bg-blue-500/20 dark:bg-blue-400/20 hover:bg-blue-500/40 rounded-sm transition-all"
              style={{ height: `${Math.max((d.count / max) * 100, 4)}%` }}
            />
            <div className="absolute bottom-full mb-1 hidden group-hover:block bg-gray-800 text-white text-[10px] px-1.5 py-0.5 rounded whitespace-nowrap z-10">
              {d.date}: {d.count}
            </div>
          </div>
        ))}
      </div>
      <div className="flex justify-between mt-1 text-[9px] text-gray-400 dark:text-slate-500">
        <span>{data[0]?.date?.slice(5)}</span>
        <span>{data[data.length - 1]?.date?.slice(5)}</span>
      </div>
    </div>
  );
}

export default function AdminStatsPage() {
  const { confirmDialog, openConfirm } = useConfirm();
  const [stats, setStats] = useState<Stats | null>(null);
  const [notices, setNotices] = useState<Notice[]>([]);
  const [loading, setLoading] = useState(true);
  const [tab, setTab] = useState<"overview" | "users" | "notices">("overview");

  // ê³µì§€ í¼
  const [showNoticeForm, setShowNoticeForm] = useState(false);
  const [noticeForm, setNoticeForm] = useState({ title: "", content: "", type: "INFO", endsAt: "" });
  const [savingNotice, setSavingNotice] = useState(false);

  const fetchAll = useCallback(async () => {
    setLoading(true);
    try {
      const [statsRes, noticesRes] = await Promise.all([
        fetch("/api/admin/stats"),
        fetch("/api/admin/notices"),
      ]);
      if (statsRes.ok) setStats(await statsRes.json());
      if (noticesRes.ok) setNotices((await noticesRes.json()).notices ?? []);
    } catch { toast.error("ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤"); }
    finally { setLoading(false); }
  }, []);

  useEffect(() => { fetchAll(); }, [fetchAll]);

  const banUser = async (id: string, name: string) => {
    const ok = await openConfirm({ title: "ì‚¬ìš©ì ì •ì§€", message: `${name}ì„ ì •ì§€í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`, confirmText: "ì •ì§€", confirmVariant: "danger" });
    if (!ok) return;
    const res = await fetch(`/api/admin/users/${id}/ban`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ reason: "ê´€ë¦¬ì ê²°ì •" }) });
    if (res.ok) { toast.success(`${name}ì´ ì •ì§€ë˜ì—ˆìŠµë‹ˆë‹¤`); fetchAll(); }
  };

  const unbanUser = async (id: string, name: string) => {
    const res = await fetch(`/api/admin/users/${id}/ban`, { method: "DELETE" });
    if (res.ok) { toast.success(`${name}ì˜ ì •ì§€ê°€ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤`); fetchAll(); }
  };

  const saveNotice = async () => {
    if (!noticeForm.title.trim() || !noticeForm.content.trim()) { toast.error("ì œëª©ê³¼ ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”"); return; }
    setSavingNotice(true);
    try {
      const res = await fetch("/api/admin/notices", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(noticeForm) });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error);
      setNotices((n) => [data.notice, ...n]);
      setShowNoticeForm(false);
      setNoticeForm({ title: "", content: "", type: "INFO", endsAt: "" });
      toast.success("ê³µì§€ê°€ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤");
    } catch (e: any) { toast.error(e.message); }
    finally { setSavingNotice(false); }
  };

  const deleteNotice = async (id: string) => {
    const ok = await openConfirm({ title: "ê³µì§€ ì‚­ì œ", message: "ì´ ê³µì§€ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?", confirmText: "ì‚­ì œ", confirmVariant: "danger" });
    if (!ok) return;
    await fetch(`/api/admin/notices/${id}`, { method: "DELETE" });
    setNotices((n) => n.filter((x) => x.id !== id));
    toast.success("ê³µì§€ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤");
  };

  const s = stats?.summary;

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900">
      {confirmDialog}

      {/* í—¤ë” */}
      <div className="bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700 sticky top-0 z-10">
        <div className="max-w-5xl mx-auto px-4 py-3 flex items-center gap-3">
          <Link href="/admin" className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
            <ChevronLeft size={20} className="text-gray-600 dark:text-slate-400" />
          </Link>
          <TrendingUp size={20} className="text-gray-800 dark:text-slate-200" />
          <h1 className="text-lg font-semibold text-gray-900 dark:text-slate-100 flex-1">í†µê³„ & ê´€ë¦¬</h1>
          <button onClick={fetchAll} className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700">
            <RefreshCw size={16} className={`text-gray-500 dark:text-slate-400 ${loading ? "animate-spin" : ""}`} />
          </button>
        </div>
        {/* íƒ­ */}
        <div className="max-w-5xl mx-auto px-4 flex gap-1 pb-1">
          {(["overview", "users", "notices"] as const).map((t) => (
            <button key={t} onClick={() => setTab(t)}
              className={`px-4 py-2 text-xs font-semibold rounded-lg transition ${tab === t ? "bg-blue-600 text-white" : "text-gray-500 dark:text-slate-400 hover:bg-gray-100 dark:hover:bg-slate-700"}`}>
              {{ overview: "ğŸ“Š ê°œìš”", users: "ğŸ‘¥ ì‚¬ìš©ì", notices: "ğŸ“¢ ê³µì§€" }[t]}
            </button>
          ))}
        </div>
      </div>

      <div className="max-w-5xl mx-auto px-4 py-6">

        {/* â”€â”€ ê°œìš” íƒ­ â”€â”€ */}
        {tab === "overview" && (
          <div className="space-y-5">
            {/* KPI ì¹´ë“œ */}
            <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
              {[
                { label: "ì „ì²´ ì‚¬ìš©ì", value: s?.totalUsers ?? 0, sub: `ì‹ ê·œ +${s?.newUsersLast30 ?? 0}/30ì¼`, icon: Users, color: "text-blue-600", bg: "bg-blue-50 dark:bg-blue-900/20" },
                { label: "ì „ì²´ íŒŒì¼", value: s?.totalFiles ?? 0, sub: `ì‹ ê·œ +${s?.newFilesLast30 ?? 0}/30ì¼`, icon: HardDrive, color: "text-green-600", bg: "bg-green-50 dark:bg-green-900/20" },
                { label: "ì´ ì €ì¥ ìš©ëŸ‰", value: formatFileSize(s?.totalStorage ?? "0"), sub: "ì‚¬ìš© ì¤‘", icon: HardDrive, color: "text-purple-600", bg: "bg-purple-50 dark:bg-purple-900/20" },
                { label: "ê²Œì‹œê¸€", value: s?.totalPosts ?? 0, sub: `ëŒ“ê¸€ ${s?.totalComments ?? 0}ê°œ`, icon: FileText, color: "text-orange-600", bg: "bg-orange-50 dark:bg-orange-900/20" },
              ].map(({ label, value, sub, icon: Icon, color, bg }) => (
                <div key={label} className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-4">
                  <div className={`w-9 h-9 rounded-xl ${bg} flex items-center justify-center mb-3`}>
                    <Icon size={18} className={color} />
                  </div>
                  <p className="text-2xl font-black text-gray-900 dark:text-slate-100">{value.toLocaleString()}</p>
                  <p className="text-xs font-medium text-gray-600 dark:text-slate-300 mt-0.5">{label}</p>
                  <p className="text-[10px] text-gray-400 dark:text-slate-500 mt-0.5">{sub}</p>
                </div>
              ))}
            </div>

            {/* ì°¨íŠ¸ */}
            <div className="grid md:grid-cols-2 gap-4">
              <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-5">
                {stats?.dailySignups && stats.dailySignups.length > 0
                  ? <MiniBarChart data={stats.dailySignups} label="ì¼ë³„ ì‹ ê·œ ê°€ì…ì (ìµœê·¼ 14ì¼)" />
                  : <p className="text-xs text-gray-400 dark:text-slate-500 text-center py-8">ë°ì´í„° ì—†ìŒ</p>}
              </div>
              <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-5">
                {stats?.dailyUploads && stats.dailyUploads.length > 0
                  ? <MiniBarChart data={stats.dailyUploads} label="ì¼ë³„ íŒŒì¼ ì—…ë¡œë“œ (ìµœê·¼ 14ì¼)" />
                  : <p className="text-xs text-gray-400 dark:text-slate-500 text-center py-8">ë°ì´í„° ì—†ìŒ</p>}
              </div>
            </div>

            {/* íŒŒì¼ íƒ€ì… ë¶„í¬ */}
            {stats?.filesByType && (
              <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-5">
                <p className="text-xs font-semibold text-gray-500 dark:text-slate-400 mb-4">íŒŒì¼ íƒ€ì…ë³„ ë¶„í¬</p>
                <div className="space-y-2">
                  {stats.filesByType.map(({ type, count, size }) => {
                    const total = stats.filesByType.reduce((a, b) => a + b.count, 0);
                    const pct = total > 0 ? Math.round((count / total) * 100) : 0;
                    return (
                      <div key={type} className="flex items-center gap-3">
                        <span className="text-xs text-gray-700 dark:text-slate-300 w-12">{type}</span>
                        <div className="flex-1 h-2 bg-gray-100 dark:bg-slate-700 rounded-full overflow-hidden">
                          <div className="h-full bg-blue-500 rounded-full" style={{ width: `${pct}%` }} />
                        </div>
                        <span className="text-xs text-gray-500 dark:text-slate-400 w-16 text-right">{count}ê°œ ({pct}%)</span>
                        <span className="text-[10px] text-gray-400 dark:text-slate-500 w-16 text-right">{formatFileSize(size)}</span>
                      </div>
                    );
                  })}
                </div>
              </div>
            )}

            {/* ì €ì¥ ì‚¬ìš©ëŸ‰ Top 10 */}
            {stats?.topStorageUsers && (
              <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-5">
                <p className="text-xs font-semibold text-gray-500 dark:text-slate-400 mb-4">ì €ì¥ ì‚¬ìš©ëŸ‰ Top 10</p>
                <div className="divide-y divide-gray-100 dark:divide-slate-700">
                  {stats.topStorageUsers.map((u, i) => (
                    <div key={u.id} className="flex items-center gap-3 py-2.5">
                      <span className="text-xs font-bold text-gray-400 dark:text-slate-500 w-5">{i + 1}</span>
                      <div className="flex-1 min-w-0">
                        <p className="text-sm font-medium text-gray-900 dark:text-slate-100 truncate">{u.name}</p>
                        <p className="text-[10px] text-gray-400 dark:text-slate-500 truncate">{u.email}</p>
                      </div>
                      <span className="text-xs font-semibold text-gray-700 dark:text-slate-300">{formatFileSize(u.storageUsed)}</span>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        )}

        {/* â”€â”€ ì‚¬ìš©ì íƒ­ â”€â”€ */}
        {tab === "users" && (
          <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700">
            <div className="px-5 py-4 border-b border-gray-100 dark:border-slate-700 flex items-center justify-between">
              <p className="text-sm font-semibold text-gray-900 dark:text-slate-100">ì €ì¥ ì‚¬ìš©ëŸ‰ ìƒìœ„ ì‚¬ìš©ì</p>
              {s && <span className="text-xs text-gray-400 dark:text-slate-500">ì •ì§€: {s.bannedUsers}ëª…</span>}
            </div>
            <div className="divide-y divide-gray-100 dark:divide-slate-700">
              {(stats?.topStorageUsers ?? []).map((u) => (
                <div key={u.id} className="flex items-center gap-3 px-5 py-3">
                  <div className="w-9 h-9 rounded-full bg-gradient-to-br from-blue-400 to-purple-500 flex items-center justify-center text-white text-sm font-bold shrink-0">
                    {u.name[0]}
                  </div>
                  <div className="flex-1 min-w-0">
                    <p className="text-sm font-medium text-gray-900 dark:text-slate-100 truncate">{u.name}</p>
                    <p className="text-xs text-gray-400 dark:text-slate-500 truncate">{u.email} Â· {formatFileSize(u.storageUsed)}</p>
                  </div>
                  <div className="flex gap-2 shrink-0">
                    <button onClick={() => banUser(u.id, u.name)}
                      className="flex items-center gap-1 px-2.5 py-1.5 text-xs font-semibold text-red-600 bg-red-50 dark:bg-red-900/20 hover:bg-red-100 rounded-lg transition">
                      <Ban size={11} /> ì •ì§€
                    </button>
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}

        {/* â”€â”€ ê³µì§€ íƒ­ â”€â”€ */}
        {tab === "notices" && (
          <div className="space-y-4">
            <div className="flex justify-end">
              <button onClick={() => setShowNoticeForm(true)}
                className="flex items-center gap-1.5 px-4 py-2 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-xl transition">
                <Plus size={14} /> ê³µì§€ ë“±ë¡
              </button>
            </div>

            {/* ê³µì§€ ë“±ë¡ í¼ */}
            {showNoticeForm && (
              <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-5 space-y-4">
                <div className="flex items-center justify-between">
                  <h3 className="text-sm font-bold text-gray-900 dark:text-slate-100">ìƒˆ ê³µì§€ ë“±ë¡</h3>
                  <button onClick={() => setShowNoticeForm(false)} className="text-gray-400 hover:text-gray-600 dark:hover:text-slate-300"><X size={16} /></button>
                </div>
                <div className="flex gap-2">
                  {["INFO", "WARNING", "MAINTENANCE"].map((t) => (
                    <button key={t} onClick={() => setNoticeForm((f) => ({ ...f, type: t }))}
                      className={`px-3 py-1.5 text-xs font-semibold rounded-lg transition ${noticeForm.type === t ? "bg-blue-600 text-white" : "bg-gray-100 dark:bg-slate-700 text-gray-600 dark:text-slate-400"}`}>
                      {t === "INFO" ? "â„¹ï¸ ì•ˆë‚´" : t === "WARNING" ? "âš ï¸ ê²½ê³ " : "ğŸ”§ ì ê²€"}
                    </button>
                  ))}
                </div>
                <input type="text" value={noticeForm.title} onChange={(e) => setNoticeForm((f) => ({ ...f, title: e.target.value }))}
                  placeholder="ê³µì§€ ì œëª©" className="w-full px-4 py-2.5 text-sm border border-gray-200 dark:border-slate-600 rounded-xl bg-white dark:bg-slate-700 dark:text-slate-100 focus:outline-none focus:ring-2 focus:ring-blue-500" />
                <textarea value={noticeForm.content} onChange={(e) => setNoticeForm((f) => ({ ...f, content: e.target.value }))}
                  placeholder="ê³µì§€ ë‚´ìš©" rows={3}
                  className="w-full px-4 py-2.5 text-sm border border-gray-200 dark:border-slate-600 rounded-xl bg-white dark:bg-slate-700 dark:text-slate-100 focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none" />
                <div className="flex items-center gap-3">
                  <label className="text-xs text-gray-500 dark:text-slate-400">ì¢…ë£Œì¼:</label>
                  <input type="datetime-local" value={noticeForm.endsAt} onChange={(e) => setNoticeForm((f) => ({ ...f, endsAt: e.target.value }))}
                    className="text-xs border border-gray-200 dark:border-slate-600 rounded-lg px-3 py-1.5 bg-white dark:bg-slate-700 dark:text-slate-100 focus:outline-none" />
                </div>
                <div className="flex gap-2">
                  <button onClick={() => setShowNoticeForm(false)} className="flex-1 py-2.5 text-sm text-gray-600 dark:text-slate-400 bg-gray-100 dark:bg-slate-700 hover:bg-gray-200 rounded-xl transition">ì·¨ì†Œ</button>
                  <button onClick={saveNotice} disabled={savingNotice} className="flex-1 py-2.5 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-xl transition disabled:opacity-50">
                    {savingNotice ? "ë“±ë¡ ì¤‘..." : "ë“±ë¡"}
                  </button>
                </div>
              </div>
            )}

            {/* ê³µì§€ ëª©ë¡ */}
            {notices.length === 0 ? (
              <div className="flex flex-col items-center py-20 text-center">
                <Bell size={32} className="text-gray-300 dark:text-slate-600 mb-3" />
                <p className="text-gray-500 dark:text-slate-400 font-medium">ë“±ë¡ëœ ê³µì§€ê°€ ì—†ìŠµë‹ˆë‹¤</p>
              </div>
            ) : (
              <div className="space-y-2">
                {notices.map((n) => (
                  <div key={n.id} className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-4 flex items-start gap-3">
                    <div className="mt-0.5">{NOTICE_ICONS[n.type as keyof typeof NOTICE_ICONS] ?? NOTICE_ICONS.INFO}</div>
                    <div className="flex-1 min-w-0">
                      <p className="text-sm font-semibold text-gray-900 dark:text-slate-100">{n.title}</p>
                      <p className="text-xs text-gray-500 dark:text-slate-400 mt-0.5 line-clamp-2">{n.content}</p>
                      {n.endsAt && <p className="text-[10px] text-gray-400 dark:text-slate-500 mt-1">~{new Date(n.endsAt).toLocaleString("ko-KR")}</p>}
                    </div>
                    <button onClick={() => deleteNotice(n.id)} className="p-1.5 text-gray-400 hover:text-red-500 hover:bg-red-50 dark:hover:bg-red-900/20 rounded-lg transition">
                      <Trash2 size={13} />
                    </button>
                  </div>
                ))}
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/app/api/activity-logs/route.ts">
// src/app/api/activity-logs/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// GET /api/activity-logs?page=1&limit=30&action=FILE_UPLOAD
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const page   = Math.max(1, parseInt(searchParams.get("page")  ?? "1"));
    const limit  = Math.min(50, parseInt(searchParams.get("limit") ?? "30"));
    const action = searchParams.get("action") ?? undefined;
    const skip   = (page - 1) * limit;

    const where: any = { userId: session.user.id };
    if (action) where.action = action;

    const [logs, total] = await Promise.all([
      prisma.activityLog.findMany({
        where,
        orderBy: { createdAt: "desc" },
        skip,
        take: limit,
      }),
      prisma.activityLog.count({ where }),
    ]);

    return NextResponse.json({
      logs,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    });
  } catch (error) {
    console.error("GET /api/activity-logs error:", error);
    return NextResponse.json({ error: "ì„œë²„ ì˜¤ë¥˜" }, { status: 500 });
  }
}

// DELETE /api/activity-logs â€” ë‚´ ë¡œê·¸ ì „ì²´ ì‚­ì œ
export async function DELETE(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    await prisma.activityLog.deleteMany({ where: { userId: session.user.id } });
    return NextResponse.json({ message: "í™œë™ ë¡œê·¸ë¥¼ ëª¨ë‘ ì‚­ì œí–ˆìŠµë‹ˆë‹¤" });
  } catch (error) {
    console.error("DELETE /api/activity-logs error:", error);
    return NextResponse.json({ error: "ì„œë²„ ì˜¤ë¥˜" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/admin/notices/route.ts">
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// src/app/api/admin/notices/route.ts â€” ì‹œìŠ¤í…œ ê³µì§€ CRUD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// GET â€” í™œì„± ê³µì§€ (ëª¨ë“  ì‚¬ìš©ì ì ‘ê·¼ ê°€ëŠ¥)
export async function GET() {
  const notices = await prisma.systemNotice.findMany({
    where: {
      isActive: true,
      OR: [
        { endsAt: null },
        { endsAt: { gt: new Date() } },
      ],
    },
    orderBy: { createdAt: "desc" },
    take: 5,
  });
  return NextResponse.json({ notices });
}

// POST â€” ê³µì§€ ìƒì„± (ê´€ë¦¬ì ì „ìš©)
export async function POST(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user || session.user.role !== "ADMIN")
    return NextResponse.json({ error: "ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 403 });

  const { title, content, type = "INFO", startsAt, endsAt } = await request.json();
  if (!title?.trim() || !content?.trim())
    return NextResponse.json({ error: "ì œëª©ê³¼ ë‚´ìš©ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 400 });

  const notice = await prisma.systemNotice.create({
    data: {
      title: title.trim(),
      content: content.trim(),
      type,
      createdBy: session.user.id,
      startsAt: startsAt ? new Date(startsAt) : null,
      endsAt:   endsAt   ? new Date(endsAt)   : null,
    },
  });

  return NextResponse.json({ notice, message: "ê³µì§€ê°€ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤" });
}
</file>

<file path="src/app/api/admin/users/[id]/ban/route.ts">
// src/app/api/admin/users/[id]/ban/route.ts
// POST â€” ì‚¬ìš©ì ì •ì§€ / DELETE â€” ì •ì§€ í•´ì œ

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user || session.user.role !== "ADMIN")
    return NextResponse.json({ error: "ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 403 });

  if (params.id === session.user.id)
    return NextResponse.json({ error: "ìì‹ ì„ ì •ì§€í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 400 });

  const { reason } = await request.json();

  const user = await prisma.user.update({
    where: { id: params.id },
    data: { isBanned: true, banReason: reason ?? "ê´€ë¦¬ì ê²°ì •", bannedAt: new Date() },
    select: { id: true, name: true, email: true, isBanned: true },
  });

  return NextResponse.json({ user, message: `${user.name}ì´ ì •ì§€ë˜ì—ˆìŠµë‹ˆë‹¤` });
}

export async function DELETE(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user || session.user.role !== "ADMIN")
    return NextResponse.json({ error: "ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 403 });

  const user = await prisma.user.update({
    where: { id: params.id },
    data: { isBanned: false, banReason: null, bannedAt: null },
    select: { id: true, name: true, isBanned: true },
  });

  return NextResponse.json({ user, message: `${user.name}ì˜ ì •ì§€ê°€ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤` });
}
</file>

<file path="src/app/api/admin/users/[id]/route.ts">
// src/app/api/admin/users/[id]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

async function requireAdmin(selfId: string) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return null;
  const user = await prisma.user.findUnique({ where: { id: session.user.id } });
  if (!user || user.role !== "ADMIN") return null;
  return user;
}

// PATCH /api/admin/users/[id] â€” ì—­í•  ë³€ê²½
export async function PATCH(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
  const admin = await requireAdmin(session.user.id);
  if (!admin) return NextResponse.json({ error: "ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 403 });

  const { role } = await request.json();
  if (!["USER", "ADMIN"].includes(role)) {
    return NextResponse.json({ error: "ì˜¬ë°”ë¥´ì§€ ì•Šì€ ì—­í• ì…ë‹ˆë‹¤" }, { status: 400 });
  }

  const updated = await prisma.user.update({
    where: { id: params.id },
    data: { role },
    select: { id: true, name: true, role: true },
  });

  return NextResponse.json(updated);
}

// DELETE /api/admin/users/[id] â€” ê³„ì • ì‚­ì œ
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
  const admin = await requireAdmin(session.user.id);
  if (!admin) return NextResponse.json({ error: "ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 403 });

  // ìì‹  ì‚­ì œ ë°©ì§€
  if (params.id === session.user.id) {
    return NextResponse.json({ error: "ìì‹ ì˜ ê³„ì •ì€ ì‚­ì œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 400 });
  }

  await prisma.user.delete({ where: { id: params.id } });
  return NextResponse.json({ message: "ê³„ì •ì„ ì‚­ì œí–ˆìŠµë‹ˆë‹¤" });
}
</file>

<file path="src/app/api/admin/users/route.ts">
// src/app/api/admin/users/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

async function requireAdmin() {
  const session = await getServerSession(authOptions);
  if (!session?.user) return null;
  const user = await prisma.user.findUnique({ where: { id: session.user.id } });
  if (!user || user.role !== "ADMIN") return null;
  return user;
}

// GET /api/admin/users â€” ì „ì²´ ì‚¬ìš©ì ëª©ë¡
export async function GET(request: NextRequest) {
  const admin = await requireAdmin();
  if (!admin) {
    return NextResponse.json({ error: "ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 403 });
  }

  const users = await prisma.user.findMany({
    orderBy: { createdAt: "desc" },
    select: {
      id: true,
      name: true,
      email: true,
      role: true,
      emailVerified: true,
      isOnline: true,
      createdAt: true,
      _count: {
        select: { files: true, posts: true, comments: true },
      },
    },
  });

  return NextResponse.json(users);
}
</file>

<file path="src/app/api/auth/2fa/disable/route.ts">
// src/app/api/auth/2fa/disable/route.ts
// DELETE â†’ 2FA ë¹„í™œì„±í™” (í˜„ì¬ OTP ì½”ë“œ ë˜ëŠ” ë°±ì—… ì½”ë“œ í™•ì¸ í›„)

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import * as OTPAuth from "otpauth";

export async function DELETE(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const { code } = await request.json();

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { twoFactorSecret: true, twoFactorEnabled: true, twoFactorBackups: true },
    });

    if (!user?.twoFactorEnabled) {
      return NextResponse.json({ error: "2ë‹¨ê³„ ì¸ì¦ì´ í™œì„±í™”ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤" }, { status: 400 });
    }

    // TOTP ë˜ëŠ” ë°±ì—… ì½”ë“œ ê²€ì¦
    let valid = false;

    if (user.twoFactorSecret) {
      const totp = new OTPAuth.TOTP({
        algorithm: "SHA1", digits: 6, period: 30,
        secret: OTPAuth.Secret.fromBase32(user.twoFactorSecret),
      });
      valid = totp.validate({ token: code.replace(/\s/g, ""), window: 1 }) !== null;
    }

    // ë°±ì—… ì½”ë“œ í™•ì¸
    if (!valid && user.twoFactorBackups?.includes(code.toUpperCase())) {
      valid = true;
    }

    if (!valid) {
      return NextResponse.json({ error: "ì½”ë“œê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤" }, { status: 400 });
    }

    await prisma.user.update({
      where: { id: session.user.id },
      data: {
        twoFactorEnabled: false,
        twoFactorSecret: null,
        twoFactorBackups: [],
      },
    });

    return NextResponse.json({ message: "2ë‹¨ê³„ ì¸ì¦ì´ ë¹„í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤" });
  } catch (error) {
    console.error("DELETE /api/auth/2fa/disable error:", error);
    return NextResponse.json({ error: "ì„œë²„ ì˜¤ë¥˜" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/auth/2fa/setup/route.ts">
// src/app/api/auth/2fa/setup/route.ts
// POST â†’ ë¹„ë°€í‚¤ ìƒì„± + QRì½”ë“œ ë°˜í™˜ (ì•„ì§ í™œì„±í™” ì•ˆ ë¨)
// PATCH â†’ OTP ê²€ì¦ í›„ 2FA ìµœì¢… í™œì„±í™” + ë°±ì—… ì½”ë“œ ë°œê¸‰

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import * as OTPAuth from "otpauth";
import QRCode from "qrcode";
import crypto from "crypto";

// ë°±ì—… ì½”ë“œ 8ê°œ ìƒì„±
function generateBackupCodes(): string[] {
  return Array.from({ length: 8 }, () =>
    crypto.randomBytes(4).toString("hex").toUpperCase()
  );
}

// POST /api/auth/2fa/setup â€” ë¹„ë°€í‚¤ + QRì½”ë“œ ìƒì„±
export async function POST() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { email: true, twoFactorEnabled: true },
    });

    if (user?.twoFactorEnabled) {
      return NextResponse.json({ error: "ì´ë¯¸ 2ë‹¨ê³„ ì¸ì¦ì´ í™œì„±í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤" }, { status: 400 });
    }

    // TOTP ë¹„ë°€í‚¤ ìƒì„±
    const secret = new OTPAuth.Secret();
    const totp = new OTPAuth.TOTP({
      issuer: "ì´ìŒ (Eum)",
      label: user?.email ?? session.user.email ?? "user",
      algorithm: "SHA1",
      digits: 6,
      period: 30,
      secret,
    });

    const otpauthUrl = totp.toString();
    const qrCodeDataUrl = await QRCode.toDataURL(otpauthUrl);

    // ì„ì‹œë¡œ ë¹„ë°€í‚¤ ì €ì¥ (ì•„ì§ í™œì„±í™” ì•ˆ ë¨)
    await prisma.user.update({
      where: { id: session.user.id },
      data: { twoFactorSecret: secret.base32 },
    });

    return NextResponse.json({
      secret: secret.base32,
      qrCode: qrCodeDataUrl,
      manualKey: secret.base32.match(/.{1,4}/g)?.join(" "), // ê°€ë…ì„± ì¢‹ê²Œ 4ìë¦¬ì”© ë¶„ë¦¬
    });
  } catch (error) {
    console.error("POST /api/auth/2fa/setup error:", error);
    return NextResponse.json({ error: "ì„œë²„ ì˜¤ë¥˜" }, { status: 500 });
  }
}

// PATCH /api/auth/2fa/setup â€” OTP ê²€ì¦ í›„ í™œì„±í™”
export async function PATCH(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const { code } = await request.json();
    if (!code || typeof code !== "string") {
      return NextResponse.json({ error: "OTP ì½”ë“œê°€ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 400 });
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { twoFactorSecret: true, twoFactorEnabled: true },
    });

    if (!user?.twoFactorSecret) {
      return NextResponse.json({ error: "ë¨¼ì € QRì½”ë“œë¥¼ ìƒì„±í•´ì£¼ì„¸ìš”" }, { status: 400 });
    }

    const totp = new OTPAuth.TOTP({
      algorithm: "SHA1",
      digits: 6,
      period: 30,
      secret: OTPAuth.Secret.fromBase32(user.twoFactorSecret),
    });

    const delta = totp.validate({ token: code.replace(/\s/g, ""), window: 1 });
    if (delta === null) {
      return NextResponse.json({ error: "OTP ì½”ë“œê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤" }, { status: 400 });
    }

    const backupCodes = generateBackupCodes();

    await prisma.user.update({
      where: { id: session.user.id },
      data: {
        twoFactorEnabled: true,
        twoFactorBackups: backupCodes,
      },
    });

    return NextResponse.json({
      message: "2ë‹¨ê³„ ì¸ì¦ì´ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤",
      backupCodes,
    });
  } catch (error) {
    console.error("PATCH /api/auth/2fa/setup error:", error);
    return NextResponse.json({ error: "ì„œë²„ ì˜¤ë¥˜" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/auth/register/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { hash } from "bcryptjs"; // âœ… bcrypt â†’ bcryptjs
import { z } from "zod";
import { prisma } from "@/lib/db";
import { DEMO_MODE } from "@/lib/demo-mode";

const signupSchema = z.object({
  email: z.string().email("ìœ íš¨í•œ ì´ë©”ì¼ì„ ì…ë ¥í•˜ì„¸ìš”"),
  password: z.string().min(8, "ë¹„ë°€ë²ˆí˜¸ëŠ” ìµœì†Œ 8ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤"),
  name: z.string().min(2, "ì´ë¦„ì€ ìµœì†Œ 2ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤"),
  marketingConsent: z.boolean().optional(),
});

export async function POST(request: NextRequest) {
  try {
    if (DEMO_MODE) {
      return NextResponse.json(
        {
          error: "ë°ëª¨ ëª¨ë“œì—ì„œëŠ” íšŒì›ê°€ì…ì´ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.",
          demoAccount: "reviewer@appstore.com / Demo2024!Review",
        },
        { status: 403 }
      );
    }

    const body = await request.json();
    const validation = signupSchema.safeParse(body);

    if (!validation.success) {
      return NextResponse.json(
        { error: validation.error.errors[0].message },
        { status: 400 }
      );
    }

    const { email, password, name } = validation.data;

    const existingUser = await prisma.user.findUnique({ where: { email } });
    if (existingUser) {
      return NextResponse.json(
        { error: "ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ ì´ë©”ì¼ì…ë‹ˆë‹¤" },
        { status: 409 }
      );
    }

    const passwordHash = await hash(password, 12);

    const user = await prisma.user.create({
      data: {
        email,
        passwordHash,
        name,
        role: "USER",
        emailVerified: false,
      },
      select: {
        id: true,
        email: true,
        name: true,
        createdAt: true,
      },
    });

    return NextResponse.json(
      { message: "íšŒì›ê°€ì…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤", user },
      { status: 201 }
    );
  } catch (error) {
    console.error("Signup error:", error);
    return NextResponse.json({ error: "ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/auth/verify-email/confirm/route.ts">
// src/app/api/auth/verify-email/confirm/route.ts
// ì´ë©”ì¼ ì¸ì¦ ë§í¬ í´ë¦­ ì‹œ í˜¸ì¶œë˜ëŠ” ì—”ë“œí¬ì¸íŠ¸

import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const token = searchParams.get("token");

  if (!token) {
    return NextResponse.redirect(
      new URL("/profile?verified=error&reason=missing_token", request.url)
    );
  }

  try {
    const record = await prisma.emailVerificationToken.findUnique({
      where: { token },
      include: { user: true },
    });

    if (!record) {
      return NextResponse.redirect(
        new URL("/profile?verified=error&reason=invalid_token", request.url)
      );
    }

    if (new Date() > record.expiresAt) {
      await prisma.emailVerificationToken.delete({ where: { id: record.id } });
      return NextResponse.redirect(
        new URL("/profile?verified=error&reason=expired", request.url)
      );
    }

    // ì´ë©”ì¼ ì¸ì¦ ì™„ë£Œ
    await prisma.user.update({
      where: { id: record.userId },
      data: { emailVerified: true },
    });

    // í† í° ì‚­ì œ
    await prisma.emailVerificationToken.delete({ where: { id: record.id } });

    return NextResponse.redirect(
      new URL("/profile?verified=success", request.url)
    );
  } catch (error) {
    console.error("GET /api/auth/verify-email/confirm error:", error);
    return NextResponse.redirect(
      new URL("/profile?verified=error&reason=server_error", request.url)
    );
  }
}
</file>

<file path="src/app/api/auth/verify-email/route.ts">
// src/app/api/auth/verify-email/route.ts
// ì´ë©”ì¼ ì¸ì¦ ì¬ë°œì†¡ + í† í° ê²€ì¦ API

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import { sendEmail } from "@/lib/email";
import crypto from "crypto";

// POST /api/auth/verify-email â€” ì¸ì¦ ì´ë©”ì¼ ë°œì†¡ (ë¡œê·¸ì¸ ìƒíƒœ)
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
    });

    if (!user) {
      return NextResponse.json({ error: "ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 404 });
    }
    if (user.emailVerified) {
      return NextResponse.json({ error: "ì´ë¯¸ ì¸ì¦ëœ ì´ë©”ì¼ì…ë‹ˆë‹¤" }, { status: 400 });
    }

    // ê¸°ì¡´ í† í° ì‚­ì œ í›„ ìƒˆ í† í° ìƒì„±
    await prisma.emailVerificationToken.deleteMany({
      where: { userId: user.id },
    });

    const token = crypto.randomBytes(32).toString("hex");
    const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24ì‹œê°„

    await prisma.emailVerificationToken.create({
      data: { userId: user.id, token, expiresAt },
    });

    const verifyUrl = `${process.env.NEXTAUTH_URL}/api/auth/verify-email/confirm?token=${token}`;

    await sendEmail({
      to: user.email,
      subject: "[ì´ìŒ] ì´ë©”ì¼ ì¸ì¦ì„ ì™„ë£Œí•´ì£¼ì„¸ìš”",
      html: `
        <div style="font-family: sans-serif; max-width: 480px; margin: 0 auto; padding: 32px;">
          <h1 style="font-size: 24px; color: #1e293b; margin-bottom: 8px;">ì´ìŒ ì´ë©”ì¼ ì¸ì¦</h1>
          <p style="color: #475569; margin-bottom: 24px;">
            ì•ˆë…•í•˜ì„¸ìš”, <strong>${user.name}</strong>ë‹˜!<br/>
            ì•„ë˜ ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ì´ë©”ì¼ ì¸ì¦ì„ ì™„ë£Œí•´ì£¼ì„¸ìš”.
          </p>
          <a href="${verifyUrl}"
             style="display: inline-block; background: #2563eb; color: white;
                    padding: 12px 28px; border-radius: 8px; text-decoration: none;
                    font-weight: bold; font-size: 15px;">
            ì´ë©”ì¼ ì¸ì¦í•˜ê¸°
          </a>
          <p style="color: #94a3b8; font-size: 13px; margin-top: 24px;">
            ì´ ë§í¬ëŠ” 24ì‹œê°„ í›„ ë§Œë£Œë©ë‹ˆë‹¤.<br/>
            ë³¸ì¸ì´ ìš”ì²­í•˜ì§€ ì•Šì•˜ë‹¤ë©´ ì´ ì´ë©”ì¼ì„ ë¬´ì‹œí•´ì£¼ì„¸ìš”.
          </p>
        </div>
      `,
    });

    return NextResponse.json({ message: "ì¸ì¦ ì´ë©”ì¼ì„ ë°œì†¡í–ˆìŠµë‹ˆë‹¤" });
  } catch (error) {
    console.error("POST /api/auth/verify-email error:", error);
    return NextResponse.json({ error: "ì´ë©”ì¼ ë°œì†¡ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/errors/report/route.ts">
// src/app/api/errors/report/route.ts
// í´ë¼ì´ì–¸íŠ¸ ì—ëŸ¬ ìˆ˜ì‹  ë° ì„œë²„ ë¡œê¹…

import { NextRequest, NextResponse } from "next/server";
import logger from "@/lib/logger";
import { withRequestLog } from "@/lib/request-logger";

interface ErrorReport {
  message: string;
  stack?:  string;
  context?: object;
  url?:    string;
  ua?:     string;
  ts?:     string;
}

export const POST = withRequestLog(async (request: NextRequest) => {
  let body: ErrorReport;
  try {
    body = await request.json();
  } catch {
    return NextResponse.json({ ok: true }); // íŒŒì‹± ì‹¤íŒ¨í•´ë„ 204
  }

  logger.error("[Client Error]", {
    message: body.message?.slice(0, 500),
    stack:   body.stack?.slice(0, 2000),
    url:     body.url,
    ua:      body.ua?.slice(0, 200),
    ts:      body.ts,
    context: body.context,
    ip:      request.headers.get("x-forwarded-for") ?? "unknown",
  });

  return NextResponse.json({ ok: true });
});
</file>

<file path="src/app/api/files/[id]/encrypt/route.ts">
// src/app/api/files/[id]/encrypt/route.ts
// POST â€” íŒŒì¼ì— ë¹„ë°€ë²ˆí˜¸ ì„¤ì • (AES-256-GCM ì•”í˜¸í™”)
// DELETE â€” ë¹„ë°€ë²ˆí˜¸ í•´ì œ (ë³µí˜¸í™”)

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import crypto from "crypto";
import { readFile, writeFile } from "fs/promises";
import { existsSync } from "fs";

const ALGO = "aes-256-gcm";

function deriveKey(password: string, salt: Buffer): Buffer {
  return crypto.pbkdf2Sync(password, salt, 100_000, 32, "sha256");
}

// POST â€” ì•”í˜¸í™” (ì ê¸ˆ)
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

  const { password } = await request.json();
  if (!password || password.length < 4)
    return NextResponse.json({ error: "ë¹„ë°€ë²ˆí˜¸ëŠ” 4ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤" }, { status: 400 });

  const file = await prisma.file.findFirst({
    where: { id: params.id, userId: session.user.id },
  });
  if (!file) return NextResponse.json({ error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 404 });
  if (file.isEncrypted) return NextResponse.json({ error: "ì´ë¯¸ ì•”í˜¸í™”ëœ íŒŒì¼ì…ë‹ˆë‹¤" }, { status: 400 });
  if (!existsSync(file.filepath))
    return NextResponse.json({ error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 404 });

  // AES-256-GCM ì•”í˜¸í™”
  const salt = crypto.randomBytes(16);
  const iv   = crypto.randomBytes(12);
  const key  = deriveKey(password, salt);
  const cipher = crypto.createCipheriv(ALGO, key, iv);

  const plaintext = await readFile(file.filepath);
  const encrypted = Buffer.concat([cipher.update(plaintext), cipher.final()]);
  const authTag   = cipher.getAuthTag();

  // í˜•ì‹: [4B salt_len][salt][12B iv][16B authTag][encrypted]
  const out = Buffer.concat([
    Buffer.from([salt.length]),
    salt, iv, authTag, encrypted,
  ]);
  await writeFile(file.filepath, out);

  await prisma.file.update({
    where: { id: params.id },
    data: { isEncrypted: true },
  });

  return NextResponse.json({ message: "íŒŒì¼ì´ ì•”í˜¸í™”ë˜ì—ˆìŠµë‹ˆë‹¤" });
}

// DELETE â€” ë³µí˜¸í™” (ì ê¸ˆ í•´ì œ)
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

  const { password } = await request.json();
  if (!password) return NextResponse.json({ error: "ë¹„ë°€ë²ˆí˜¸ê°€ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 400 });

  const file = await prisma.file.findFirst({
    where: { id: params.id, userId: session.user.id },
  });
  if (!file) return NextResponse.json({ error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 404 });
  if (!file.isEncrypted) return NextResponse.json({ error: "ì•”í˜¸í™”ë˜ì§€ ì•Šì€ íŒŒì¼ì…ë‹ˆë‹¤" }, { status: 400 });

  try {
    const raw   = await readFile(file.filepath);
    const saltLen = raw[0];
    const salt  = raw.slice(1, 1 + saltLen);
    const iv    = raw.slice(1 + saltLen, 1 + saltLen + 12);
    const authTag = raw.slice(1 + saltLen + 12, 1 + saltLen + 12 + 16);
    const ciphertext = raw.slice(1 + saltLen + 12 + 16);

    const key = deriveKey(password, salt);
    const decipher = crypto.createDecipheriv(ALGO, key, iv);
    decipher.setAuthTag(authTag);

    const decrypted = Buffer.concat([decipher.update(ciphertext), decipher.final()]);
    await writeFile(file.filepath, decrypted);

    await prisma.file.update({
      where: { id: params.id },
      data: { isEncrypted: false },
    });

    return NextResponse.json({ message: "ì•”í˜¸í™”ê°€ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤" });
  } catch {
    return NextResponse.json({ error: "ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤" }, { status: 400 });
  }
}
</file>

<file path="src/app/api/files/[id]/favorite/route.ts">
// src/app/api/files/[id]/favorite/route.ts
// POST â€” ì¦ê²¨ì°¾ê¸° í† ê¸€ (starred)
// PATCH â€” í•€ ê³ ì • í† ê¸€ (pinned)

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// POST â€” ì¦ê²¨ì°¾ê¸° í† ê¸€
export async function POST(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

  const file = await prisma.file.findFirst({
    where: { id: params.id, userId: session.user.id },
    select: { id: true, isStarred: true },
  });
  if (!file) return NextResponse.json({ error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 404 });

  const updated = await prisma.file.update({
    where: { id: params.id },
    data: { isStarred: !file.isStarred },
    select: { id: true, isStarred: true },
  });

  return NextResponse.json({ starred: updated.isStarred });
}

// PATCH â€” í•€ ê³ ì • í† ê¸€
export async function PATCH(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

  const file = await prisma.file.findFirst({
    where: { id: params.id, userId: session.user.id },
    select: { id: true, isPinned: true },
  });
  if (!file) return NextResponse.json({ error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 404 });

  // í•€ ê³ ì •ì€ ìµœëŒ€ 10ê°œ
  if (!file.isPinned) {
    const pinnedCount = await prisma.file.count({
      where: { userId: session.user.id, isPinned: true },
    });
    if (pinnedCount >= 10)
      return NextResponse.json({ error: "í•€ ê³ ì •ì€ ìµœëŒ€ 10ê°œê¹Œì§€ ê°€ëŠ¥í•©ë‹ˆë‹¤" }, { status: 400 });
  }

  const updated = await prisma.file.update({
    where: { id: params.id },
    data: { isPinned: !file.isPinned },
    select: { id: true, isPinned: true },
  });

  return NextResponse.json({ pinned: updated.isPinned });
}

// â”€â”€ schema.prisma File ëª¨ë¸ì— ì¶”ê°€í•  í•„ë“œ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// isStarred  Boolean  @default(false) @map("is_starred")
// isPinned   Boolean  @default(false) @map("is_pinned")
// @@index([userId, isStarred])
// @@index([userId, isPinned])
</file>

<file path="src/app/api/files/[id]/public-link/route.ts">
// src/app/api/files/[id]/public-link/route.ts
// POST â†’ ê³µê°œ ê³µìœ  ë§í¬ ìƒì„± (í† í° ë°œê¸‰)
// DELETE â†’ ê³µê°œ ë§í¬ ë¹„í™œì„±í™”

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import crypto from "crypto";

// POST â€” ê³µê°œ ë§í¬ ìƒì„±
export async function POST(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

  const file = await prisma.file.findUnique({ where: { id: params.id } });
  if (!file) return NextResponse.json({ error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 404 });
  if (file.userId !== session.user.id)
    return NextResponse.json({ error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" }, { status: 403 });

  // ì´ë¯¸ í† í° ìˆìœ¼ë©´ ì¬ì‚¬ìš©, ì—†ìœ¼ë©´ ìƒˆë¡œ ë°œê¸‰
  const token = file.publicToken ?? crypto.randomBytes(24).toString("hex");

  await prisma.file.update({
    where: { id: params.id },
    data: { publicToken: token },
  });

  const link = `${process.env.NEXTAUTH_URL}/share/${token}`;
  return NextResponse.json({ token, link });
}

// DELETE â€” ê³µê°œ ë§í¬ ë¹„í™œì„±í™”
export async function DELETE(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

  const file = await prisma.file.findUnique({ where: { id: params.id } });
  if (!file || file.userId !== session.user.id)
    return NextResponse.json({ error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" }, { status: 403 });

  await prisma.file.update({ where: { id: params.id }, data: { publicToken: null } });
  return NextResponse.json({ message: "ê³µê°œ ë§í¬ê°€ ë¹„í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤" });
}
</file>

<file path="src/app/api/files/[id]/restore/route.ts">
// src/app/api/files/[id]/restore/route.ts
// POST â€” íœ´ì§€í†µì—ì„œ ë³µêµ¬

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function POST(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

  const file = await prisma.file.findUnique({ where: { id: params.id } });
  if (!file || file.userId !== session.user.id)
    return NextResponse.json({ error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" }, { status: 403 });
  if (!file.deletedAt)
    return NextResponse.json({ error: "íœ´ì§€í†µì— ìˆëŠ” íŒŒì¼ì´ ì•„ë‹™ë‹ˆë‹¤" }, { status: 400 });

  await prisma.file.update({
    where: { id: params.id },
    data: { deletedAt: null },
  });

  return NextResponse.json({ message: "íŒŒì¼ì´ ë³µêµ¬ë˜ì—ˆìŠµë‹ˆë‹¤" });
}
</file>

<file path="src/app/api/files/[id]/route.ts">
// src/app/api/files/[id]/route.ts (DELETE ë©”ì„œë“œ êµì²´)
// ê¸°ì¡´ DELETEë¥¼ soft deleteë¡œ ë³€ê²½

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import { unlink } from "fs/promises";
import { existsSync } from "fs";

// PATCH â€” íŒŒì¼ ë©”íƒ€ ìˆ˜ì • (ê¸°ì¡´ ìœ ì§€)
export async function GET(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

  const file = await prisma.file.findFirst({
    where: { id: params.id, userId: session.user.id },
    include: { fileTags: { include: { tag: true } } },
  });

  if (!file) return NextResponse.json({ error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 404 });
  return NextResponse.json(file);
}

// DELETE â€” íœ´ì§€í†µìœ¼ë¡œ ì´ë™ (soft delete)
export async function DELETE(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

    const file = await prisma.file.findUnique({ where: { id: params.id } });
    if (!file) return NextResponse.json({ error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 404 });
    if (file.userId !== session.user.id)
      return NextResponse.json({ error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" }, { status: 403 });

    // ì´ë¯¸ ì‚­ì œëœ íŒŒì¼ì´ë©´ ì˜êµ¬ ì‚­ì œ
    if (file.deletedAt) {
      if (existsSync(file.filepath)) await unlink(file.filepath);
      if (file.thumbnailUrl && existsSync(file.thumbnailUrl)) await unlink(file.thumbnailUrl);
      await prisma.file.delete({ where: { id: params.id } });
      return NextResponse.json({ message: "íŒŒì¼ì´ ì˜êµ¬ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤", permanent: true });
    }

    // ì²˜ìŒ ì‚­ì œ: íœ´ì§€í†µìœ¼ë¡œ ì´ë™
    await prisma.file.update({
      where: { id: params.id },
      data: { deletedAt: new Date() },
    });

    return NextResponse.json({ message: "íŒŒì¼ì´ íœ´ì§€í†µìœ¼ë¡œ ì´ë™ë˜ì—ˆìŠµë‹ˆë‹¤", permanent: false });
  } catch (error) {
    console.error("File delete error:", error);
    return NextResponse.json({ error: "íŒŒì¼ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/files/[id]/thumbnail/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import sharp from "sharp";
import { existsSync } from "fs";
import { writeFile, mkdir } from "fs/promises";
import { join } from "path";

const STORAGE_PATH = process.env.STORAGE_PATH || "./storage";

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const fileId = params.id;

    // íŒŒì¼ ì •ë³´ ì¡°íšŒ
    const file = await prisma.file.findUnique({
      where: { id: fileId },
    });

    if (!file) {
      return NextResponse.json(
        { error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ê¶Œí•œ í™•ì¸
    const isOwner = file.userId === session.user.id;

    // ê³µìœ  í™•ì¸
    let isShared = false;
    if (!isOwner) {
      const shareCheck = await prisma.sharedResource.findFirst({
        where: {
          resourceType: "FILE",
          resourceId: fileId,
          sharedWithId: session.user.id,
        },
      });
      isShared = !!shareCheck;
    }

    const canView = isOwner || isShared;

    if (!canView) {
      return NextResponse.json(
        { error: "ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // ì´ë¯¸ì§€ íŒŒì¼ë§Œ ì¸ë„¤ì¼ ìƒì„±
    if (!file.mimeType.startsWith("image/")) {
      return NextResponse.json(
        { error: "ì´ë¯¸ì§€ íŒŒì¼ë§Œ ì¸ë„¤ì¼ì„ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤" },
        { status: 400 }
      );
    }

    const thumbnailDir = join(STORAGE_PATH, "thumbnails");
    const thumbnailPath = join(thumbnailDir, `${fileId}.jpg`);

    // ì¸ë„¤ì¼ì´ ì´ë¯¸ ì¡´ì¬í•˜ë©´ ë°˜í™˜
    if (existsSync(thumbnailPath)) {
      const thumbnailBuffer = await sharp(thumbnailPath).toBuffer();
      return new NextResponse(new Uint8Array(thumbnailBuffer), {
        headers: {
          "Content-Type": "image/jpeg",
          "Cache-Control": "public, max-age=31536000",
        },
      });
    }

    // ì›ë³¸ íŒŒì¼ ì¡´ì¬ í™•ì¸
    if (!existsSync(file.filepath)) {
      return NextResponse.json(
        { error: "ì›ë³¸ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ì¸ë„¤ì¼ ë””ë ‰í† ë¦¬ ìƒì„±
    if (!existsSync(thumbnailDir)) {
      await mkdir(thumbnailDir, { recursive: true });
    }

    // ì¸ë„¤ì¼ ìƒì„±
    const thumbnailBuffer = await sharp(file.filepath)
      .resize(300, 300, {
        fit: "cover",
        position: "center",
      })
      .jpeg({ quality: 80 })
      .toBuffer();

    // ì¸ë„¤ì¼ ì €ì¥
    await writeFile(thumbnailPath, thumbnailBuffer);

    // DB ì—…ë°ì´íŠ¸
    await prisma.file.update({
      where: { id: fileId },
      data: {
        thumbnailUrl: `/api/files/${fileId}/thumbnail`,
      },
    });

    return new NextResponse(new Uint8Array(thumbnailBuffer), {
      headers: {
        "Content-Type": "image/jpeg",
        "Cache-Control": "public, max-age=31536000",
      },
    });

  } catch (error) {
    console.error("Thumbnail generation error:", error);
    return NextResponse.json(
      { error: "ì¸ë„¤ì¼ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/files/[id]/versions/[versionId]/rollback/route.ts">
// src/app/api/files/[id]/versions/[versionId]/rollback/route.ts
// POST â€” íŠ¹ì • ë²„ì „ìœ¼ë¡œ ë¡¤ë°± (í˜„ì¬ íŒŒì¼ì„ ë²„ì „ ìŠ¤ëƒ…ìƒ·ìœ¼ë¡œ êµì²´)

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import { copyFile } from "fs/promises";
import { existsSync } from "fs";

export async function POST(
  _req: NextRequest,
  { params }: { params: { id: string; versionId: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

  const [file, version] = await Promise.all([
    prisma.file.findFirst({ where: { id: params.id, userId: session.user.id } }),
    prisma.fileVersion.findFirst({ where: { id: params.versionId, fileId: params.id } }),
  ]);

  if (!file) return NextResponse.json({ error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 404 });
  if (!version) return NextResponse.json({ error: "ë²„ì „ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 404 });
  if (!existsSync(version.filepath))
    return NextResponse.json({ error: "ë²„ì „ ìŠ¤ëƒ…ìƒ· íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤" }, { status: 404 });

  // ë¡¤ë°± ì „ í˜„ì¬ ìƒíƒœë¥¼ ìƒˆ ë²„ì „ìœ¼ë¡œ ì €ì¥
  const latest = await prisma.fileVersion.findFirst({
    where: { fileId: params.id }, orderBy: { versionNum: "desc" },
  });
  const nextVer = (latest?.versionNum ?? 0) + 1;
  const snapshotPath = version.filepath.replace(`_v${version.versionNum}`, `_v${nextVer}_before_rollback`);

  if (existsSync(file.filepath)) {
    await copyFile(file.filepath, snapshotPath);
    await prisma.fileVersion.create({
      data: {
        fileId: params.id, versionNum: nextVer,
        filepath: snapshotPath, size: file.size,
        createdBy: session.user.id,
        comment: `ë¡¤ë°± ì „ ìë™ ì €ì¥ (v${version.versionNum}ìœ¼ë¡œ ë¡¤ë°±)`,
      },
    });
  }

  // ì‹¤ì œ ë¡¤ë°±: ë²„ì „ ìŠ¤ëƒ…ìƒ· â†’ í˜„ì¬ íŒŒì¼ ê²½ë¡œë¡œ ë³µì‚¬
  await copyFile(version.filepath, file.filepath);
  await prisma.file.update({
    where: { id: params.id },
    data: { size: version.size, updatedAt: new Date() },
  });

  return NextResponse.json({
    message: `ë²„ì „ ${version.versionNum}ìœ¼ë¡œ ë¡¤ë°±ë˜ì—ˆìŠµë‹ˆë‹¤`,
    versionNum: version.versionNum,
  });
}
</file>

<file path="src/app/api/files/[id]/versions/route.ts">
// src/app/api/files/[id]/versions/route.ts
// GET  â€” ë²„ì „ ëª©ë¡ ì¡°íšŒ
// POST â€” í˜„ì¬ íŒŒì¼ì„ ìƒˆ ë²„ì „ìœ¼ë¡œ ì €ì¥

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import { copyFile, mkdir } from "fs/promises";
import { existsSync } from "fs";
import path from "path";

const VERSIONS_DIR = process.env.STORAGE_PATH
  ? path.join(process.env.STORAGE_PATH, "versions")
  : "./storage/versions";

export async function GET(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

  const file = await prisma.file.findFirst({
    where: { id: params.id, userId: session.user.id },
  });
  if (!file) return NextResponse.json({ error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 404 });

  const versions = await prisma.fileVersion.findMany({
    where: { fileId: params.id },
    include: { user: { select: { name: true } } },
    orderBy: { versionNum: "desc" },
  });

  return NextResponse.json({ versions });
}

export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

  const file = await prisma.file.findFirst({
    where: { id: params.id, userId: session.user.id },
  });
  if (!file) return NextResponse.json({ error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 404 });

  const { comment } = await request.json().catch(() => ({}));

  // ìµœì‹  ë²„ì „ ë²ˆí˜¸
  const latest = await prisma.fileVersion.findFirst({
    where: { fileId: params.id },
    orderBy: { versionNum: "desc" },
  });
  const nextVer = (latest?.versionNum ?? 0) + 1;

  // ë²„ì „ ìŠ¤ëƒ…ìƒ· ì €ì¥
  if (!existsSync(VERSIONS_DIR)) await mkdir(VERSIONS_DIR, { recursive: true });
  const ext = path.extname(file.filepath);
  const snapshotPath = path.join(VERSIONS_DIR, `${params.id}_v${nextVer}${ext}`);

  if (!existsSync(file.filepath)) {
    return NextResponse.json({ error: "ì›ë³¸ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 404 });
  }
  await copyFile(file.filepath, snapshotPath);

  const version = await prisma.fileVersion.create({
    data: {
      fileId: params.id,
      versionNum: nextVer,
      filepath: snapshotPath,
      size: file.size,
      createdBy: session.user.id,
      comment: comment ?? null,
    },
  });

  // ìµœëŒ€ 10ê°œ ë²„ì „ ìœ ì§€ (ê°€ì¥ ì˜¤ë˜ëœ ê²ƒ ì‚­ì œ)
  const allVersions = await prisma.fileVersion.findMany({
    where: { fileId: params.id },
    orderBy: { versionNum: "asc" },
  });
  if (allVersions.length > 10) {
    const toDelete = allVersions.slice(0, allVersions.length - 10);
    for (const v of toDelete) {
      try {
        const { unlink } = await import("fs/promises");
        if (existsSync(v.filepath)) await unlink(v.filepath);
        await prisma.fileVersion.delete({ where: { id: v.id } });
      } catch {}
    }
  }

  return NextResponse.json({ version, message: `ë²„ì „ ${nextVer}ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤` });
}
</file>

<file path="src/app/api/files/route.ts">
// src/app/api/files/route.ts
// âš ï¸ ìˆ˜ì •ì‚¬í•­:
// 1. myFilesWhereì— deletedAt: null ì¶”ê°€ (íœ´ì§€í†µ íŒŒì¼ ë…¸ì¶œ ë°©ì§€)
// 2. pinned=true ì¿¼ë¦¬íŒŒë¼ë¯¸í„° ì§€ì› ì¶”ê°€ (PinnedFilesSectionìš©)

export const dynamic = "force-dynamic";

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const page      = parseInt(searchParams.get("page")      || "1");
    const limit     = parseInt(searchParams.get("limit")     || "20");
    const sortBy    = searchParams.get("sortBy")    || "createdAt";
    const sortOrder = (searchParams.get("sortOrder") || "desc") as "asc" | "desc";
    const folderId  = searchParams.get("folderId");
    const search    = searchParams.get("search")    || "";
    const fileType  = searchParams.get("fileType")  || "";
    const startDate = searchParams.get("startDate");
    const endDate   = searchParams.get("endDate");
    const filter    = searchParams.get("filter")    || "all";
    // âœ… ì¶”ê°€: ê³ ì • íŒŒì¼ ì „ìš© í•„í„°
    const pinnedOnly = searchParams.get("pinned") === "true";

    const skip = (page - 1) * limit;

    // âœ… ìˆ˜ì •: deletedAt: null ì¶”ê°€
    const myFilesWhere: any = {
      userId:    session.user.id,
      deletedAt: null,
    };

    // ê³ ì • íŒŒì¼ë§Œ ì¡°íšŒ
    if (pinnedOnly) {
      myFilesWhere.isPinned = true;
      const files = await prisma.file.findMany({
        where:   myFilesWhere,
        orderBy: { updatedAt: "desc" },
        take:    limit,
        select: {
          id: true, originalName: true, mimeType: true,
          size: true, thumbnailUrl: true, createdAt: true,
          isStarred: true, isPinned: true,
        },
      });
      return NextResponse.json({ files: files.map((f) => ({ ...f, size: f.size.toString() })) });
    }

    if (folderId === "null" || !folderId) {
      myFilesWhere.folderId = null;
    } else {
      myFilesWhere.folderId = folderId;
    }

    if (search) {
      myFilesWhere.OR = [
        { originalName: { contains: search, mode: "insensitive" } },
        { filename:     { contains: search, mode: "insensitive" } },
      ];
    }

    if (fileType === "image") {
      myFilesWhere.mimeType = { startsWith: "image/" };
    } else if (fileType === "video") {
      myFilesWhere.mimeType = { startsWith: "video/" };
    } else if (fileType === "document") {
      myFilesWhere.OR = [
        { mimeType: { contains: "pdf" } },
        { mimeType: { contains: "document" } },
        { mimeType: { contains: "word" } },
      ];
    }

    if (startDate || endDate) {
      myFilesWhere.createdAt = {};
      if (startDate) myFilesWhere.createdAt.gte = new Date(startDate);
      if (endDate)   myFilesWhere.createdAt.lte = new Date(endDate);
    }

    const sharedResources = await prisma.sharedResource.findMany({
      where: { resourceType: "FILE", sharedWithId: session.user.id },
    });
    const sharedFileIds = sharedResources.map((sr) => sr.resourceId);

    const sharedFilesData = sharedFileIds.length > 0
      ? await prisma.file.findMany({
          where:   { id: { in: sharedFileIds }, deletedAt: null },
          include: { user: { select: { id: true, name: true, email: true } }, fileTags: { include: { tag: true } } },
        })
      : [];

    const sharedFilesWithMeta = sharedFilesData.map((file) => {
      const shareInfo = sharedResources.find((sr) => sr.resourceId === file.id);
      return {
        ...file, size: file.size.toString(),
        isShared: true, isOwner: false,
        sharedBy: file.user?.name, sharedByEmail: file.user?.email,
        sharedAt: shareInfo?.createdAt, permission: shareInfo?.permission,
      };
    });

    let myFiles:      any[] = [];
    let totalMyFiles  = 0;

    if (filter === "all" || filter === "mine") {
      [myFiles, totalMyFiles] = await Promise.all([
        prisma.file.findMany({
          where:   myFilesWhere,
          orderBy: { [sortBy]: sortOrder },
          skip:    filter === "mine" ? skip : undefined,
          take:    filter === "mine" ? limit : undefined,
          include: { fileTags: { include: { tag: true } } },
        }),
        prisma.file.count({ where: myFilesWhere }),
      ]);
    }

    const myFilesWithMeta = myFiles.map((file) => ({
      ...file, size: file.size.toString(), isShared: false, isOwner: true,
    }));

    let resultFiles: any[] = [];
    let finalTotal = 0;

    if (filter === "all") {
      const combined = [...myFilesWithMeta, ...sharedFilesWithMeta];
      combined.sort((a, b) => {
        const aVal = (a as any)[sortBy], bVal = (b as any)[sortBy];
        return sortOrder === "desc" ? (aVal > bVal ? -1 : 1) : (aVal > bVal ? 1 : -1);
      });
      finalTotal  = combined.length;
      resultFiles = combined.slice(skip, skip + limit);
    } else if (filter === "mine") {
      resultFiles = myFilesWithMeta;
      finalTotal  = totalMyFiles;
    } else {
      sharedFilesWithMeta.sort((a, b) => {
        const aVal = (a as any)[sortBy], bVal = (b as any)[sortBy];
        return sortOrder === "desc" ? (aVal > bVal ? -1 : 1) : (aVal > bVal ? 1 : -1);
      });
      finalTotal  = sharedFilesWithMeta.length;
      resultFiles = sharedFilesWithMeta.slice(skip, skip + limit);
    }

    return NextResponse.json({
      files: resultFiles,
      pagination: { total: finalTotal, page, limit, totalPages: Math.ceil(finalTotal / limit) },
      stats: { myFiles: totalMyFiles, sharedFiles: sharedFilesWithMeta.length },
    });

  } catch (error) {
    console.error("Files fetch error:", error);
    return NextResponse.json({ error: "íŒŒì¼ ëª©ë¡ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/files/shared/route.ts">
// src/app/api/files/shared/route.ts
// âš ï¸ ìˆ˜ì •: SharedResource ëª¨ë¸ì— file ì§ì ‘ ê´€ê³„ ì—†ìŒ
//    resourceIdë¡œ ë³„ë„ File ì¡°íšŒë¡œ ë³€ê²½

export const dynamic = "force-dynamic";

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    // 1. ê³µìœ ë°›ì€ ë¦¬ì†ŒìŠ¤ ì¡°íšŒ (FILE íƒ€ì…ë§Œ)
    const sharedResources = await prisma.sharedResource.findMany({
      where: {
        resourceType: "FILE",
        sharedWithId: session.user.id,
      },
      include: {
        owner: { select: { name: true, email: true } },
      },
      orderBy: { createdAt: "desc" },
    });

    if (sharedResources.length === 0) {
      return NextResponse.json({ files: [] });
    }

    // 2. resourceIdë¡œ íŒŒì¼ ì •ë³´ ë³„ë„ ì¡°íšŒ
    const fileIds = sharedResources.map((sr) => sr.resourceId);
    const files = await prisma.file.findMany({
      where:  { id: { in: fileIds }, deletedAt: null },
      select: {
        id: true, filename: true, originalName: true,
        size: true, mimeType: true, thumbnailUrl: true, createdAt: true,
        user: { select: { name: true, email: true } },
      },
    });

    const fileMap = Object.fromEntries(files.map((f) => [f.id, f]));

    // 3. ì¡°í•©
    const result = sharedResources
      .map((share) => {
        const file = fileMap[share.resourceId];
        if (!file) return null;
        return {
          id:            file.id,
          filename:      file.filename,
          originalName:  file.originalName,
          size:          file.size.toString(),
          mimeType:      file.mimeType,
          thumbnailUrl:  file.thumbnailUrl,
          createdAt:     file.createdAt,
          sharedBy:      share.owner.name,
          sharedByEmail: share.owner.email,
          permission:    share.permission,
          sharedAt:      share.createdAt,
        };
      })
      .filter(Boolean);

    return NextResponse.json({ files: result });

  } catch (error) {
    console.error("Shared files fetch error:", error);
    return NextResponse.json(
      { error: "ê³µìœ  íŒŒì¼ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/files/trash/route.ts">
// src/app/api/files/trash/route.ts
// GET  â€” íœ´ì§€í†µ íŒŒì¼ ëª©ë¡
// DELETE â€” íœ´ì§€í†µ ë¹„ìš°ê¸° (ì˜êµ¬ ì‚­ì œ)

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import { unlink } from "fs/promises";
import { existsSync } from "fs";

export async function GET() {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

  const files = await prisma.file.findMany({
    where: { userId: session.user.id, deletedAt: { not: null } },
    orderBy: { deletedAt: "desc" },
    select: {
      id: true, originalName: true, mimeType: true,
      size: true, thumbnailUrl: true, deletedAt: true, createdAt: true,
    },
  });

  return NextResponse.json({ files });
}

export async function DELETE() {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

  const files = await prisma.file.findMany({
    where: { userId: session.user.id, deletedAt: { not: null } },
    select: { id: true, filepath: true, thumbnailUrl: true },
  });

  // ì‹¤ì œ íŒŒì¼ ì‚­ì œ
  await Promise.all(
    files.map(async (f) => {
      try {
        if (existsSync(f.filepath)) await unlink(f.filepath);
        if (f.thumbnailUrl && existsSync(f.thumbnailUrl)) await unlink(f.thumbnailUrl);
      } catch {}
    })
  );

  // DB ì˜êµ¬ ì‚­ì œ
  await prisma.file.deleteMany({
    where: { userId: session.user.id, deletedAt: { not: null } },
  });

  return NextResponse.json({ message: `${files.length}ê°œ íŒŒì¼ì´ ì˜êµ¬ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤`, count: files.length });
}
</file>

<file path="src/app/api/files/upload/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import { writeFile, mkdir } from "fs/promises";
import { existsSync } from "fs";
import { join } from "path";
import crypto from "crypto";
import sharp from "sharp";

const STORAGE_PATH = process.env.STORAGE_PATH || "./storage";
const MAX_FILE_SIZE = parseInt(process.env.NEXT_PUBLIC_MAX_FILE_SIZE || "52428800"); // 50MB

export async function POST(request: NextRequest) {
  try {
    // 1. ì„¸ì…˜ í™•ì¸
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const formData = await request.formData();
    const file = formData.get("file") as File;
    const folderId = formData.get("folderId") as string | null;

    // 2. íŒŒì¼ ìœ íš¨ì„± ê²€ì‚¬
    if (!file) {
      return NextResponse.json({ error: "íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”" }, { status: 400 });
    }

    if (file.size > MAX_FILE_SIZE) {
      return NextResponse.json(
        { error: `íŒŒì¼ í¬ê¸°ëŠ” ${MAX_FILE_SIZE / (1024 * 1024)}MBë¥¼ ì´ˆê³¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤` },
        { status: 400 }
      );
    }

    // 3. íŒŒì¼ í•´ì‹œ ìƒì„± (ì¤‘ë³µ ì²´í¬ìš©)
    const bytes = await file.arrayBuffer();
    const buffer = Buffer.from(bytes);
    const fileHash = crypto.createHash("sha256").update(buffer).digest("hex");

    /**
     * 4. ì‹œìŠ¤í…œ ì „ì²´ ì¤‘ë³µ í™•ì¸ (Hash ê¸°ë°˜)
     * DBì˜ hash í•„ë“œì— @unique ì œì•½ì¡°ê±´ì´ ìˆìœ¼ë¯€ë¡œ, 
     * ë‹¤ë¥¸ ìœ ì €ê°€ ì˜¬ë¦° íŒŒì¼ì´ë¼ë„ í•´ì‹œê°€ ê°™ìœ¼ë©´ create ì‹œ ì—ëŸ¬ê°€ ë°œìƒí•©ë‹ˆë‹¤.
     */
    const existingFile = await prisma.file.findFirst({
      where: { hash: fileHash },
    });

    if (existingFile) {
      const isMine = existingFile.userId === session.user.id;
      return NextResponse.json(
        { 
          error: isMine 
            ? "ì´ë¯¸ ë‚´ ë³´ê´€í•¨ì— ë™ì¼í•œ íŒŒì¼ì´ ì¡´ì¬í•©ë‹ˆë‹¤." 
            : "ì´ë¯¸ ì‹œìŠ¤í…œì— ë“±ë¡ëœ ë™ì¼í•œ ë‚´ìš©ì˜ íŒŒì¼ì…ë‹ˆë‹¤.",
          existingFile: { id: existingFile.id, originalName: existingFile.originalName } 
        },
        { status: 409 } // Conflict
      );
    }

    // 5. ê³ ìœ  íŒŒì¼ëª… ë° ê²½ë¡œ ì„¤ì •
    const fileExtension = file.name.split(".").pop() || "bin";
    const uniqueFilename = `${crypto.randomUUID()}.${fileExtension}`;

    const uploadDir = join(STORAGE_PATH, "files");
    const thumbnailDir = join(STORAGE_PATH, "thumbnails");
    
    if (!existsSync(uploadDir)) await mkdir(uploadDir, { recursive: true });
    if (!existsSync(thumbnailDir)) await mkdir(thumbnailDir, { recursive: true });

    // 6. ë¬¼ë¦¬ íŒŒì¼ ì €ì¥
    const filepath = join(uploadDir, uniqueFilename);
    await writeFile(filepath, buffer);

    // 7. ì¸ë„¤ì¼ ìƒì„± (ì´ë¯¸ì§€ì¸ ê²½ìš°ë§Œ)
    let thumbnailUrl: string | null = null;
    if (file.type.startsWith("image/")) {
      try {
        const thumbnailFilename = `thumb_${uniqueFilename.replace(/\.\w+$/, ".jpg")}`;
        const thumbnailPath = join(thumbnailDir, thumbnailFilename);
        
        await sharp(buffer)
          .resize(300, 300, { fit: "cover", position: "center" })
          .jpeg({ quality: 80 })
          .toFile(thumbnailPath);
        
        thumbnailUrl = `/api/files/thumbnail/${thumbnailFilename}`;
      } catch (err) {
        console.error("Thumbnail generation failed:", err);
        // ì¸ë„¤ì¼ ì‹¤íŒ¨ëŠ” íŒŒì¼ ì—…ë¡œë“œ ìì²´ë¥¼ ì¤‘ë‹¨ì‹œí‚¤ì§€ ì•ŠìŒ
      }
    }

    /**
     * 8. DB ì €ì¥ ë° ìµœì¢… ì¤‘ë³µ ì—ëŸ¬ í•¸ë“¤ë§
     * findFirst ì´í›„ create ì§ì „ì— ë‹¤ë¥¸ ìš”ì²­ì´ ë“¤ì–´ì˜¬ ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ 
     * Prismaì˜ P2002(Unique ì œì•½ ìœ„ë°˜) ì—ëŸ¬ë¥¼ Catchí•©ë‹ˆë‹¤.
     */
    try {
      const savedFile = await prisma.file.create({
        data: {
          filename: uniqueFilename,
          originalName: file.name,
          filepath: filepath,
          size: BigInt(file.size),
          mimeType: file.type,
          hash: fileHash,
          thumbnailUrl,
          userId: session.user.id,
          folderId: folderId || null,
        },
      });

      return NextResponse.json(
        {
          message: "íŒŒì¼ì´ ì—…ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤",
          file: {
            id: savedFile.id,
            filename: savedFile.filename,
            originalName: savedFile.originalName,
            size: savedFile.size.toString(),
            mimeType: savedFile.mimeType,
            thumbnailUrl: savedFile.thumbnailUrl,
            createdAt: savedFile.createdAt,
          },
        },
        { status: 201 }
      );
    } catch (dbError: any) {
      if (dbError.code === "P2002") {
        return NextResponse.json(
          { error: "ì´ë¯¸ ì¡´ì¬í•˜ëŠ” íŒŒì¼ì…ë‹ˆë‹¤(ì¤‘ë³µ ë°ì´í„°)." },
          { status: 409 }
        );
      }
      throw dbError; // ë‹¤ë¥¸ DB ì˜¤ë¥˜ëŠ” ì™¸ë¶€ catch ë¸”ë¡ì—ì„œ ì²˜ë¦¬
    }

  } catch (error) {
    console.error("File upload error:", error);
    return NextResponse.json(
      { error: "íŒŒì¼ ì—…ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/folders/[id]/download/route.ts">
// src/app/api/folders/[id]/download/route.ts
// GET â€” í´ë” ì „ì²´ë¥¼ ZIPìœ¼ë¡œ ì••ì¶•í•´ ë‹¤ìš´ë¡œë“œ

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import { existsSync, createReadStream } from "fs";
import path from "path";
import archiver from "archiver";
import { PassThrough } from "stream";

// npm install archiver && npm install --save-dev @types/archiver

async function getFolderFiles(
  folderId: string,
  userId: string,
  prefix = ""
): Promise<{ filepath: string; archiveName: string }[]> {
  const [files, subFolders] = await Promise.all([
    prisma.file.findMany({
      where: { folderId, userId, deletedAt: null },
      select: { filepath: true, originalName: true },
    }),
    prisma.folder.findMany({
      where: { parentId: folderId, userId },
      select: { id: true, name: true },
    }),
  ]);

  const result: { filepath: string; archiveName: string }[] = [];

  for (const f of files) {
    if (existsSync(f.filepath)) {
      result.push({ filepath: f.filepath, archiveName: path.join(prefix, f.originalName) });
    }
  }

  for (const sf of subFolders) {
    const subFiles = await getFolderFiles(sf.id, userId, path.join(prefix, sf.name));
    result.push(...subFiles);
  }

  return result;
}

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

  const folder = await prisma.folder.findFirst({
    where: { id: params.id, userId: session.user.id },
  });
  if (!folder) return NextResponse.json({ error: "í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 404 });

  const files = await getFolderFiles(params.id, session.user.id, "");

  if (files.length === 0) {
    return NextResponse.json({ error: "í´ë”ì— íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤" }, { status: 400 });
  }

  // archiverë¡œ ZIP ìŠ¤íŠ¸ë¦¼ ìƒì„±
  const passThrough = new PassThrough();
  const archive = archiver("zip", { zlib: { level: 6 } });

  archive.on("error", (err) => { passThrough.destroy(err); });
  archive.pipe(passThrough);

  for (const { filepath, archiveName } of files) {
    archive.append(createReadStream(filepath), { name: archiveName });
  }
  archive.finalize();

  const readable = new ReadableStream({
    start(controller) {
      passThrough.on("data", (chunk) => controller.enqueue(chunk));
      passThrough.on("end", () => controller.close());
      passThrough.on("error", (err) => controller.error(err));
    },
  });

  const zipName = `${folder.name}.zip`;
  return new NextResponse(readable, {
    headers: {
      "Content-Type": "application/zip",
      "Content-Disposition": `attachment; filename*=UTF-8''${encodeURIComponent(zipName)}`,
    },
  });
}
</file>

<file path="src/app/api/folders/[id]/move/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// í´ë” ì´ë™
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json(
        { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
        { status: 401 }
      );
    }

    const folderId = params.id;
    const body = await request.json();
    const { parentId } = body; // nullì´ë©´ ë£¨íŠ¸ë¡œ ì´ë™

    // í´ë” í™•ì¸
    const folder = await prisma.folder.findUnique({
      where: { id: folderId },
    });

    if (!folder) {
      return NextResponse.json(
        { error: "í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    if (folder.userId !== session.user.id) {
      return NextResponse.json(
        { error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    // ìê¸° ìì‹ ìœ¼ë¡œ ì´ë™ ë°©ì§€
    if (parentId === folderId) {
      return NextResponse.json(
        { error: "í´ë”ë¥¼ ìê¸° ìì‹ ìœ¼ë¡œ ì´ë™í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 400 }
      );
    }

    // ëŒ€ìƒ í´ë” í™•ì¸ (ìˆëŠ” ê²½ìš°)
    if (parentId) {
      const targetFolder = await prisma.folder.findUnique({
        where: { id: parentId },
      });

      if (!targetFolder) {
        return NextResponse.json(
          { error: "ëŒ€ìƒ í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
          { status: 404 }
        );
      }

      if (targetFolder.userId !== session.user.id) {
        return NextResponse.json(
          { error: "ëŒ€ìƒ í´ë”ì— ëŒ€í•œ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" },
          { status: 403 }
        );
      }

      // ìˆœí™˜ ì°¸ì¡° ë°©ì§€ (ìì‹ í´ë”ë¡œ ì´ë™ ë¶ˆê°€)
      const isDescendant = await checkIsDescendant(parentId, folderId);
      if (isDescendant) {
        return NextResponse.json(
          { error: "í•˜ìœ„ í´ë”ë¡œëŠ” ì´ë™í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
          { status: 400 }
        );
      }
    }

    // ê°™ì€ ìœ„ì¹˜ì— ê°™ì€ ì´ë¦„ì˜ í´ë”ê°€ ìˆëŠ”ì§€ í™•ì¸
    const existingFolder = await prisma.folder.findFirst({
      where: {
        userId: session.user.id,
        parentId: parentId || null,
        name: folder.name,
        id: { not: folderId },
      },
    });

    if (existingFolder) {
      return NextResponse.json(
        { error: "ëŒ€ìƒ ìœ„ì¹˜ì— ê°™ì€ ì´ë¦„ì˜ í´ë”ê°€ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤" },
        { status: 409 }
      );
    }

    // í´ë” ì´ë™
    const updatedFolder = await prisma.folder.update({
      where: { id: folderId },
      data: {
        parentId: parentId || null,
      },
      include: {
        _count: {
          select: {
            children: true,
            files: true,
          },
        },
      },
    });

    return NextResponse.json({
      message: "í´ë”ê°€ ì´ë™ë˜ì—ˆìŠµë‹ˆë‹¤",
      folder: updatedFolder,
    });

  } catch (error) {
    console.error("Folder move error:", error);
    return NextResponse.json(
      { error: "í´ë” ì´ë™ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// ìˆœí™˜ ì°¸ì¡° í™•ì¸ í—¬í¼ í•¨ìˆ˜
async function checkIsDescendant(
  targetId: string,
  ancestorId: string
): Promise<boolean> {
  let currentId: string | null = targetId;

  while (currentId) {
    if (currentId === ancestorId) {
      return true;
    }

    const folder: { parentId: string | null } | null = await prisma.folder.findUnique({
      where: { id: currentId },
      select: { parentId: true },
    });

    currentId = folder?.parentId ?? null;
  }

  return false;
}
</file>

<file path="src/app/api/health/route.ts">
// src/app/api/health/route.ts
// Docker HEALTHCHECK + ë¡œë“œë°¸ëŸ°ì„œ ìƒíƒœ í™•ì¸ìš©

import { NextResponse } from "next/server";
import { prisma } from "@/lib/db";

export const dynamic = "force-dynamic";

export async function GET() {
  const start = Date.now();

  // DB ì—°ê²° í™•ì¸
  let dbOk = false;
  try {
    await prisma.$queryRaw`SELECT 1`;
    dbOk = true;
  } catch {}

  const latencyMs = Date.now() - start;
  const status    = dbOk ? 200 : 503;

  return NextResponse.json(
    {
      status:    dbOk ? "ok" : "degraded",
      timestamp: new Date().toISOString(),
      uptime:    process.uptime(),
      latencyMs,
      checks: {
        database: dbOk ? "ok" : "error",
        memory: {
          heapUsed:  Math.round(process.memoryUsage().heapUsed / 1024 / 1024),
          heapTotal: Math.round(process.memoryUsage().heapTotal / 1024 / 1024),
          unit: "MB",
        },
      },
    },
    { status }
  );
}
</file>

<file path="src/app/api/link-preview/route.ts">
// src/app/api/link-preview/route.ts
// GET /api/link-preview?url=https://...
// Open Graph ë©”íƒ€ë°ì´í„° ì¶”ì¶œ

import { NextRequest, NextResponse } from "next/server";
import { withCache, TTL } from "@/lib/cache";

interface OGData {
  title:       string | null;
  description: string | null;
  image:       string | null;
  siteName:    string | null;
  url:         string;
  favicon:     string | null;
}

function extractMeta(html: string, property: string): string | null {
  // og: íƒœê·¸
  const ogMatch = html.match(
    new RegExp(`<meta[^>]+property=["']${property}["'][^>]+content=["']([^"']+)["']`, "i")
  ) ?? html.match(
    new RegExp(`<meta[^>]+content=["']([^"']+)["'][^>]+property=["']${property}["']`, "i")
  );
  if (ogMatch) return ogMatch[1];
  return null;
}

function extractMetaName(html: string, name: string): string | null {
  return html.match(
    new RegExp(`<meta[^>]+name=["']${name}["'][^>]+content=["']([^"']+)["']`, "i")
  )?.[1] ?? null;
}

function extractTitle(html: string): string | null {
  return html.match(/<title[^>]*>([^<]+)<\/title>/i)?.[1]?.trim() ?? null;
}

export async function GET(request: NextRequest) {
  const url = new URL(request.url).searchParams.get("url");
  if (!url) return NextResponse.json({ error: "url íŒŒë¼ë¯¸í„°ê°€ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 400 });

  // URL ìœ íš¨ì„± ê²€ì‚¬
  let parsed: URL;
  try {
    parsed = new URL(url);
    if (!["http:", "https:"].includes(parsed.protocol))
      return NextResponse.json({ error: "HTTP/HTTPS URLë§Œ ì§€ì›í•©ë‹ˆë‹¤" }, { status: 400 });
  } catch {
    return NextResponse.json({ error: "ìœ íš¨í•˜ì§€ ì•Šì€ URLì…ë‹ˆë‹¤" }, { status: 400 });
  }

  const cacheKey = `og:${url}`;
  const cached = withCache<OGData | null>(
    cacheKey,
    async () => {
      try {
        const res = await fetch(url, {
          headers: { "User-Agent": "EumBot/1.0 (+https://eum.app)" },
          signal: AbortSignal.timeout(5000),
        });
        if (!res.ok) return null;

        const html = await res.text();
        const origin = parsed.origin;

        const og: OGData = {
          title:       extractMeta(html, "og:title")       ?? extractTitle(html),
          description: extractMeta(html, "og:description") ?? extractMetaName(html, "description"),
          image:       extractMeta(html, "og:image"),
          siteName:    extractMeta(html, "og:site_name")   ?? parsed.hostname,
          url,
          favicon:     `${origin}/favicon.ico`,
        };

        // ìƒëŒ€ URL â†’ ì ˆëŒ€ URL ë³€í™˜
        if (og.image && !og.image.startsWith("http")) {
          og.image = og.image.startsWith("/")
            ? `${origin}${og.image}`
            : `${origin}/${og.image}`;
        }

        return og;
      } catch {
        return null;
      }
    },
    TTL.LONG  // 1ì‹œê°„ ìºì‹œ
  );

  const data = await cached;
  if (!data) return NextResponse.json({ error: "ë¯¸ë¦¬ë³´ê¸°ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 422 });

  return NextResponse.json(data, {
    headers: { "Cache-Control": "public, max-age=3600" },
  });
}
</file>

<file path="src/app/api/notifications/[id]/route.ts">
// src/app/api/notifications/[id]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// PATCH /api/notifications/[id] â€” ë‹¨ê±´ ì½ìŒ ì²˜ë¦¬
export async function PATCH(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const notification = await prisma.notification.findFirst({
      where: { id: params.id, userId: session.user.id },
    });
    if (!notification) {
      return NextResponse.json({ error: "ì•Œë¦¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 404 });
    }

    const updated = await prisma.notification.update({
      where: { id: params.id },
      data: { isRead: true },
    });

    return NextResponse.json(updated);
  } catch (error) {
    console.error("PATCH /api/notifications/[id] error:", error);
    return NextResponse.json({ error: "ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" }, { status: 500 });
  }
}

// DELETE /api/notifications/[id] â€” ë‹¨ê±´ ì‚­ì œ
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const notification = await prisma.notification.findFirst({
      where: { id: params.id, userId: session.user.id },
    });
    if (!notification) {
      return NextResponse.json({ error: "ì•Œë¦¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 404 });
    }

    await prisma.notification.delete({ where: { id: params.id } });

    return NextResponse.json({ message: "ì•Œë¦¼ì„ ì‚­ì œí–ˆìŠµë‹ˆë‹¤" });
  } catch (error) {
    console.error("DELETE /api/notifications/[id] error:", error);
    return NextResponse.json({ error: "ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/notifications/route.ts">
// src/app/api/notifications/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// GET /api/notifications â€” ë‚´ ì•Œë¦¼ ëª©ë¡ (ìµœì‹ ìˆœ, ìµœëŒ€ 50ê°œ)
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const unreadOnly = searchParams.get("unread") === "true";

    const notifications = await prisma.notification.findMany({
      where: {
        userId: session.user.id,
        ...(unreadOnly ? { isRead: false } : {}),
      },
      orderBy: { createdAt: "desc" },
      take: 50,
    });

    const unreadCount = await prisma.notification.count({
      where: { userId: session.user.id, isRead: false },
    });

    return NextResponse.json({ notifications, unreadCount });
  } catch (error) {
    console.error("GET /api/notifications error:", error);
    return NextResponse.json({ error: "ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" }, { status: 500 });
  }
}

// PATCH /api/notifications â€” ì „ì²´ ì½ìŒ ì²˜ë¦¬
export async function PATCH(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    await prisma.notification.updateMany({
      where: { userId: session.user.id, isRead: false },
      data: { isRead: true },
    });

    return NextResponse.json({ message: "ëª¨ë“  ì•Œë¦¼ì„ ì½ìŒ ì²˜ë¦¬í–ˆìŠµë‹ˆë‹¤" });
  } catch (error) {
    console.error("PATCH /api/notifications error:", error);
    return NextResponse.json({ error: "ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" }, { status: 500 });
  }
}

// DELETE /api/notifications â€” ì „ì²´ ì‚­ì œ
export async function DELETE(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    await prisma.notification.deleteMany({
      where: { userId: session.user.id },
    });

    return NextResponse.json({ message: "ëª¨ë“  ì•Œë¦¼ì„ ì‚­ì œí–ˆìŠµë‹ˆë‹¤" });
  } catch (error) {
    console.error("DELETE /api/notifications error:", error);
    return NextResponse.json({ error: "ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/posts/[id]/bookmark/route.ts">
// src/app/api/posts/[id]/bookmark/route.ts
// POST â€” ë¶ë§ˆí¬ í† ê¸€

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function POST(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

  const existing = await prisma.postBookmark.findUnique({
    where: { postId_userId: { postId: params.id, userId: session.user.id } },
  });

  if (existing) {
    await prisma.postBookmark.delete({ where: { id: existing.id } });
    return NextResponse.json({ bookmarked: false });
  } else {
    await prisma.postBookmark.create({ data: { postId: params.id, userId: session.user.id } });
    return NextResponse.json({ bookmarked: true });
  }
}

export async function GET(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ bookmarked: false });

  const bookmark = await prisma.postBookmark.findUnique({
    where: { postId_userId: { postId: params.id, userId: session.user.id } },
  });

  return NextResponse.json({ bookmarked: !!bookmark });
}
</file>

<file path="src/app/api/posts/[id]/like/route.ts">
// src/app/api/posts/[id]/like/route.ts
// POST â€” ì¢‹ì•„ìš” í† ê¸€ (ìˆìœ¼ë©´ ì·¨ì†Œ, ì—†ìœ¼ë©´ ì¶”ê°€)

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function POST(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

  const existing = await prisma.postLike.findUnique({
    where: { postId_userId: { postId: params.id, userId: session.user.id } },
  });

  if (existing) {
    await prisma.postLike.delete({ where: { id: existing.id } });
    const count = await prisma.postLike.count({ where: { postId: params.id } });
    return NextResponse.json({ liked: false, count });
  } else {
    await prisma.postLike.create({ data: { postId: params.id, userId: session.user.id } });
    const count = await prisma.postLike.count({ where: { postId: params.id } });
    return NextResponse.json({ liked: true, count });
  }
}

// GET â€” ì¢‹ì•„ìš” ìƒíƒœ ì¡°íšŒ
export async function GET(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ liked: false, count: 0 });

  const [liked, count] = await Promise.all([
    prisma.postLike.findUnique({
      where: { postId_userId: { postId: params.id, userId: session.user.id } },
    }),
    prisma.postLike.count({ where: { postId: params.id } }),
  ]);

  return NextResponse.json({ liked: !!liked, count });
}
</file>

<file path="src/app/api/posts/[id]/share/route.ts">
// src/app/api/posts/[id]/share/route.ts
// âœ… ìˆ˜ì •: catch(error) â†’ catch(err) with type cast
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const postId = params.id;
    const body = await request.json();
    const { sharedWithEmail, permission = "VIEW" } = body;

    if (!sharedWithEmail) {
      return NextResponse.json({ error: "ê³µìœ í•  ì‚¬ìš©ì ì´ë©”ì¼ì„ ì…ë ¥í•˜ì„¸ìš”" }, { status: 400 });
    }

    const post = await prisma.post.findUnique({ where: { id: postId } });
    if (!post) {
      return NextResponse.json({ error: "ê²Œì‹œê¸€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 404 });
    }
    if (post.userId !== session.user.id) {
      return NextResponse.json({ error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" }, { status: 403 });
    }

    const sharedWithUser = await prisma.user.findUnique({
      where: { email: sharedWithEmail },
    });
    if (!sharedWithUser) {
      return NextResponse.json({ error: "ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 404 });
    }
    if (sharedWithUser.id === session.user.id) {
      return NextResponse.json({ error: "ìê¸° ìì‹ ì—ê²ŒëŠ” ê³µìœ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 400 });
    }

    const existing = await prisma.sharedResource.findFirst({
      where: { resourceType: "POST", resourceId: postId, sharedWithId: sharedWithUser.id },
    });

    if (existing) {
      const updated = await prisma.sharedResource.update({
        where: { id: existing.id },
        data: { permission },
      });
      return NextResponse.json({ message: "ê³µìœ  ê¶Œí•œì´ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤", share: updated });
    }

    const share = await prisma.sharedResource.create({
      data: {
        resourceType: "POST",
        resourceId:   postId,
        ownerId:      session.user.id,
        sharedWithId: sharedWithUser.id,
        permission,
      },
    });

    return NextResponse.json({ message: "ê²Œì‹œê¸€ì´ ê³µìœ ë˜ì—ˆìŠµë‹ˆë‹¤", share }, { status: 201 });

  } catch (err: unknown) {
    const e = err as any;
    console.error("ê²Œì‹œê¸€ ê³µìœ  ì˜¤ë¥˜:", e?.message ?? err);
    return NextResponse.json({ error: "ê²Œì‹œê¸€ ê³µìœ  ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" }, { status: 500 });
  }
}

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const shares = await prisma.sharedResource.findMany({
      where: { resourceType: "POST", resourceId: params.id, ownerId: session.user.id },
      include: { sharedWith: { select: { id: true, name: true, email: true } } },
    });

    return NextResponse.json({ shares });
  } catch (err: unknown) {
    console.error("ê²Œì‹œê¸€ ê³µìœ  ëª©ë¡ ì˜¤ë¥˜:", err);
    return NextResponse.json({ error: "ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" }, { status: 500 });
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const { shareId } = await request.json();
    const share = await prisma.sharedResource.findUnique({ where: { id: shareId } });
    if (!share || share.ownerId !== session.user.id) {
      return NextResponse.json({ error: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤" }, { status: 403 });
    }

    await prisma.sharedResource.delete({ where: { id: shareId } });
    return NextResponse.json({ message: "ê³µìœ ê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤" });
  } catch (err: unknown) {
    console.error("ê²Œì‹œê¸€ ê³µìœ  ì·¨ì†Œ ì˜¤ë¥˜:", err);
    return NextResponse.json({ error: "ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/posts/bookmarks/route.ts">
// src/app/api/posts/bookmarks/route.ts
// GET â€” ë‚´ ë¶ë§ˆí¬ ëª©ë¡

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function GET() {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

  const bookmarks = await prisma.postBookmark.findMany({
    where: { userId: session.user.id },
    include: {
      post: {
        select: {
          id: true, title: true, content: true, createdAt: true,
          user: { select: { id: true, name: true } },
          _count: { select: { comments: true, likes: true } },
        },
      },
    },
    orderBy: { createdAt: "desc" },
  });

  return NextResponse.json({
    posts: bookmarks.map((b) => ({ ...b.post, bookmarkedAt: b.createdAt })),
  });
}
</file>

<file path="src/app/api/share/[token]/route.ts">
// src/app/api/share/[token]/route.ts
// ê³µê°œ í† í°ìœ¼ë¡œ íŒŒì¼ ì •ë³´ ì¡°íšŒ (ë¹„ë¡œê·¸ì¸ ì ‘ê·¼ ê°€ëŠ¥)

import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { createReadStream } from "fs";
import { stat } from "fs/promises";

export async function GET(
  request: NextRequest,
  { params }: { params: { token: string } }
) {
  const file = await prisma.file.findUnique({
    where: { publicToken: params.token },
    select: {
      id: true, originalName: true, mimeType: true,
      size: true, filepath: true, thumbnailUrl: true,
      createdAt: true,
      user: { select: { name: true } },
      deletedAt: true,
    },
  });

  if (!file || file.deletedAt) {
    return NextResponse.json({ error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ê±°ë‚˜ ë§Œë£Œëœ ë§í¬ì…ë‹ˆë‹¤" }, { status: 404 });
  }

  const download = new URL(request.url).searchParams.get("download");

  // ë©”íƒ€ë°ì´í„°ë§Œ ë°˜í™˜
  if (!download) {
    return NextResponse.json({
      originalName: file.originalName,
      mimeType: file.mimeType,
      size: file.size.toString(),
      thumbnailUrl: file.thumbnailUrl,
      createdAt: file.createdAt,
      ownerName: file.user.name,
    });
  }

  // íŒŒì¼ ìŠ¤íŠ¸ë¦¼ ë°˜í™˜ (ë‹¤ìš´ë¡œë“œ)
  try {
    const fileStat = await stat(file.filepath);
    const stream = createReadStream(file.filepath);
    const readable = new ReadableStream({
      start(controller) {
        stream.on("data", (chunk) => controller.enqueue(chunk));
        stream.on("end", () => controller.close());
        stream.on("error", (err) => controller.error(err));
      },
    });

    return new NextResponse(readable, {
      headers: {
        "Content-Type": file.mimeType,
        "Content-Length": fileStat.size.toString(),
        "Content-Disposition": `attachment; filename*=UTF-8''${encodeURIComponent(file.originalName)}`,
      },
    });
  } catch {
    return NextResponse.json({ error: "íŒŒì¼ì„ ì½ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/share/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// ê³µìœ  ëª©ë¡ ì¡°íšŒ
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    // ë‚´ê°€ ê³µìœ ë°›ì€ ëª©ë¡
    const sharedWithMe = await prisma.sharedResource.findMany({
      where: { sharedWithId: session.user.id },
      include: {
        owner: {
          select: { id: true, name: true, email: true },
        },
      },
      orderBy: { createdAt: "desc" },
    });

    // ë‚´ê°€ ê³µìœ í•œ ëª©ë¡
    const sharedByMe = await prisma.sharedResource.findMany({
      where: { ownerId: session.user.id },
      include: {
        sharedWith: {
          select: { id: true, name: true, email: true },
        },
      },
      orderBy: { createdAt: "desc" },
    });

    return NextResponse.json({ sharedWithMe, sharedByMe });
  } catch (error) {
    console.error("Share list error:", error);
    return NextResponse.json(
      { error: "ê³µìœ  ëª©ë¡ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}

// ê³µìœ  ìƒì„±
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const body = await request.json();
    const { resourceType, resourceId, sharedWithEmail, permission } = body;

    // í•„ìˆ˜ê°’ í™•ì¸
    if (!resourceType || !resourceId || !sharedWithEmail) {
      return NextResponse.json(
        { error: "resourceType, resourceId, sharedWithEmail ì€ í•„ìˆ˜ì…ë‹ˆë‹¤" },
        { status: 400 }
      );
    }

    // ê³µìœ  ëŒ€ìƒ ì‚¬ìš©ì ì°¾ê¸° (ì´ë©”ì¼ë¡œ)
    const sharedWithUser = await prisma.user.findUnique({
      where: { email: sharedWithEmail.trim().toLowerCase() },
    });

    if (!sharedWithUser) {
      return NextResponse.json(
        { error: "í•´ë‹¹ ì´ë©”ì¼ì˜ ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 404 }
      );
    }

    // ìê¸° ìì‹ ì—ê²Œ ê³µìœ  ë°©ì§€
    if (sharedWithUser.id === session.user.id) {
      return NextResponse.json(
        { error: "ìê¸° ìì‹ ì—ê²ŒëŠ” ê³µìœ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
        { status: 400 }
      );
    }

    // ë¦¬ì†ŒìŠ¤ ì¡´ì¬ + ì†Œìœ ì í™•ì¸
    if (resourceType === "FILE") {
      const file = await prisma.file.findUnique({
        where: { id: resourceId },
      });
      if (!file) {
        return NextResponse.json(
          { error: "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
          { status: 404 }
        );
      }
      if (file.userId !== session.user.id) {
        return NextResponse.json(
          { error: "íŒŒì¼ ì†Œìœ ìë§Œ ê³µìœ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤" },
          { status: 403 }
        );
      }
    } else if (resourceType === "FOLDER") {
      const folder = await prisma.folder.findUnique({
        where: { id: resourceId },
      });
      if (!folder) {
        return NextResponse.json(
          { error: "í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
          { status: 404 }
        );
      }
      if (folder.userId !== session.user.id) {
        return NextResponse.json(
          { error: "í´ë” ì†Œìœ ìë§Œ ê³µìœ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤" },
          { status: 403 }
        );
      }
    } else if (resourceType === "POST") {
      const post = await prisma.post.findUnique({
        where: { id: resourceId },
      });
      if (!post) {
        return NextResponse.json(
          { error: "ê²Œì‹œê¸€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
          { status: 404 }
        );
      }
      if (post.userId !== session.user.id) {
        return NextResponse.json(
          { error: "ê²Œì‹œê¸€ ì‘ì„±ìë§Œ ê³µìœ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤" },
          { status: 403 }
        );
      }
    } else {
      return NextResponse.json(
        { error: "ì˜¬ë°”ë¥´ì§€ ì•Šì€ resourceType ì…ë‹ˆë‹¤ (FILE | FOLDER | POST)" },
        { status: 400 }
      );
    }

    // ì´ë¯¸ ê³µìœ  ì¤‘ì¸ì§€ í™•ì¸
    const existing = await prisma.sharedResource.findFirst({
      where: {
        resourceType,
        resourceId,
        sharedWithId: sharedWithUser.id,
      },
    });

    if (existing) {
      // ì´ë¯¸ ìˆìœ¼ë©´ ê¶Œí•œë§Œ ì—…ë°ì´íŠ¸
      const updated = await prisma.sharedResource.update({
        where: { id: existing.id },
        data: { permission: permission || "VIEW" },
      });
      return NextResponse.json({
        message: "ê³µìœ  ê¶Œí•œì´ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤",
        share: updated,
      });
    }

    // ìƒˆ ê³µìœ  ìƒì„±
    const share = await prisma.sharedResource.create({
      data: {
        resourceType,
        resourceId,
        ownerId: session.user.id,        // â† sharedById â†’ ownerId ìˆ˜ì •
        sharedWithId: sharedWithUser.id,
        permission: permission || "VIEW",
      },
    });

    return NextResponse.json(
      { message: "ê³µìœ ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤", share },
      { status: 201 }
    );
  } catch (error) {
    console.error("Share create error:", error);
    return NextResponse.json(
      { error: "ê³µìœ  ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/users/[id]/follow/route.ts">
// src/app/api/users/[id]/follow/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// POST /api/users/[id]/follow â€” íŒ”ë¡œìš°
export async function POST(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

  if (params.id === session.user.id) {
    return NextResponse.json({ error: "ìì‹ ì„ íŒ”ë¡œìš°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 400 });
  }

  try {
    await prisma.follow.create({
      data: { followerId: session.user.id, followingId: params.id },
    });

    // íŒ”ë¡œìš° ì•Œë¦¼ ìƒì„± (notification.ts ìœ í‹¸ ì‚¬ìš©)
    try {
      await prisma.notification.create({
        data: {
          userId: params.id,
          type: "SYSTEM",
          title: `${session.user.name}ë‹˜ì´ íŒ”ë¡œìš°í–ˆìŠµë‹ˆë‹¤`,
          link: `/users/${session.user.id}`,
        },
      });
    } catch {} // ì•Œë¦¼ ì‹¤íŒ¨ëŠ” ë¬´ì‹œ

    return NextResponse.json({ following: true });
  } catch (e: any) {
    if (e.code === "P2002") {
      return NextResponse.json({ error: "ì´ë¯¸ íŒ”ë¡œìš° ì¤‘ì…ë‹ˆë‹¤" }, { status: 409 });
    }
    return NextResponse.json({ error: "ì„œë²„ ì˜¤ë¥˜" }, { status: 500 });
  }
}

// DELETE /api/users/[id]/follow â€” ì–¸íŒ”ë¡œìš°
export async function DELETE(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

  await prisma.follow.deleteMany({
    where: { followerId: session.user.id, followingId: params.id },
  });

  return NextResponse.json({ following: false });
}

// GET /api/users/[id]/follow â€” íŒ”ë¡œìš° ì—¬ë¶€ + ì¹´ìš´íŠ¸
export async function GET(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);

  const [followerCount, followingCount, isFollowing] = await Promise.all([
    prisma.follow.count({ where: { followingId: params.id } }),
    prisma.follow.count({ where: { followerId: params.id } }),
    session?.user
      ? prisma.follow.findFirst({
          where: { followerId: session.user.id, followingId: params.id },
        })
      : null,
  ]);

  return NextResponse.json({
    followerCount,
    followingCount,
    isFollowing: !!isFollowing,
  });
}
</file>

<file path="src/app/api/users/[id]/followers/route.ts">
// src/app/api/users/[id]/followers/route.ts
// GET /api/users/[id]/followers?type=followers|following

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

  const type = new URL(request.url).searchParams.get("type") ?? "followers";

  const users =
    type === "followers"
      ? await prisma.follow.findMany({
          where: { followingId: params.id },
          include: { follower: { select: { id: true, name: true, email: true, isOnline: true } } },
          orderBy: { createdAt: "desc" },
        }).then((r) => r.map((f) => ({ ...f.follower, followedAt: f.createdAt })))
      : await prisma.follow.findMany({
          where: { followerId: params.id },
          include: { following: { select: { id: true, name: true, email: true, isOnline: true } } },
          orderBy: { createdAt: "desc" },
        }).then((r) => r.map((f) => ({ ...f.following, followedAt: f.createdAt })));

  return NextResponse.json({ users });
}
</file>

<file path="src/app/api/users/[id]/public/route.ts">
// src/app/api/users/[id]/public/route.ts
// ê³µê°œ í”„ë¡œí•„ ì¡°íšŒ (ë¹„ë°€ë²ˆí˜¸ í•´ì‹œ ë“± ë¯¼ê° ì •ë³´ ì œì™¸)

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function GET(
  _req: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

  const user = await prisma.user.findUnique({
    where: { id: params.id },
    select: {
      id: true, name: true, email: true, role: true,
      isOnline: true, createdAt: true,
      _count: { select: { files: true, posts: true, comments: true } },
    },
  });

  if (!user) return NextResponse.json({ error: "ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 404 });

  return NextResponse.json(user);
}
</file>

<file path="src/app/api/users/me/api-keys/[keyId]/route.ts">
// src/app/api/users/me/api-keys/[keyId]/route.ts
// DELETE â€” API í‚¤ ì‚­ì œ

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function DELETE(
  _req: NextRequest,
  { params }: { params: { keyId: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

  const key = await prisma.apiKey.findFirst({
    where: { id: params.keyId, userId: session.user.id },
  });
  if (!key) return NextResponse.json({ error: "API í‚¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 404 });

  await prisma.apiKey.delete({ where: { id: params.keyId } });
  return NextResponse.json({ message: "API í‚¤ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤" });
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// src/lib/api-key-auth.ts
// ì™¸ë¶€ API ì—”ë“œí¬ì¸íŠ¸ì—ì„œ Bearer í† í° ì¸ì¦ ì‹œ ì‚¬ìš©
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//
// import { verifyApiKey } from "@/lib/api-key-auth";
//
// export async function GET(request: NextRequest) {
//   const auth = await verifyApiKey(request, ["read:files"]);
//   if (!auth.ok) return NextResponse.json({ error: auth.error }, { status: 401 });
//   const { userId } = auth;
//   ...
// }
</file>

<file path="src/app/api/users/me/api-keys/route.ts">
// src/app/api/users/me/api-keys/route.ts
// GET    â€” API í‚¤ ëª©ë¡
// POST   â€” ìƒˆ API í‚¤ ìƒì„±

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import crypto from "crypto";
import bcrypt from "bcryptjs";

const MAX_KEYS = 10;
const VALID_SCOPES = ["read:files", "write:files", "read:posts", "write:posts", "read:profile"];

export async function GET() {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

  const keys = await prisma.apiKey.findMany({
    where: { userId: session.user.id },
    select: {
      id: true, name: true, keyPrefix: true,
      scopes: true, lastUsedAt: true, expiresAt: true, createdAt: true,
    },
    orderBy: { createdAt: "desc" },
  });

  return NextResponse.json({ keys });
}

export async function POST(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

  const count = await prisma.apiKey.count({ where: { userId: session.user.id } });
  if (count >= MAX_KEYS)
    return NextResponse.json({ error: `API í‚¤ëŠ” ìµœëŒ€ ${MAX_KEYS}ê°œê¹Œì§€ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤` }, { status: 400 });

  const { name, scopes = [], expiresInDays } = await request.json();

  if (!name?.trim()) return NextResponse.json({ error: "ì´ë¦„ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 400 });
  const validScopes = (scopes as string[]).filter((s) => VALID_SCOPES.includes(s));

  // eum_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx í˜•ì‹
  const rawKey = `eum_${crypto.randomBytes(32).toString("hex")}`;
  const keyHash = await bcrypt.hash(rawKey, 10);
  const keyPrefix = rawKey.slice(0, 12); // "eum_xxxxxxxx"

  const expiresAt = expiresInDays
    ? new Date(Date.now() + expiresInDays * 86400000)
    : null;

  const key = await prisma.apiKey.create({
    data: {
      userId: session.user.id,
      name: name.trim(),
      keyHash,
      keyPrefix,
      scopes: validScopes,
      expiresAt,
    },
  });

  // rawKeyëŠ” ìƒì„± ì§í›„ 1ë²ˆë§Œ ë°˜í™˜ (ì´í›„ ì¡°íšŒ ë¶ˆê°€)
  return NextResponse.json({
    key: {
      id: key.id, name: key.name, keyPrefix: key.keyPrefix,
      scopes: key.scopes, expiresAt: key.expiresAt, createdAt: key.createdAt,
    },
    rawKey, // âš ï¸ ì§€ê¸ˆ ë³µì‚¬í•˜ì§€ ì•Šìœ¼ë©´ ë‹¤ì‹œ ë³¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤
  });
}
</file>

<file path="src/app/api/users/me/avatar/route.ts">
// src/app/api/users/me/avatar/route.ts
// POST â€” ì•„ë°”íƒ€ ë˜ëŠ” ì»¤ë²„ ì´ë¯¸ì§€ ì—…ë¡œë“œ

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import { writeFile, mkdir, unlink } from "fs/promises";
import { existsSync } from "fs";
import path from "path";
import sharp from "sharp";
import crypto from "crypto";

const STORAGE_PATH = process.env.STORAGE_PATH ?? "./storage";
const AVATAR_DIR   = path.join(STORAGE_PATH, "avatars");
const COVER_DIR    = path.join(STORAGE_PATH, "covers");

export async function POST(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

  const formData = await request.formData();
  const file     = formData.get("file") as File | null;
  const type     = formData.get("type") as "avatar" | "cover" | null;

  if (!file)                    return NextResponse.json({ error: "íŒŒì¼ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 400 });
  if (!["avatar", "cover"].includes(type ?? ""))
    return NextResponse.json({ error: "typeì€ avatar ë˜ëŠ” coverì—¬ì•¼ í•©ë‹ˆë‹¤" }, { status: 400 });
  if (!file.type.startsWith("image/"))
    return NextResponse.json({ error: "ì´ë¯¸ì§€ íŒŒì¼ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤" }, { status: 400 });
  if (file.size > 5 * 1024 * 1024)
    return NextResponse.json({ error: "íŒŒì¼ í¬ê¸°ëŠ” 5MB ì´í•˜ì—¬ì•¼ í•©ë‹ˆë‹¤" }, { status: 400 });

  const isAvatar = type === "avatar";
  const dir      = isAvatar ? AVATAR_DIR : COVER_DIR;
  if (!existsSync(dir)) await mkdir(dir, { recursive: true });

  const id      = crypto.randomUUID();
  const outPath = path.join(dir, `${session.user.id}_${id}.webp`);

  const bytes  = await file.arrayBuffer();
  const buffer = Buffer.from(bytes);

  // ì•„ë°”íƒ€: 400x400 ì •ì‚¬ê°í˜• / ì»¤ë²„: 1200x400
  await sharp(buffer)
    .rotate()
    .resize(
      isAvatar ? 400 : 1200,
      isAvatar ? 400 : 400,
      { fit: isAvatar ? "cover" : "cover", position: "attention" }
    )
    .webp({ quality: 85 })
    .toFile(outPath);

  // ê¸°ì¡´ íŒŒì¼ ì‚­ì œ
  const user = await prisma.user.findUnique({
    where: { id: session.user.id },
    select: { avatarUrl: true, coverUrl: true },
  });
  const oldPath = isAvatar ? user?.avatarUrl : user?.coverUrl;
  if (oldPath && existsSync(oldPath)) await unlink(oldPath).catch(() => {});

  // DB ì—…ë°ì´íŠ¸
  const updated = await prisma.user.update({
    where: { id: session.user.id },
    data: isAvatar
      ? { avatarUrl: outPath }
      : { coverUrl:  outPath },
    select: { avatarUrl: true, coverUrl: true },
  });

  // ê³µê°œ URL ë°˜í™˜ (Next.js image serving API í†µí•´)
  const publicUrl = `/api/users/me/avatar?type=${type}&v=${id}`;
  return NextResponse.json({ url: outPath, publicUrl, message: "ì—…ë¡œë“œ ì™„ë£Œ" });
}

// GET â€” ì•„ë°”íƒ€/ì»¤ë²„ ì´ë¯¸ì§€ íŒŒì¼ ì„œë¹™
export async function GET(request: NextRequest) {
  const session = await getServerSession(authOptions);
  const userId  = new URL(request.url).searchParams.get("userId") ?? session?.user?.id;
  const type    = new URL(request.url).searchParams.get("type") ?? "avatar";

  if (!userId) return new NextResponse(null, { status: 404 });

  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { avatarUrl: true, coverUrl: true },
  });

  const filePath = type === "avatar" ? user?.avatarUrl : user?.coverUrl;
  if (!filePath || !existsSync(filePath)) return new NextResponse(null, { status: 404 });

  const { readFile } = await import("fs/promises");
  const data = await readFile(filePath);
  return new NextResponse(data, {
    headers: {
      "Content-Type": "image/webp",
      "Cache-Control": "public, max-age=3600",
    },
  });
}

// â”€â”€ schema.prisma User ëª¨ë¸ì— ì¶”ê°€ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// avatarUrl  String? @map("avatar_url")
// coverUrl   String? @map("cover_url")
</file>

<file path="src/app/api/users/me/onboarding/route.ts">
// src/app/api/users/me/onboarding/route.ts
// POST â€” ì˜¨ë³´ë”© ì™„ë£Œ ê¸°ë¡ (DBì— ì €ì¥)
// GET  â€” ì˜¨ë³´ë”© ì™„ë£Œ ì—¬ë¶€ í™•ì¸

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function POST() {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

  await prisma.user.update({
    where: { id: session.user.id },
    data: { onboardingDone: true },
  });

  return NextResponse.json({ message: "ì˜¨ë³´ë”© ì™„ë£Œ" });
}

export async function GET() {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ onboardingDone: false });

  const user = await prisma.user.findUnique({
    where: { id: session.user.id },
    select: { onboardingDone: true },
  });

  return NextResponse.json({ onboardingDone: user?.onboardingDone ?? false });
}
</file>

<file path="src/app/api/users/me/sessions/route.ts">
// src/app/api/users/me/sessions/route.ts
// GET  â€” ë‚´ í™œì„± ì„¸ì…˜ ëª©ë¡
// DELETE â€” íŠ¹ì • ì„¸ì…˜ ë˜ëŠ” í˜„ì¬ ì™¸ ëª¨ë“  ì„¸ì…˜ ë¡œê·¸ì•„ì›ƒ

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

// GET â€” ì„¸ì…˜ ëª©ë¡
export async function GET(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

  const sessions = await prisma.userSession.findMany({
    where: { userId: session.user.id },
    orderBy: { lastActive: "desc" },
    take: 20,
  });

  // í˜„ì¬ ì„¸ì…˜ í† í° (ì¿ í‚¤ì—ì„œ)
  const currentToken = request.cookies.get("next-auth.session-token")?.value
    ?? request.cookies.get("__Secure-next-auth.session-token")?.value;

  return NextResponse.json({
    sessions: sessions.map((s) => ({
      ...s,
      isCurrent: s.token === currentToken,
    })),
  });
}

// DELETE â€” ì„¸ì…˜ ì¢…ë£Œ
export async function DELETE(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

  const { sessionId, revokeAll } = await request.json();

  if (revokeAll) {
    // í˜„ì¬ ì„¸ì…˜ ì œì™¸í•˜ê³  ì „ë¶€ ì‚­ì œ
    const currentToken = request.cookies.get("next-auth.session-token")?.value
      ?? request.cookies.get("__Secure-next-auth.session-token")?.value;

    await prisma.userSession.deleteMany({
      where: {
        userId: session.user.id,
        token: currentToken ? { not: currentToken } : undefined,
      },
    });
    return NextResponse.json({ message: "ë‹¤ë¥¸ ëª¨ë“  ê¸°ê¸°ì—ì„œ ë¡œê·¸ì•„ì›ƒë˜ì—ˆìŠµë‹ˆë‹¤" });
  }

  if (sessionId) {
    const s = await prisma.userSession.findFirst({
      where: { id: sessionId, userId: session.user.id },
    });
    if (!s) return NextResponse.json({ error: "ì„¸ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 404 });
    await prisma.userSession.delete({ where: { id: sessionId } });
    return NextResponse.json({ message: "ì„¸ì…˜ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤" });
  }

  return NextResponse.json({ error: "sessionId ë˜ëŠ” revokeAll í•„ìš”" }, { status: 400 });
}
</file>

<file path="src/app/api/users/mention-search/route.ts">
// src/app/api/users/mention-search/route.ts
// GET /api/users/mention-search?q=ê²€ìƒ‰ì–´&limit=5
// @ë©˜ì…˜ ìë™ì™„ì„±ìš© ë¹ ë¥¸ ì‚¬ìš©ì ê²€ìƒ‰

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import { withCache, TTL } from "@/lib/cache";

export async function GET(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ users: [] });

  const q = new URL(request.url).searchParams.get("q")?.trim() ?? "";
  if (q.length < 1) return NextResponse.json({ users: [] });

  const users = await withCache(
    `mention-search:${q.toLowerCase()}`,
    () => prisma.user.findMany({
      where: {
        id:   { not: session.user.id },
        name: { contains: q, mode: "insensitive" },
      },
      select: { id: true, name: true, isOnline: true },
      take:   6,
      orderBy: [{ isOnline: "desc" }, { name: "asc" }],
    }),
    TTL.SHORT
  );

  return NextResponse.json({ users });
}
</file>

<file path="src/app/api/users/search/route.ts">
// src/app/api/users/search/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function GET(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

  const { searchParams } = new URL(request.url);
  const q = searchParams.get("q")?.trim() ?? "";
  const page = Math.max(1, parseInt(searchParams.get("page") ?? "1"));
  const limit = 20;

  if (q.length < 1) return NextResponse.json({ users: [], total: 0 });

  const where = {
    OR: [
      { name:  { contains: q, mode: "insensitive" as const } },
      { email: { contains: q, mode: "insensitive" as const } },
    ],
    id: { not: session.user.id },
  };

  const [users, total] = await Promise.all([
    prisma.user.findMany({
      where,
      select: {
        id: true, name: true, email: true,
        role: true, isOnline: true, createdAt: true,
        _count: { select: { files: true, posts: true } },
        followers: { where: { followerId: session.user.id }, select: { id: true } },
      },
      skip: (page - 1) * limit,
      take: limit,
      orderBy: [{ isOnline: "desc" }, { name: "asc" }],
    }),
    prisma.user.count({ where }),
  ]);

  return NextResponse.json({
    users: users.map((u) => ({ ...u, isFollowing: u.followers.length > 0, followers: undefined })),
    total,
    totalPages: Math.ceil(total / limit),
  });
}
</file>

<file path="src/app/banned/page.tsx">
// src/app/banned/page.tsx
// middleware.tsì—ì„œ isBanned ì‚¬ìš©ìë¥¼ ì´ í˜ì´ì§€ë¡œ ë¦¬ë””ë ‰ì…˜

import { signOut } from "next-auth/react";
import Link from "next/link";

export default function BannedPage() {
  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gray-50 dark:bg-slate-900 px-4">
      <div className="max-w-md w-full text-center space-y-6">
        <div className="w-20 h-20 rounded-2xl bg-red-50 dark:bg-red-900/30 flex items-center justify-center mx-auto text-4xl">
          ğŸš«
        </div>
        <div>
          <h1 className="text-2xl font-black text-gray-900 dark:text-slate-100 mb-2">
            ê³„ì •ì´ ì •ì§€ë˜ì—ˆìŠµë‹ˆë‹¤
          </h1>
          <p className="text-gray-500 dark:text-slate-400 text-sm">
            ì´ ê³„ì •ì€ ì„œë¹„ìŠ¤ ì´ìš© ê·œì • ìœ„ë°˜ìœ¼ë¡œ ì¸í•´ ì •ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.
            <br />
            ë¬¸ì˜ì‚¬í•­ì€ ê´€ë¦¬ìì—ê²Œ ì—°ë½í•´ ì£¼ì„¸ìš”.
          </p>
        </div>
        <div className="flex flex-col gap-3">
          <a
            href="mailto:admin@eum.app"
            className="w-full py-3 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-xl transition text-center"
          >
            ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜
          </a>
          <Link
            href="/api/auth/signout"
            className="w-full py-3 text-sm font-semibold text-gray-700 dark:text-slate-300 bg-white dark:bg-slate-800 border border-gray-200 dark:border-slate-700 hover:bg-gray-50 dark:hover:bg-slate-700 rounded-xl transition text-center"
          >
            ë¡œê·¸ì•„ì›ƒ
          </Link>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/global-error.tsx">
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// src/app/global-error.tsx â€” ìµœìƒìœ„ ì—ëŸ¬ í•¸ë“¤ëŸ¬ (ë ˆì´ì•„ì›ƒ ì˜¤ë¥˜)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// "use client";
// export default function GlobalError({ error, reset }) {
//   return (
//     <html><body>
//       <div className="min-h-screen flex items-center justify-center">
//         <div className="text-center">
//           <h1 className="text-2xl font-bold mb-4">ì¹˜ëª…ì  ì˜¤ë¥˜</h1>
//           <button onClick={reset} className="px-6 py-2 bg-blue-600 text-white rounded-xl">
//             ì•± ì¬ì‹œì‘
//           </button>
//         </div>
//       </div>
//     </body></html>
//   );
// }
</file>

<file path="src/app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

@import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   ë¼ì´íŠ¸ ëª¨ë“œ CSS ë³€ìˆ˜ (ê¸°ë³¸ê°’)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
:root {
  --eum-purple: #7c3aed;
  --eum-blue: #2563eb;
  --eum-dark: #0f0c29;
  --eum-glass: rgba(255, 255, 255, 0.06);
  --eum-border: rgba(255, 255, 255, 0.12);

  --bg-base:       #f8f9fa;
  --bg-surface:    #ffffff;
  --bg-elevated:   #ffffff;
  --bg-muted:      #f1f5f9;
  --bg-hover:      #f1f5f9;

  --text-primary:  #0f172a;
  --text-secondary:#475569;
  --text-muted:    #94a3b8;
  --text-inverted: #ffffff;

  --border-base:   #e2e8f0;
  --border-strong: #cbd5e1;

  --shadow-sm: 0 1px 3px rgba(0,0,0,0.06);
  --shadow-md: 0 4px 12px rgba(0,0,0,0.08);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   ë‹¤í¬ëª¨ë“œ CSS ë³€ìˆ˜
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.dark {
  --bg-base:       #0f172a;
  --bg-surface:    #1e293b;
  --bg-elevated:   #293548;
  --bg-muted:      #1e293b;
  --bg-hover:      #2d3f55;

  --text-primary:  #f1f5f9;
  --text-secondary:#94a3b8;
  --text-muted:    #64748b;
  --text-inverted: #0f172a;

  --border-base:   #334155;
  --border-strong: #475569;

  --shadow-sm: 0 1px 3px rgba(0,0,0,0.3);
  --shadow-md: 0 4px 12px rgba(0,0,0,0.4);

  --eum-glass: rgba(255, 255, 255, 0.04);
  --eum-border: rgba(255, 255, 255, 0.08);
}

* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

body {
  font-family: 'Pretendard', -apple-system, sans-serif;
  background-color: var(--bg-base);
  color: var(--text-primary);
  overflow-x: hidden;
  transition: background-color 0.2s ease, color 0.2s ease;
}

.eum-landing {
  background-color: var(--eum-dark);
  color: #ffffff;
}

::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: var(--bg-base); }
::-webkit-scrollbar-thumb {
  background: rgba(124, 58, 237, 0.3);
  border-radius: 10px;
}
::-webkit-scrollbar-thumb:hover { background: var(--eum-purple); }

.text-eum-gradient {
  background: linear-gradient(135deg, #a78bfa, #60a5fa);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.eum-glass-effect {
  background: var(--eum-glass);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  border: 1px solid var(--eum-border);
}

*, *::before, *::after {
  transition: background-color 0.15s ease, border-color 0.15s ease;
}
button, a, input, textarea, select {
  transition: background-color 0.15s ease, border-color 0.15s ease,
              color 0.1s ease, box-shadow 0.15s ease, opacity 0.15s ease;
}
</file>

<file path="src/app/notifications/page.tsx">
"use client";

import { useState, useEffect, useCallback } from "react";
import { useRouter } from "next/navigation";
import Link from "next/link";
import {
  Bell,
  BellOff,
  MessageCircle,
  Share2,
  FileUp,
  Phone,
  Info,
  MessageSquare,
  Trash2,
  CheckCheck,
  ChevronLeft,
  RefreshCw,
} from "lucide-react";
import { toast } from "@/components/Toast";

type NotificationType = "COMMENT" | "SHARE" | "CHAT" | "SYSTEM" | "FILE_UPLOAD" | "CALL";

interface Notification {
  id: string;
  type: NotificationType;
  title: string;
  body?: string;
  link?: string;
  isRead: boolean;
  createdAt: string;
}

// íƒ€ì…ë³„ ì•„ì´ì½˜ + ìƒ‰ìƒ
const TYPE_META: Record<
  NotificationType,
  { icon: React.ElementType; color: string; bg: string; label: string }
> = {
  COMMENT:     { icon: MessageSquare, color: "text-blue-600",  bg: "bg-blue-50",   label: "ëŒ“ê¸€" },
  SHARE:       { icon: Share2,        color: "text-green-600", bg: "bg-green-50",  label: "ê³µìœ " },
  CHAT:        { icon: MessageCircle, color: "text-purple-600",bg: "bg-purple-50", label: "ì±„íŒ…" },
  SYSTEM:      { icon: Info,          color: "text-gray-600 dark:text-slate-400",  bg: "bg-gray-50 dark:bg-slate-900",   label: "ì‹œìŠ¤í…œ" },
  FILE_UPLOAD: { icon: FileUp,        color: "text-orange-600",bg: "bg-orange-50", label: "íŒŒì¼" },
  CALL:        { icon: Phone,         color: "text-red-600",   bg: "bg-red-50",    label: "ì „í™”" },
};

function timeAgo(dateStr: string): string {
  const diff = Date.now() - new Date(dateStr).getTime();
  const m = Math.floor(diff / 60000);
  if (m < 1) return "ë°©ê¸ˆ ì „";
  if (m < 60) return `${m}ë¶„ ì „`;
  const h = Math.floor(m / 60);
  if (h < 24) return `${h}ì‹œê°„ ì „`;
  const d = Math.floor(h / 24);
  if (d < 7) return `${d}ì¼ ì „`;
  return new Date(dateStr).toLocaleDateString("ko-KR");
}

export default function NotificationsPage() {
  const router = useRouter();
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [unreadCount, setUnreadCount] = useState(0);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState<"all" | "unread">("all");
  const [deletingId, setDeletingId] = useState<string | null>(null);

  const fetchNotifications = useCallback(async () => {
    setLoading(true);
    try {
      const res = await fetch(
        `/api/notifications${filter === "unread" ? "?unread=true" : ""}`
      );
      if (!res.ok) throw new Error("failed");
      const data = await res.json();
      setNotifications(data.notifications);
      setUnreadCount(data.unreadCount);
    } catch {
      toast.error("ì•Œë¦¼ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  }, [filter]);

  useEffect(() => {
    fetchNotifications();
  }, [fetchNotifications]);

  // ë‹¨ê±´ ì½ìŒ
  const markRead = async (id: string) => {
    setNotifications((prev) =>
      prev.map((n) => (n.id === id ? { ...n, isRead: true } : n))
    );
    setUnreadCount((c) => Math.max(0, c - 1));
    await fetch(`/api/notifications/${id}`, { method: "PATCH" });
  };

  // ë‹¨ê±´ ì‚­ì œ
  const deleteOne = async (id: string) => {
    setDeletingId(id);
    try {
      await fetch(`/api/notifications/${id}`, { method: "DELETE" });
      setNotifications((prev) => prev.filter((n) => n.id !== id));
      const wasUnread = notifications.find((n) => n.id === id)?.isRead === false;
      if (wasUnread) setUnreadCount((c) => Math.max(0, c - 1));
      toast.success("ì•Œë¦¼ì„ ì‚­ì œí–ˆìŠµë‹ˆë‹¤");
    } catch {
      toast.error("ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setDeletingId(null);
    }
  };

  // ì „ì²´ ì½ìŒ
  const markAllRead = async () => {
    await fetch("/api/notifications", { method: "PATCH" });
    setNotifications((prev) => prev.map((n) => ({ ...n, isRead: true })));
    setUnreadCount(0);
    toast.success("ëª¨ë“  ì•Œë¦¼ì„ ì½ìŒ ì²˜ë¦¬í–ˆìŠµë‹ˆë‹¤");
  };

  // ì „ì²´ ì‚­ì œ
  const deleteAll = async () => {
    await fetch("/api/notifications", { method: "DELETE" });
    setNotifications([]);
    setUnreadCount(0);
    toast.success("ëª¨ë“  ì•Œë¦¼ì„ ì‚­ì œí–ˆìŠµë‹ˆë‹¤");
  };

  // ì•Œë¦¼ í´ë¦­: ì½ìŒ ì²˜ë¦¬ í›„ ë§í¬ ì´ë™
  const handleClick = (n: Notification) => {
    if (!n.isRead) markRead(n.id);
    if (n.link) router.push(n.link);
  };

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900 dark:bg-slate-900">
      {/* í—¤ë” */}
      <div className="bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700 dark:border-slate-700 sticky top-0 z-10">
        <div className="max-w-2xl mx-auto px-4 py-3 flex items-center gap-3">
          <Link href="/dashboard" className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 dark:bg-slate-700 transition-colors">
            <ChevronLeft size={20} className="text-gray-600 dark:text-slate-400" />
          </Link>
          <div className="flex items-center gap-2 flex-1">
            <Bell size={20} className="text-gray-800" />
            <h1 className="text-lg font-semibold text-gray-900 dark:text-slate-100">ì•Œë¦¼</h1>
            {unreadCount > 0 && (
              <span className="bg-red-500 text-white text-xs font-bold px-2 py-0.5 rounded-full">
                {unreadCount}
              </span>
            )}
          </div>
          <button
            onClick={fetchNotifications}
            className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 dark:bg-slate-700 transition-colors"
            title="ìƒˆë¡œê³ ì¹¨"
          >
            <RefreshCw size={16} className="text-gray-500 dark:text-slate-400" />
          </button>
        </div>

        {/* í•„í„° íƒ­ */}
        <div className="max-w-2xl mx-auto px-4 pb-2 flex gap-1">
          {(["all", "unread"] as const).map((f) => (
            <button
              key={f}
              onClick={() => setFilter(f)}
              className={`px-3 py-1.5 rounded-full text-sm font-medium transition-colors ${
                filter === f
                  ? "bg-blue-600 text-white"
                  : "text-gray-500 dark:text-slate-400 hover:bg-gray-100 dark:hover:bg-slate-700 dark:bg-slate-700"
              }`}
            >
              {f === "all" ? "ì „ì²´" : `ì½ì§€ ì•ŠìŒ ${unreadCount > 0 ? `(${unreadCount})` : ""}`}
            </button>
          ))}
        </div>
      </div>

      <div className="max-w-2xl mx-auto px-4 py-4">
        {/* ì¼ê´„ ì•¡ì…˜ */}
        {notifications.length > 0 && (
          <div className="flex justify-end gap-2 mb-3">
            {unreadCount > 0 && (
              <button
                onClick={markAllRead}
                className="flex items-center gap-1.5 text-sm text-blue-600 hover:text-blue-700 font-medium px-3 py-1.5 rounded-lg hover:bg-blue-50 transition-colors"
              >
                <CheckCheck size={14} />
                ëª¨ë‘ ì½ìŒ
              </button>
            )}
            <button
              onClick={deleteAll}
              className="flex items-center gap-1.5 text-sm text-red-500 hover:text-red-600 font-medium px-3 py-1.5 rounded-lg hover:bg-red-50 transition-colors"
            >
              <Trash2 size={14} />
              ì „ì²´ ì‚­ì œ
            </button>
          </div>
        )}

        {/* ì•Œë¦¼ ëª©ë¡ */}
        {loading ? (
          <div className="space-y-3">
            {[...Array(5)].map((_, i) => (
              <div key={i} className="bg-white dark:bg-slate-800 rounded-xl p-4 animate-pulse">
                <div className="flex gap-3">
                  <div className="w-10 h-10 rounded-full bg-gray-200 shrink-0" />
                  <div className="flex-1 space-y-2">
                    <div className="h-4 bg-gray-200 rounded w-3/4" />
                    <div className="h-3 bg-gray-100 dark:bg-slate-700 rounded w-1/2" />
                  </div>
                </div>
              </div>
            ))}
          </div>
        ) : notifications.length === 0 ? (
          <div className="flex flex-col items-center justify-center py-24 text-center">
            <div className="w-16 h-16 rounded-full bg-gray-100 dark:bg-slate-700 flex items-center justify-center mb-4">
              <BellOff size={28} className="text-gray-400 dark:text-slate-500" />
            </div>
            <p className="text-gray-500 dark:text-slate-400 font-medium">ì•Œë¦¼ì´ ì—†ìŠµë‹ˆë‹¤</p>
            <p className="text-gray-400 dark:text-slate-500 text-sm mt-1">
              {filter === "unread" ? "ì½ì§€ ì•Šì€ ì•Œë¦¼ì´ ì—†ìŠµë‹ˆë‹¤" : "ìƒˆ ì•Œë¦¼ì´ ì˜¤ë©´ ì—¬ê¸° í‘œì‹œë©ë‹ˆë‹¤"}
            </p>
          </div>
        ) : (
          <div className="space-y-2">
            {notifications.map((n) => {
              const meta = TYPE_META[n.type];
              const Icon = meta.icon;
              return (
                <div
                  key={n.id}
                  className={`bg-white dark:bg-slate-800 rounded-xl border transition-all ${
                    n.isRead ? "border-gray-100 dark:border-slate-700" : "border-blue-100 shadow-sm"
                  }`}
                >
                  <div
                    className={`flex items-start gap-3 p-4 cursor-pointer hover:bg-gray-50 dark:hover:bg-slate-700 dark:bg-slate-900 rounded-xl transition-colors ${
                      !n.isRead ? "bg-blue-50/40" : ""
                    }`}
                    onClick={() => handleClick(n)}
                  >
                    {/* ì•„ì´ì½˜ */}
                    <div className={`w-10 h-10 rounded-full flex items-center justify-center shrink-0 ${meta.bg}`}>
                      <Icon size={18} className={meta.color} />
                    </div>

                    {/* ë‚´ìš© */}
                    <div className="flex-1 min-w-0">
                      <div className="flex items-start justify-between gap-2">
                        <p className={`text-sm leading-snug ${n.isRead ? "text-gray-700 dark:text-slate-300" : "text-gray-900 dark:text-slate-100 font-semibold"}`}>
                          {n.title}
                        </p>
                        <div className="flex items-center gap-1 shrink-0">
                          {!n.isRead && (
                            <span className="w-2 h-2 rounded-full bg-blue-500 shrink-0" />
                          )}
                        </div>
                      </div>
                      {n.body && (
                        <p className="text-xs text-gray-500 dark:text-slate-400 mt-0.5 line-clamp-2">{n.body}</p>
                      )}
                      <div className="flex items-center gap-2 mt-1.5">
                        <span className={`text-[10px] font-medium px-1.5 py-0.5 rounded-full ${meta.bg} ${meta.color}`}>
                          {meta.label}
                        </span>
                        <span className="text-xs text-gray-400 dark:text-slate-500">{timeAgo(n.createdAt)}</span>
                      </div>
                    </div>
                  </div>

                  {/* ì•¡ì…˜ ë²„íŠ¼ */}
                  <div className="flex border-t border-gray-100 dark:border-slate-700">
                    {!n.isRead && (
                      <button
                        onClick={(e) => { e.stopPropagation(); markRead(n.id); }}
                        className="flex-1 py-2 text-xs text-blue-600 font-medium hover:bg-blue-50 transition-colors rounded-bl-xl"
                      >
                        ì½ìŒ ì²˜ë¦¬
                      </button>
                    )}
                    <button
                      onClick={(e) => { e.stopPropagation(); deleteOne(n.id); }}
                      disabled={deletingId === n.id}
                      className={`${n.isRead ? "w-full rounded-b-xl" : "flex-1"} py-2 text-xs text-red-400 font-medium hover:bg-red-50 transition-colors ${n.isRead ? "rounded-bl-xl" : ""} rounded-br-xl`}
                    >
                      {deletingId === n.id ? "ì‚­ì œ ì¤‘..." : "ì‚­ì œ"}
                    </button>
                  </div>
                </div>
              );
            })}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/app/notifications/settings/page.tsx">
"use client";

import { useState, useEffect } from "react";
import Link from "next/link";
import {
  Bell, BellOff, ChevronLeft, MessageSquare, Share2,
  MessageCircle, Phone, Info, FileUp, Mail, RefreshCw,
} from "lucide-react";
import { registerFCMToken, unregisterFCMToken } from "@/lib/firebase";
import { toast } from "@/components/Toast";

interface NotificationPreferences {
  pushEnabled: boolean;
  comment:     boolean;
  share:       boolean;
  chat:        boolean;
  call:        boolean;
  system:      boolean;
  fileUpload:  boolean;
  emailDigest: boolean;
}

const DEFAULT_PREFS: NotificationPreferences = {
  pushEnabled: true,
  comment:     true,
  share:       true,
  chat:        true,
  call:        true,
  system:      true,
  fileUpload:  false,
  emailDigest: false,
};

interface SettingItem {
  key: keyof NotificationPreferences;
  label: string;
  desc: string;
  icon: React.ElementType;
  color: string;
  bg: string;
  requiresPush?: boolean; // pushEnabledê°€ falseë©´ ë¹„í™œì„±í™”
}

const SETTINGS: SettingItem[] = [
  {
    key: "comment", label: "ëŒ“ê¸€ ì•Œë¦¼", requiresPush: true,
    desc: "ë‚´ ê²Œì‹œê¸€ì— ìƒˆ ëŒ“ê¸€ì´ ë‹¬ë ¸ì„ ë•Œ",
    icon: MessageSquare, color: "text-blue-600", bg: "bg-blue-50 dark:bg-blue-900/30",
  },
  {
    key: "share", label: "ê³µìœ  ì•Œë¦¼", requiresPush: true,
    desc: "íŒŒì¼ì´ë‚˜ í´ë”ê°€ ê³µìœ ë˜ì—ˆì„ ë•Œ",
    icon: Share2, color: "text-green-600", bg: "bg-green-50 dark:bg-green-900/30",
  },
  {
    key: "chat", label: "ì±„íŒ… ì•Œë¦¼", requiresPush: true,
    desc: "ìƒˆ ì±„íŒ… ë©”ì‹œì§€ê°€ ë„ì°©í–ˆì„ ë•Œ",
    icon: MessageCircle, color: "text-purple-600", bg: "bg-purple-50 dark:bg-purple-900/30",
  },
  {
    key: "call", label: "í†µí™” ì•Œë¦¼", requiresPush: true,
    desc: "ìŒì„±/ì˜ìƒ í†µí™” ìš”ì²­ì´ ë“¤ì–´ì™”ì„ ë•Œ",
    icon: Phone, color: "text-red-600", bg: "bg-red-50 dark:bg-red-900/30",
  },
  {
    key: "system", label: "ì‹œìŠ¤í…œ ì•Œë¦¼", requiresPush: true,
    desc: "ì„œë¹„ìŠ¤ ê³µì§€ ë° ì¤‘ìš” ì•ˆë‚´",
    icon: Info, color: "text-gray-600", bg: "bg-gray-50 dark:bg-gray-800",
  },
  {
    key: "fileUpload", label: "íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ", requiresPush: true,
    desc: "ëŒ€ìš©ëŸ‰ íŒŒì¼ ì—…ë¡œë“œê°€ ì™„ë£Œë˜ì—ˆì„ ë•Œ",
    icon: FileUp, color: "text-orange-600", bg: "bg-orange-50 dark:bg-orange-900/30",
  },
  {
    key: "emailDigest", label: "ì´ë©”ì¼ ì£¼ê°„ ìš”ì•½",
    desc: "ë§¤ì£¼ í™œë™ ìš”ì•½ì„ ì´ë©”ì¼ë¡œ ë°›ê¸° (ì¤€ë¹„ ì¤‘)",
    icon: Mail, color: "text-indigo-600", bg: "bg-indigo-50 dark:bg-indigo-900/30",
  },
];

// â”€â”€â”€ Toggle ë²„íŠ¼ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function Toggle({
  enabled, onToggle, disabled = false,
}: {
  enabled: boolean; onToggle: () => void; disabled?: boolean;
}) {
  return (
    <button
      onClick={onToggle}
      disabled={disabled}
      aria-checked={enabled}
      role="switch"
      className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors
        focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2
        ${enabled ? "bg-blue-600" : "bg-gray-200 dark:bg-slate-600"}
        ${disabled ? "opacity-40 cursor-not-allowed" : "cursor-pointer"}`}
    >
      <span
        className={`inline-block h-4 w-4 transform rounded-full bg-white shadow transition-transform
          ${enabled ? "translate-x-6" : "translate-x-1"}`}
      />
    </button>
  );
}

export default function NotificationSettingsPage() {
  const [prefs, setPrefs] = useState<NotificationPreferences>(DEFAULT_PREFS);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [browserPermission, setBrowserPermission] = useState<NotificationPermission | null>(null);

  // ë¸Œë¼ìš°ì € ì•Œë¦¼ ê¶Œí•œ ìƒíƒœ
  useEffect(() => {
    if ("Notification" in window) {
      setBrowserPermission(Notification.permission);
    }
  }, []);

  // ì„œë²„ì—ì„œ ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸°
  useEffect(() => {
    fetch("/api/notifications/preferences")
      .then((r) => r.json())
      .then((d) => setPrefs({ ...DEFAULT_PREFS, ...d.prefs }))
      .catch(() => toast.error("ì„¤ì •ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤"))
      .finally(() => setLoading(false));
  }, []);

  // ê°œë³„ í† ê¸€ ì €ì¥ (debounce ì—†ì´ ì¦‰ì‹œ ì €ì¥)
  const toggle = async (key: keyof NotificationPreferences) => {
    const newPrefs = { ...prefs, [key]: !prefs[key] };
    setPrefs(newPrefs);
    setSaving(true);
    try {
      await fetch("/api/notifications/preferences", {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(newPrefs),
      });
    } catch {
      // ì‹¤íŒ¨ ì‹œ ë¡¤ë°±
      setPrefs(prefs);
      toast.error("ì„¤ì • ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
    } finally {
      setSaving(false);
    }
  };

  // í‘¸ì‹œ ì „ì²´ í† ê¸€ (FCM ì—°ë™ í¬í•¨)
  const togglePush = async () => {
    setSaving(true);
    if (prefs.pushEnabled) {
      await unregisterFCMToken();
      await toggle("pushEnabled");
    } else {
      if (browserPermission === "denied") {
        toast.error("ë¸Œë¼ìš°ì € ì„¤ì •ì—ì„œ ì•Œë¦¼ ê¶Œí•œì„ í—ˆìš©í•œ ë’¤ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.");
        setSaving(false);
        return;
      }
      const success = await registerFCMToken();
      if (success) {
        setBrowserPermission("granted");
        await toggle("pushEnabled");
      } else {
        toast.error("ì•Œë¦¼ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”.");
      }
    }
    setSaving(false);
  };

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900">
      {/* í—¤ë” */}
      <div className="bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700 sticky top-0 z-10">
        <div className="max-w-2xl mx-auto px-4 py-3 flex items-center gap-3">
          <Link
            href="/profile"
            className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors"
          >
            <ChevronLeft size={20} className="text-gray-600 dark:text-slate-400" />
          </Link>
          <Bell size={20} className="text-gray-800 dark:text-slate-200" />
          <h1 className="text-lg font-semibold text-gray-900 dark:text-slate-100 flex-1">
            ì•Œë¦¼ ì„¤ì •
          </h1>
          {saving && (
            <RefreshCw size={14} className="animate-spin text-blue-500" />
          )}
        </div>
      </div>

      <div className="max-w-2xl mx-auto px-4 py-6 space-y-4">

        {/* ë¸Œë¼ìš°ì € ê¶Œí•œ ê²½ê³  */}
        {browserPermission === "denied" && (
          <div className="flex items-start gap-3 p-4 bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-700 rounded-xl">
            <BellOff size={18} className="text-amber-600 shrink-0 mt-0.5" />
            <div>
              <p className="text-sm font-semibold text-amber-800 dark:text-amber-400">
                ë¸Œë¼ìš°ì € ì•Œë¦¼ì´ ì°¨ë‹¨ë¨
              </p>
              <p className="text-xs text-amber-700 dark:text-amber-500 mt-0.5">
                ì£¼ì†Œì°½ ì™¼ìª½ ìë¬¼ì‡  ì•„ì´ì½˜ â†’ ì•Œë¦¼ â†’ í—ˆìš©ìœ¼ë¡œ ë³€ê²½ í›„ ìƒˆë¡œê³ ì¹¨í•˜ì„¸ìš”.
              </p>
            </div>
          </div>
        )}

        {/* í‘¸ì‹œ ì•Œë¦¼ ë§ˆìŠ¤í„° í† ê¸€ */}
        <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-5">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              <div className="w-10 h-10 rounded-full bg-blue-50 dark:bg-blue-900/30 flex items-center justify-center">
                <Bell size={20} className="text-blue-600 dark:text-blue-400" />
              </div>
              <div>
                <p className="font-semibold text-gray-900 dark:text-slate-100">
                  í‘¸ì‹œ ì•Œë¦¼ ì „ì²´
                </p>
                <p className="text-xs text-gray-500 dark:text-slate-400 mt-0.5">
                  ì•±ì„ ë‹«ì•„ë„ ì•Œë¦¼ì„ ë°›ìŠµë‹ˆë‹¤
                </p>
              </div>
            </div>
            <Toggle
              enabled={prefs.pushEnabled}
              onToggle={togglePush}
              disabled={loading || browserPermission === "denied"}
            />
          </div>
        </div>

        {/* ì•Œë¦¼ ì¢…ë¥˜ë³„ ì„¤ì • */}
        <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 overflow-hidden">
          <div className="px-5 py-3 border-b border-gray-100 dark:border-slate-700">
            <p className="text-xs font-semibold text-gray-500 dark:text-slate-400 uppercase tracking-wide">
              ì•Œë¦¼ ì¢…ë¥˜
            </p>
          </div>

          {loading ? (
            <div className="p-8 flex justify-center">
              <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600" />
            </div>
          ) : (
            <div className="divide-y divide-gray-100 dark:divide-slate-700">
              {SETTINGS.map(({ key, label, desc, icon: Icon, color, bg, requiresPush }) => {
                const isDisabled = requiresPush && !prefs.pushEnabled;
                return (
                  <div
                    key={key}
                    className={`flex items-center gap-3 px-5 py-4 transition-colors
                      ${isDisabled ? "opacity-50" : "hover:bg-gray-50 dark:hover:bg-slate-700/50"}`}
                  >
                    <div className={`w-9 h-9 rounded-full ${bg} flex items-center justify-center shrink-0`}>
                      <Icon size={16} className={color} />
                    </div>
                    <div className="flex-1 min-w-0">
                      <p className="text-sm font-medium text-gray-900 dark:text-slate-100">
                        {label}
                        {key === "emailDigest" && (
                          <span className="ml-2 text-[10px] font-semibold bg-gray-100 dark:bg-slate-700 text-gray-500 dark:text-slate-400 px-1.5 py-0.5 rounded">
                            ì¤€ë¹„ ì¤‘
                          </span>
                        )}
                      </p>
                      <p className="text-xs text-gray-500 dark:text-slate-400">{desc}</p>
                    </div>
                    <Toggle
                      enabled={prefs[key]}
                      onToggle={() => toggle(key)}
                      disabled={loading || saving || isDisabled || key === "emailDigest"}
                    />
                  </div>
                );
              })}
            </div>
          )}
        </div>

        {/* ì•ˆë‚´ */}
        <p className="text-xs text-center text-gray-400 dark:text-slate-500 pb-4">
          ì„¤ì •ì€ ìë™ìœ¼ë¡œ ì €ì¥ë©ë‹ˆë‹¤. ë³€ê²½ ì‚¬í•­ì€ ì¦‰ì‹œ ë°˜ì˜ë©ë‹ˆë‹¤.
        </p>
      </div>
    </div>
  );
}
</file>

<file path="src/app/page.tsx">
"use client";

import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import { useEffect, useRef, useState } from "react";
import Link from "next/link";
import {
  Cloud, ShieldCheck, Zap, Share2, ArrowRight,
  MessageCircle, Search, Bell, Smartphone, Lock,
  HardDrive, Globe, CheckCircle2,
} from "lucide-react";

function useInView(threshold = 0.15) {
  const ref = useRef<HTMLDivElement>(null);
  const [inView, setInView] = useState(false);
  useEffect(() => {
    const obs = new IntersectionObserver(([e]) => { if (e.isIntersecting) setInView(true); }, { threshold });
    if (ref.current) obs.observe(ref.current);
    return () => obs.disconnect();
  }, [threshold]);
  return { ref, inView };
}

function CountUp({ to, suffix = "" }: { to: number; suffix?: string }) {
  const [val, setVal] = useState(0);
  const { ref, inView } = useInView();
  useEffect(() => {
    if (!inView) return;
    const step = Math.ceil(to / 60);
    let cur = 0;
    const t = setInterval(() => {
      cur = Math.min(cur + step, to);
      setVal(cur);
      if (cur >= to) clearInterval(t);
    }, 16);
    return () => clearInterval(t);
  }, [inView, to]);
  return <span ref={ref}>{val.toLocaleString()}{suffix}</span>;
}

const FEATURES = [
  {
    icon: HardDrive, color: "from-blue-500 to-cyan-400",
    title: "ìŠ¤ë§ˆíŠ¸ íŒŒì¼ ê´€ë¦¬",
    desc: "í´ë” ê³„ì¸µ, íƒœê·¸, ì „ë¬¸ ê²€ìƒ‰ìœ¼ë¡œ ìˆ˜ì²œ ê°œì˜ íŒŒì¼ì„ í•œëˆˆì— ì •ë¦¬í•˜ì„¸ìš”.",
    points: ["í´ë” & íƒœê·¸ ê¸°ë°˜ ë¶„ë¥˜", "íŒŒì¼ ë¯¸ë¦¬ë³´ê¸° (ì´ë¯¸ì§€Â·ì˜ìƒÂ·PDF)", "í¼ë¯¸ì…˜ ê¸°ë°˜ ì„ íƒ ê³µìœ "],
  },
  {
    icon: MessageCircle, color: "from-purple-500 to-pink-400",
    title: "ì‹¤ì‹œê°„ ì±„íŒ… & í†µí™”",
    desc: "í…ìŠ¤íŠ¸, íŒŒì¼ ì „ì†¡, ìŒì„±Â·ì˜ìƒ í†µí™”ê¹Œì§€ í•˜ë‚˜ì˜ ì•±ì—ì„œ í•´ê²°í•˜ì„¸ìš”.",
    points: ["WebRTC ìŒì„±Â·ì˜ìƒ í†µí™”", "ì±„íŒ…ë°© íŒŒì¼ ì²¨ë¶€", "ì˜¨ë¼ì¸ í”„ë ˆì¦ŒìŠ¤ í‘œì‹œ"],
  },
  {
    icon: ShieldCheck, color: "from-green-500 to-emerald-400",
    title: "ê°•ë ¥í•œ ë³´ì•ˆ",
    desc: "bcrypt ì•”í˜¸í™”, ì„¸ì…˜ ë³´í˜¸, 2ë‹¨ê³„ ì¸ì¦ìœ¼ë¡œ ë°ì´í„°ë¥¼ ì•ˆì „í•˜ê²Œ ì§€í‚µë‹ˆë‹¤.",
    points: ["ë¹„ë°€ë²ˆí˜¸ bcrypt í•´ì‹±", "TOTP 2ë‹¨ê³„ ì¸ì¦", "ì—­í•  ê¸°ë°˜ ì ‘ê·¼ ì œì–´"],
  },
  {
    icon: Bell, color: "from-orange-500 to-amber-400",
    title: "ìŠ¤ë§ˆíŠ¸ ì•Œë¦¼",
    desc: "ëŒ“ê¸€, ê³µìœ , ì±„íŒ…, í†µí™” ìš”ì²­ì„ FCM í‘¸ì‹œë¡œ ì‹¤ì‹œê°„ ìˆ˜ì‹ í•˜ì„¸ìš”.",
    points: ["FCM ë¸Œë¼ìš°ì € í‘¸ì‹œ", "ì•Œë¦¼ ì¢…ë¥˜ë³„ ê°œë³„ ì„¤ì •", "ì•± ë‚´ ì•Œë¦¼ íˆìŠ¤í† ë¦¬"],
  },
  {
    icon: Search, color: "from-indigo-500 to-violet-400",
    title: "í†µí•© ì „ë¬¸ ê²€ìƒ‰",
    desc: "íŒŒì¼ëª…, ê²Œì‹œê¸€ ë³¸ë¬¸, íƒœê·¸, ì‘ì„±ìë¥¼ í•œ ë²ˆì— ê²€ìƒ‰í•˜ì„¸ìš”.",
    points: ["íŒŒì¼ + ê²Œì‹œê¸€ í†µí•© ê²€ìƒ‰", "íƒœê·¸ í•„í„°ë§", "ì €ì¥ëœ ê²€ìƒ‰ ì¡°ê±´"],
  },
  {
    icon: Smartphone, color: "from-rose-500 to-pink-400",
    title: "PWA ëª¨ë°”ì¼ ì•±",
    desc: "í™ˆ í™”ë©´ì— ì¶”ê°€í•˜ë©´ ë„¤ì´í‹°ë¸Œ ì•±ì²˜ëŸ¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
    points: ["í™ˆ í™”ë©´ ì„¤ì¹˜ ì§€ì›", "ì˜¤í”„ë¼ì¸ ìºì‹±", "ëª¨ë°”ì¼ ìµœì í™” UI"],
  },
];

const STATS = [
  { value: 5120, suffix: "MB", label: "1ì¸ë‹¹ ë¬´ë£Œ ì €ì¥ìš©ëŸ‰" },
  { value: 50,   suffix: "MB", label: "ìµœëŒ€ íŒŒì¼ ì—…ë¡œë“œ í¬ê¸°" },
  { value: 99,   suffix: "%",  label: "ì—…íƒ€ì„ ëª©í‘œ" },
  { value: 2048, suffix: "+",  label: "ì§€ì› íŒŒì¼ í˜•ì‹" },
];

export default function HomePage() {
  const { status } = useSession();
  const router = useRouter();

  useEffect(() => {
    if (status === "authenticated") router.push("/dashboard");
  }, [status, router]);

  if (status === "loading") return (
    <div className="min-h-screen bg-[#0f0c29] flex items-center justify-center">
      <div className="w-12 h-12 border-4 border-purple-500/20 border-t-purple-500 rounded-full animate-spin" />
    </div>
  );

  return (
    <div className="min-h-screen bg-[#0f0c29] text-white overflow-x-hidden selection:bg-purple-500/30">

      {/* ë°°ê²½ */}
      <div className="fixed inset-0 -z-10 pointer-events-none overflow-hidden">
        <div className="absolute -top-40 -left-40 w-[700px] h-[700px] bg-purple-700/20 rounded-full blur-[120px]" />
        <div className="absolute top-1/2 -right-40 w-[500px] h-[500px] bg-blue-700/15 rounded-full blur-[100px]" />
        <div className="absolute -bottom-40 left-1/3 w-[600px] h-[600px] bg-indigo-700/10 rounded-full blur-[120px]" />
        <div className="absolute inset-0 opacity-[0.03]"
          style={{ backgroundImage: "linear-gradient(#fff 1px,transparent 1px),linear-gradient(90deg,#fff 1px,transparent 1px)", backgroundSize: "60px 60px" }} />
      </div>

      {/* ë„¤ë¹„ê²Œì´ì…˜ */}
      <nav className="sticky top-0 z-50 border-b border-white/5 backdrop-blur-xl bg-[#0f0c29]/80">
        <div className="max-w-6xl mx-auto px-6 h-16 flex items-center justify-between">
          <div className="flex items-center gap-2">
            <div className="w-8 h-8 rounded-xl bg-gradient-to-br from-purple-500 to-blue-600 flex items-center justify-center">
              <Cloud size={16} className="text-white" />
            </div>
            <span className="text-lg font-black tracking-tight">ì´ìŒ</span>
          </div>
          <div className="hidden md:flex items-center gap-6 text-sm text-white/50">
            <a href="#features" className="hover:text-white transition-colors">ê¸°ëŠ¥</a>
            <a href="#stats" className="hover:text-white transition-colors">ì‚¬ì–‘</a>
            <a href="#tech" className="hover:text-white transition-colors">ê¸°ìˆ  ìŠ¤íƒ</a>
          </div>
          <div className="flex items-center gap-3">
            <Link href="/login" className="px-4 py-2 text-sm font-semibold text-white/60 hover:text-white transition-colors">
              ë¡œê·¸ì¸
            </Link>
            <Link href="/register" className="px-4 py-2 text-sm font-bold bg-white text-black rounded-xl hover:bg-purple-50 transition-all">
              ë¬´ë£Œ ì‹œì‘
            </Link>
          </div>
        </div>
      </nav>

      <div className="max-w-6xl mx-auto px-6">

        {/* íˆì–´ë¡œ */}
        <section className="pt-24 pb-32 text-center">
          <div className="inline-flex items-center gap-2 px-4 py-2 rounded-full bg-white/5 border border-white/10 text-purple-300 text-xs font-bold mb-10">
            <span className="relative flex h-2 w-2">
              <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-purple-400 opacity-75" />
              <span className="relative inline-flex rounded-full h-2 w-2 bg-purple-500" />
            </span>
            NEXT-GEN PERSONAL CLOUD
          </div>

          <h1 className="text-5xl md:text-7xl lg:text-8xl font-black mb-8 leading-[1.05] tracking-tight">
            ì‚¬ëŒê³¼ íŒŒì¼ì„<br />
            <span className="bg-clip-text text-transparent bg-gradient-to-r from-purple-400 via-blue-300 to-emerald-300">
              í•˜ë‚˜ë¡œ ì‡ë‹¤
            </span>
          </h1>

          <p className="text-lg md:text-xl text-white/45 max-w-2xl mx-auto mb-14 leading-relaxed">
            íŒŒì¼ ê´€ë¦¬ë¶€í„° ì‹¤ì‹œê°„ ì±„íŒ…, WebRTC í†µí™”, ìŠ¤ë§ˆíŠ¸ ê²€ìƒ‰ê¹Œì§€.<br className="hidden md:block" />
            í•˜ë‚˜ì˜ í”Œë«í¼ì—ì„œ ëª¨ë“  ê²ƒì„ ê²½í—˜í•˜ì„¸ìš”.
          </p>

          <div className="flex flex-col sm:flex-row items-center justify-center gap-4 mb-20">
            <Link
              href="/register"
              className="group w-full sm:w-auto px-8 py-4 bg-white text-black font-black rounded-2xl hover:bg-purple-50 transition-all flex items-center justify-center gap-2 shadow-xl shadow-white/10"
            >
              ì§€ê¸ˆ ë¬´ë£Œë¡œ ì‹œì‘í•˜ê¸°
              <ArrowRight size={18} className="group-hover:translate-x-1 transition-transform" />
            </Link>
            <a
              href="#features"
              className="w-full sm:w-auto px-8 py-4 bg-white/5 text-white font-bold rounded-2xl border border-white/10 hover:bg-white/10 transition-all"
            >
              ê¸°ëŠ¥ ë‘˜ëŸ¬ë³´ê¸°
            </a>
          </div>

          {/* ë¯¸ë¦¬ë³´ê¸° ëª¨í˜• */}
          <div className="relative max-w-3xl mx-auto">
            <div className="relative bg-white/5 border border-white/10 rounded-[28px] p-1 shadow-2xl shadow-purple-900/20">
              <div className="bg-slate-900/80 rounded-[22px] p-4 text-left">
                <div className="flex items-center gap-2 mb-4">
                  <div className="w-3 h-3 rounded-full bg-red-500/70" />
                  <div className="w-3 h-3 rounded-full bg-yellow-500/70" />
                  <div className="w-3 h-3 rounded-full bg-green-500/70" />
                  <div className="flex-1 mx-4 h-6 bg-white/5 rounded-full" />
                </div>
                <div className="grid grid-cols-3 gap-2">
                  {["ğŸ“ Documents", "ğŸ–¼ï¸ Photos", "ğŸ¬ Videos", "ğŸ“„ Reports", "ğŸµ Music", "ğŸ“Š Data"].map((name) => (
                    <div key={name} className="bg-white/5 rounded-xl p-3 flex items-center gap-2 border border-white/5">
                      <span className="text-sm">{name.split(" ")[0]}</span>
                      <span className="text-xs text-white/40 truncate">{name.split(" ").slice(1).join(" ")}</span>
                    </div>
                  ))}
                </div>
                <div className="mt-3 flex gap-2">
                  <div className="flex-1 h-10 bg-blue-500/20 rounded-xl border border-blue-500/30 flex items-center px-3 gap-2">
                    <div className="w-2 h-2 rounded-full bg-green-400 animate-pulse" />
                    <span className="text-xs text-white/40">ê¹€ì² ìˆ˜ë‹˜ê³¼ ì±„íŒ… ì¤‘...</span>
                  </div>
                  <div className="w-10 h-10 bg-purple-500/20 rounded-xl border border-purple-500/30 flex items-center justify-center">
                    <Bell size={14} className="text-purple-300" />
                  </div>
                </div>
              </div>
            </div>
            <div className="absolute -inset-4 bg-gradient-to-r from-purple-600/20 via-blue-600/10 to-emerald-600/20 rounded-[40px] blur-2xl -z-10" />
          </div>
        </section>

        {/* í†µê³„ */}
        <section id="stats" className="py-20">
          <div className="grid grid-cols-2 md:grid-cols-4 gap-6">
            {STATS.map(({ value, suffix, label }) => (
              <div key={label} className="text-center p-6 rounded-[24px] bg-white/5 border border-white/10 hover:border-purple-500/30 transition-all">
                <p className="text-4xl font-black mb-2 bg-clip-text text-transparent bg-gradient-to-r from-purple-300 to-blue-300">
                  <CountUp to={value} suffix={suffix} />
                </p>
                <p className="text-white/40 text-xs font-medium">{label}</p>
              </div>
            ))}
          </div>
        </section>

        {/* ê¸°ëŠ¥ */}
        <section id="features" className="py-20">
          <div className="text-center mb-16">
            <p className="text-purple-400 text-xs font-bold uppercase tracking-widest mb-4">FEATURES</p>
            <h2 className="text-4xl md:text-5xl font-black mb-4">í•„ìš”í•œ ëª¨ë“  ê²ƒì´<br />í•œ ê³³ì—</h2>
            <p className="text-white/40 max-w-xl mx-auto">ê°œì¸ ìŠ¤í† ë¦¬ì§€ë¥¼ ë„˜ì–´ì„œëŠ” ì˜¬ì¸ì› ìƒì‚°ì„± í”Œë«í¼</p>
          </div>
          <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-5">
            {FEATURES.map(({ icon: Icon, color, title, desc, points }) => (
              <div key={title} className="group p-6 rounded-[24px] bg-white/5 border border-white/10 hover:border-white/20 hover:-translate-y-1 transition-all duration-300">
                <div className={`w-12 h-12 rounded-2xl bg-gradient-to-br ${color} flex items-center justify-center mb-5 shadow-lg group-hover:scale-110 transition-transform`}>
                  <Icon size={22} className="text-white" />
                </div>
                <h3 className="text-lg font-bold mb-2">{title}</h3>
                <p className="text-white/40 text-sm leading-relaxed mb-4">{desc}</p>
                <ul className="space-y-1.5">
                  {points.map((pt) => (
                    <li key={pt} className="flex items-center gap-2 text-xs text-white/50">
                      <CheckCircle2 size={12} className="text-emerald-400 shrink-0" />
                      {pt}
                    </li>
                  ))}
                </ul>
              </div>
            ))}
          </div>
        </section>

        {/* ê¸°ìˆ  ìŠ¤íƒ */}
        <section id="tech" className="py-20">
          <div className="relative p-10 rounded-[40px] bg-gradient-to-b from-white/8 to-transparent border border-white/10 overflow-hidden">
            <div className="absolute top-0 right-0 p-8 opacity-5">
              <Globe size={160} />
            </div>
            <div className="relative z-10">
              <div className="flex items-center gap-3 mb-10">
                <CheckCircle2 className="text-emerald-400" size={22} />
                <h3 className="text-2xl font-black tracking-tight">SYSTEM OPERATIONAL</h3>
              </div>
              <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-6 gap-6">
                {[
                  { label: "Framework", value: "Next.js 14" },
                  { label: "Database",  value: "PostgreSQL" },
                  { label: "ORM",       value: "Prisma 5" },
                  { label: "Auth",      value: "NextAuth.js" },
                  { label: "Realtime",  value: "Socket.IO" },
                  { label: "Security",  value: "bcrypt + TOTP" },
                ].map(({ label, value }) => (
                  <div key={label}>
                    <p className="text-white/25 text-[10px] font-bold uppercase tracking-widest mb-1">{label}</p>
                    <p className="text-white font-mono text-sm font-semibold">{value}</p>
                  </div>
                ))}
              </div>
            </div>
          </div>
        </section>

        {/* CTA */}
        <section className="py-20 text-center">
          <h2 className="text-4xl md:text-5xl font-black mb-6">ì§€ê¸ˆ ë°”ë¡œ ì‹œì‘í•˜ì„¸ìš”</h2>
          <p className="text-white/40 mb-10 max-w-md mx-auto">ì‹ ìš©ì¹´ë“œ ë¶ˆí•„ìš”. 5GB ë¬´ë£Œ ìŠ¤í† ë¦¬ì§€ë¡œ ë°”ë¡œ ì‹œì‘í•˜ì„¸ìš”.</p>
          <Link
            href="/register"
            className="group inline-flex items-center gap-2 px-10 py-5 bg-white text-black font-black rounded-2xl hover:bg-purple-50 transition-all text-lg shadow-2xl shadow-white/10"
          >
            ë¬´ë£Œë¡œ ì‹œì‘í•˜ê¸°
            <ArrowRight size={20} className="group-hover:translate-x-1 transition-transform" />
          </Link>
        </section>
      </div>

      {/* í‘¸í„° */}
      <footer className="border-t border-white/5 py-10">
        <div className="max-w-6xl mx-auto px-6 flex flex-col md:flex-row items-center justify-between gap-4">
          <div className="flex items-center gap-2">
            <div className="w-6 h-6 rounded-lg bg-gradient-to-br from-purple-500 to-blue-600 flex items-center justify-center">
              <Cloud size={12} className="text-white" />
            </div>
            <span className="text-sm font-bold text-white/40">ì´ìŒ (Eum)</span>
          </div>
          <p className="text-white/20 text-xs font-medium tracking-widest uppercase">
            Â© 2026 EUM CLOUD SERVICE. ALL RIGHTS RESERVED.
          </p>
          <div className="flex gap-4 text-xs text-white/30">
            <Link href="/login" className="hover:text-white/60 transition-colors">ë¡œê·¸ì¸</Link>
            <Link href="/register" className="hover:text-white/60 transition-colors">íšŒì›ê°€ì…</Link>
          </div>
        </div>
      </footer>
    </div>
  );
}
</file>

<file path="src/app/posts/[id]/page.tsx">
"use client";

import { useSession } from "next-auth/react";
import { useRouter, useParams } from "next/navigation";
import { useEffect, useState } from "react";
import Link from "next/link";
import { toast } from "@/components/Toast";
import { useConfirm } from "@/components/ConfirmDialog";

interface Comment {
  id: string;
  content: string;
  createdAt: string;
  user: { id: string; name: string };
}

interface Post {
  id: string;
  title: string;
  content: string;
  visibility: string;
  createdAt: string;
  user: { id: string; name: string; email: string };
  comments: Comment[];
}

// PostShareModalì€ ê¸°ì¡´ ì»´í¬ë„ŒíŠ¸ ê·¸ëŒ€ë¡œ ì‚¬ìš©
import PostShareModal from "@/components/PostShareModal";

export default function PostDetailPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const params = useParams();
  const postId = params.id as string;

  const [post, setPost] = useState<Post | null>(null);
  const [loading, setLoading] = useState(true);
  const [comment, setComment] = useState("");
  const [submitting, setSubmitting] = useState(false);
  const [shareModalOpen, setShareModalOpen] = useState(false);

  const { confirmDialog, openConfirm } = useConfirm();

  useEffect(() => {
    if (status === "unauthenticated") router.push("/login");
  }, [status, router]);

  useEffect(() => {
    if (session && postId) fetchPost();
  }, [session, postId]);

  const fetchPost = async () => {
    try {
      const res = await fetch(`/api/posts/${postId}`);
      if (res.ok) {
        const data = await res.json();
        setPost(data.post);
      } else {
        // âœ… alert() â†’ toast + router.push
        toast.error("ê²Œì‹œê¸€ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤");
        router.push("/posts");
      }
    } catch {
      toast.error("ê²Œì‹œê¸€ ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  };

  const handleCommentSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!comment.trim()) return;
    setSubmitting(true);

    try {
      const res = await fetch(`/api/posts/${postId}/comments`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ content: comment }),
      });

      if (res.ok) {
        setComment("");
        fetchPost();
      } else {
        toast.error("ëŒ“ê¸€ ì‘ì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
      }
    } catch {
      toast.error("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setSubmitting(false);
    }
  };

  const handleDeleteComment = (commentId: string) => {
    // âœ… confirm() â†’ ConfirmDialog
    openConfirm({
      title: "ëŒ“ê¸€ ì‚­ì œ",
      message: "ëŒ“ê¸€ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
      confirmLabel: "ì‚­ì œ",
      variant: "danger",
      onConfirm: async () => {
        try {
          const res = await fetch(`/api/comments/${commentId}`, { method: "DELETE" });
          if (res.ok) {
            fetchPost();
          } else {
            toast.error("ëŒ“ê¸€ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
          }
        } catch {
          toast.error("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
        }
      },
    });
  };

  const handleDeletePost = () => {
    // âœ… confirm() â†’ ConfirmDialog
    openConfirm({
      title: "ê²Œì‹œê¸€ ì‚­ì œ",
      message: "ê²Œì‹œê¸€ì„ ì‚­ì œí•˜ë©´ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
      confirmLabel: "ì‚­ì œ",
      variant: "danger",
      onConfirm: async () => {
        try {
          const res = await fetch(`/api/posts/${postId}`, { method: "DELETE" });
          if (res.ok) {
            toast.success("ê²Œì‹œê¸€ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤");
            router.push("/posts");
          } else {
            toast.error("ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
          }
        } catch {
          toast.error("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
        }
      },
    });
  };

  const getVisibilityBadge = (visibility: string) => {
    const badges: Record<string, { text: string; color: string }> = {
      PUBLIC: { text: "ê³µê°œ", color: "bg-green-100 text-green-700" },
      SHARED: { text: "ê³µìœ ", color: "bg-blue-100 text-blue-700" },
      PRIVATE: { text: "ë¹„ê³µê°œ", color: "bg-gray-100 text-gray-700" },
    };
    return badges[visibility] || badges.PRIVATE;
  };

  if (status === "loading" || loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <p className="text-gray-600">ë¡œë”© ì¤‘...</p>
      </div>
    );
  }

  if (!session || !post) return null;

  const isAuthor = post.user.id === session.user.id;
  const badge = getVisibilityBadge(post.visibility);

  return (
    <div className="min-h-screen bg-gray-50">
      {confirmDialog}

      <header className="bg-white shadow">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
          <Link href="/posts" className="text-gray-600 hover:text-gray-900">
            â† ëª©ë¡ìœ¼ë¡œ
          </Link>
        </div>
      </header>

      <main className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        {/* ê²Œì‹œê¸€ ë³¸ë¬¸ */}
        <div className="bg-white rounded-lg shadow p-6 mb-6">
          <div className="flex items-start justify-between mb-4">
            <div className="flex-1">
              <h1 className="text-2xl font-bold text-gray-900 mb-2">{post.title}</h1>
              <div className="flex items-center gap-4 text-sm text-gray-500">
                <span>{post.user.name}</span>
                <span>â€¢</span>
                <span>{new Date(post.createdAt).toLocaleDateString("ko-KR")}</span>
                <span className={`px-2 py-1 text-xs rounded-full ${badge.color}`}>
                  {badge.text}
                </span>
              </div>
            </div>
            {isAuthor && (
              <div className="flex gap-2">
                {post.visibility === "SHARED" && (
                  <button
                    onClick={() => setShareModalOpen(true)}
                    className="px-3 py-1 text-sm text-blue-600 border border-blue-300 hover:bg-blue-50 rounded"
                  >
                    ê³µìœ  ê´€ë¦¬
                  </button>
                )}
                <button
                  onClick={handleDeletePost}
                  className="px-3 py-1 text-sm text-red-600 border border-red-300 hover:bg-red-50 rounded"
                >
                  ì‚­ì œ
                </button>
              </div>
            )}
          </div>

          {post.visibility === "SHARED" && (
            <div className="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-md">
              <p className="text-sm text-blue-800">
                ğŸ”— ì´ ê²Œì‹œê¸€ì€ <strong>íŠ¹ì • ì‚¬ìš©ìì—ê²Œë§Œ ê³µìœ </strong>ëœ ìƒíƒœì…ë‹ˆë‹¤.
                {isAuthor && <> "ê³µìœ  ê´€ë¦¬" ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ê³µìœ  ëŒ€ìƒì„ ê´€ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</>}
              </p>
            </div>
          )}

          <div className="prose max-w-none">
            <p className="whitespace-pre-wrap text-gray-700">{post.content}</p>
          </div>
        </div>

        {/* ëŒ“ê¸€ */}
        <div className="bg-white rounded-lg shadow p-6">
          <h2 className="text-lg font-semibold text-gray-900 mb-4">
            ëŒ“ê¸€ ({post.comments.length})
          </h2>

          <form onSubmit={handleCommentSubmit} className="mb-6">
            <textarea
              value={comment}
              onChange={(e) => setComment(e.target.value)}
              rows={3}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 mb-2 text-gray-900"
              placeholder="ëŒ“ê¸€ì„ ì…ë ¥í•˜ì„¸ìš”"
            />
            <div className="flex justify-end">
              <button
                type="submit"
                disabled={submitting || !comment.trim()}
                className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:bg-gray-400 transition"
              >
                {submitting ? "ì‘ì„± ì¤‘..." : "ëŒ“ê¸€ ì‘ì„±"}
              </button>
            </div>
          </form>

          <div className="space-y-4">
            {post.comments.length === 0 ? (
              <p className="text-center text-gray-500 py-4">ì²« ëŒ“ê¸€ì„ ì‘ì„±í•´ë³´ì„¸ìš”</p>
            ) : (
              post.comments.map((c) => (
                <div key={c.id} className="border-t pt-4 first:border-t-0 first:pt-0">
                  <div className="flex items-start justify-between">
                    <div className="flex-1">
                      <div className="flex items-center gap-2 mb-1">
                        <span className="font-medium text-gray-900">{c.user.name}</span>
                        <span className="text-sm text-gray-500">
                          {new Date(c.createdAt).toLocaleDateString("ko-KR")}
                        </span>
                      </div>
                      <p className="text-gray-700">{c.content}</p>
                    </div>
                    {c.user.id === session.user.id && (
                      <button
                        onClick={() => handleDeleteComment(c.id)}
                        className="text-red-500 hover:text-red-700 text-sm ml-4 flex-shrink-0"
                      >
                        ì‚­ì œ
                      </button>
                    )}
                  </div>
                </div>
              ))
            )}
          </div>
        </div>
      </main>

      {shareModalOpen && (
        <PostShareModal
          postId={postId}
          postTitle={post.title}
          onClose={() => setShareModalOpen(false)}
        />
      )}
    </div>
  );
}
</file>

<file path="src/app/posts/new/page.tsx">
"use client";

import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import { useState, useEffect } from "react";
import Link from "next/link";
import { toast } from "@/components/Toast";

export default function NewPostPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const [formData, setFormData] = useState({
    title: "",
    content: "",
    visibility: "PRIVATE",
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  useEffect(() => {
    if (status === "unauthenticated") router.push("/login");
  }, [status, router]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");
    setLoading(true);

    try {
      const res = await fetch("/api/posts", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(formData),
      });

      const data = await res.json();

      if (!res.ok) {
        setError(data.error || "ê²Œì‹œê¸€ ì‘ì„± ì‹¤íŒ¨");
        setLoading(false);
        return;
      }

      // âœ… alert() â†’ toast (ì‘ì„± ì™„ë£Œ í›„ ë°”ë¡œ ì´ë™í•˜ë¯€ë¡œ toast.successë¡œ ì¶©ë¶„)
      toast.success("ê²Œì‹œê¸€ì´ ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤");
      router.push(`/posts/${data.post.id}`);
    } catch {
      setError("ì‘ì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
      setLoading(false);
    }
  };

  if (status === "loading") {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <p className="text-gray-600">ë¡œë”© ì¤‘...</p>
      </div>
    );
  }

  if (!session) return null;

  return (
    <div className="min-h-screen bg-gray-50">
      <header className="bg-white shadow">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
          <div className="flex items-center gap-4">
            <Link href="/posts" className="text-gray-600 hover:text-gray-900">
              â† ëª©ë¡
            </Link>
            <h1 className="text-2xl font-bold text-gray-900">ê¸€ì“°ê¸°</h1>
          </div>
        </div>
      </header>

      <main className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div className="bg-white rounded-lg shadow p-6">
          {error && (
            <div className="mb-4 p-4 bg-red-50 border border-red-200 rounded-md">
              <p className="text-sm text-red-800">{error}</p>
            </div>
          )}

          <form onSubmit={handleSubmit} className="space-y-6">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">ì œëª©</label>
              <input
                type="text"
                value={formData.title}
                onChange={(e) => setFormData({ ...formData, title: e.target.value })}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-900"
                placeholder="ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”"
                required
              />
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">ê³µê°œ ì„¤ì •</label>
              <select
                value={formData.visibility}
                onChange={(e) => setFormData({ ...formData, visibility: e.target.value })}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-900"
              >
                <option value="PRIVATE">ë¹„ê³µê°œ</option>
                <option value="SHARED">ê³µìœ </option>
                <option value="PUBLIC">ê³µê°œ</option>
              </select>
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">ë‚´ìš©</label>
              <textarea
                value={formData.content}
                onChange={(e) => setFormData({ ...formData, content: e.target.value })}
                rows={15}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-900"
                placeholder="ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”"
                required
              />
            </div>

            <div className="flex justify-end gap-2">
              <Link
                href="/posts"
                className="px-4 py-2 text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50"
              >
                ì·¨ì†Œ
              </Link>
              <button
                type="submit"
                disabled={loading}
                className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:bg-gray-400 transition"
              >
                {loading ? "ì‘ì„± ì¤‘..." : "ì‘ì„±í•˜ê¸°"}
              </button>
            </div>
          </form>
        </div>
      </main>
    </div>
  );
}
</file>

<file path="src/app/posts/page.tsx">
"use client";

import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import { useEffect, useState } from "react";
import Link from "next/link";
import SearchBar from "@/components/SearchBar";

interface Post {
  id: string;
  title: string;
  content: string;
  visibility: string;
  createdAt: string;
  user: {
    id: string;
    name: string;
  };
  _count: {
    comments: number;
  };
  isOwner: boolean;
  isShared: boolean;
  sharedBy?: string;
}

export default function PostsPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const [posts, setPosts] = useState<Post[]>([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState<"all" | "my" | "public" | "shared">("all");
  const [searchQuery, setSearchQuery] = useState("");

  useEffect(() => {
    if (status === "unauthenticated") {
      router.push("/login");
    }
  }, [status, router]);

  useEffect(() => {
    if (session) {
      fetchPosts();
    }
  }, [session, filter, searchQuery]);

  const fetchPosts = async () => {
    setLoading(true);
    try {
      const params = new URLSearchParams();
      if (filter !== "all") {
        params.set("visibility", filter);
      }
      if (searchQuery) {
        params.set("search", searchQuery);
      }

      const res = await fetch(`/api/posts?${params}`);
      if (res.ok) {
        const data = await res.json();
        setPosts(data.posts);
      } else {
        console.error("Failed to fetch posts");
      }
    } catch (err) {
      console.error("Failed to fetch posts:", err);
    } finally {
      setLoading(false);
    }
  };

  const getVisibilityBadge = (visibility: string) => {
    const badges = {
      PUBLIC: { text: "ê³µê°œ", color: "bg-green-100 text-green-700" },
      SHARED: { text: "ê³µìœ ", color: "bg-blue-100 text-blue-700" },
      PRIVATE: { text: "ë¹„ê³µê°œ", color: "bg-gray-100 text-gray-700" },
    };
    return badges[visibility as keyof typeof badges] || badges.PRIVATE;
  };

  if (status === "loading") {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <p className="text-gray-600">ë¡œë”© ì¤‘...</p>
      </div>
    );
  }

  if (!session) return null;

  return (
    <div className="min-h-screen bg-gray-50">
      {/* í—¤ë” */}
      <header className="bg-white shadow">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4 flex justify-between items-center">
          <div className="flex items-center gap-4">
            <Link href="/dashboard" className="text-2xl">
              â˜ï¸
            </Link>
            <h1 className="text-2xl font-bold text-gray-900">ê²Œì‹œíŒ</h1>
          </div>
          <Link
            href="/posts/new"
            className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
          >
            ê¸€ì“°ê¸°
          </Link>
        </div>
      </header>

      {/* ë©”ì¸ */}
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        {/* í•„í„° */}
        <div className="flex gap-2 mb-4">
          <button
            onClick={() => setFilter("all")}
            className={`px-4 py-2 rounded-md ${
              filter === "all"
                ? "bg-blue-600 text-white"
                : "bg-white text-gray-700 border hover:bg-gray-50"
            }`}
          >
            ì „ì²´
          </button>
          <button
            onClick={() => setFilter("my")}
            className={`px-4 py-2 rounded-md ${
              filter === "my"
                ? "bg-blue-600 text-white"
                : "bg-white text-gray-700 border hover:bg-gray-50"
            }`}
          >
            ë‚´ ê¸€
          </button>
          <button
            onClick={() => setFilter("public")}
            className={`px-4 py-2 rounded-md ${
              filter === "public"
                ? "bg-green-600 text-white"
                : "bg-white text-gray-700 border hover:bg-gray-50"
            }`}
          >
            ê³µê°œ ê¸€
          </button>
          <button
            onClick={() => setFilter("shared")}
            className={`px-4 py-2 rounded-md ${
              filter === "shared"
                ? "bg-purple-600 text-white"
                : "bg-white text-gray-700 border hover:bg-gray-50"
            }`}
          >
            ê³µìœ ë°›ì€ ê¸€
          </button>
        </div>

        {/* ê²€ìƒ‰ */}
        <div className="mb-6">
          <SearchBar
            onSearch={setSearchQuery}
            placeholder="ê²Œì‹œê¸€ ê²€ìƒ‰..."
          />
        </div>

        {/* ì„¤ëª… */}
        <div className="mb-4 p-4 bg-blue-50 border border-blue-200 rounded-md">
          <p className="text-sm text-blue-800">
            <strong>ğŸ’¡ ê³µê°œ ì„¤ì • ì•ˆë‚´:</strong>
            <br />
            â€¢ <strong>ë¹„ê³µê°œ</strong>: ë‚˜ë§Œ ë³¼ ìˆ˜ ìˆìŒ
            <br />
            â€¢ <strong>ê³µìœ </strong>: íŠ¹ì • ì‚¬ìš©ìì—ê²Œë§Œ ê³µìœ  (íŒŒì¼ì²˜ëŸ¼ ì´ë©”ì¼ë¡œ ê³µìœ )
            <br />
            â€¢ <strong>ê³µê°œ</strong>: ëª¨ë“  ì‚¬ìš©ìê°€ ë³¼ ìˆ˜ ìˆìŒ
          </p>
        </div>

        {/* ê²Œì‹œê¸€ ëª©ë¡ */}
        {loading ? (
          <p className="text-center text-gray-500 py-8">ë¡œë”© ì¤‘...</p>
        ) : posts.length === 0 ? (
          <div className="bg-white rounded-lg shadow p-8 text-center">
            <p className="text-gray-500">ê²Œì‹œê¸€ì´ ì—†ìŠµë‹ˆë‹¤</p>
            <Link
              href="/posts/new"
              className="inline-block mt-4 text-blue-600 hover:text-blue-700"
            >
              ì²« ê²Œì‹œê¸€ì„ ì‘ì„±í•´ë³´ì„¸ìš”
            </Link>
          </div>
        ) : (
          <div className="space-y-4">
            {posts.map((post) => {
              const badge = getVisibilityBadge(post.visibility);
              
              return (
                <Link
                  key={post.id}
                  href={`/posts/${post.id}`}
                  className={`block bg-white rounded-lg shadow hover:shadow-md transition p-6 ${
                    post.isShared ? "border-2 border-purple-300" : ""
                  }`}
                >
                  {/* ê³µìœ ë°›ì€ ê¸€ í—¤ë” */}
                  {post.isShared && (
                    <div className="mb-3 flex items-center gap-2 text-sm text-purple-700 bg-purple-50 px-3 py-2 rounded">
                      <span>ğŸ”—</span>
                      <span><strong>{post.sharedBy}ë‹˜</strong>ì´ ê³µìœ í•œ ê¸€</span>
                    </div>
                  )}

                  <div className="flex items-start justify-between">
                    <div className="flex-1">
                      <div className="flex items-center gap-2 mb-2">
                        <h3 className="text-lg font-semibold text-gray-900">
                          {post.title}
                        </h3>
                        {post.isShared && (
                          <span className="px-2 py-1 text-xs bg-purple-100 text-purple-700 rounded">
                            ê³µìœ ë°›ìŒ
                          </span>
                        )}
                      </div>
                      <p className="text-gray-600 mb-3 line-clamp-2">
                        {post.content}
                      </p>
                      <div className="flex items-center gap-4 text-sm text-gray-500">
                        <span>{post.isShared ? post.sharedBy : post.user.name}</span>
                        <span>â€¢</span>
                        <span>
                          {new Date(post.createdAt).toLocaleDateString("ko-KR")}
                        </span>
                        <span>â€¢</span>
                        <span>ëŒ“ê¸€ {post._count.comments}</span>
                      </div>
                    </div>
                    <span className={`px-3 py-1 text-xs rounded-full ${badge.color}`}>
                      {badge.text}
                    </span>
                  </div>
                </Link>
              );
            })}
          </div>
        )}
      </main>
    </div>
  );
}
</file>

<file path="src/app/search/page.tsx">
"use client";

import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import { useEffect, useState } from "react";
import Link from "next/link";
import { toast } from "@/components/Toast";
import { useConfirm } from "@/components/ConfirmDialog";

interface SearchResult { files: any[]; posts: any[]; total: number; }
interface SavedSearch { id: string; name: string; query: string; filters: string; createdAt: string; }
interface Tag { id: string; name: string; }

export default function SearchPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const { confirmDialog, openConfirm } = useConfirm();

  const [query, setQuery] = useState("");
  const [results, setResults] = useState<SearchResult>({ files: [], posts: [], total: 0 });
  const [loading, setLoading] = useState(false);
  const [hasSearched, setHasSearched] = useState(false);

  const [showFilters, setShowFilters] = useState(false);
  const [filterType, setFilterType] = useState<"ALL" | "FILE" | "POST">("ALL");
  const [filterMimeType, setFilterMimeType] = useState("");
  const [filterTagIds, setFilterTagIds] = useState<string[]>([]);
  const [filterDateFrom, setFilterDateFrom] = useState("");
  const [filterDateTo, setFilterDateTo] = useState("");

  const [allTags, setAllTags] = useState<Tag[]>([]);
  const [savedSearches, setSavedSearches] = useState<SavedSearch[]>([]);
  const [showSaveModal, setShowSaveModal] = useState(false);
  const [saveSearchName, setSaveSearchName] = useState("");
  const [showSavedList, setShowSavedList] = useState(false);

  useEffect(() => {
    if (status === "unauthenticated") router.push("/login");
  }, [status, router]);

  useEffect(() => {
    if (session) { fetchTags(); fetchSavedSearches(); }
  }, [session]);

  const fetchTags = async () => {
    try {
      const res = await fetch("/api/tags");
      if (res.ok) setAllTags((await res.json()).tags || []);
    } catch {}
  };

  const fetchSavedSearches = async () => {
    try {
      const res = await fetch("/api/search/saved");
      if (res.ok) setSavedSearches((await res.json()).savedSearches || []);
    } catch {}
  };

  const activeFilterCount = [
    filterType !== "ALL",
    filterMimeType !== "",
    filterTagIds.length > 0,
    filterDateFrom !== "",
    filterDateTo !== "",
  ].filter(Boolean).length;

  const handleSearch = async (overrideQuery?: string) => {
    const searchQuery = overrideQuery ?? query;
    // âœ… alert() â†’ toast.warning
    if (!searchQuery.trim() && filterTagIds.length === 0) {
      toast.warning("ê²€ìƒ‰ì–´ ë˜ëŠ” íƒœê·¸ë¥¼ ì„ íƒí•˜ì„¸ìš”");
      return;
    }

    setLoading(true);
    setHasSearched(true);

    try {
      const params = new URLSearchParams();
      if (searchQuery.trim()) params.set("q", searchQuery.trim());
      if (filterType !== "ALL") params.set("type", filterType);
      if (filterMimeType) params.set("mimeType", filterMimeType);
      if (filterTagIds.length > 0) params.set("tags", filterTagIds.join(","));
      if (filterDateFrom) params.set("dateFrom", filterDateFrom);
      if (filterDateTo) params.set("dateTo", filterDateTo);

      const res = await fetch(`/api/search?${params}`);
      if (res.ok) {
        setResults(await res.json());
      } else {
        toast.error("ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
      }
    } catch {
      toast.error("ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  };

  const handleResetFilters = () => {
    setFilterType("ALL");
    setFilterMimeType("");
    setFilterTagIds([]);
    setFilterDateFrom("");
    setFilterDateTo("");
  };

  const handleToggleTag = (tagId: string) =>
    setFilterTagIds((prev) =>
      prev.includes(tagId) ? prev.filter((id) => id !== tagId) : [...prev, tagId]
    );

  const handleSaveSearch = async () => {
    // âœ… alert() â†’ toast.warning
    if (!saveSearchName.trim()) {
      toast.warning("ê²€ìƒ‰ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”");
      return;
    }
    try {
      const filters = JSON.stringify({
        type: filterType, mimeType: filterMimeType,
        tagIds: filterTagIds, dateFrom: filterDateFrom, dateTo: filterDateTo,
      });
      const res = await fetch("/api/search/saved", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name: saveSearchName.trim(), query, filters }),
      });
      if (res.ok) {
        toast.success("ê²€ìƒ‰ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤");
        setShowSaveModal(false);
        setSaveSearchName("");
        fetchSavedSearches();
      } else {
        toast.error("ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
      }
    } catch {
      toast.error("ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    }
  };

  const handleLoadSavedSearch = (saved: SavedSearch) => {
    setQuery(saved.query || "");
    try {
      const filters = JSON.parse(saved.filters || "{}");
      setFilterType(filters.type || "ALL");
      setFilterMimeType(filters.mimeType || "");
      setFilterTagIds(filters.tagIds || []);
      setFilterDateFrom(filters.dateFrom || "");
      setFilterDateTo(filters.dateTo || "");
    } catch {}
    setShowSavedList(false);
    handleSearch(saved.query || "");
  };

  const handleDeleteSavedSearch = (id: string) => {
    // âœ… confirm() â†’ ConfirmDialog
    openConfirm({
      title: "ì €ì¥ëœ ê²€ìƒ‰ ì‚­ì œ",
      message: "ì €ì¥ëœ ê²€ìƒ‰ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
      confirmLabel: "ì‚­ì œ",
      variant: "danger",
      onConfirm: async () => {
        try {
          const res = await fetch(`/api/search/saved/${id}`, { method: "DELETE" });
          if (res.ok) {
            fetchSavedSearches();
            toast.success("ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤");
          }
        } catch {}
      },
    });
  };

  if (status === "loading") {
    return <div className="min-h-screen flex items-center justify-center">ë¡œë”© ì¤‘...</div>;
  }
  if (!session) return null;

  return (
    <div className="min-h-screen bg-gray-50">
      {confirmDialog}

      <header className="bg-white shadow">
        <div className="max-w-4xl mx-auto px-4 py-4 flex justify-between items-center">
          <h1 className="text-xl font-bold">ğŸ” ê²€ìƒ‰</h1>
          <Link href="/dashboard" className="text-sm text-blue-600 hover:text-blue-700">
            â† ëŒ€ì‹œë³´ë“œ
          </Link>
        </div>
      </header>

      <main className="max-w-4xl mx-auto px-4 py-6">
        {/* ê²€ìƒ‰ì°½ */}
        <div className="bg-white shadow rounded-lg p-5 mb-4">
          <div className="flex gap-2 mb-3">
            <input
              type="text"
              value={query}
              onChange={(e) => setQuery(e.target.value)}
              onKeyDown={(e) => e.key === "Enter" && handleSearch()}
              placeholder="íŒŒì¼ëª…, ê²Œì‹œê¸€ ì œëª©ìœ¼ë¡œ ê²€ìƒ‰..."
              className="flex-1 px-4 py-2.5 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm text-gray-900"
            />
            <button
              onClick={() => handleSearch()}
              disabled={loading}
              className="px-5 py-2.5 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:bg-gray-400 text-sm font-medium"
            >
              {loading ? "ê²€ìƒ‰ ì¤‘..." : "ê²€ìƒ‰"}
            </button>
          </div>

          <div className="flex items-center gap-2">
            <button
              onClick={() => setShowFilters(!showFilters)}
              className={`flex items-center gap-1.5 px-3 py-1.5 rounded-md text-sm border transition ${
                showFilters
                  ? "bg-blue-50 border-blue-300 text-blue-700"
                  : "bg-gray-50 border-gray-300 text-gray-600 hover:bg-gray-100"
              }`}
            >
              <span>âš™ï¸ í•„í„°</span>
              {activeFilterCount > 0 && (
                <span className="bg-blue-600 text-white text-xs rounded-full w-4 h-4 flex items-center justify-center">
                  {activeFilterCount}
                </span>
              )}
            </button>

            {activeFilterCount > 0 && (
              <button
                onClick={handleResetFilters}
                className="px-3 py-1.5 text-xs text-red-500 hover:text-red-700 border border-red-200 rounded-md hover:bg-red-50"
              >
                í•„í„° ì´ˆê¸°í™”
              </button>
            )}

            <div className="ml-auto flex gap-2">
              {hasSearched && (
                <button
                  onClick={() => setShowSaveModal(true)}
                  className="px-3 py-1.5 text-xs text-green-600 border border-green-300 rounded-md hover:bg-green-50"
                >
                  ğŸ’¾ ê²€ìƒ‰ ì €ì¥
                </button>
              )}
              {savedSearches.length > 0 && (
                <button
                  onClick={() => setShowSavedList(!showSavedList)}
                  className="px-3 py-1.5 text-xs text-purple-600 border border-purple-300 rounded-md hover:bg-purple-50"
                >
                  ğŸ“‹ ì €ì¥ëœ ê²€ìƒ‰ ({savedSearches.length})
                </button>
              )}
            </div>
          </div>

          {/* í•„í„° íŒ¨ë„ */}
          {showFilters && (
            <div className="mt-4 pt-4 border-t space-y-4">
              <div>
                <p className="text-xs font-semibold text-gray-500 uppercase mb-2">ê²€ìƒ‰ ëŒ€ìƒ</p>
                <div className="flex gap-2">
                  {(["ALL", "FILE", "POST"] as const).map((type) => (
                    <button
                      key={type}
                      onClick={() => setFilterType(type)}
                      className={`px-3 py-1.5 text-sm rounded-full border transition ${
                        filterType === type
                          ? "bg-blue-600 text-white border-blue-600"
                          : "bg-white text-gray-600 border-gray-300 hover:bg-gray-50"
                      }`}
                    >
                      {type === "ALL" ? "ì „ì²´" : type === "FILE" ? "ğŸ“„ íŒŒì¼ë§Œ" : "ğŸ“ ê²Œì‹œê¸€ë§Œ"}
                    </button>
                  ))}
                </div>
              </div>

              {(filterType === "ALL" || filterType === "FILE") && (
                <div>
                  <p className="text-xs font-semibold text-gray-500 uppercase mb-2">íŒŒì¼ íƒ€ì…</p>
                  <div className="flex flex-wrap gap-2">
                    {[
                      { label: "ì „ì²´", value: "" },
                      { label: "ğŸ–¼ï¸ ì´ë¯¸ì§€", value: "image" },
                      { label: "ğŸ“¹ ë™ì˜ìƒ", value: "video" },
                      { label: "ğŸ“„ PDF", value: "pdf" },
                      { label: "ğŸ“Š ë¬¸ì„œ", value: "document" },
                      { label: "ğŸ—œï¸ ì••ì¶•", value: "zip" },
                    ].map((opt) => (
                      <button
                        key={opt.value}
                        onClick={() => setFilterMimeType(opt.value)}
                        className={`px-3 py-1.5 text-sm rounded-full border transition ${
                          filterMimeType === opt.value
                            ? "bg-green-600 text-white border-green-600"
                            : "bg-white text-gray-600 border-gray-300 hover:bg-gray-50"
                        }`}
                      >
                        {opt.label}
                      </button>
                    ))}
                  </div>
                </div>
              )}

              {allTags.length > 0 && (
                <div>
                  <p className="text-xs font-semibold text-gray-500 uppercase mb-2">
                    íƒœê·¸ í•„í„°
                    {filterTagIds.length > 0 && (
                      <span className="ml-2 text-blue-600 normal-case font-normal">
                        {filterTagIds.length}ê°œ ì„ íƒë¨
                      </span>
                    )}
                  </p>
                  <div className="flex flex-wrap gap-2 max-h-24 overflow-y-auto">
                    {allTags.map((tag) => (
                      <button
                        key={tag.id}
                        onClick={() => handleToggleTag(tag.id)}
                        className={`px-3 py-1 text-sm rounded-full border transition ${
                          filterTagIds.includes(tag.id)
                            ? "bg-orange-500 text-white border-orange-500"
                            : "bg-white text-gray-600 border-gray-300 hover:bg-gray-50"
                        }`}
                      >
                        ğŸ·ï¸ {tag.name}
                      </button>
                    ))}
                  </div>
                </div>
              )}

              <div>
                <p className="text-xs font-semibold text-gray-500 uppercase mb-2">ì—…ë¡œë“œ ë‚ ì§œ</p>
                <div className="flex items-center gap-2">
                  <input
                    type="date"
                    value={filterDateFrom}
                    onChange={(e) => setFilterDateFrom(e.target.value)}
                    className="px-3 py-1.5 border border-gray-300 rounded-md text-sm"
                  />
                  <span className="text-gray-400 text-sm">~</span>
                  <input
                    type="date"
                    value={filterDateTo}
                    onChange={(e) => setFilterDateTo(e.target.value)}
                    className="px-3 py-1.5 border border-gray-300 rounded-md text-sm"
                  />
                  {(filterDateFrom || filterDateTo) && (
                    <button
                      onClick={() => { setFilterDateFrom(""); setFilterDateTo(""); }}
                      className="text-xs text-red-400 hover:text-red-600"
                    >
                      âœ•
                    </button>
                  )}
                </div>
              </div>

              <button
                onClick={() => handleSearch()}
                className="w-full py-2 bg-blue-600 text-white rounded-md text-sm font-medium hover:bg-blue-700"
              >
                ğŸ” í•„í„° ì ìš©í•´ì„œ ê²€ìƒ‰
              </button>
            </div>
          )}

          {/* ì €ì¥ëœ ê²€ìƒ‰ ëª©ë¡ */}
          {showSavedList && savedSearches.length > 0 && (
            <div className="mt-4 pt-4 border-t">
              <p className="text-xs font-semibold text-gray-500 uppercase mb-2">ì €ì¥ëœ ê²€ìƒ‰</p>
              <div className="space-y-2 max-h-48 overflow-y-auto">
                {savedSearches.map((saved) => (
                  <div key={saved.id} className="flex items-center justify-between p-2.5 bg-gray-50 rounded-md">
                    <button onClick={() => handleLoadSavedSearch(saved)} className="flex-1 text-left">
                      <p className="text-sm font-medium text-blue-600 hover:text-blue-800">{saved.name}</p>
                      {saved.query && <p className="text-xs text-gray-400">"{saved.query}"</p>}
                    </button>
                    <button
                      onClick={() => handleDeleteSavedSearch(saved.id)}
                      className="ml-2 text-xs text-red-400 hover:text-red-600"
                    >
                      ì‚­ì œ
                    </button>
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>

        {/* ê²€ìƒ‰ ê²°ê³¼ */}
        {hasSearched && !loading && (
          <div className="bg-white shadow rounded-lg p-5">
            {results.total === 0 ? (
              <div className="text-center py-8">
                <p className="text-gray-500 text-lg mb-2">ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤</p>
                <p className="text-gray-400 text-sm">ë‹¤ë¥¸ ê²€ìƒ‰ì–´ë‚˜ í•„í„°ë¥¼ ì‚¬ìš©í•´ë³´ì„¸ìš”</p>
              </div>
            ) : (
              <>
                <div className="flex items-center justify-between mb-4">
                  <h2 className="font-semibold">
                    ê²€ìƒ‰ ê²°ê³¼ <span className="text-blue-600">({results.total}ê°œ)</span>
                  </h2>
                  <div className="flex gap-2 text-xs text-gray-500">
                    {results.files.length > 0 && <span>ğŸ“„ íŒŒì¼ {results.files.length}ê°œ</span>}
                    {results.posts.length > 0 && <span>ğŸ“ ê²Œì‹œê¸€ {results.posts.length}ê°œ</span>}
                  </div>
                </div>

                {results.files.length > 0 && (
                  <div className="mb-5">
                    <h3 className="text-sm font-semibold text-gray-600 mb-2">ğŸ“„ íŒŒì¼ ({results.files.length})</h3>
                    <div className="space-y-2">
                      {results.files.map((file: any) => (
                        <div
                          key={file.id}
                          className="flex items-center gap-3 p-3 border rounded-md hover:bg-gray-50 cursor-pointer"
                          onClick={() => router.push("/dashboard")}
                        >
                          <div className="w-10 h-10 rounded bg-gray-100 flex-shrink-0 overflow-hidden">
                            {file.thumbnailUrl ? (
                              <img src={file.thumbnailUrl} alt="" className="w-full h-full object-cover" />
                            ) : (
                              <div className="w-full h-full flex items-center justify-center text-lg">
                                {file.mimeType?.startsWith("image/") ? "ğŸ–¼ï¸" :
                                 file.mimeType?.startsWith("video/") ? "ğŸ¥" :
                                 file.mimeType === "application/pdf" ? "ğŸ“•" : "ğŸ“„"}
                              </div>
                            )}
                          </div>
                          <div className="flex-1 min-w-0">
                            <p className="font-medium text-sm truncate">{file.originalName}</p>
                            <div className="flex items-center gap-2 mt-0.5">
                              <span className="text-xs text-gray-400">
                                {(parseInt(file.size) / 1024 / 1024).toFixed(2)} MB
                              </span>
                              <span className="text-xs text-gray-300">â€¢</span>
                              <span className="text-xs text-gray-400">
                                {new Date(file.createdAt).toLocaleDateString("ko-KR")}
                              </span>
                              {file.fileTags?.map((ft: any) => (
                                <span key={ft.tag.id} className="px-1.5 py-0.5 text-xs bg-blue-100 text-blue-600 rounded-full">
                                  {ft.tag.name}
                                </span>
                              ))}
                            </div>
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}

                {results.posts.length > 0 && (
                  <div>
                    <h3 className="text-sm font-semibold text-gray-600 mb-2">ğŸ“ ê²Œì‹œê¸€ ({results.posts.length})</h3>
                    <div className="space-y-2">
                      {results.posts.map((post: any) => (
                        <Link key={post.id} href={`/posts/${post.id}`} className="block p-3 border rounded-md hover:bg-gray-50">
                          <div className="flex items-start justify-between">
                            <div className="flex-1 min-w-0">
                              <p className="font-medium text-sm">{post.title}</p>
                              <p className="text-xs text-gray-500 mt-0.5 line-clamp-1">{post.content}</p>
                            </div>
                            <span className={`ml-2 px-2 py-0.5 text-xs rounded-full flex-shrink-0 ${
                              post.visibility === "PUBLIC" ? "bg-green-100 text-green-700" :
                              post.visibility === "SHARED" ? "bg-blue-100 text-blue-700" :
                              "bg-gray-100 text-gray-600"
                            }`}>
                              {post.visibility === "PUBLIC" ? "ê³µê°œ" :
                               post.visibility === "SHARED" ? "ê³µìœ " : "ë¹„ê³µê°œ"}
                            </span>
                          </div>
                          <div className="flex items-center gap-2 mt-1">
                            <span className="text-xs text-gray-400">
                              {new Date(post.createdAt).toLocaleDateString("ko-KR")}
                            </span>
                            {post.postTags?.map((pt: any) => (
                              <span key={pt.tag.id} className="px-1.5 py-0.5 text-xs bg-orange-100 text-orange-600 rounded-full">
                                {pt.tag.name}
                              </span>
                            ))}
                          </div>
                        </Link>
                      ))}
                    </div>
                  </div>
                )}
              </>
            )}
          </div>
        )}
      </main>

      {/* ê²€ìƒ‰ ì €ì¥ ëª¨ë‹¬ */}
      {showSaveModal && (
        <div
          className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 p-4"
          onClick={() => setShowSaveModal(false)}
        >
          <div className="bg-white rounded-lg shadow-xl max-w-sm w-full p-5" onClick={(e) => e.stopPropagation()}>
            <h3 className="text-base font-semibold mb-3">ğŸ’¾ ê²€ìƒ‰ ì €ì¥</h3>
            <input
              type="text"
              value={saveSearchName}
              onChange={(e) => setSaveSearchName(e.target.value)}
              onKeyDown={(e) => e.key === "Enter" && handleSaveSearch()}
              placeholder="ì €ì¥í•  ê²€ìƒ‰ ì´ë¦„ (ì˜ˆ: íƒœêµ­ì—¬í–‰ ì´ë¯¸ì§€)"
              className="w-full px-3 py-2 border rounded-md text-sm mb-3 text-gray-900"
              autoFocus
            />
            <div className="text-xs text-gray-500 mb-4 space-y-0.5">
              {query && <p>ê²€ìƒ‰ì–´: "{query}"</p>}
              {filterType !== "ALL" && <p>ëŒ€ìƒ: {filterType}</p>}
              {filterMimeType && <p>íƒ€ì…: {filterMimeType}</p>}
              {filterTagIds.length > 0 && <p>íƒœê·¸: {filterTagIds.length}ê°œ</p>}
              {(filterDateFrom || filterDateTo) && <p>ë‚ ì§œ: {filterDateFrom} ~ {filterDateTo}</p>}
            </div>
            <div className="flex justify-end gap-2">
              <button
                onClick={() => setShowSaveModal(false)}
                className="px-3 py-1.5 text-sm text-gray-600 hover:bg-gray-100 rounded-md"
              >
                ì·¨ì†Œ
              </button>
              <button
                onClick={handleSaveSearch}
                className="px-3 py-1.5 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700"
              >
                ì €ì¥
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/app/settings/2fa/page.tsx">
"use client";

import { useState } from "react";
import Link from "next/link";
import Image from "next/image";
import { ChevronLeft, Shield, ShieldCheck, ShieldOff, Copy, Eye, EyeOff, AlertTriangle } from "lucide-react";
import { toast } from "@/components/Toast";

type Step = "idle" | "qr" | "verify" | "backup" | "disable";

interface SetupData {
  qrCode: string;
  manualKey: string;
}

export default function TwoFactorPage() {
  const [isEnabled, setIsEnabled] = useState(false); // ì‹¤ì œë¡  APIì—ì„œ ê°€ì ¸ì™€ì•¼ í•¨
  const [step, setStep] = useState<Step>("idle");
  const [setupData, setSetupData] = useState<SetupData | null>(null);
  const [otp, setOtp] = useState("");
  const [backupCodes, setBackupCodes] = useState<string[]>([]);
  const [showManualKey, setShowManualKey] = useState(false);
  const [loading, setLoading] = useState(false);
  const [disableCode, setDisableCode] = useState("");

  // ì´ˆê¸° ìƒíƒœ ë¡œë“œ
  useState(() => {
    fetch("/api/users/me")
      .then((r) => r.json())
      .then((d) => setIsEnabled(d.twoFactorEnabled ?? false))
      .catch(() => {});
  });

  // QRì½”ë“œ ìƒì„± ìš”ì²­
  const startSetup = async () => {
    setLoading(true);
    try {
      const res = await fetch("/api/auth/2fa/setup", { method: "POST" });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error);
      setSetupData({ qrCode: data.qrCode, manualKey: data.manualKey });
      setStep("qr");
    } catch (e: any) {
      toast.error(e.message || "QRì½”ë“œ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  };

  // OTP ê²€ì¦ ë° í™œì„±í™”
  const verifyAndActivate = async () => {
    if (otp.replace(/\s/g, "").length !== 6) {
      toast.error("6ìë¦¬ ì½”ë“œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”");
      return;
    }
    setLoading(true);
    try {
      const res = await fetch("/api/auth/2fa/setup", {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ code: otp }),
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error);
      setBackupCodes(data.backupCodes);
      setIsEnabled(true);
      setStep("backup");
      setOtp("");
    } catch (e: any) {
      toast.error(e.message || "ì½”ë“œê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  };

  // 2FA ë¹„í™œì„±í™”
  const disable2FA = async () => {
    setLoading(true);
    try {
      const res = await fetch("/api/auth/2fa/disable", {
        method: "DELETE",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ code: disableCode }),
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error);
      setIsEnabled(false);
      setStep("idle");
      setDisableCode("");
      toast.success("2ë‹¨ê³„ ì¸ì¦ì´ ë¹„í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤");
    } catch (e: any) {
      toast.error(e.message || "ì½”ë“œê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  };

  const copyToClipboard = (text: string) => {
    navigator.clipboard.writeText(text);
    toast.success("ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤");
  };

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900">
      {/* í—¤ë” */}
      <div className="bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700 sticky top-0 z-10">
        <div className="max-w-2xl mx-auto px-4 py-3 flex items-center gap-3">
          <Link href="/profile" className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
            <ChevronLeft size={20} className="text-gray-600 dark:text-slate-400" />
          </Link>
          <Shield size={20} className="text-gray-800 dark:text-slate-200" />
          <h1 className="text-lg font-semibold text-gray-900 dark:text-slate-100 flex-1">
            2ë‹¨ê³„ ì¸ì¦
          </h1>
          {isEnabled && (
            <span className="flex items-center gap-1 text-xs font-semibold text-green-600 bg-green-50 dark:bg-green-900/30 px-2 py-1 rounded-full">
              <ShieldCheck size={12} /> í™œì„±í™”ë¨
            </span>
          )}
        </div>
      </div>

      <div className="max-w-2xl mx-auto px-4 py-6 space-y-4">

        {/* â”€â”€ IDLE: í˜„ì¬ ìƒíƒœ + ì‹œì‘ ë²„íŠ¼ â”€â”€ */}
        {step === "idle" && (
          <>
            <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-6">
              <div className="flex items-start gap-4">
                <div className={`w-12 h-12 rounded-full flex items-center justify-center shrink-0 ${
                  isEnabled ? "bg-green-50 dark:bg-green-900/30" : "bg-gray-100 dark:bg-slate-700"
                }`}>
                  {isEnabled
                    ? <ShieldCheck size={24} className="text-green-600" />
                    : <Shield size={24} className="text-gray-500 dark:text-slate-400" />
                  }
                </div>
                <div>
                  <p className="font-semibold text-gray-900 dark:text-slate-100">
                    {isEnabled ? "2ë‹¨ê³„ ì¸ì¦ í™œì„±í™”ë¨" : "2ë‹¨ê³„ ì¸ì¦ ë¹„í™œì„±í™”"}
                  </p>
                  <p className="text-sm text-gray-500 dark:text-slate-400 mt-1">
                    {isEnabled
                      ? "ë¡œê·¸ì¸ ì‹œ ì¸ì¦ ì•±ì˜ 6ìë¦¬ ì½”ë“œê°€ í•„ìš”í•©ë‹ˆë‹¤."
                      : "TOTP ì¸ì¦ ì•±(Google Authenticator, Authy ë“±)ì„ ì‚¬ìš©í•´ ê³„ì •ì„ ë”ìš± ì•ˆì „í•˜ê²Œ ë³´í˜¸í•˜ì„¸ìš”."}
                  </p>
                </div>
              </div>
            </div>

            {!isEnabled ? (
              <button
                onClick={startSetup}
                disabled={loading}
                className="w-full py-3 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 disabled:opacity-50 rounded-xl transition"
              >
                {loading ? "ì¤€ë¹„ ì¤‘..." : "2ë‹¨ê³„ ì¸ì¦ ì„¤ì • ì‹œì‘"}
              </button>
            ) : (
              <button
                onClick={() => setStep("disable")}
                className="w-full py-3 text-sm font-semibold text-red-600 bg-red-50 dark:bg-red-900/20 hover:bg-red-100 dark:hover:bg-red-900/30 rounded-xl border border-red-200 dark:border-red-800 transition"
              >
                2ë‹¨ê³„ ì¸ì¦ ë¹„í™œì„±í™”
              </button>
            )}
          </>
        )}

        {/* â”€â”€ QRì½”ë“œ ë‹¨ê³„ â”€â”€ */}
        {step === "qr" && setupData && (
          <div className="space-y-4">
            <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-6 space-y-4">
              <h2 className="font-semibold text-gray-900 dark:text-slate-100">â‘  ì•±ìœ¼ë¡œ QRì½”ë“œ ìŠ¤ìº”</h2>
              <p className="text-sm text-gray-500 dark:text-slate-400">
                Google Authenticator, Authy, Microsoft Authenticator ë“±ì˜ ì•±ì„ ì—´ê³  ì•„ë˜ QRì½”ë“œë¥¼ ìŠ¤ìº”í•˜ì„¸ìš”.
              </p>
              <div className="flex justify-center">
                <div className="p-3 bg-white rounded-xl shadow">
                  <img src={setupData.qrCode} alt="QR Code" className="w-48 h-48" />
                </div>
              </div>

              {/* ìˆ˜ë™ ì…ë ¥ í‚¤ */}
              <div>
                <button
                  onClick={() => setShowManualKey(!showManualKey)}
                  className="flex items-center gap-1.5 text-xs text-blue-600 dark:text-blue-400 hover:underline"
                >
                  {showManualKey ? <EyeOff size={12} /> : <Eye size={12} />}
                  QRì½”ë“œ ìŠ¤ìº”ì´ ì•ˆ ëœë‹¤ë©´ (ìˆ˜ë™ ì…ë ¥)
                </button>
                {showManualKey && (
                  <div className="mt-2 flex items-center gap-2 p-3 bg-gray-50 dark:bg-slate-900 rounded-lg">
                    <code className="text-xs font-mono text-gray-700 dark:text-slate-300 flex-1 break-all">
                      {setupData.manualKey}
                    </code>
                    <button
                      onClick={() => copyToClipboard(setupData.manualKey)}
                      className="p-1.5 hover:bg-gray-200 dark:hover:bg-slate-700 rounded"
                    >
                      <Copy size={12} className="text-gray-500" />
                    </button>
                  </div>
                )}
              </div>
            </div>

            <button
              onClick={() => setStep("verify")}
              className="w-full py-3 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-xl transition"
            >
              ë‹¤ìŒ â†’ ì½”ë“œ í™•ì¸
            </button>
            <button onClick={() => setStep("idle")} className="w-full py-2 text-sm text-gray-500 dark:text-slate-400">
              ì·¨ì†Œ
            </button>
          </div>
        )}

        {/* â”€â”€ OTP ê²€ì¦ ë‹¨ê³„ â”€â”€ */}
        {step === "verify" && (
          <div className="space-y-4">
            <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-6 space-y-4">
              <h2 className="font-semibold text-gray-900 dark:text-slate-100">â‘¡ ì¸ì¦ ì½”ë“œ í™•ì¸</h2>
              <p className="text-sm text-gray-500 dark:text-slate-400">
                ì•±ì— í‘œì‹œëœ 6ìë¦¬ ì½”ë“œë¥¼ ì…ë ¥í•˜ì—¬ ì„¤ì •ì„ ì™„ë£Œí•˜ì„¸ìš”.
              </p>
              <input
                type="text"
                inputMode="numeric"
                pattern="[0-9]*"
                maxLength={6}
                value={otp}
                onChange={(e) => setOtp(e.target.value.replace(/\D/g, ""))}
                placeholder="6ìë¦¬ ì½”ë“œ"
                className="w-full text-center text-2xl font-mono tracking-[0.5em] border border-gray-200 dark:border-slate-600 rounded-xl px-4 py-3 focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-slate-700 dark:text-slate-100"
              />
            </div>
            <button
              onClick={verifyAndActivate}
              disabled={loading || otp.length !== 6}
              className="w-full py-3 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 disabled:opacity-50 rounded-xl transition"
            >
              {loading ? "í™•ì¸ ì¤‘..." : "ì¸ì¦ ì™„ë£Œ"}
            </button>
            <button onClick={() => setStep("qr")} className="w-full py-2 text-sm text-gray-500 dark:text-slate-400">
              â† ì´ì „
            </button>
          </div>
        )}

        {/* â”€â”€ ë°±ì—… ì½”ë“œ ë‹¨ê³„ â”€â”€ */}
        {step === "backup" && (
          <div className="space-y-4">
            <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-6 space-y-4">
              <div className="flex items-center gap-2">
                <ShieldCheck size={20} className="text-green-600" />
                <h2 className="font-semibold text-green-700 dark:text-green-400">2ë‹¨ê³„ ì¸ì¦ í™œì„±í™” ì™„ë£Œ!</h2>
              </div>

              <div className="p-3 bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-700 rounded-xl flex items-start gap-2">
                <AlertTriangle size={16} className="text-amber-600 shrink-0 mt-0.5" />
                <p className="text-xs text-amber-700 dark:text-amber-400">
                  ì•„ë˜ ë°±ì—… ì½”ë“œë¥¼ ì•ˆì „í•œ ê³³ì— ì €ì¥í•˜ì„¸ìš”. ì¸ì¦ ì•±ì„ ìƒì–´ë²„ë ¸ì„ ë•Œ ì‚¬ìš©í•  ìˆ˜ ìˆìœ¼ë©° ê° ì½”ë“œëŠ” 1íšŒë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.
                </p>
              </div>

              <div className="grid grid-cols-2 gap-2">
                {backupCodes.map((code) => (
                  <div key={code} className="font-mono text-sm text-center py-2 px-3 bg-gray-50 dark:bg-slate-900 rounded-lg text-gray-700 dark:text-slate-300 border border-gray-200 dark:border-slate-700">
                    {code}
                  </div>
                ))}
              </div>

              <button
                onClick={() => copyToClipboard(backupCodes.join("\n"))}
                className="w-full flex items-center justify-center gap-2 py-2 text-sm text-blue-600 dark:text-blue-400 hover:bg-blue-50 dark:hover:bg-blue-900/20 rounded-lg transition"
              >
                <Copy size={14} /> ì „ì²´ ë³µì‚¬
              </button>
            </div>

            <button
              onClick={() => setStep("idle")}
              className="w-full py-3 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-xl transition"
            >
              ì™„ë£Œ
            </button>
          </div>
        )}

        {/* â”€â”€ ë¹„í™œì„±í™” ë‹¨ê³„ â”€â”€ */}
        {step === "disable" && (
          <div className="space-y-4">
            <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-6 space-y-4">
              <div className="flex items-center gap-2">
                <ShieldOff size={20} className="text-red-500" />
                <h2 className="font-semibold text-gray-900 dark:text-slate-100">2ë‹¨ê³„ ì¸ì¦ ë¹„í™œì„±í™”</h2>
              </div>
              <p className="text-sm text-gray-500 dark:text-slate-400">
                ì¸ì¦ ì•±ì˜ 6ìë¦¬ ì½”ë“œ ë˜ëŠ” ë°±ì—… ì½”ë“œë¥¼ ì…ë ¥í•˜ì„¸ìš”.
              </p>
              <input
                type="text"
                value={disableCode}
                onChange={(e) => setDisableCode(e.target.value.replace(/\s/g, "").toUpperCase())}
                placeholder="ì½”ë“œ ì…ë ¥"
                className="w-full text-center text-xl font-mono tracking-widest border border-gray-200 dark:border-slate-600 rounded-xl px-4 py-3 focus:outline-none focus:ring-2 focus:ring-red-400 bg-white dark:bg-slate-700 dark:text-slate-100"
              />
            </div>
            <button
              onClick={disable2FA}
              disabled={loading || disableCode.length < 6}
              className="w-full py-3 text-sm font-semibold text-white bg-red-500 hover:bg-red-600 disabled:opacity-50 rounded-xl transition"
            >
              {loading ? "ì²˜ë¦¬ ì¤‘..." : "ë¹„í™œì„±í™” í™•ì¸"}
            </button>
            <button onClick={() => setStep("idle")} className="w-full py-2 text-sm text-gray-500 dark:text-slate-400">
              ì·¨ì†Œ
            </button>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/app/settings/api-keys/page.tsx">
"use client";
// src/app/settings/api-keys/page.tsx

import { useState, useEffect, useCallback } from "react";
import Link from "next/link";
import { ChevronLeft, Key, Plus, Trash2, Copy, Eye, EyeOff, AlertTriangle, RefreshCw } from "lucide-react";
import { toast } from "@/components/Toast";
import { useConfirm } from "@/components/ConfirmDialog";

interface ApiKey {
  id: string; name: string; keyPrefix: string;
  scopes: string[]; lastUsedAt: string | null;
  expiresAt: string | null; createdAt: string;
}

const ALL_SCOPES = [
  { value: "read:files",   label: "íŒŒì¼ ì½ê¸°" },
  { value: "write:files",  label: "íŒŒì¼ ì“°ê¸°" },
  { value: "read:posts",   label: "ê²Œì‹œê¸€ ì½ê¸°" },
  { value: "write:posts",  label: "ê²Œì‹œê¸€ ì“°ê¸°" },
  { value: "read:profile", label: "í”„ë¡œí•„ ì½ê¸°" },
];

const EXPIRY_OPTIONS = [
  { label: "ë§Œë£Œ ì—†ìŒ", value: 0 },
  { label: "30ì¼",      value: 30 },
  { label: "90ì¼",      value: 90 },
  { label: "1ë…„",       value: 365 },
];

function timeAgo(d: string | null) {
  if (!d) return "ì‚¬ìš©ëœ ì  ì—†ìŒ";
  const diff = Date.now() - new Date(d).getTime();
  const m = Math.floor(diff / 60000);
  if (m < 1) return "ë°©ê¸ˆ ì „";
  if (m < 60) return `${m}ë¶„ ì „`;
  const h = Math.floor(m / 60);
  if (h < 24) return `${h}ì‹œê°„ ì „`;
  return new Date(d).toLocaleDateString("ko-KR");
}

export default function ApiKeysPage() {
  const { confirmDialog, openConfirm } = useConfirm();
  const [keys, setKeys] = useState<ApiKey[]>([]);
  const [loading, setLoading] = useState(true);
  const [creating, setCreating] = useState(false);
  const [newKey, setNewKey] = useState<{ rawKey: string; name: string } | null>(null);
  const [showRawKey, setShowRawKey] = useState(false);

  // í¼ ìƒíƒœ
  const [form, setForm] = useState({ name: "", scopes: [] as string[], expiresInDays: 0 });
  const [showForm, setShowForm] = useState(false);

  const fetchKeys = useCallback(async () => {
    setLoading(true);
    try {
      const res = await fetch("/api/users/me/api-keys");
      const data = await res.json();
      setKeys(data.keys ?? []);
    } catch { toast.error("API í‚¤ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤"); }
    finally { setLoading(false); }
  }, []);

  useEffect(() => { fetchKeys(); }, [fetchKeys]);

  const createKey = async () => {
    if (!form.name.trim()) { toast.error("í‚¤ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”"); return; }
    if (form.scopes.length === 0) { toast.error("ê¶Œí•œì„ í•˜ë‚˜ ì´ìƒ ì„ íƒí•´ì£¼ì„¸ìš”"); return; }
    setCreating(true);
    try {
      const res = await fetch("/api/users/me/api-keys", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(form),
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error);
      setNewKey({ rawKey: data.rawKey, name: data.key.name });
      setKeys((k) => [data.key, ...k]);
      setShowForm(false);
      setForm({ name: "", scopes: [], expiresInDays: 0 });
    } catch (e: any) { toast.error(e.message); }
    finally { setCreating(false); }
  };

  const deleteKey = async (id: string, name: string) => {
    const ok = await openConfirm({
      title: "API í‚¤ ì‚­ì œ", message: `"${name}" í‚¤ë¥¼ ì‚­ì œí•˜ë©´ ì´ í‚¤ë¡œ ì—°ë™ëœ ì„œë¹„ìŠ¤ê°€ ì‘ë™ì„ ë©ˆì¶¥ë‹ˆë‹¤.`,
      confirmText: "ì‚­ì œ", confirmVariant: "danger",
    });
    if (!ok) return;
    await fetch(`/api/users/me/api-keys/${id}`, { method: "DELETE" });
    setKeys((k) => k.filter((x) => x.id !== id));
    toast.success("API í‚¤ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤");
  };

  const toggleScope = (scope: string) =>
    setForm((f) => ({
      ...f,
      scopes: f.scopes.includes(scope) ? f.scopes.filter((s) => s !== scope) : [...f.scopes, scope],
    }));

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900">
      {confirmDialog}

      {/* í—¤ë” */}
      <div className="bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700 sticky top-0 z-10">
        <div className="max-w-2xl mx-auto px-4 py-3 flex items-center gap-3">
          <Link href="/profile" className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
            <ChevronLeft size={20} className="text-gray-600 dark:text-slate-400" />
          </Link>
          <Key size={20} className="text-gray-800 dark:text-slate-200" />
          <h1 className="text-lg font-semibold text-gray-900 dark:text-slate-100 flex-1">API í‚¤ ê´€ë¦¬</h1>
          <button onClick={fetchKeys} className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700"><RefreshCw size={16} className="text-gray-500 dark:text-slate-400" /></button>
          <button onClick={() => setShowForm(true)}
            className="flex items-center gap-1.5 px-3 py-1.5 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-xl transition">
            <Plus size={14} /> ìƒˆ í‚¤
          </button>
        </div>
      </div>

      <div className="max-w-2xl mx-auto px-4 py-6 space-y-4">

        {/* ìƒì„±ëœ í‚¤ í‘œì‹œ */}
        {newKey && (
          <div className="bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-xl p-4 space-y-3">
            <div className="flex items-center gap-2">
              <AlertTriangle size={16} className="text-amber-600 shrink-0" />
              <p className="text-sm font-bold text-amber-700 dark:text-amber-400">ì§€ê¸ˆ ë³µì‚¬í•˜ì§€ ì•Šìœ¼ë©´ ë‹¤ì‹œ ë³¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!</p>
            </div>
            <p className="text-xs text-gray-600 dark:text-slate-400">"{newKey.name}" API í‚¤ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.</p>
            <div className="flex items-center gap-2 bg-white dark:bg-slate-800 rounded-xl border border-gray-200 dark:border-slate-700 px-3 py-2">
              <code className="flex-1 text-xs font-mono text-gray-800 dark:text-slate-200 break-all">
                {showRawKey ? newKey.rawKey : newKey.rawKey.slice(0, 16) + "â€¢".repeat(20)}
              </code>
              <button onClick={() => setShowRawKey(!showRawKey)} className="text-gray-400 hover:text-gray-600 shrink-0">
                {showRawKey ? <EyeOff size={14} /> : <Eye size={14} />}
              </button>
              <button onClick={() => { navigator.clipboard.writeText(newKey.rawKey); toast.success("ë³µì‚¬ë¨"); }}
                className="text-blue-600 hover:text-blue-700 shrink-0"><Copy size={14} /></button>
            </div>
            <button onClick={() => setNewKey(null)} className="text-xs text-gray-500 hover:text-gray-700 dark:hover:text-slate-300">
              í™•ì¸í–ˆìŠµë‹ˆë‹¤ Ã—
            </button>
          </div>
        )}

        {/* ìƒì„± í¼ */}
        {showForm && (
          <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-5 space-y-4">
            <h3 className="text-sm font-bold text-gray-900 dark:text-slate-100">ìƒˆ API í‚¤ ìƒì„±</h3>
            <input type="text" value={form.name} onChange={(e) => setForm((f) => ({ ...f, name: e.target.value }))}
              placeholder="í‚¤ ì´ë¦„ (ì˜ˆ: ë‚´ ì•±)"
              className="w-full px-4 py-2.5 text-sm border border-gray-200 dark:border-slate-600 rounded-xl bg-white dark:bg-slate-700 dark:text-slate-100 focus:outline-none focus:ring-2 focus:ring-blue-500" />
            <div>
              <p className="text-xs font-semibold text-gray-500 dark:text-slate-400 mb-2">ê¶Œí•œ</p>
              <div className="grid grid-cols-2 gap-2">
                {ALL_SCOPES.map((s) => (
                  <label key={s.value} className="flex items-center gap-2 cursor-pointer">
                    <input type="checkbox" checked={form.scopes.includes(s.value)} onChange={() => toggleScope(s.value)}
                      className="w-4 h-4 rounded accent-blue-600" />
                    <span className="text-xs text-gray-700 dark:text-slate-300">{s.label}</span>
                  </label>
                ))}
              </div>
            </div>
            <div>
              <p className="text-xs font-semibold text-gray-500 dark:text-slate-400 mb-2">ë§Œë£Œ</p>
              <div className="flex gap-2 flex-wrap">
                {EXPIRY_OPTIONS.map((o) => (
                  <button key={o.value} onClick={() => setForm((f) => ({ ...f, expiresInDays: o.value }))}
                    className={`px-3 py-1.5 text-xs font-medium rounded-lg transition ${
                      form.expiresInDays === o.value
                        ? "bg-blue-600 text-white"
                        : "bg-gray-100 dark:bg-slate-700 text-gray-600 dark:text-slate-400 hover:bg-gray-200"
                    }`}>{o.label}
                  </button>
                ))}
              </div>
            </div>
            <div className="flex gap-2">
              <button onClick={() => setShowForm(false)}
                className="flex-1 py-2.5 text-sm text-gray-600 dark:text-slate-400 bg-gray-100 dark:bg-slate-700 hover:bg-gray-200 rounded-xl transition">ì·¨ì†Œ</button>
              <button onClick={createKey} disabled={creating}
                className="flex-1 py-2.5 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-xl transition disabled:opacity-50">
                {creating ? "ìƒì„± ì¤‘..." : "í‚¤ ìƒì„±"}
              </button>
            </div>
          </div>
        )}

        {/* í‚¤ ëª©ë¡ */}
        {loading ? (
          <div className="space-y-2">{[...Array(3)].map((_, i) => (
            <div key={i} className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-4 animate-pulse h-20" />
          ))}</div>
        ) : keys.length === 0 ? (
          <div className="flex flex-col items-center py-20 text-center">
            <Key size={32} className="text-gray-300 dark:text-slate-600 mb-3" />
            <p className="text-gray-500 dark:text-slate-400 font-medium">API í‚¤ê°€ ì—†ìŠµë‹ˆë‹¤</p>
            <p className="text-xs text-gray-400 dark:text-slate-500 mt-1">ì™¸ë¶€ ì„œë¹„ìŠ¤ì™€ ì—°ë™í•  API í‚¤ë¥¼ ë§Œë“œì„¸ìš”</p>
          </div>
        ) : (
          <div className="space-y-2">
            {keys.map((k) => (
              <div key={k.id} className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-4 flex items-start gap-3">
                <div className="w-9 h-9 rounded-xl bg-blue-50 dark:bg-blue-900/30 flex items-center justify-center shrink-0">
                  <Key size={16} className="text-blue-600 dark:text-blue-400" />
                </div>
                <div className="flex-1 min-w-0">
                  <p className="text-sm font-semibold text-gray-900 dark:text-slate-100">{k.name}</p>
                  <code className="text-xs text-gray-400 dark:text-slate-500 font-mono">{k.keyPrefix}â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢</code>
                  <div className="flex flex-wrap gap-1 mt-1.5">
                    {k.scopes.map((s) => (
                      <span key={s} className="text-[9px] font-semibold bg-gray-100 dark:bg-slate-700 text-gray-500 dark:text-slate-400 px-1.5 py-0.5 rounded">{s}</span>
                    ))}
                  </div>
                  <p className="text-[10px] text-gray-400 dark:text-slate-500 mt-1">
                    ë§ˆì§€ë§‰ ì‚¬ìš©: {timeAgo(k.lastUsedAt)}
                    {k.expiresAt && ` Â· ë§Œë£Œ: ${new Date(k.expiresAt).toLocaleDateString("ko-KR")}`}
                  </p>
                </div>
                <button onClick={() => deleteKey(k.id, k.name)} className="p-2 text-gray-400 hover:text-red-500 hover:bg-red-50 dark:hover:bg-red-900/20 rounded-lg transition">
                  <Trash2 size={14} />
                </button>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/app/settings/sessions/page.tsx">
"use client";
// src/app/settings/sessions/page.tsx

import { useState, useEffect, useCallback } from "react";
import Link from "next/link";
import { ChevronLeft, Monitor, Smartphone, Tablet, LogOut, RefreshCw, Shield } from "lucide-react";
import { toast } from "@/components/Toast";
import { useConfirm } from "@/components/ConfirmDialog";

interface SessionInfo {
  id: string;
  userAgent: string | null;
  ip: string | null;
  lastActive: string;
  createdAt: string;
  isCurrent: boolean;
}

function parseDevice(ua: string | null): { icon: typeof Monitor; label: string; detail: string } {
  if (!ua) return { icon: Monitor, label: "ì•Œ ìˆ˜ ì—†ëŠ” ê¸°ê¸°", detail: "" };
  const isMobile = /Mobile|Android|iPhone/i.test(ua);
  const isTablet = /iPad|Tablet/i.test(ua);
  const browser =
    ua.includes("Chrome") ? "Chrome" :
    ua.includes("Firefox") ? "Firefox" :
    ua.includes("Safari") ? "Safari" :
    ua.includes("Edge") ? "Edge" : "ë¸Œë¼ìš°ì €";
  const os =
    ua.includes("Windows") ? "Windows" :
    ua.includes("Mac") ? "macOS" :
    ua.includes("Linux") ? "Linux" :
    ua.includes("Android") ? "Android" :
    ua.includes("iOS") ? "iOS" : "";

  return {
    icon: isTablet ? Tablet : isMobile ? Smartphone : Monitor,
    label: `${browser}${os ? ` on ${os}` : ""}`,
    detail: isTablet ? "íƒœë¸”ë¦¿" : isMobile ? "ëª¨ë°”ì¼" : "ë°ìŠ¤í¬í†±",
  };
}

function timeAgo(d: string) {
  const diff = Date.now() - new Date(d).getTime();
  const m = Math.floor(diff / 60000);
  if (m < 1) return "ë°©ê¸ˆ ì „";
  if (m < 60) return `${m}ë¶„ ì „`;
  const h = Math.floor(m / 60);
  if (h < 24) return `${h}ì‹œê°„ ì „`;
  return new Date(d).toLocaleDateString("ko-KR");
}

export default function SessionsPage() {
  const { confirmDialog, openConfirm } = useConfirm();
  const [sessions, setSessions] = useState<SessionInfo[]>([]);
  const [loading, setLoading] = useState(true);

  const fetchSessions = useCallback(async () => {
    setLoading(true);
    try {
      const res = await fetch("/api/users/me/sessions");
      const data = await res.json();
      setSessions(data.sessions ?? []);
    } catch {
      toast.error("ì„¸ì…˜ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => { fetchSessions(); }, [fetchSessions]);

  const revokeSession = async (id: string) => {
    const ok = await openConfirm({
      title: "ì„¸ì…˜ ì¢…ë£Œ",
      message: "ì´ ê¸°ê¸°ì—ì„œ ë¡œê·¸ì•„ì›ƒì‹œí‚¬ê¹Œìš”?",
      confirmText: "ë¡œê·¸ì•„ì›ƒ", confirmVariant: "danger",
    });
    if (!ok) return;
    const res = await fetch("/api/users/me/sessions", {
      method: "DELETE",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ sessionId: id }),
    });
    if (res.ok) {
      setSessions((s) => s.filter((x) => x.id !== id));
      toast.success("ì„¸ì…˜ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤");
    }
  };

  const revokeAll = async () => {
    const other = sessions.filter((s) => !s.isCurrent);
    if (other.length === 0) { toast.error("ì¢…ë£Œí•  ë‹¤ë¥¸ ì„¸ì…˜ì´ ì—†ìŠµë‹ˆë‹¤"); return; }
    const ok = await openConfirm({
      title: "ëª¨ë“  ê¸°ê¸° ë¡œê·¸ì•„ì›ƒ",
      message: `í˜„ì¬ ê¸°ê¸°ë¥¼ ì œì™¸í•œ ${other.length}ê°œ ê¸°ê¸°ì—ì„œ ë¡œê·¸ì•„ì›ƒí•©ë‹ˆë‹¤.`,
      confirmText: "ëª¨ë‘ ë¡œê·¸ì•„ì›ƒ", confirmVariant: "danger",
    });
    if (!ok) return;
    const res = await fetch("/api/users/me/sessions", {
      method: "DELETE",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ revokeAll: true }),
    });
    if (res.ok) {
      setSessions((s) => s.filter((x) => x.isCurrent));
      toast.success("ë‹¤ë¥¸ ëª¨ë“  ê¸°ê¸°ì—ì„œ ë¡œê·¸ì•„ì›ƒë˜ì—ˆìŠµë‹ˆë‹¤");
    }
  };

  const otherCount = sessions.filter((s) => !s.isCurrent).length;

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900">
      {confirmDialog}

      {/* í—¤ë” */}
      <div className="bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700 sticky top-0 z-10">
        <div className="max-w-2xl mx-auto px-4 py-3 flex items-center gap-3">
          <Link href="/profile" className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
            <ChevronLeft size={20} className="text-gray-600 dark:text-slate-400" />
          </Link>
          <Shield size={20} className="text-gray-800 dark:text-slate-200" />
          <h1 className="text-lg font-semibold text-gray-900 dark:text-slate-100 flex-1">ë¡œê·¸ì¸ëœ ê¸°ê¸°</h1>
          <button onClick={fetchSessions} className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
            <RefreshCw size={16} className="text-gray-500 dark:text-slate-400" />
          </button>
        </div>
      </div>

      <div className="max-w-2xl mx-auto px-4 py-6 space-y-4">
        {/* ì „ì²´ ë¡œê·¸ì•„ì›ƒ */}
        {otherCount > 0 && (
          <button
            onClick={revokeAll}
            className="w-full flex items-center justify-center gap-2 py-3 text-sm font-semibold text-red-600 bg-red-50 dark:bg-red-900/20 hover:bg-red-100 dark:hover:bg-red-900/30 rounded-xl border border-red-200 dark:border-red-800 transition"
          >
            <LogOut size={15} /> ë‹¤ë¥¸ ëª¨ë“  ê¸°ê¸° ë¡œê·¸ì•„ì›ƒ ({otherCount}ê°œ)
          </button>
        )}

        {/* ì„¸ì…˜ ëª©ë¡ */}
        {loading ? (
          <div className="space-y-3">
            {[...Array(3)].map((_, i) => (
              <div key={i} className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-4 animate-pulse flex gap-3">
                <div className="w-10 h-10 rounded-xl bg-gray-200 dark:bg-slate-700" />
                <div className="flex-1 space-y-2">
                  <div className="h-3.5 bg-gray-200 dark:bg-slate-700 rounded w-1/2" />
                  <div className="h-3 bg-gray-100 dark:bg-slate-700/50 rounded w-1/3" />
                </div>
              </div>
            ))}
          </div>
        ) : (
          <div className="space-y-2">
            {sessions.map((s) => {
              const device = parseDevice(s.userAgent);
              const Icon = device.icon;
              return (
                <div key={s.id} className={`bg-white dark:bg-slate-800 rounded-xl border transition-all p-4 flex items-center gap-3 ${
                  s.isCurrent
                    ? "border-blue-200 dark:border-blue-700 shadow-sm"
                    : "border-gray-100 dark:border-slate-700"
                }`}>
                  <div className={`w-10 h-10 rounded-xl flex items-center justify-center shrink-0 ${
                    s.isCurrent ? "bg-blue-50 dark:bg-blue-900/30" : "bg-gray-100 dark:bg-slate-700"
                  }`}>
                    <Icon size={20} className={s.isCurrent ? "text-blue-600 dark:text-blue-400" : "text-gray-500 dark:text-slate-400"} />
                  </div>
                  <div className="flex-1 min-w-0">
                    <div className="flex items-center gap-2">
                      <p className="text-sm font-semibold text-gray-900 dark:text-slate-100">{device.label}</p>
                      {s.isCurrent && (
                        <span className="text-[10px] font-bold bg-blue-100 dark:bg-blue-900/50 text-blue-600 dark:text-blue-400 px-1.5 py-0.5 rounded-full">í˜„ì¬ ê¸°ê¸°</span>
                      )}
                    </div>
                    <div className="flex items-center gap-2 mt-0.5">
                      <span className="text-xs text-gray-400 dark:text-slate-500">{device.detail}</span>
                      {s.ip && <><span className="text-gray-300 dark:text-slate-600">Â·</span><span className="text-xs text-gray-400 dark:text-slate-500 font-mono">{s.ip}</span></>}
                    </div>
                    <p className="text-[10px] text-gray-400 dark:text-slate-500 mt-0.5">
                      ë§ˆì§€ë§‰ í™œë™: {timeAgo(s.lastActive)} Â· ë¡œê·¸ì¸: {new Date(s.createdAt).toLocaleDateString("ko-KR")}
                    </p>
                  </div>
                  {!s.isCurrent && (
                    <button
                      onClick={() => revokeSession(s.id)}
                      className="p-2 rounded-lg hover:bg-red-50 dark:hover:bg-red-900/20 text-gray-400 hover:text-red-500 transition-colors shrink-0"
                      title="ì´ ê¸°ê¸° ë¡œê·¸ì•„ì›ƒ"
                    >
                      <LogOut size={15} />
                    </button>
                  )}
                </div>
              );
            })}
          </div>
        )}

        <p className="text-xs text-center text-gray-400 dark:text-slate-500 pb-4">
          ì˜ì‹¬ìŠ¤ëŸ¬ìš´ ê¸°ê¸°ê°€ ìˆë‹¤ë©´ ì¦‰ì‹œ ë¡œê·¸ì•„ì›ƒí•˜ê³  ë¹„ë°€ë²ˆí˜¸ë¥¼ ë³€ê²½í•˜ì„¸ìš”.
        </p>
      </div>
    </div>
  );
}
</file>

<file path="src/app/share/[token]/page.tsx">
"use client";
// src/app/share/[token]/page.tsx â€” ê³µê°œ ê³µìœ  ë§í¬ í˜ì´ì§€ (ë¹„ë¡œê·¸ì¸ ì ‘ê·¼)

import { useState, useEffect } from "react";
import { useParams } from "next/navigation";
import Link from "next/link";
import { Download, File, Cloud, AlertCircle } from "lucide-react";
import { getFileIcon, formatFileSize } from "@/lib/client-utils";

interface ShareMeta {
  originalName: string;
  mimeType: string;
  size: string;
  thumbnailUrl: string | null;
  createdAt: string;
  ownerName: string;
}

export default function SharePage() {
  const { token } = useParams<{ token: string }>();
  const [meta, setMeta] = useState<ShareMeta | null>(null);
  const [error, setError] = useState(false);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch(`/api/share/${token}`)
      .then((r) => { if (!r.ok) throw new Error(); return r.json(); })
      .then(setMeta)
      .catch(() => setError(true))
      .finally(() => setLoading(false));
  }, [token]);

  const isImage = meta?.mimeType.startsWith("image/");
  const isVideo = meta?.mimeType.startsWith("video/");
  const isAudio = meta?.mimeType.startsWith("audio/");

  return (
    <div className="min-h-screen bg-[#0f0c29] flex flex-col items-center justify-center px-4 text-white">
      {/* ë°°ê²½ */}
      <div className="fixed inset-0 -z-10 overflow-hidden pointer-events-none">
        <div className="absolute top-1/4 left-1/4 w-96 h-96 bg-purple-700/15 rounded-full blur-[100px]" />
        <div className="absolute bottom-1/4 right-1/4 w-80 h-80 bg-blue-700/10 rounded-full blur-[80px]" />
      </div>

      {/* ë¡œê³  */}
      <Link href="/" className="flex items-center gap-2 mb-10">
        <div className="w-8 h-8 rounded-xl bg-gradient-to-br from-purple-500 to-blue-600 flex items-center justify-center">
          <Cloud size={16} className="text-white" />
        </div>
        <span className="text-lg font-black">ì´ìŒ</span>
      </Link>

      {loading && (
        <div className="w-10 h-10 border-4 border-purple-500/20 border-t-purple-500 rounded-full animate-spin" />
      )}

      {error && (
        <div className="text-center max-w-sm">
          <div className="w-16 h-16 rounded-full bg-red-500/10 border border-red-500/20 flex items-center justify-center mx-auto mb-4">
            <AlertCircle size={28} className="text-red-400" />
          </div>
          <h2 className="text-xl font-bold mb-2">íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤</h2>
          <p className="text-white/40 text-sm">ë§í¬ê°€ ë§Œë£Œë˜ì—ˆê±°ë‚˜ ì‚­ì œëœ íŒŒì¼ì…ë‹ˆë‹¤.</p>
        </div>
      )}

      {meta && !error && (
        <div className="w-full max-w-lg">
          <div className="bg-white/5 border border-white/10 rounded-[28px] overflow-hidden">
            {/* ë¯¸ë¦¬ë³´ê¸° */}
            <div className="bg-black/20 min-h-48 flex items-center justify-center p-6">
              {isImage && (
                <img
                  src={`/api/share/${token}?download=1`}
                  alt={meta.originalName}
                  className="max-h-72 max-w-full rounded-xl object-contain shadow-2xl"
                />
              )}
              {isVideo && (
                <video
                  src={`/api/share/${token}?download=1`}
                  controls
                  className="max-h-72 max-w-full rounded-xl"
                />
              )}
              {isAudio && (
                <div className="text-center space-y-4">
                  <div className="text-6xl">{getFileIcon(meta.mimeType)}</div>
                  <audio src={`/api/share/${token}?download=1`} controls className="w-full" />
                </div>
              )}
              {!isImage && !isVideo && !isAudio && (
                <div className="text-center">
                  <span className="text-7xl">{getFileIcon(meta.mimeType)}</span>
                </div>
              )}
            </div>

            {/* íŒŒì¼ ì •ë³´ */}
            <div className="p-6 space-y-4">
              <div>
                <h1 className="text-lg font-bold break-all">{meta.originalName}</h1>
                <p className="text-sm text-white/40 mt-1">
                  {formatFileSize(meta.size)} Â· {meta.ownerName}ì´ ê³µìœ  Â· {new Date(meta.createdAt).toLocaleDateString("ko-KR")}
                </p>
              </div>

              {/* ë‹¤ìš´ë¡œë“œ ë²„íŠ¼ */}
              <a
                href={`/api/share/${token}?download=1`}
                className="flex items-center justify-center gap-2 w-full py-3.5 bg-white text-black font-bold rounded-2xl hover:bg-purple-50 transition-all"
              >
                <Download size={18} />
                íŒŒì¼ ë‹¤ìš´ë¡œë“œ
              </a>

              <p className="text-center text-xs text-white/20">
                ì´ìŒ í¼ìŠ¤ë„ í´ë¼ìš°ë“œë¡œ ê³µìœ ë¨ Â·{" "}
                <Link href="/register" className="hover:text-white/50 underline">
                  ë¬´ë£Œë¡œ ì‹œì‘í•˜ê¸°
                </Link>
              </p>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/app/shared/page.tsx">
"use client";

import { useState, useEffect, useCallback } from "react";
import Link from "next/link";
import {
  ChevronLeft, Share2, Search, Download,
  LayoutGrid, List, RefreshCw, Eye,
} from "lucide-react";
import { getFileIcon, getFileColor, formatFileSize } from "@/lib/client-utils";
import FilePreviewModal from "@/components/FilePreviewModal";
import { toast } from "@/components/Toast";

interface SharedFile {
  id: string;
  filename: string;
  originalName: string;
  size: string;
  mimeType: string;
  thumbnailUrl: string | null;
  createdAt: string;
  sharedBy: string;
  sharedByEmail: string;
  permission: "VIEW" | "EDIT" | "ADMIN";
  sharedAt: string;
}

function timeAgo(d: string) {
  const diff = Date.now() - new Date(d).getTime();
  const days = Math.floor(diff / 86400000);
  if (days === 0) return "ì˜¤ëŠ˜";
  if (days < 7) return `${days}ì¼ ì „`;
  return new Date(d).toLocaleDateString("ko-KR");
}

export default function SharedPage() {
  const [files, setFiles] = useState<SharedFile[]>([]);
  const [loading, setLoading] = useState(true);
  const [search, setSearch] = useState("");
  const [viewMode, setViewMode] = useState<"grid" | "list">("grid");
  const [sortBy, setSortBy] = useState<"sharedAt" | "name" | "size">("sharedAt");
  const [preview, setPreview] = useState<SharedFile | null>(null);

  const fetch_ = useCallback(async () => {
    setLoading(true);
    try {
      const res = await fetch("/api/files/shared");
      if (!res.ok) throw new Error();
      const data = await res.json();
      setFiles(data.files ?? []);
    } catch {
      toast.error("ê³µìœ  íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => { fetch_(); }, [fetch_]);

  const filtered = files
    .filter((f) =>
      f.originalName.toLowerCase().includes(search.toLowerCase()) ||
      f.sharedBy.toLowerCase().includes(search.toLowerCase())
    )
    .sort((a, b) => {
      if (sortBy === "name") return a.originalName.localeCompare(b.originalName);
      if (sortBy === "size") return Number(b.size) - Number(a.size);
      return new Date(b.sharedAt).getTime() - new Date(a.sharedAt).getTime();
    });

  const permColor = {
    VIEW: "bg-blue-50 dark:bg-blue-900/20 text-blue-700 dark:text-blue-400",
    EDIT: "bg-green-50 dark:bg-green-900/20 text-green-700 dark:text-green-400",
    ADMIN: "bg-red-50 dark:bg-red-900/20 text-red-700 dark:text-red-400",
  };
  const permLabel = { VIEW: "ì½ê¸°", EDIT: "í¸ì§‘", ADMIN: "ê´€ë¦¬" };

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900">
      <FilePreviewModal
        file={preview ? { id: preview.id, originalName: preview.originalName, mimeType: preview.mimeType, size: preview.size } : null}
        onClose={() => setPreview(null)}
      />

      {/* í—¤ë” */}
      <div className="bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700 sticky top-0 z-10">
        <div className="max-w-4xl mx-auto px-4 py-3 flex items-center gap-3">
          <Link href="/dashboard" className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
            <ChevronLeft size={20} className="text-gray-600 dark:text-slate-400" />
          </Link>
          <Share2 size={20} className="text-gray-800 dark:text-slate-200" />
          <h1 className="text-lg font-semibold text-gray-900 dark:text-slate-100 flex-1">
            ê³µìœ ë°›ì€ íŒŒì¼
            {files.length > 0 && <span className="ml-2 text-sm font-normal text-gray-400 dark:text-slate-500">({files.length})</span>}
          </h1>
          <button onClick={fetch_} className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
            <RefreshCw size={16} className="text-gray-500 dark:text-slate-400" />
          </button>
        </div>

        {/* ê²€ìƒ‰ + ì •ë ¬ + ë·° */}
        <div className="max-w-4xl mx-auto px-4 pb-3 flex gap-2 flex-wrap">
          <div className="relative flex-1 min-w-48">
            <Search size={14} className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400" />
            <input
              type="text"
              placeholder="íŒŒì¼ëª… ë˜ëŠ” ê³µìœ ì ê²€ìƒ‰"
              value={search}
              onChange={(e) => setSearch(e.target.value)}
              className="w-full pl-8 pr-3 py-2 text-sm border border-gray-200 dark:border-slate-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-slate-700 dark:text-slate-100"
            />
          </div>
          <select
            value={sortBy}
            onChange={(e) => setSortBy(e.target.value as any)}
            className="text-sm border border-gray-200 dark:border-slate-600 rounded-lg px-3 py-2 bg-white dark:bg-slate-700 dark:text-slate-100 focus:outline-none"
          >
            <option value="sharedAt">ìµœì‹ ìˆœ</option>
            <option value="name">ì´ë¦„ìˆœ</option>
            <option value="size">í¬ê¸°ìˆœ</option>
          </select>
          <div className="flex gap-1 bg-gray-100 dark:bg-slate-800 p-1 rounded-lg">
            <button onClick={() => setViewMode("grid")} className={`p-1.5 rounded ${viewMode === "grid" ? "bg-white dark:bg-slate-700 shadow-sm" : ""}`}>
              <LayoutGrid size={15} className="text-gray-600 dark:text-slate-400" />
            </button>
            <button onClick={() => setViewMode("list")} className={`p-1.5 rounded ${viewMode === "list" ? "bg-white dark:bg-slate-700 shadow-sm" : ""}`}>
              <List size={15} className="text-gray-600 dark:text-slate-400" />
            </button>
          </div>
        </div>
      </div>

      <div className="max-w-4xl mx-auto px-4 py-6">
        {loading ? (
          <div className={viewMode === "grid" ? "grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3" : "space-y-2"}>
            {[...Array(8)].map((_, i) => (
              <div key={i} className="bg-white dark:bg-slate-800 rounded-xl p-4 animate-pulse aspect-square" />
            ))}
          </div>
        ) : filtered.length === 0 ? (
          <div className="flex flex-col items-center justify-center py-32 text-center">
            <div className="w-16 h-16 rounded-full bg-gray-100 dark:bg-slate-800 flex items-center justify-center mb-4">
              <Share2 size={28} className="text-gray-400 dark:text-slate-500" />
            </div>
            <p className="text-gray-500 dark:text-slate-400 font-medium">ê³µìœ ë°›ì€ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤</p>
            <p className="text-xs text-gray-400 dark:text-slate-500 mt-1">ë‹¤ë¥¸ ì‚¬ëŒì´ íŒŒì¼ì„ ê³µìœ í•˜ë©´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤</p>
          </div>
        ) : viewMode === "grid" ? (
          /* ê·¸ë¦¬ë“œ ë·° */
          <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3">
            {filtered.map((f) => (
              <div key={f.id} className="group bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 overflow-hidden hover:shadow-md transition-all">
                {/* ì¸ë„¤ì¼ */}
                <div
                  className={`aspect-square flex items-center justify-center cursor-pointer ${
                    f.thumbnailUrl ? "bg-gray-50 dark:bg-slate-900" : getFileColor(f.mimeType)
                  }`}
                  onClick={() => setPreview(f)}
                >
                  {f.thumbnailUrl
                    ? <img src={f.thumbnailUrl} className="w-full h-full object-cover" alt={f.originalName} />
                    : <span className="text-4xl">{getFileIcon(f.mimeType)}</span>
                  }
                  <div className="absolute inset-0 bg-black/0 group-hover:bg-black/10 transition-colors flex items-center justify-center opacity-0 group-hover:opacity-100">
                    <Eye size={20} className="text-white drop-shadow" />
                  </div>
                </div>
                {/* ì •ë³´ */}
                <div className="p-2.5">
                  <p className="text-xs font-medium text-gray-900 dark:text-slate-100 truncate">{f.originalName}</p>
                  <p className="text-[10px] text-gray-400 dark:text-slate-500 mt-0.5">{f.sharedBy} Â· {timeAgo(f.sharedAt)}</p>
                  <div className="flex items-center justify-between mt-1.5">
                    <span className={`text-[9px] font-bold px-1.5 py-0.5 rounded-full ${permColor[f.permission]}`}>
                      {permLabel[f.permission]}
                    </span>
                    <a
                      href={`/api/files/${f.id}/download`}
                      className="p-1 rounded hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors"
                      title="ë‹¤ìš´ë¡œë“œ"
                    >
                      <Download size={12} className="text-gray-500 dark:text-slate-400" />
                    </a>
                  </div>
                </div>
              </div>
            ))}
          </div>
        ) : (
          /* ë¦¬ìŠ¤íŠ¸ ë·° */
          <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 overflow-hidden">
            <table className="w-full text-sm">
              <thead>
                <tr className="border-b border-gray-100 dark:border-slate-700 bg-gray-50 dark:bg-slate-800/80">
                  <th className="text-left px-4 py-3 text-xs font-semibold text-gray-500 dark:text-slate-400">íŒŒì¼</th>
                  <th className="text-left px-4 py-3 text-xs font-semibold text-gray-500 dark:text-slate-400 hidden md:table-cell">ê³µìœ ì</th>
                  <th className="text-left px-4 py-3 text-xs font-semibold text-gray-500 dark:text-slate-400 hidden sm:table-cell">í¬ê¸°</th>
                  <th className="text-left px-4 py-3 text-xs font-semibold text-gray-500 dark:text-slate-400">ê¶Œí•œ</th>
                  <th className="text-left px-4 py-3 text-xs font-semibold text-gray-500 dark:text-slate-400 hidden lg:table-cell">ê³µìœ ì¼</th>
                  <th className="px-4 py-3" />
                </tr>
              </thead>
              <tbody>
                {filtered.map((f) => (
                  <tr key={f.id} className="border-b border-gray-50 dark:border-slate-700 hover:bg-gray-50 dark:hover:bg-slate-700/50 transition-colors">
                    <td className="px-4 py-3">
                      <div className="flex items-center gap-2.5">
                        <span className="text-xl shrink-0">{getFileIcon(f.mimeType)}</span>
                        <div className="min-w-0">
                          <p className="font-medium text-gray-900 dark:text-slate-100 truncate max-w-[160px]">{f.originalName}</p>
                        </div>
                      </div>
                    </td>
                    <td className="px-4 py-3 hidden md:table-cell text-sm text-gray-600 dark:text-slate-400">{f.sharedBy}</td>
                    <td className="px-4 py-3 hidden sm:table-cell text-xs text-gray-500 dark:text-slate-400">{formatFileSize(f.size)}</td>
                    <td className="px-4 py-3">
                      <span className={`text-[10px] font-bold px-2 py-1 rounded-full ${permColor[f.permission]}`}>{permLabel[f.permission]}</span>
                    </td>
                    <td className="px-4 py-3 hidden lg:table-cell text-xs text-gray-400 dark:text-slate-500">{timeAgo(f.sharedAt)}</td>
                    <td className="px-4 py-3">
                      <div className="flex items-center gap-1">
                        <button onClick={() => setPreview(f)} className="p-1.5 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors" title="ë¯¸ë¦¬ë³´ê¸°">
                          <Eye size={14} className="text-gray-500 dark:text-slate-400" />
                        </button>
                        <a href={`/api/files/${f.id}/download`} className="p-1.5 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors" title="ë‹¤ìš´ë¡œë“œ">
                          <Download size={14} className="text-gray-500 dark:text-slate-400" />
                        </a>
                      </div>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/app/trash/page.tsx">
"use client";
// src/app/trash/page.tsx

import { useState, useEffect, useCallback } from "react";
import Link from "next/link";
import { ChevronLeft, Trash2, RotateCcw, AlertTriangle, RefreshCw } from "lucide-react";
import { getFileIcon, formatFileSize } from "@/lib/client-utils";
import { toast } from "@/components/Toast";
import { useConfirm } from "@/components/ConfirmDialog";

interface TrashFile {
  id: string;
  originalName: string;
  mimeType: string;
  size: string;
  thumbnailUrl: string | null;
  deletedAt: string;
  createdAt: string;
}

function daysLeft(deletedAt: string) {
  const deleted = new Date(deletedAt).getTime();
  const expiry = deleted + 30 * 24 * 60 * 60 * 1000; // 30ì¼ í›„ ìë™ ì‚­ì œ ì •ì±…
  const remaining = Math.ceil((expiry - Date.now()) / 86400000);
  return Math.max(0, remaining);
}

export default function TrashPage() {
  const { confirmDialog, openConfirm } = useConfirm();
  const [files, setFiles] = useState<TrashFile[]>([]);
  const [loading, setLoading] = useState(true);
  const [selected, setSelected] = useState<Set<string>>(new Set());

  const fetchTrash = useCallback(async () => {
    setLoading(true);
    try {
      const res = await fetch("/api/files/trash");
      const data = await res.json();
      setFiles(data.files ?? []);
    } catch {
      toast.error("íœ´ì§€í†µì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => { fetchTrash(); }, [fetchTrash]);

  const restore = async (id: string) => {
    const res = await fetch(`/api/files/${id}/restore`, { method: "POST" });
    if (res.ok) {
      setFiles((f) => f.filter((x) => x.id !== id));
      toast.success("íŒŒì¼ì´ ë³µêµ¬ë˜ì—ˆìŠµë‹ˆë‹¤");
    } else toast.error("ë³µêµ¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
  };

  const permanentDelete = async (id: string) => {
    const ok = await openConfirm({
      title: "ì˜êµ¬ ì‚­ì œ", message: "ì´ íŒŒì¼ì„ ì˜êµ¬ ì‚­ì œí• ê¹Œìš”? ë³µêµ¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
      confirmText: "ì˜êµ¬ ì‚­ì œ", confirmVariant: "danger",
    });
    if (!ok) return;
    const res = await fetch(`/api/files/${id}`, { method: "DELETE" });
    if (res.ok) {
      setFiles((f) => f.filter((x) => x.id !== id));
      toast.success("ì˜êµ¬ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤");
    }
  };

  const emptyTrash = async () => {
    const ok = await openConfirm({
      title: "íœ´ì§€í†µ ë¹„ìš°ê¸°",
      message: `${files.length}ê°œ íŒŒì¼ì„ ëª¨ë‘ ì˜êµ¬ ì‚­ì œí• ê¹Œìš”? ë³µêµ¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`,
      confirmText: "ëª¨ë‘ ì‚­ì œ", confirmVariant: "danger",
    });
    if (!ok) return;
    const res = await fetch("/api/files/trash", { method: "DELETE" });
    if (res.ok) { setFiles([]); toast.success("íœ´ì§€í†µì„ ë¹„ì› ìŠµë‹ˆë‹¤"); }
  };

  const restoreSelected = async () => {
    await Promise.all([...selected].map((id) => fetch(`/api/files/${id}/restore`, { method: "POST" })));
    setFiles((f) => f.filter((x) => !selected.has(x.id)));
    setSelected(new Set());
    toast.success(`${selected.size}ê°œ íŒŒì¼ì´ ë³µêµ¬ë˜ì—ˆìŠµë‹ˆë‹¤`);
  };

  const toggleSelect = (id: string) =>
    setSelected((s) => { const n = new Set(s); n.has(id) ? n.delete(id) : n.add(id); return n; });
  const toggleAll = () =>
    setSelected(selected.size === files.length ? new Set() : new Set(files.map((f) => f.id)));

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900">
      {confirmDialog}

      {/* í—¤ë” */}
      <div className="bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700 sticky top-0 z-10">
        <div className="max-w-4xl mx-auto px-4 py-3 flex items-center gap-3">
          <Link href="/dashboard" className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
            <ChevronLeft size={20} className="text-gray-600 dark:text-slate-400" />
          </Link>
          <Trash2 size={20} className="text-gray-800 dark:text-slate-200" />
          <h1 className="text-lg font-semibold text-gray-900 dark:text-slate-100 flex-1">
            íœ´ì§€í†µ {files.length > 0 && <span className="text-sm font-normal text-gray-400 dark:text-slate-500">({files.length})</span>}
          </h1>
          <button onClick={fetchTrash} className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700">
            <RefreshCw size={16} className="text-gray-500 dark:text-slate-400" />
          </button>
          {files.length > 0 && (
            <button onClick={emptyTrash} className="flex items-center gap-1.5 px-3 py-1.5 text-xs font-semibold text-red-600 bg-red-50 dark:bg-red-900/20 hover:bg-red-100 dark:hover:bg-red-900/30 rounded-lg border border-red-200 dark:border-red-800 transition">
              <Trash2 size={12} /> ë¹„ìš°ê¸°
            </button>
          )}
        </div>

        {/* ì„ íƒ ì•¡ì…˜ ë°” */}
        {selected.size > 0 && (
          <div className="max-w-4xl mx-auto px-4 pb-2 flex items-center gap-3">
            <span className="text-xs text-blue-600 dark:text-blue-400 font-semibold">{selected.size}ê°œ ì„ íƒë¨</span>
            <button onClick={restoreSelected} className="flex items-center gap-1 text-xs text-green-600 dark:text-green-400 hover:underline">
              <RotateCcw size={11} /> ì„ íƒ ë³µêµ¬
            </button>
          </div>
        )}
      </div>

      {/* ì•ˆë‚´ ë°°ë„ˆ */}
      <div className="max-w-4xl mx-auto px-4 pt-4">
        <div className="flex items-center gap-2 px-4 py-3 bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-800 rounded-xl mb-4">
          <AlertTriangle size={15} className="text-amber-600 dark:text-amber-400 shrink-0" />
          <p className="text-xs text-amber-700 dark:text-amber-400">
            íœ´ì§€í†µì˜ íŒŒì¼ì€ ì‚­ì œ í›„ <strong>30ì¼</strong>ì´ ì§€ë‚˜ë©´ ìë™ìœ¼ë¡œ ì˜êµ¬ ì‚­ì œë©ë‹ˆë‹¤.
          </p>
        </div>
      </div>

      <div className="max-w-4xl mx-auto px-4 pb-8">
        {loading ? (
          <div className="space-y-2">
            {[...Array(5)].map((_, i) => (
              <div key={i} className="bg-white dark:bg-slate-800 rounded-xl p-4 animate-pulse flex gap-3">
                <div className="w-10 h-10 bg-gray-200 dark:bg-slate-700 rounded-xl shrink-0" />
                <div className="flex-1 space-y-2">
                  <div className="h-3.5 bg-gray-200 dark:bg-slate-700 rounded w-1/3" />
                  <div className="h-3 bg-gray-100 dark:bg-slate-700/50 rounded w-1/4" />
                </div>
              </div>
            ))}
          </div>
        ) : files.length === 0 ? (
          <div className="flex flex-col items-center justify-center py-32">
            <div className="w-20 h-20 rounded-full bg-gray-100 dark:bg-slate-800 flex items-center justify-center mb-4">
              <Trash2 size={32} className="text-gray-300 dark:text-slate-600" />
            </div>
            <p className="text-gray-500 dark:text-slate-400 font-medium">íœ´ì§€í†µì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤</p>
          </div>
        ) : (
          <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 overflow-hidden">
            {/* ì „ì²´ ì„ íƒ */}
            <div className="px-4 py-2.5 border-b border-gray-100 dark:border-slate-700 flex items-center gap-3">
              <input type="checkbox" checked={selected.size === files.length} onChange={toggleAll}
                className="w-4 h-4 rounded accent-blue-600" />
              <span className="text-xs text-gray-500 dark:text-slate-400">ì „ì²´ ì„ íƒ</span>
            </div>

            <div className="divide-y divide-gray-100 dark:divide-slate-700">
              {files.map((f) => {
                const days = daysLeft(f.deletedAt);
                return (
                  <div key={f.id} className={`flex items-center gap-3 px-4 py-3 hover:bg-gray-50 dark:hover:bg-slate-700/50 transition-colors ${selected.has(f.id) ? "bg-blue-50 dark:bg-blue-900/20" : ""}`}>
                    <input type="checkbox" checked={selected.has(f.id)} onChange={() => toggleSelect(f.id)}
                      className="w-4 h-4 rounded accent-blue-600 shrink-0" />
                    <span className="text-2xl shrink-0">{getFileIcon(f.mimeType)}</span>
                    <div className="flex-1 min-w-0">
                      <p className="text-sm font-medium text-gray-900 dark:text-slate-100 truncate">{f.originalName}</p>
                      <div className="flex items-center gap-2 mt-0.5">
                        <span className="text-xs text-gray-400 dark:text-slate-500">{formatFileSize(f.size)}</span>
                        <span className="text-xs text-gray-300 dark:text-slate-600">Â·</span>
                        <span className={`text-xs font-medium ${days <= 3 ? "text-red-500" : "text-gray-400 dark:text-slate-500"}`}>
                          {days > 0 ? `${days}ì¼ í›„ ìë™ ì‚­ì œ` : "ê³§ ì‚­ì œë¨"}
                        </span>
                      </div>
                    </div>
                    <div className="flex items-center gap-1 shrink-0">
                      <button onClick={() => restore(f.id)}
                        className="flex items-center gap-1 px-2.5 py-1.5 text-xs font-medium text-green-700 dark:text-green-400 bg-green-50 dark:bg-green-900/20 hover:bg-green-100 dark:hover:bg-green-900/30 rounded-lg transition">
                        <RotateCcw size={11} /> ë³µêµ¬
                      </button>
                      <button onClick={() => permanentDelete(f.id)}
                        className="p-1.5 text-gray-400 hover:text-red-500 hover:bg-red-50 dark:hover:bg-red-900/20 rounded-lg transition">
                        <Trash2 size={14} />
                      </button>
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/app/users/[id]/page.tsx">
"use client";

import { useState, useEffect, useCallback } from "react";
import { useSession } from "next-auth/react";
import { useParams, useRouter } from "next/navigation";
import Link from "next/link";
import { ChevronLeft, UserCheck, UserPlus, Users, FileText, MessageSquare } from "lucide-react";
import { toast } from "@/components/Toast";

interface PublicUser {
  id: string;
  name: string;
  email: string;
  role: "USER" | "ADMIN";
  isOnline: boolean;
  createdAt: string;
  _count: { files: number; posts: number; comments: number };
}

interface FollowInfo {
  followerCount: number;
  followingCount: number;
  isFollowing: boolean;
}

interface FollowUser {
  id: string;
  name: string;
  email: string;
  isOnline: boolean;
  followedAt: string;
}

export default function UserProfilePage() {
  const { id } = useParams<{ id: string }>();
  const { data: session } = useSession();
  const router = useRouter();

  const [user, setUser] = useState<PublicUser | null>(null);
  const [followInfo, setFollowInfo] = useState<FollowInfo | null>(null);
  const [tab, setTab] = useState<"followers" | "following">("followers");
  const [tabUsers, setTabUsers] = useState<FollowUser[]>([]);
  const [loading, setLoading] = useState(true);
  const [followLoading, setFollowLoading] = useState(false);
  const [showTab, setShowTab] = useState(false);

  const isSelf = session?.user?.id === id;

  const fetchUser = useCallback(async () => {
    try {
      const [uRes, fRes] = await Promise.all([
        fetch(`/api/users/${id}/public`),
        fetch(`/api/users/${id}/follow`),
      ]);
      if (uRes.ok) setUser(await uRes.json());
      if (fRes.ok) setFollowInfo(await fRes.json());
    } catch {
      toast.error("ì‚¬ìš©ì ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  }, [id]);

  const fetchTabUsers = useCallback(async () => {
    const res = await fetch(`/api/users/${id}/followers?type=${tab}`);
    if (res.ok) setTabUsers((await res.json()).users);
  }, [id, tab]);

  useEffect(() => { fetchUser(); }, [fetchUser]);
  useEffect(() => { if (showTab) fetchTabUsers(); }, [showTab, fetchTabUsers]);

  const toggleFollow = async () => {
    if (!session) { router.push("/login"); return; }
    if (!followInfo) return;
    setFollowLoading(true);
    try {
      const method = followInfo.isFollowing ? "DELETE" : "POST";
      const res = await fetch(`/api/users/${id}/follow`, { method });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error);
      setFollowInfo((f) => f ? {
        ...f,
        isFollowing: data.following,
        followerCount: f.followerCount + (data.following ? 1 : -1),
      } : f);
      toast.success(data.following ? "íŒ”ë¡œìš°í–ˆìŠµë‹ˆë‹¤" : "íŒ”ë¡œìš°ë¥¼ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤");
    } catch (e: any) {
      toast.error(e.message || "ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setFollowLoading(false);
    }
  };

  if (loading) return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900 flex items-center justify-center">
      <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600" />
    </div>
  );

  if (!user) return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900 flex flex-col items-center justify-center gap-3">
      <p className="text-gray-500 dark:text-slate-400">ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤</p>
      <Link href="/dashboard" className="text-blue-600 text-sm hover:underline">ëŒ€ì‹œë³´ë“œë¡œ</Link>
    </div>
  );

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900">
      {/* í—¤ë” */}
      <div className="bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700 sticky top-0 z-10">
        <div className="max-w-2xl mx-auto px-4 py-3 flex items-center gap-3">
          <button onClick={() => router.back()} className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
            <ChevronLeft size={20} className="text-gray-600 dark:text-slate-400" />
          </button>
          <h1 className="text-lg font-semibold text-gray-900 dark:text-slate-100 flex-1 truncate">
            {user.name}
          </h1>
        </div>
      </div>

      <div className="max-w-2xl mx-auto px-4 py-6 space-y-4">
        {/* í”„ë¡œí•„ ì¹´ë“œ */}
        <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-6">
          <div className="flex items-start gap-4">
            {/* ì•„ë°”íƒ€ */}
            <div className="relative shrink-0">
              <div className="w-16 h-16 rounded-full bg-gradient-to-br from-blue-400 to-purple-500 flex items-center justify-center text-white text-2xl font-bold">
                {user.name[0]}
              </div>
              <span className={`absolute bottom-0.5 right-0.5 w-3.5 h-3.5 rounded-full border-2 border-white dark:border-slate-800 ${
                user.isOnline ? "bg-green-500" : "bg-gray-300"
              }`} />
            </div>

            {/* ì •ë³´ */}
            <div className="flex-1 min-w-0">
              <div className="flex items-center gap-2 flex-wrap">
                <h2 className="text-xl font-bold text-gray-900 dark:text-slate-100">{user.name}</h2>
                {user.role === "ADMIN" && (
                  <span className="text-xs font-semibold bg-yellow-100 dark:bg-yellow-900/30 text-yellow-700 dark:text-yellow-400 px-2 py-0.5 rounded-full">ğŸ‘‘ ê´€ë¦¬ì</span>
                )}
              </div>
              <p className="text-sm text-gray-500 dark:text-slate-400 mt-0.5">{user.email}</p>
              <p className="text-xs text-gray-400 dark:text-slate-500 mt-1">
                {user.isOnline ? "ğŸŸ¢ ì˜¨ë¼ì¸" : "âš« ì˜¤í”„ë¼ì¸"} Â· {new Date(user.createdAt).toLocaleDateString("ko-KR")} ê°€ì…
              </p>
            </div>

            {/* íŒ”ë¡œìš° ë²„íŠ¼ */}
            {!isSelf && session && (
              <button
                onClick={toggleFollow}
                disabled={followLoading}
                className={`flex items-center gap-1.5 px-4 py-2 rounded-xl text-sm font-semibold transition shrink-0 ${
                  followInfo?.isFollowing
                    ? "bg-gray-100 dark:bg-slate-700 text-gray-700 dark:text-slate-300 hover:bg-red-50 dark:hover:bg-red-900/20 hover:text-red-600"
                    : "bg-blue-600 text-white hover:bg-blue-700"
                } disabled:opacity-50`}
              >
                {followInfo?.isFollowing
                  ? <><UserCheck size={15} /> íŒ”ë¡œì‰</>
                  : <><UserPlus size={15} /> íŒ”ë¡œìš°</>
                }
              </button>
            )}
          </div>

          {/* í†µê³„ */}
          <div className="grid grid-cols-4 gap-2 mt-5 pt-5 border-t border-gray-100 dark:border-slate-700">
            {[
              { label: "íŒ”ë¡œì›Œ", value: followInfo?.followerCount ?? 0, onClick: () => { setTab("followers"); setShowTab(true); } },
              { label: "íŒ”ë¡œì‰", value: followInfo?.followingCount ?? 0, onClick: () => { setTab("following"); setShowTab(true); } },
              { label: "ê²Œì‹œê¸€", value: user._count.posts, onClick: undefined },
              { label: "íŒŒì¼",   value: user._count.files, onClick: undefined },
            ].map(({ label, value, onClick }) => (
              <button
                key={label}
                onClick={onClick}
                disabled={!onClick}
                className={`text-center ${onClick ? "cursor-pointer hover:bg-gray-50 dark:hover:bg-slate-700 rounded-lg p-1 transition-colors" : "cursor-default"}`}
              >
                <p className="text-lg font-bold text-gray-900 dark:text-slate-100">{value.toLocaleString()}</p>
                <p className="text-xs text-gray-500 dark:text-slate-400">{label}</p>
              </button>
            ))}
          </div>
        </div>

        {/* íŒ”ë¡œì›Œ/íŒ”ë¡œì‰ ëª©ë¡ */}
        {showTab && (
          <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700">
            <div className="flex border-b border-gray-100 dark:border-slate-700">
              {(["followers", "following"] as const).map((t) => (
                <button
                  key={t}
                  onClick={() => setTab(t)}
                  className={`flex-1 py-3 text-sm font-semibold transition-colors ${
                    tab === t
                      ? "text-blue-600 border-b-2 border-blue-600"
                      : "text-gray-500 dark:text-slate-400 hover:text-gray-700 dark:hover:text-slate-300"
                  }`}
                >
                  {t === "followers" ? `íŒ”ë¡œì›Œ ${followInfo?.followerCount ?? 0}` : `íŒ”ë¡œì‰ ${followInfo?.followingCount ?? 0}`}
                </button>
              ))}
              <button onClick={() => setShowTab(false)} className="px-4 text-gray-400 hover:text-gray-600 text-lg">Ã—</button>
            </div>
            <div className="divide-y divide-gray-100 dark:divide-slate-700">
              {tabUsers.length === 0 ? (
                <p className="text-center py-8 text-sm text-gray-400 dark:text-slate-500">
                  {tab === "followers" ? "íŒ”ë¡œì›Œê°€ ì—†ìŠµë‹ˆë‹¤" : "íŒ”ë¡œì‰ ì¤‘ì¸ ì‚¬ìš©ìê°€ ì—†ìŠµë‹ˆë‹¤"}
                </p>
              ) : tabUsers.map((u) => (
                <Link key={u.id} href={`/users/${u.id}`} className="flex items-center gap-3 px-4 py-3 hover:bg-gray-50 dark:hover:bg-slate-700 transition-colors">
                  <div className="relative">
                    <div className="w-9 h-9 rounded-full bg-gradient-to-br from-blue-400 to-purple-500 flex items-center justify-center text-white text-sm font-bold">
                      {u.name[0]}
                    </div>
                    {u.isOnline && <span className="absolute bottom-0 right-0 w-2.5 h-2.5 bg-green-500 rounded-full border border-white dark:border-slate-800" />}
                  </div>
                  <div className="flex-1 min-w-0">
                    <p className="text-sm font-medium text-gray-900 dark:text-slate-100 truncate">{u.name}</p>
                    <p className="text-xs text-gray-400 dark:text-slate-500 truncate">{u.email}</p>
                  </div>
                </Link>
              ))}
            </div>
          </div>
        )}

        {/* ê²Œì‹œê¸€ ë°”ë¡œê°€ê¸° */}
        <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-4">
          <Link href={`/posts?author=${id}`} className="flex items-center justify-between group">
            <div className="flex items-center gap-3">
              <FileText size={18} className="text-indigo-500" />
              <span className="text-sm font-medium text-gray-900 dark:text-slate-100">ì‘ì„±í•œ ê²Œì‹œê¸€</span>
            </div>
            <span className="text-sm text-blue-600 dark:text-blue-400 group-hover:underline">ë³´ê¸° â†’</span>
          </Link>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/DragDropUpload.tsx">
"use client";
// src/components/DragDropUpload.tsx
// ëŒ€ì‹œë³´ë“œ ì—…ë¡œë“œ ì˜ì—­ì„ ì´ ì»´í¬ë„ŒíŠ¸ë¡œ êµì²´í•˜ì„¸ìš”

import { useState, useRef, useCallback } from "react";
import { Upload, X, CheckCircle, AlertCircle, File } from "lucide-react";
import { getFileIcon, formatFileSize } from "@/lib/client-utils";

const MAX_FILE_SIZE = 50 * 1024 * 1024; // 50MB
const MAX_FILES = 10;

interface UploadFile {
  id: string;
  file: File;
  progress: number;
  status: "pending" | "uploading" | "done" | "error";
  error?: string;
}

interface Props {
  folderId?: string | null;
  onUploadComplete?: () => void;
}

export default function DragDropUpload({ folderId, onUploadComplete }: Props) {
  const [isDragging, setIsDragging] = useState(false);
  const [files, setFiles] = useState<UploadFile[]>([]);
  const inputRef = useRef<HTMLInputElement>(null);

  const addFiles = useCallback((newFiles: File[]) => {
    const valid = newFiles
      .slice(0, MAX_FILES - files.length)
      .filter((f) => {
        if (f.size > MAX_FILE_SIZE) return false;
        return true;
      })
      .map((f) => ({
        id: Math.random().toString(36).slice(2),
        file: f,
        progress: 0,
        status: "pending" as const,
      }));
    setFiles((prev) => [...prev, ...valid]);
  }, [files.length]);

  // ë“œë˜ê·¸ ì´ë²¤íŠ¸
  const onDragOver = (e: React.DragEvent) => { e.preventDefault(); setIsDragging(true); };
  const onDragLeave = (e: React.DragEvent) => { e.preventDefault(); setIsDragging(false); };
  const onDrop = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);
    const dropped = Array.from(e.dataTransfer.files);
    addFiles(dropped);
  };

  const removeFile = (id: string) => setFiles((f) => f.filter((x) => x.id !== id));

  const uploadFile = async (uploadFile: UploadFile) => {
    setFiles((prev) => prev.map((f) => f.id === uploadFile.id ? { ...f, status: "uploading" } : f));

    const formData = new FormData();
    formData.append("file", uploadFile.file);
    if (folderId) formData.append("folderId", folderId);

    try {
      const xhr = new XMLHttpRequest();
      await new Promise<void>((resolve, reject) => {
        xhr.upload.onprogress = (e) => {
          if (e.lengthComputable) {
            const pct = Math.round((e.loaded / e.total) * 100);
            setFiles((prev) => prev.map((f) => f.id === uploadFile.id ? { ...f, progress: pct } : f));
          }
        };
        xhr.onload = () => {
          if (xhr.status >= 200 && xhr.status < 300) resolve();
          else reject(new Error(JSON.parse(xhr.responseText)?.error ?? "ì—…ë¡œë“œ ì‹¤íŒ¨"));
        };
        xhr.onerror = () => reject(new Error("ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜"));
        xhr.open("POST", "/api/files/upload");
        xhr.send(formData);
      });

      setFiles((prev) => prev.map((f) => f.id === uploadFile.id ? { ...f, status: "done", progress: 100 } : f));
    } catch (err: any) {
      setFiles((prev) => prev.map((f) => f.id === uploadFile.id ? { ...f, status: "error", error: err.message } : f));
    }
  };

  const uploadAll = async () => {
    const pending = files.filter((f) => f.status === "pending");
    await Promise.all(pending.map(uploadFile));
    if (pending.length > 0) onUploadComplete?.();
  };

  const clearDone = () => setFiles((f) => f.filter((x) => x.status !== "done"));

  const hasPending = files.some((f) => f.status === "pending");
  const allDone = files.length > 0 && files.every((f) => f.status === "done" || f.status === "error");

  return (
    <div className="space-y-3">
      {/* ë“œë¡­ ì˜ì—­ */}
      <div
        onDragOver={onDragOver}
        onDragLeave={onDragLeave}
        onDrop={onDrop}
        onClick={() => inputRef.current?.click()}
        className={`relative flex flex-col items-center justify-center min-h-36 rounded-2xl border-2 border-dashed cursor-pointer transition-all ${
          isDragging
            ? "border-blue-500 bg-blue-50 dark:bg-blue-900/20 scale-[1.01]"
            : "border-gray-200 dark:border-slate-700 bg-gray-50 dark:bg-slate-800/50 hover:border-blue-400 hover:bg-blue-50/50 dark:hover:bg-slate-800"
        }`}
      >
        <input
          ref={inputRef}
          type="file"
          multiple
          className="hidden"
          onChange={(e) => addFiles(Array.from(e.target.files ?? []))}
        />
        <Upload size={28} className={`mb-2 transition-colors ${isDragging ? "text-blue-500" : "text-gray-400 dark:text-slate-500"}`} />
        <p className={`text-sm font-semibold transition-colors ${isDragging ? "text-blue-600 dark:text-blue-400" : "text-gray-600 dark:text-slate-400"}`}>
          {isDragging ? "ì—¬ê¸°ì— ë†“ìœ¼ì„¸ìš”!" : "íŒŒì¼ì„ ë“œë˜ê·¸í•˜ê±°ë‚˜ í´ë¦­í•˜ì—¬ ì„ íƒ"}
        </p>
        <p className="text-xs text-gray-400 dark:text-slate-500 mt-1">ìµœëŒ€ {MAX_FILES}ê°œ Â· íŒŒì¼ë‹¹ 50MB</p>
      </div>

      {/* íŒŒì¼ ëª©ë¡ */}
      {files.length > 0 && (
        <div className="space-y-2">
          {files.map((f) => (
            <div key={f.id} className="flex items-center gap-3 bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 px-3 py-2.5">
              <span className="text-xl shrink-0">{getFileIcon(f.file.type)}</span>
              <div className="flex-1 min-w-0">
                <p className="text-xs font-medium text-gray-900 dark:text-slate-100 truncate">{f.file.name}</p>
                <p className="text-[10px] text-gray-400 dark:text-slate-500">{formatFileSize(f.file.size)}</p>
                {/* ì§„í–‰ ë°” */}
                {(f.status === "uploading" || f.status === "done") && (
                  <div className="mt-1.5 h-1.5 bg-gray-100 dark:bg-slate-700 rounded-full overflow-hidden">
                    <div
                      className={`h-full rounded-full transition-all duration-200 ${f.status === "done" ? "bg-green-500" : "bg-blue-500"}`}
                      style={{ width: `${f.progress}%` }}
                    />
                  </div>
                )}
                {f.status === "error" && (
                  <p className="text-[10px] text-red-500 mt-0.5">{f.error}</p>
                )}
              </div>
              {/* ìƒíƒœ ì•„ì´ì½˜ */}
              <div className="shrink-0">
                {f.status === "done" && <CheckCircle size={16} className="text-green-500" />}
                {f.status === "error" && <AlertCircle size={16} className="text-red-500" />}
                {f.status === "uploading" && (
                  <div className="w-4 h-4 border-2 border-blue-500/30 border-t-blue-500 rounded-full animate-spin" />
                )}
                {f.status === "pending" && (
                  <button onClick={(e) => { e.stopPropagation(); removeFile(f.id); }} className="text-gray-400 hover:text-red-500 transition-colors">
                    <X size={16} />
                  </button>
                )}
              </div>
            </div>
          ))}

          {/* ì•¡ì…˜ ë²„íŠ¼ */}
          <div className="flex gap-2">
            {hasPending && (
              <button
                onClick={uploadAll}
                className="flex-1 py-2.5 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-xl transition-colors"
              >
                ì—…ë¡œë“œ ì‹œì‘ ({files.filter((f) => f.status === "pending").length}ê°œ)
              </button>
            )}
            {allDone && (
              <button
                onClick={clearDone}
                className="flex-1 py-2.5 text-sm font-medium text-gray-600 dark:text-slate-400 bg-gray-100 dark:bg-slate-700 hover:bg-gray-200 dark:hover:bg-slate-600 rounded-xl transition-colors"
              >
                ëª©ë¡ ì§€ìš°ê¸°
              </button>
            )}
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/ErrorBoundary.tsx">
"use client";
// src/components/ErrorBoundary.tsx
// React ì—ëŸ¬ ë°”ìš´ë”ë¦¬ â€” í˜ì´ì§€/ì»´í¬ë„ŒíŠ¸ ë‹¨ìœ„ í¬ë˜ì‹œ ê²©ë¦¬

import React, { Component, ErrorInfo, ReactNode } from "react";
import { AlertTriangle, RefreshCw, Home, ChevronDown, ChevronUp } from "lucide-react";

interface Props {
  children:   ReactNode;
  fallback?:  ReactNode;
  level?:     "page" | "section" | "inline";
  onError?:   (error: Error, info: ErrorInfo) => void;
}

interface State {
  hasError:     boolean;
  error:        Error | null;
  showDetails:  boolean;
}

export class ErrorBoundary extends Component<Props, State> {
  state: State = { hasError: false, error: null, showDetails: false };

  static getDerivedStateFromError(error: Error): Partial<State> {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, info: ErrorInfo) {
    // ì—ëŸ¬ ë¡œê¹… (ì„œë²„ë¡œ ì „ì†¡)
    this.props.onError?.(error, info);
    reportError(error, {
      componentStack: info.componentStack,
      level:          this.props.level ?? "section",
    });
  }

  reset = () => this.setState({ hasError: false, error: null, showDetails: false });

  render() {
    if (!this.state.hasError) return this.props.children;

    // ì»¤ìŠ¤í…€ fallbackì´ ìˆìœ¼ë©´ ì‚¬ìš©
    if (this.props.fallback) return this.props.fallback;

    const { level = "section", error } = { ...this.props, ...this.state };

    // â”€â”€ inline (í† ìŠ¤íŠ¸/ì¹´ë“œ ìˆ˜ì¤€) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (level === "inline") {
      return (
        <div className="flex items-center gap-2 px-3 py-2 bg-red-50 dark:bg-red-900/20 border border-red-100 dark:border-red-800 rounded-xl">
          <AlertTriangle size={14} className="text-red-500 shrink-0" />
          <p className="text-xs text-red-600 dark:text-red-400 flex-1">
            ì´ ì„¹ì…˜ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤
          </p>
          <button onClick={this.reset} className="text-xs text-red-500 hover:text-red-700 font-medium">
            ì¬ì‹œë„
          </button>
        </div>
      );
    }

    // â”€â”€ section (ì¹´ë“œ/íŒ¨ë„ ìˆ˜ì¤€) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (level === "section") {
      return (
        <div className="flex flex-col items-center justify-center py-12 px-6 text-center rounded-2xl border-2 border-dashed border-red-200 dark:border-red-800 bg-red-50/50 dark:bg-red-900/10">
          <div className="w-12 h-12 rounded-full bg-red-100 dark:bg-red-900/30 flex items-center justify-center mb-3">
            <AlertTriangle size={22} className="text-red-500" />
          </div>
          <p className="text-sm font-semibold text-gray-900 dark:text-slate-100 mb-1">
            ì´ ì„¹ì…˜ì—ì„œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤
          </p>
          <p className="text-xs text-gray-400 dark:text-slate-500 mb-4">
            {error?.message ?? "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜"}
          </p>
          <button
            onClick={this.reset}
            className="flex items-center gap-1.5 px-4 py-2 text-sm font-semibold text-white bg-red-600 hover:bg-red-700 rounded-xl transition"
          >
            <RefreshCw size={13} /> ë‹¤ì‹œ ì‹œë„
          </button>
        </div>
      );
    }

    // â”€â”€ page (ì „ì²´ í˜ì´ì§€ ìˆ˜ì¤€) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    return (
      <div className="min-h-screen flex flex-col items-center justify-center bg-gray-50 dark:bg-slate-900 px-4">
        <div className="max-w-md w-full text-center">
          {/* ì•„ì´ì½˜ */}
          <div className="w-20 h-20 rounded-2xl bg-red-50 dark:bg-red-900/30 flex items-center justify-center mx-auto mb-6 shadow-lg">
            <AlertTriangle size={36} className="text-red-500" />
          </div>

          <h1 className="text-2xl font-black text-gray-900 dark:text-slate-100 mb-2">
            ì˜ˆê¸°ì¹˜ ì•Šì€ ì˜¤ë¥˜
          </h1>
          <p className="text-gray-500 dark:text-slate-400 mb-8">
            í˜ì´ì§€ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.
            <br />ë‹¤ì‹œ ì‹œë„í•˜ê±°ë‚˜ í™ˆìœ¼ë¡œ ëŒì•„ê°€ì„¸ìš”.
          </p>

          {/* ì—ëŸ¬ ìƒì„¸ (ê°œë°œ í™˜ê²½) */}
          {process.env.NODE_ENV === "development" && error && (
            <div className="mb-6 text-left">
              <button
                onClick={() => this.setState((s) => ({ showDetails: !s.showDetails }))}
                className="flex items-center gap-1.5 text-xs text-gray-400 hover:text-gray-600 dark:hover:text-slate-300 mb-2"
              >
                {this.state.showDetails ? <ChevronUp size={12} /> : <ChevronDown size={12} />}
                ì—ëŸ¬ ìƒì„¸ (ê°œë°œ í™˜ê²½)
              </button>
              {this.state.showDetails && (
                <pre className="text-left text-[10px] bg-gray-900 text-red-300 rounded-xl p-4 overflow-auto max-h-40 whitespace-pre-wrap">
                  {error.message}{"\n\n"}{error.stack}
                </pre>
              )}
            </div>
          )}

          <div className="flex gap-3">
            <button
              onClick={this.reset}
              className="flex-1 flex items-center justify-center gap-2 py-3 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-xl transition"
            >
              <RefreshCw size={15} /> ë‹¤ì‹œ ì‹œë„
            </button>
            <a
              href="/dashboard"
              className="flex-1 flex items-center justify-center gap-2 py-3 text-sm font-semibold text-gray-700 dark:text-slate-300 bg-white dark:bg-slate-800 hover:bg-gray-50 dark:hover:bg-slate-700 border border-gray-200 dark:border-slate-700 rounded-xl transition"
            >
              <Home size={15} /> í™ˆìœ¼ë¡œ
            </a>
          </div>
        </div>
      </div>
    );
  }
}

// â”€â”€ ì—ëŸ¬ ë¦¬í¬íŒ… í•¨ìˆ˜ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function reportError(error: Error, context?: object) {
  if (process.env.NODE_ENV === "development") {
    console.error("[ErrorBoundary]", error, context);
    return;
  }
  // í”„ë¡œë•ì…˜ì—ì„œ ì„œë²„ë¡œ ì—ëŸ¬ ì „ì†¡
  try {
    await fetch("/api/errors/report", {
      method:  "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        message: error.message,
        stack:   error.stack,
        context,
        url:     window.location.href,
        ua:      navigator.userAgent,
        ts:      new Date().toISOString(),
      }),
    });
  } catch {}
}

// â”€â”€ ë˜í¼ ì»´í¬ë„ŒíŠ¸ (í¸ì˜ìš©) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function PageErrorBoundary({ children }: { children: ReactNode }) {
  return <ErrorBoundary level="page">{children}</ErrorBoundary>;
}
export function SectionErrorBoundary({ children }: { children: ReactNode }) {
  return <ErrorBoundary level="section">{children}</ErrorBoundary>;
}
export function InlineErrorBoundary({ children }: { children: ReactNode }) {
  return <ErrorBoundary level="inline">{children}</ErrorBoundary>;
}
</file>

<file path="src/components/FileEncryptButton.tsx">
"use client";
// src/components/FileEncryptButton.tsx

import { useState } from "react";
import { Lock, LockOpen, Eye, EyeOff } from "lucide-react";
import { toast } from "@/components/Toast";

interface Props {
  fileId: string;
  isEncrypted: boolean;
  onStatusChange?: (encrypted: boolean) => void;
}

function PasswordModal({
  title, hint, onConfirm, onClose, loading,
}: {
  title: string; hint: string;
  onConfirm: (pw: string) => void;
  onClose: () => void; loading: boolean;
}) {
  const [pw, setPw] = useState("");
  const [show, setShow] = useState(false);
  return (
    <div className="fixed inset-0 z-[9999] flex items-center justify-center px-4" onClick={onClose}>
      <div className="absolute inset-0 bg-black/50 backdrop-blur-sm" />
      <div className="relative z-10 w-full max-w-sm bg-white dark:bg-slate-800 rounded-2xl shadow-2xl p-6 space-y-4"
        onClick={(e) => e.stopPropagation()}>
        <h3 className="text-base font-bold text-gray-900 dark:text-slate-100">{title}</h3>
        <p className="text-xs text-gray-500 dark:text-slate-400">{hint}</p>
        <div className="relative">
          <input
            autoFocus
            type={show ? "text" : "password"}
            value={pw}
            onChange={(e) => setPw(e.target.value)}
            onKeyDown={(e) => e.key === "Enter" && pw.length >= 4 && onConfirm(pw)}
            placeholder="ë¹„ë°€ë²ˆí˜¸ ì…ë ¥"
            className="w-full pr-10 pl-4 py-2.5 text-sm border border-gray-200 dark:border-slate-600 rounded-xl bg-white dark:bg-slate-700 dark:text-slate-100 focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
          <button onClick={() => setShow(!show)}
            className="absolute right-3 top-1/2 -translate-y-1/2 text-gray-400">
            {show ? <EyeOff size={15} /> : <Eye size={15} />}
          </button>
        </div>
        <div className="flex gap-2 pt-1">
          <button onClick={onClose}
            className="flex-1 py-2.5 text-sm text-gray-600 dark:text-slate-400 bg-gray-100 dark:bg-slate-700 hover:bg-gray-200 dark:hover:bg-slate-600 rounded-xl transition">
            ì·¨ì†Œ
          </button>
          <button onClick={() => onConfirm(pw)} disabled={pw.length < 4 || loading}
            className="flex-1 py-2.5 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-xl transition disabled:opacity-50">
            {loading ? "ì²˜ë¦¬ ì¤‘..." : "í™•ì¸"}
          </button>
        </div>
      </div>
    </div>
  );
}

export default function FileEncryptButton({ fileId, isEncrypted: initEncrypted, onStatusChange }: Props) {
  const [isEncrypted, setIsEncrypted] = useState(initEncrypted);
  const [showModal, setShowModal] = useState(false);
  const [loading, setLoading] = useState(false);

  const handleConfirm = async (password: string) => {
    setLoading(true);
    try {
      const res = await fetch(`/api/files/${fileId}/encrypt`, {
        method: isEncrypted ? "DELETE" : "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ password }),
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error);
      const newState = !isEncrypted;
      setIsEncrypted(newState);
      onStatusChange?.(newState);
      toast.success(data.message);
      setShowModal(false);
    } catch (e: any) {
      toast.error(e.message || "ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  };

  return (
    <>
      {showModal && (
        <PasswordModal
          title={isEncrypted ? "íŒŒì¼ ì ê¸ˆ í•´ì œ" : "íŒŒì¼ ì•”í˜¸í™”"}
          hint={isEncrypted
            ? "ì„¤ì •í–ˆë˜ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ ì•”í˜¸í™”ë¥¼ í•´ì œí•©ë‹ˆë‹¤."
            : "ì´ íŒŒì¼ì„ ë¹„ë°€ë²ˆí˜¸ë¡œ ë³´í˜¸í•©ë‹ˆë‹¤. ë¹„ë°€ë²ˆí˜¸ë¥¼ ìƒì–´ë²„ë¦¬ë©´ íŒŒì¼ì„ ë³µêµ¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."}
          onConfirm={handleConfirm}
          onClose={() => setShowModal(false)}
          loading={loading}
        />
      )}
      <button
        onClick={() => setShowModal(true)}
        className={`flex items-center gap-1.5 px-3 py-1.5 text-xs font-semibold rounded-lg transition ${
          isEncrypted
            ? "bg-orange-50 dark:bg-orange-900/20 text-orange-600 dark:text-orange-400 hover:bg-orange-100 dark:hover:bg-orange-900/30"
            : "bg-gray-100 dark:bg-slate-700 text-gray-600 dark:text-slate-400 hover:bg-gray-200 dark:hover:bg-slate-600"
        }`}
      >
        {isEncrypted ? <><Lock size={12} /> ì ê¹€</> : <><LockOpen size={12} /> ì•”í˜¸í™”</>}
      </button>
    </>
  );
}
</file>

<file path="src/components/FileFavoritePin.tsx">
"use client";
// src/components/FileFavoritePin.tsx
// âš ï¸ ìˆ˜ì •: PinnedFilesSectionì˜ require("react") ë²„ê·¸ ì œê±°

import { useState, useEffect } from "react";
import { Star, Pin } from "lucide-react";
import { toast } from "@/components/Toast";

interface Props {
  fileId:    string;
  isStarred: boolean;
  isPinned:  boolean;
  onUpdate?: (starred: boolean, pinned: boolean) => void;
}

export default function FileFavoritePin({ fileId, isStarred: initStarred, isPinned: initPinned, onUpdate }: Props) {
  const [starred, setStarred] = useState(initStarred);
  const [pinned,  setPinned]  = useState(initPinned);
  const [loading, setLoading] = useState(false);

  async function toggleStar() {
    setLoading(true);
    try {
      const res = await fetch(`/api/files/${fileId}/favorite`, { method: "POST" });
      if (!res.ok) throw new Error();
      const { starred: s } = await res.json();
      setStarred(s);
      onUpdate?.(s, pinned);
      toast.success(s ? "ì¦ê²¨ì°¾ê¸°ì— ì¶”ê°€í–ˆìŠµë‹ˆë‹¤" : "ì¦ê²¨ì°¾ê¸°ë¥¼ í•´ì œí–ˆìŠµë‹ˆë‹¤");
    } catch {
      toast.error("ì²˜ë¦¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  }

  async function togglePin() {
    setLoading(true);
    try {
      const res = await fetch(`/api/files/${fileId}/favorite`, { method: "PATCH" });
      if (!res.ok) {
        const err = await res.json().catch(() => ({}));
        toast.error(err?.error ?? "ì²˜ë¦¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
        return;
      }
      const { pinned: p } = await res.json();
      setPinned(p);
      onUpdate?.(starred, p);
      toast.success(p ? "íŒŒì¼ì„ ê³ ì •í–ˆìŠµë‹ˆë‹¤" : "ê³ ì •ì„ í•´ì œí–ˆìŠµë‹ˆë‹¤");
    } catch {
      toast.error("ì²˜ë¦¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  }

  return (
    <div className="flex items-center gap-1">
      <button onClick={toggleStar} disabled={loading}
        className={`p-1.5 rounded-lg transition ${starred ? "text-yellow-500 bg-yellow-50 dark:bg-yellow-900/20" : "text-gray-400 hover:text-yellow-500 hover:bg-yellow-50"}`}
        title={starred ? "ì¦ê²¨ì°¾ê¸° í•´ì œ" : "ì¦ê²¨ì°¾ê¸°"}>
        <Star size={14} fill={starred ? "currentColor" : "none"} />
      </button>
      <button onClick={togglePin} disabled={loading}
        className={`p-1.5 rounded-lg transition ${pinned ? "text-blue-500 bg-blue-50 dark:bg-blue-900/20" : "text-gray-400 hover:text-blue-500 hover:bg-blue-50"}`}
        title={pinned ? "ê³ ì • í•´ì œ" : "ê³ ì •"}>
        <Pin size={14} fill={pinned ? "currentColor" : "none"} />
      </button>
    </div>
  );
}

export function PinnedFilesSection() {
  const [files, setFiles] = useState<any[]>([]);

  useEffect(() => {
    fetch("/api/files?pinned=true&limit=10")
      .then((r) => r.json())
      .then((d) => setFiles(d.files ?? []))
      .catch(() => {});
  }, []);

  if (files.length === 0) return null;

  return (
    <div className="mb-6">
      <div className="flex items-center gap-2 mb-3">
        <Pin size={14} className="text-blue-500" />
        <h3 className="text-sm font-semibold text-gray-700 dark:text-slate-300">ê³ ì •ëœ íŒŒì¼</h3>
      </div>
      <div className="flex gap-2 overflow-x-auto pb-2">
        {files.map((f) => (
          <div key={f.id} className="shrink-0 bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-3 w-36 hover:shadow-md transition cursor-pointer">
            <div className="text-2xl mb-2 text-center">
              {f.mimeType?.startsWith("image/") && f.thumbnailUrl
                ? <img src={f.thumbnailUrl} alt={f.originalName} className="w-full h-16 object-cover rounded-lg" />
                : <span>ğŸ“„</span>}
            </div>
            <p className="text-xs font-medium text-gray-800 dark:text-slate-200 truncate">{f.originalName}</p>
          </div>
        ))}
      </div>
    </div>
  );
}
</file>

<file path="src/components/FileShareModal.tsx">
"use client";

import { useState, useEffect } from "react";
import { toast } from "@/components/Toast";

interface Share {
  id: string;
  sharedWith: { id: string; email: string; name: string };
  permission: string;
  createdAt: string;
}

interface FileShareModalProps {
  fileId: string | null;
  fileName: string;
  onClose: () => void;
}

export default function FileShareModal({ fileId, fileName, onClose }: FileShareModalProps) {
  const [email, setEmail] = useState("");
  const [permission, setPermission] = useState("VIEW");
  const [shares, setShares] = useState<Share[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  // âœ… confirm() ëŒ€ì²´: ì‚­ì œ ëŒ€ê¸° ì¤‘ì¸ shareId ì €ì¥
  const [pendingDeleteId, setPendingDeleteId] = useState<string | null>(null);

  useEffect(() => {
    if (fileId) fetchShares();
  }, [fileId]);

  const fetchShares = async () => {
    if (!fileId) return;
    try {
      const res = await fetch(`/api/files/${fileId}/share`);
      if (res.ok) setShares((await res.json()).shares);
    } catch {}
  };

  const handleShare = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!fileId || !email) return;
    setLoading(true);
    setError("");
    try {
      const res = await fetch(`/api/files/${fileId}/share`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ sharedWithEmail: email, permission }),
      });
      const data = await res.json();
      if (!res.ok) {
        setError(data.error || "ê³µìœ  ì‹¤íŒ¨");
        return;
      }
      // âœ… alert() â†’ toast
      toast.success("íŒŒì¼ì´ ê³µìœ ë˜ì—ˆìŠµë‹ˆë‹¤");
      setEmail("");
      fetchShares();
    } catch {
      setError("ê³µìœ  ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  };

  const handleDeleteShare = async (shareId: string) => {
    if (!fileId) return;
    try {
      const res = await fetch(`/api/files/${fileId}/share?shareId=${shareId}`, {
        method: "DELETE",
      });
      if (res.ok) {
        toast.success("ê³µìœ ê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤");
        fetchShares();
      } else {
        toast.error("ê³µìœ  ì·¨ì†Œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
      }
    } catch {
      toast.error("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setPendingDeleteId(null);
    }
  };

  if (!fileId) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4" onClick={onClose}>
      <div className="bg-white rounded-xl shadow-xl max-w-2xl w-full max-h-[80vh] overflow-hidden" onClick={(e) => e.stopPropagation()}>
        {/* í—¤ë” */}
        <div className="flex items-center justify-between p-6 border-b">
          <h3 className="text-lg font-semibold text-gray-900">íŒŒì¼ ê³µìœ : {fileName}</h3>
          <button onClick={onClose} className="text-gray-400 hover:text-gray-600 text-2xl">Ã—</button>
        </div>

        <div className="p-6 overflow-y-auto max-h-[60vh]">
          {/* ê³µìœ  ì¶”ê°€ í¼ */}
          <form onSubmit={handleShare} className="mb-6">
            <label className="block text-sm font-medium text-gray-700 mb-2">ê³µìœ í•  ì‚¬ìš©ì ì´ë©”ì¼</label>
            {error && (
              <div className="mb-3 p-3 bg-red-50 border border-red-200 rounded-md">
                <p className="text-sm text-red-800">{error}</p>
              </div>
            )}
            <div className="flex gap-2 mb-3">
              <input
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                placeholder="user@example.com"
                className="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-900"
                required
              />
              <select
                value={permission}
                onChange={(e) => setPermission(e.target.value)}
                className="px-3 py-2 border border-gray-300 rounded-md text-gray-900"
              >
                <option value="VIEW">ë³´ê¸°</option>
                <option value="EDIT">í¸ì§‘</option>
              </select>
              <button
                type="submit"
                disabled={loading}
                className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:opacity-50"
              >
                {loading ? "ê³µìœ  ì¤‘..." : "ê³µìœ "}
              </button>
            </div>
          </form>

          {/* ê³µìœ  ëª©ë¡ */}
          {shares.length > 0 && (
            <div>
              <h4 className="text-sm font-medium text-gray-700 mb-3">ê³µìœ ëœ ì‚¬ìš©ì</h4>
              <div className="space-y-2">
                {shares.map((share) => (
                  <div key={share.id}>
                    <div className="flex items-center justify-between p-3 bg-gray-50 rounded-md">
                      <div>
                        <p className="text-sm font-medium text-gray-900">{share.sharedWith.name}</p>
                        <p className="text-xs text-gray-500">{share.sharedWith.email}</p>
                      </div>
                      <div className="flex items-center gap-2">
                        <span className="px-2 py-1 text-xs bg-blue-100 text-blue-700 rounded">
                          {share.permission === "VIEW" ? "ë³´ê¸°" : "í¸ì§‘"}
                        </span>
                        {/* âœ… confirm() â†’ ì¸ë¼ì¸ í™•ì¸ UI */}
                        {pendingDeleteId === share.id ? (
                          <div className="flex items-center gap-1">
                            <span className="text-xs text-gray-500">ì·¨ì†Œí• ê¹Œìš”?</span>
                            <button
                              onClick={() => handleDeleteShare(share.id)}
                              className="text-xs px-2 py-1 bg-red-500 text-white rounded"
                            >
                              í™•ì¸
                            </button>
                            <button
                              onClick={() => setPendingDeleteId(null)}
                              className="text-xs px-2 py-1 bg-gray-200 rounded"
                            >
                              ì•„ë‹ˆì˜¤
                            </button>
                          </div>
                        ) : (
                          <button
                            onClick={() => setPendingDeleteId(share.id)}
                            className="text-red-500 hover:text-red-700 text-sm"
                          >
                            ì·¨ì†Œ
                          </button>
                        )}
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>

        <div className="flex justify-end p-6 border-t">
          <button
            onClick={onClose}
            className="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50"
          >
            ë‹«ê¸°
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/FileVersionHistory.tsx">
"use client";
// src/components/FileVersionHistory.tsx
// íŒŒì¼ ìƒì„¸/ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ì—ì„œ ì‚¬ìš©

import { useState, useEffect } from "react";
import { History, RotateCcw, Plus, X, Clock, ChevronDown, ChevronUp } from "lucide-react";
import { formatFileSize } from "@/lib/client-utils";
import { toast } from "@/components/Toast";
import { useConfirm } from "@/components/ConfirmDialog";

interface FileVersion {
  id: string;
  versionNum: number;
  size: bigint | string;
  comment: string | null;
  createdAt: string;
  user: { name: string };
}

interface Props {
  fileId: string;
  fileName: string;
  onRollback?: () => void;
}

function timeAgo(d: string) {
  const diff = Date.now() - new Date(d).getTime();
  const m = Math.floor(diff / 60000);
  if (m < 1) return "ë°©ê¸ˆ ì „";
  if (m < 60) return `${m}ë¶„ ì „`;
  const h = Math.floor(m / 60);
  if (h < 24) return `${h}ì‹œê°„ ì „`;
  const days = Math.floor(h / 24);
  return `${days}ì¼ ì „`;
}

export default function FileVersionHistory({ fileId, fileName, onRollback }: Props) {
  const { confirmDialog, openConfirm } = useConfirm();
  const [open, setOpen] = useState(false);
  const [versions, setVersions] = useState<FileVersion[]>([]);
  const [loading, setLoading] = useState(false);
  const [saving, setSaving] = useState(false);
  const [comment, setComment] = useState("");
  const [showCommentInput, setShowCommentInput] = useState(false);

  useEffect(() => {
    if (!open) return;
    setLoading(true);
    fetch(`/api/files/${fileId}/versions`)
      .then((r) => r.json())
      .then((d) => setVersions(d.versions ?? []))
      .catch(() => toast.error("ë²„ì „ ê¸°ë¡ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤"))
      .finally(() => setLoading(false));
  }, [open, fileId]);

  const saveVersion = async () => {
    setSaving(true);
    try {
      const res = await fetch(`/api/files/${fileId}/versions`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ comment: comment.trim() || undefined }),
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error);
      setVersions((v) => [data.version, ...v]);
      setComment("");
      setShowCommentInput(false);
      toast.success(data.message);
    } catch (e: any) {
      toast.error(e.message || "ë²„ì „ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
    } finally {
      setSaving(false);
    }
  };

  const rollback = async (version: FileVersion) => {
    const ok = await openConfirm({
      title: `ë²„ì „ ${version.versionNum}ìœ¼ë¡œ ë¡¤ë°±`,
      message: `"${fileName}"ì„ ë²„ì „ ${version.versionNum}ìœ¼ë¡œ ë˜ëŒë¦½ë‹ˆë‹¤. í˜„ì¬ ìƒíƒœëŠ” ìë™ìœ¼ë¡œ ë°±ì—…ë©ë‹ˆë‹¤.`,
      confirmText: "ë¡¤ë°±", confirmVariant: "danger",
    });
    if (!ok) return;
    const res = await fetch(`/api/files/${fileId}/versions/${version.id}/rollback`, { method: "POST" });
    const data = await res.json();
    if (res.ok) {
      toast.success(data.message);
      onRollback?.();
      setOpen(false);
    } else toast.error(data.error || "ë¡¤ë°±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
  };

  return (
    <div className="border border-gray-100 dark:border-slate-700 rounded-xl overflow-hidden">
      {confirmDialog}

      {/* í—¤ë” í† ê¸€ */}
      <button
        onClick={() => setOpen(!open)}
        className="w-full flex items-center gap-3 px-4 py-3 bg-white dark:bg-slate-800 hover:bg-gray-50 dark:hover:bg-slate-700/50 transition-colors"
      >
        <History size={16} className="text-gray-500 dark:text-slate-400 shrink-0" />
        <span className="text-sm font-semibold text-gray-900 dark:text-slate-100 flex-1 text-left">ë²„ì „ ê¸°ë¡</span>
        {versions.length > 0 && (
          <span className="text-xs bg-blue-100 dark:bg-blue-900/30 text-blue-600 dark:text-blue-400 px-2 py-0.5 rounded-full font-medium">
            {versions.length}ê°œ
          </span>
        )}
        {open ? <ChevronUp size={16} className="text-gray-400" /> : <ChevronDown size={16} className="text-gray-400" />}
      </button>

      {open && (
        <div className="border-t border-gray-100 dark:border-slate-700 bg-gray-50 dark:bg-slate-900/50">
          {/* ë²„ì „ ì €ì¥ */}
          <div className="px-4 py-3 border-b border-gray-100 dark:border-slate-700">
            {showCommentInput ? (
              <div className="flex gap-2">
                <input
                  type="text"
                  value={comment}
                  onChange={(e) => setComment(e.target.value)}
                  placeholder="ë²„ì „ ë©”ëª¨ (ì„ íƒ)"
                  className="flex-1 text-xs border border-gray-200 dark:border-slate-600 rounded-lg px-3 py-2 bg-white dark:bg-slate-800 dark:text-slate-100 focus:outline-none focus:ring-2 focus:ring-blue-500"
                  onKeyDown={(e) => e.key === "Enter" && saveVersion()}
                />
                <button onClick={saveVersion} disabled={saving}
                  className="px-3 py-1.5 text-xs font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-lg transition disabled:opacity-50">
                  {saving ? "ì €ì¥ ì¤‘..." : "ì €ì¥"}
                </button>
                <button onClick={() => setShowCommentInput(false)} className="p-1.5 text-gray-400 hover:text-gray-600 dark:hover:text-slate-300 rounded-lg">
                  <X size={14} />
                </button>
              </div>
            ) : (
              <button onClick={() => setShowCommentInput(true)}
                className="flex items-center gap-1.5 text-xs text-blue-600 dark:text-blue-400 hover:text-blue-700 font-medium">
                <Plus size={13} /> í˜„ì¬ ìƒíƒœë¥¼ ë²„ì „ìœ¼ë¡œ ì €ì¥
              </button>
            )}
          </div>

          {/* ë²„ì „ ëª©ë¡ */}
          <div className="max-h-64 overflow-y-auto divide-y divide-gray-100 dark:divide-slate-700">
            {loading ? (
              <div className="p-4 flex justify-center">
                <div className="w-5 h-5 border-2 border-blue-500/20 border-t-blue-500 rounded-full animate-spin" />
              </div>
            ) : versions.length === 0 ? (
              <p className="text-xs text-gray-400 dark:text-slate-500 text-center py-6">ì €ì¥ëœ ë²„ì „ì´ ì—†ìŠµë‹ˆë‹¤</p>
            ) : versions.map((v) => (
              <div key={v.id} className="flex items-center gap-3 px-4 py-3 hover:bg-white dark:hover:bg-slate-800 transition-colors">
                <div className="w-8 h-8 rounded-full bg-blue-50 dark:bg-blue-900/30 flex items-center justify-center text-xs font-bold text-blue-600 dark:text-blue-400 shrink-0">
                  v{v.versionNum}
                </div>
                <div className="flex-1 min-w-0">
                  <p className="text-xs font-medium text-gray-900 dark:text-slate-100">
                    {v.comment || `ë²„ì „ ${v.versionNum}`}
                  </p>
                  <p className="text-[10px] text-gray-400 dark:text-slate-500 flex items-center gap-1">
                    <Clock size={9} /> {timeAgo(v.createdAt)} Â· {v.user.name} Â· {formatFileSize(String(v.size))}
                  </p>
                </div>
                <button onClick={() => rollback(v)}
                  className="flex items-center gap-1 px-2.5 py-1.5 text-[10px] font-semibold text-orange-600 dark:text-orange-400 bg-orange-50 dark:bg-orange-900/20 hover:bg-orange-100 dark:hover:bg-orange-900/30 rounded-lg transition shrink-0">
                  <RotateCcw size={10} /> ë¡¤ë°±
                </button>
              </div>
            ))}
          </div>
          <p className="text-[10px] text-center text-gray-400 dark:text-slate-500 py-2">ìµœëŒ€ 10ê°œ ë²„ì „ ë³´ê´€</p>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/FolderCreateModal.tsx">
"use client";

import { useState } from "react";
import { toast } from "@/components/Toast";

interface FolderCreateModalProps {
  parentId: string | null;
  onClose: () => void;
  onSuccess: () => void;
}

export default function FolderCreateModal({ parentId, onClose, onSuccess }: FolderCreateModalProps) {
  const [name, setName] = useState("");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!name.trim()) { setError("í´ë” ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”"); return; }

    setLoading(true);
    setError("");

    try {
      const res = await fetch("/api/folders", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name: name.trim(), parentId }),
      });
      const data = await res.json();
      if (!res.ok) {
        setError(data.error || "í´ë” ìƒì„± ì‹¤íŒ¨");
        return;
      }
      // âœ… alert() â†’ toast
      toast.success("í´ë”ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤");
      onSuccess();
      onClose();
    } catch {
      setError("í´ë” ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4" onClick={onClose}>
      <div className="bg-white rounded-xl shadow-xl max-w-md w-full p-6" onClick={(e) => e.stopPropagation()}>
        <h3 className="text-lg font-semibold text-gray-900 mb-4">ìƒˆ í´ë” ë§Œë“¤ê¸°</h3>

        <form onSubmit={handleSubmit}>
          {error && (
            <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-md">
              <p className="text-sm text-red-800">{error}</p>
            </div>
          )}
          <input
            type="text"
            value={name}
            onChange={(e) => setName(e.target.value)}
            placeholder="í´ë” ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”"
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 mb-4 text-gray-900"
            autoFocus
          />
          <div className="flex justify-end gap-2">
            <button type="button" onClick={onClose} className="px-4 py-2 text-sm text-gray-600 hover:bg-gray-100 rounded-md">
              ì·¨ì†Œ
            </button>
            <button
              type="submit"
              disabled={loading}
              className="px-4 py-2 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:opacity-50"
            >
              {loading ? "ìƒì„± ì¤‘..." : "í´ë” ë§Œë“¤ê¸°"}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}
</file>

<file path="src/components/KeyboardShortcuts.tsx">
"use client";
// src/components/KeyboardShortcuts.tsx
// providers.tsx ë˜ëŠ” dashboard layoutì— <KeyboardShortcuts /> ì¶”ê°€í•˜ì„¸ìš”

import { useEffect, useState, useCallback } from "react";
import { useRouter } from "next/navigation";
import { Keyboard } from "lucide-react";

interface Shortcut {
  keys: string[];      // ['ctrl', 'k'] ë“±
  description: string;
  action: () => void;
}

// â”€â”€ ë‹¨ì¶•í‚¤ í›… â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function useKeyboardShortcuts(shortcuts: Shortcut[]) {
  useEffect(() => {
    const handler = (e: KeyboardEvent) => {
      // input/textarea í¬ì»¤ìŠ¤ ì¤‘ì—ëŠ” ëŒ€ë¶€ë¶„ ë¬´ì‹œ
      const tag = (e.target as HTMLElement)?.tagName;
      const isEditing = tag === "INPUT" || tag === "TEXTAREA" || (e.target as HTMLElement)?.isContentEditable;

      for (const shortcut of shortcuts) {
        const keys = shortcut.keys.map((k) => k.toLowerCase());
        const ctrl  = keys.includes("ctrl")  ? (e.ctrlKey  || e.metaKey) : !e.ctrlKey && !e.metaKey;
        const shift = keys.includes("shift") ? e.shiftKey  : !e.shiftKey;
        const alt   = keys.includes("alt")   ? e.altKey    : !e.altKey;
        const main  = keys.find((k) => !["ctrl", "shift", "alt", "meta"].includes(k));

        if (ctrl && shift && alt && main && e.key.toLowerCase() === main) {
          // Ctrl+K ê°™ì€ ì „ì—­ ë‹¨ì¶•í‚¤ëŠ” input ì¤‘ì—ë„ í—ˆìš©
          const isGlobal = keys.includes("ctrl") && !keys.includes("shift");
          if (isEditing && !isGlobal) continue;
          e.preventDefault();
          shortcut.action();
          break;
        }
      }
    };
    window.addEventListener("keydown", handler);
    return () => window.removeEventListener("keydown", handler);
  }, [shortcuts]);
}

// â”€â”€ ë‹¨ì¶•í‚¤ íŒ”ë ˆíŠ¸ UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function ShortcutPalette({ onClose }: { onClose: () => void }) {
  const GROUPS = [
    {
      title: "íƒìƒ‰",
      shortcuts: [
        { keys: ["G", "D"], desc: "ëŒ€ì‹œë³´ë“œ" },
        { keys: ["G", "P"], desc: "í”„ë¡œí•„" },
        { keys: ["G", "N"], desc: "ì•Œë¦¼" },
        { keys: ["G", "C"], desc: "ì±„íŒ…" },
        { keys: ["G", "S"], desc: "ê²€ìƒ‰" },
        { keys: ["G", "T"], desc: "íœ´ì§€í†µ" },
      ],
    },
    {
      title: "íŒŒì¼",
      shortcuts: [
        { keys: ["U"], desc: "íŒŒì¼ ì—…ë¡œë“œ" },
        { keys: ["N"], desc: "ìƒˆ í´ë”" },
        { keys: ["Del"], desc: "ì„ íƒ ì‚­ì œ" },
      ],
    },
    {
      title: "ì „ì—­",
      shortcuts: [
        { keys: ["Ctrl", "K"], desc: "ë‹¨ì¶•í‚¤ ë³´ê¸°" },
        { keys: ["Ctrl", "/"], desc: "ê²€ìƒ‰" },
        { keys: ["?"], desc: "ë„ì›€ë§" },
        { keys: ["Esc"], desc: "ë‹«ê¸° / ì·¨ì†Œ" },
      ],
    },
  ];

  return (
    <div className="fixed inset-0 z-[9999] flex items-center justify-center px-4" onClick={onClose}>
      <div className="absolute inset-0 bg-black/60 backdrop-blur-sm" />
      <div
        className="relative z-10 w-full max-w-lg bg-white dark:bg-slate-800 rounded-2xl shadow-2xl border border-gray-100 dark:border-slate-700 overflow-hidden"
        onClick={(e) => e.stopPropagation()}
      >
        <div className="px-5 py-4 border-b border-gray-100 dark:border-slate-700 flex items-center gap-2">
          <Keyboard size={18} className="text-gray-600 dark:text-slate-400" />
          <h2 className="text-sm font-semibold text-gray-900 dark:text-slate-100">í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤</h2>
          <button onClick={onClose} className="ml-auto text-gray-400 hover:text-gray-600 dark:hover:text-slate-300 text-lg leading-none">Ã—</button>
        </div>
        <div className="p-5 space-y-5 max-h-[70vh] overflow-y-auto">
          {GROUPS.map((group) => (
            <div key={group.title}>
              <p className="text-xs font-bold text-gray-400 dark:text-slate-500 uppercase tracking-wider mb-2">{group.title}</p>
              <div className="space-y-1">
                {group.shortcuts.map(({ keys, desc }) => (
                  <div key={desc} className="flex items-center justify-between py-1.5">
                    <span className="text-sm text-gray-700 dark:text-slate-300">{desc}</span>
                    <div className="flex items-center gap-1">
                      {keys.map((k, i) => (
                        <span key={i}>
                          <kbd className="px-2 py-1 text-xs font-mono font-semibold bg-gray-100 dark:bg-slate-700 text-gray-700 dark:text-slate-300 rounded border border-gray-200 dark:border-slate-600">
                            {k}
                          </kbd>
                          {i < keys.length - 1 && <span className="text-gray-400 mx-0.5 text-xs">+</span>}
                        </span>
                      ))}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

// â”€â”€ ì „ì—­ ë‹¨ì¶•í‚¤ ì»´í¬ë„ŒíŠ¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export default function KeyboardShortcuts() {
  const router = useRouter();
  const [showPalette, setShowPalette] = useState(false);

  // 'G + X' ì‹œí€€ìŠ¤ ì²˜ë¦¬
  const gPressedRef = { current: false };

  const shortcuts: Shortcut[] = [
    { keys: ["ctrl", "k"],  description: "ë‹¨ì¶•í‚¤ ë³´ê¸°",    action: () => setShowPalette((v) => !v) },
    { keys: ["ctrl", "/"],  description: "ê²€ìƒ‰",           action: () => router.push("/search") },
    { keys: ["?"],          description: "ë‹¨ì¶•í‚¤ ë„ì›€ë§",  action: () => setShowPalette(true) },
  ];

  useKeyboardShortcuts(shortcuts);

  // G + ë‹¤ìŒ í‚¤ ì‹œí€€ìŠ¤
  useEffect(() => {
    let gTimer: NodeJS.Timeout;
    const handler = (e: KeyboardEvent) => {
      const tag = (e.target as HTMLElement)?.tagName;
      if (tag === "INPUT" || tag === "TEXTAREA") return;
      if (e.key === "g" || e.key === "G") {
        gPressedRef.current = true;
        clearTimeout(gTimer);
        gTimer = setTimeout(() => { gPressedRef.current = false; }, 1000);
        return;
      }
      if (gPressedRef.current) {
        const map: Record<string, string> = {
          d: "/dashboard", D: "/dashboard",
          p: "/profile",   P: "/profile",
          n: "/notifications", N: "/notifications",
          c: "/chat",      C: "/chat",
          s: "/search",    S: "/search",
          t: "/trash",     T: "/trash",
        };
        if (map[e.key]) { e.preventDefault(); router.push(map[e.key]); }
        gPressedRef.current = false;
        clearTimeout(gTimer);
      }
    };
    window.addEventListener("keydown", handler);
    return () => { window.removeEventListener("keydown", handler); clearTimeout(gTimer); };
  }, [router]);

  // ESC ë‹«ê¸°
  useEffect(() => {
    const handler = (e: KeyboardEvent) => { if (e.key === "Escape") setShowPalette(false); };
    window.addEventListener("keydown", handler);
    return () => window.removeEventListener("keydown", handler);
  }, []);

  return showPalette ? <ShortcutPalette onClose={() => setShowPalette(false)} /> : null;
}
</file>

<file path="src/components/LikeBookmarkButtons.tsx">
"use client";
// src/components/LikeBookmarkButtons.tsx
// ê²Œì‹œê¸€ ìƒì„¸/ëª©ë¡ í˜ì´ì§€ì—ì„œ ì‚¬ìš©

import { useState, useEffect } from "react";
import { Heart, Bookmark } from "lucide-react";
import { toast } from "@/components/Toast";

interface Props {
  postId: string;
  initialLiked?: boolean;
  initialLikeCount?: number;
  initialBookmarked?: boolean;
  compact?: boolean;
}

export default function LikeBookmarkButtons({
  postId, initialLiked = false, initialLikeCount = 0, initialBookmarked = false, compact = false,
}: Props) {
  const [liked, setLiked] = useState(initialLiked);
  const [likeCount, setLikeCount] = useState(initialLikeCount);
  const [bookmarked, setBookmarked] = useState(initialBookmarked);
  const [likeLoading, setLikeLoading] = useState(false);
  const [bookmarkLoading, setBookmarkLoading] = useState(false);

  // ë§ˆìš´íŠ¸ ì‹œ ìµœì‹  ìƒíƒœ ì¡°íšŒ
  useEffect(() => {
    Promise.all([
      fetch(`/api/posts/${postId}/like`).then((r) => r.json()),
      fetch(`/api/posts/${postId}/bookmark`).then((r) => r.json()),
    ]).then(([likeData, bookmarkData]) => {
      setLiked(likeData.liked);
      setLikeCount(likeData.count);
      setBookmarked(bookmarkData.bookmarked);
    }).catch(() => {});
  }, [postId]);

  const toggleLike = async () => {
    setLikeLoading(true);
    const prev = { liked, likeCount };
    setLiked(!liked);
    setLikeCount((c) => c + (liked ? -1 : 1));
    try {
      const res = await fetch(`/api/posts/${postId}/like`, { method: "POST" });
      const data = await res.json();
      setLiked(data.liked);
      setLikeCount(data.count);
    } catch {
      setLiked(prev.liked);
      setLikeCount(prev.likeCount);
      toast.error("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLikeLoading(false);
    }
  };

  const toggleBookmark = async () => {
    setBookmarkLoading(true);
    setBookmarked(!bookmarked);
    try {
      const res = await fetch(`/api/posts/${postId}/bookmark`, { method: "POST" });
      const data = await res.json();
      setBookmarked(data.bookmarked);
      toast.success(data.bookmarked ? "ë¶ë§ˆí¬ì— ì¶”ê°€ëìŠµë‹ˆë‹¤" : "ë¶ë§ˆí¬ì—ì„œ ì œê±°ëìŠµë‹ˆë‹¤");
    } catch {
      setBookmarked(bookmarked);
      toast.error("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setBookmarkLoading(false);
    }
  };

  if (compact) {
    return (
      <div className="flex items-center gap-3">
        <button
          onClick={toggleLike}
          disabled={likeLoading}
          className={`flex items-center gap-1 text-xs transition-colors ${
            liked ? "text-red-500" : "text-gray-400 dark:text-slate-500 hover:text-red-400"
          }`}
        >
          <Heart size={13} fill={liked ? "currentColor" : "none"} />
          {likeCount}
        </button>
        <button
          onClick={toggleBookmark}
          disabled={bookmarkLoading}
          className={`transition-colors ${
            bookmarked ? "text-yellow-500" : "text-gray-400 dark:text-slate-500 hover:text-yellow-400"
          }`}
        >
          <Bookmark size={13} fill={bookmarked ? "currentColor" : "none"} />
        </button>
      </div>
    );
  }

  return (
    <div className="flex items-center gap-2">
      {/* ì¢‹ì•„ìš” */}
      <button
        onClick={toggleLike}
        disabled={likeLoading}
        className={`flex items-center gap-2 px-4 py-2 rounded-xl text-sm font-medium transition-all ${
          liked
            ? "bg-red-50 dark:bg-red-900/20 text-red-600 dark:text-red-400 border border-red-200 dark:border-red-800"
            : "bg-gray-100 dark:bg-slate-700 text-gray-600 dark:text-slate-400 hover:bg-red-50 dark:hover:bg-red-900/20 hover:text-red-500 border border-transparent"
        } disabled:opacity-60`}
      >
        <Heart size={16} fill={liked ? "currentColor" : "none"} className="transition-transform active:scale-125" />
        ì¢‹ì•„ìš” {likeCount > 0 && <span className="font-bold">{likeCount}</span>}
      </button>

      {/* ë¶ë§ˆí¬ */}
      <button
        onClick={toggleBookmark}
        disabled={bookmarkLoading}
        className={`flex items-center gap-2 px-4 py-2 rounded-xl text-sm font-medium transition-all ${
          bookmarked
            ? "bg-yellow-50 dark:bg-yellow-900/20 text-yellow-600 dark:text-yellow-400 border border-yellow-200 dark:border-yellow-800"
            : "bg-gray-100 dark:bg-slate-700 text-gray-600 dark:text-slate-400 hover:bg-yellow-50 dark:hover:bg-yellow-900/20 hover:text-yellow-500 border border-transparent"
        } disabled:opacity-60`}
      >
        <Bookmark size={16} fill={bookmarked ? "currentColor" : "none"} />
        {bookmarked ? "ì €ì¥ë¨" : "ì €ì¥"}
      </button>
    </div>
  );
}
</file>

<file path="src/components/LinkPreviewCard.tsx">
"use client";
// src/components/LinkPreviewCard.tsx
// ì±„íŒ… ë©”ì‹œì§€ / ê²Œì‹œê¸€ ë‚´ URL ìë™ ê°ì§€ í›„ OG ì¹´ë“œ í‘œì‹œ

import { useState, useEffect } from "react";
import { ExternalLink, Globe } from "lucide-react";

interface OGData {
  title:       string | null;
  description: string | null;
  image:       string | null;
  siteName:    string | null;
  url:         string;
  favicon:     string | null;
}

// í…ìŠ¤íŠ¸ì—ì„œ ì²« ë²ˆì§¸ URL ì¶”ì¶œ
const URL_REGEX = /https?:\/\/[^\s<>"{}|\\^`[\]]+/g;
export function extractFirstUrl(text: string): string | null {
  return text.match(URL_REGEX)?.[0] ?? null;
}

// í…ìŠ¤íŠ¸ë¥¼ URL ë§í¬ë¡œ ë³€í™˜ (ë Œë”ë§ìš©)
export function linkifyText(text: string): React.ReactNode {
  const parts = text.split(URL_REGEX);
  const urls  = text.match(URL_REGEX) ?? [];
  return parts.reduce<React.ReactNode[]>((acc, part, i) => {
    acc.push(part);
    if (urls[i]) {
      acc.push(
        <a key={i} href={urls[i]} target="_blank" rel="noopener noreferrer"
           className="text-blue-600 dark:text-blue-400 hover:underline break-all">
          {urls[i]}
        </a>
      );
    }
    return acc;
  }, []);
}

interface Props {
  url:       string;
  compact?:  boolean;
  className?: string;
}

export default function LinkPreviewCard({ url, compact = false, className = "" }: Props) {
  const [og, setOg]       = useState<OGData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError]    = useState(false);

  useEffect(() => {
    setLoading(true); setError(false);
    fetch(`/api/link-preview?url=${encodeURIComponent(url)}`)
      .then((r) => { if (!r.ok) throw new Error(); return r.json(); })
      .then(setOg)
      .catch(() => setError(true))
      .finally(() => setLoading(false));
  }, [url]);

  if (loading) {
    return (
      <div className={`animate-pulse bg-gray-100 dark:bg-slate-700 rounded-xl h-16 ${className}`} />
    );
  }
  if (error || !og) return null;

  if (compact) {
    return (
      <a href={url} target="_blank" rel="noopener noreferrer"
         className={`flex items-center gap-2 px-3 py-2 bg-gray-50 dark:bg-slate-700/50 hover:bg-gray-100 dark:hover:bg-slate-700 rounded-xl border border-gray-100 dark:border-slate-600 transition-colors group ${className}`}>
        {og.favicon
          ? <img src={og.favicon} alt="" className="w-4 h-4 rounded-sm shrink-0" onError={(e) => ((e.target as HTMLImageElement).style.display = "none")} />
          : <Globe size={14} className="text-gray-400 shrink-0" />
        }
        <span className="text-xs font-medium text-gray-700 dark:text-slate-300 truncate flex-1">{og.title ?? url}</span>
        <ExternalLink size={12} className="text-gray-400 shrink-0 opacity-0 group-hover:opacity-100 transition-opacity" />
      </a>
    );
  }

  return (
    <a href={url} target="_blank" rel="noopener noreferrer"
       className={`block bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 overflow-hidden hover:shadow-md transition-shadow group ${className}`}>
      {og.image && (
        <div className="h-40 overflow-hidden bg-gray-100 dark:bg-slate-700">
          <img
            src={og.image}
            alt={og.title ?? ""}
            className="w-full h-full object-cover group-hover:scale-105 transition-transform duration-300"
            onError={(e) => ((e.target as HTMLImageElement).parentElement!.style.display = "none")}
          />
        </div>
      )}
      <div className="p-3">
        <div className="flex items-center gap-1.5 mb-1">
          {og.favicon
            ? <img src={og.favicon} alt="" className="w-3.5 h-3.5 rounded-sm" onError={(e) => ((e.target as HTMLImageElement).style.display = "none")} />
            : <Globe size={12} className="text-gray-400" />
          }
          <span className="text-[10px] text-gray-400 dark:text-slate-500 uppercase tracking-wide">{og.siteName}</span>
        </div>
        {og.title && (
          <p className="text-sm font-semibold text-gray-900 dark:text-slate-100 line-clamp-2 mb-1">{og.title}</p>
        )}
        {og.description && (
          <p className="text-xs text-gray-500 dark:text-slate-400 line-clamp-2">{og.description}</p>
        )}
      </div>
    </a>
  );
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ì‚¬ìš© ì˜ˆì‹œ (ì±„íŒ… ë©”ì‹œì§€ ë Œë”ë§)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// import LinkPreviewCard, { extractFirstUrl, linkifyText } from "@/components/LinkPreviewCard";
//
// function ChatMessage({ content }: { content: string }) {
//   const previewUrl = extractFirstUrl(content);
//   return (
//     <div>
//       <p>{linkifyText(content)}</p>
//       {previewUrl && <LinkPreviewCard url={previewUrl} compact className="mt-2" />}
//     </div>
//   );
// }
</file>

<file path="src/components/MentionTextarea.tsx">
"use client";
// src/components/MentionTextarea.tsx
// @ìœ ì €ëª… ìë™ì™„ì„±ì´ ìˆëŠ” í…ìŠ¤íŠ¸ ì…ë ¥ì°½
// ëŒ“ê¸€ ì‘ì„±, ì±„íŒ… ë©”ì‹œì§€ ì…ë ¥ì— ì‚¬ìš©

import { useState, useRef, useEffect, useCallback } from "react";

interface MentionUser {
  id: string;
  name: string;
  isOnline: boolean;
}

interface Props {
  value: string;
  onChange: (value: string, mentionedUserIds: string[]) => void;
  placeholder?: string;
  rows?: number;
  className?: string;
  onSubmit?: () => void;
}

// @ì´í›„ í…ìŠ¤íŠ¸ ì¶”ì¶œ
function getMentionQuery(text: string, cursorPos: number): string | null {
  const before = text.slice(0, cursorPos);
  const match  = before.match(/@(\w*)$/);
  return match ? match[1] : null;
}

// í…ìŠ¤íŠ¸ì—ì„œ @ë©˜ì…˜ëœ ì‚¬ìš©ì ID ëª©ë¡ ì¶”ì¶œ
function extractMentionIds(text: string, resolvedMentions: Map<string, string>): string[] {
  const ids: string[] = [];
  const regex = /@(\S+)/g;
  let m: RegExpExecArray | null;
  while ((m = regex.exec(text)) !== null) {
    const id = resolvedMentions.get(m[1]);
    if (id) ids.push(id);
  }
  return [...new Set(ids)];
}

export default function MentionTextarea({
  value, onChange, placeholder = "ëŒ“ê¸€ì„ ì…ë ¥í•˜ì„¸ìš”...",
  rows = 3, className = "", onSubmit,
}: Props) {
  const [suggestions, setSuggestions]   = useState<MentionUser[]>([]);
  const [showDropdown, setShowDropdown] = useState(false);
  const [selectedIdx, setSelectedIdx]   = useState(0);
  const [mentionStart, setMentionStart] = useState<number | null>(null);
  const textareaRef  = useRef<HTMLTextAreaElement>(null);
  const resolvedRef  = useRef(new Map<string, string>()); // name â†’ userId
  const debounceRef  = useRef<NodeJS.Timeout>();

  const fetchSuggestions = useCallback(async (q: string) => {
    clearTimeout(debounceRef.current);
    if (!q && q !== "") { setSuggestions([]); return; }
    debounceRef.current = setTimeout(async () => {
      const res  = await fetch(`/api/users/mention-search?q=${encodeURIComponent(q)}`);
      const data = await res.json();
      setSuggestions(data.users ?? []);
      setSelectedIdx(0);
    }, 200);
  }, []);

  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const newVal    = e.target.value;
    const cursor    = e.target.selectionStart;
    const query     = getMentionQuery(newVal, cursor);

    if (query !== null) {
      setMentionStart(cursor - query.length - 1); // @ ìœ„ì¹˜
      setShowDropdown(true);
      fetchSuggestions(query);
    } else {
      setShowDropdown(false);
      setMentionStart(null);
    }

    const ids = extractMentionIds(newVal, resolvedRef.current);
    onChange(newVal, ids);
  };

  const selectUser = (user: MentionUser) => {
    if (mentionStart === null) return;
    const before  = value.slice(0, mentionStart);            // @ ì´ì „
    const cursor  = textareaRef.current?.selectionStart ?? 0;
    const after   = value.slice(cursor);                      // ì»¤ì„œ ì´í›„
    const newVal  = `${before}@${user.name} ${after}`;

    resolvedRef.current.set(user.name, user.id);
    const ids = extractMentionIds(newVal, resolvedRef.current);
    onChange(newVal, ids);
    setShowDropdown(false);

    // ì»¤ì„œë¥¼ ë©˜ì…˜ ë’¤ë¡œ ì´ë™
    requestAnimationFrame(() => {
      const pos = before.length + user.name.length + 2; // @name<space>
      textareaRef.current?.setSelectionRange(pos, pos);
      textareaRef.current?.focus();
    });
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (showDropdown && suggestions.length > 0) {
      if (e.key === "ArrowDown") { e.preventDefault(); setSelectedIdx((i) => Math.min(i + 1, suggestions.length - 1)); return; }
      if (e.key === "ArrowUp")   { e.preventDefault(); setSelectedIdx((i) => Math.max(i - 1, 0)); return; }
      if (e.key === "Enter" || e.key === "Tab") { e.preventDefault(); selectUser(suggestions[selectedIdx]); return; }
      if (e.key === "Escape")    { setShowDropdown(false); return; }
    }
    if (e.key === "Enter" && !e.shiftKey && onSubmit) {
      e.preventDefault();
      onSubmit();
    }
  };

  // í…ìŠ¤íŠ¸ ë‚´ @ë©˜ì…˜ í•˜ì´ë¼ì´íŠ¸ ë Œë”ë§ (ë¯¸ë¦¬ë³´ê¸°ìš©)
  const renderHighlighted = (text: string) =>
    text.replace(/@(\S+)/g, (m, name) =>
      resolvedRef.current.has(name)
        ? `<mark class="bg-blue-100 dark:bg-blue-900/30 text-blue-600 dark:text-blue-400 rounded px-0.5">${m}</mark>`
        : m
    );

  return (
    <div className="relative">
      <textarea
        ref={textareaRef}
        value={value}
        onChange={handleChange}
        onKeyDown={handleKeyDown}
        onBlur={() => setTimeout(() => setShowDropdown(false), 150)}
        placeholder={placeholder}
        rows={rows}
        className={`w-full resize-none rounded-xl border border-gray-200 dark:border-slate-600 
                    bg-white dark:bg-slate-700 dark:text-slate-100 px-4 py-3 text-sm
                    focus:outline-none focus:ring-2 focus:ring-blue-500 ${className}`}
      />

      {/* ìë™ì™„ì„± ë“œë¡­ë‹¤ìš´ */}
      {showDropdown && suggestions.length > 0 && (
        <div className="absolute z-50 bottom-full mb-1 left-0 right-0 max-h-48 overflow-y-auto
                        bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 shadow-xl">
          {suggestions.map((u, i) => (
            <button
              key={u.id}
              onMouseDown={(e) => { e.preventDefault(); selectUser(u); }}
              className={`w-full flex items-center gap-2.5 px-3 py-2.5 text-left transition-colors ${
                i === selectedIdx
                  ? "bg-blue-50 dark:bg-blue-900/30"
                  : "hover:bg-gray-50 dark:hover:bg-slate-700/50"
              }`}
            >
              <div className="relative shrink-0">
                <div className="w-7 h-7 rounded-full bg-gradient-to-br from-blue-400 to-purple-500 flex items-center justify-center text-white text-xs font-bold">
                  {u.name[0]}
                </div>
                {u.isOnline && (
                  <span className="absolute bottom-0 right-0 w-2 h-2 bg-green-500 rounded-full border border-white dark:border-slate-800" />
                )}
              </div>
              <span className="text-sm font-medium text-gray-800 dark:text-slate-200">{u.name}</span>
              <span className="text-xs text-gray-400 dark:text-slate-500 ml-auto">@{u.name}</span>
            </button>
          ))}
          <p className="text-[10px] text-gray-400 dark:text-slate-500 text-center py-1.5 border-t border-gray-100 dark:border-slate-700">
            â†‘â†“ ì„ íƒ Â· Enter/Tab í™•ì • Â· Esc ë‹«ê¸°
          </p>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/MessageBubble.tsx">
"use client";

import { memo } from "react";

interface Message {
  id?: string;
  content?: string;
  type?: string;
  createdAt?: string;
  senderId?: string;
  userId?: string;
  sender?: { id: string; name: string };
  file?: { url: string; originalName?: string; name?: string };
}

interface MessageBubbleProps {
  msg: Message;
  isMe: boolean;
  senderName: string;
  showDateDivider: boolean;
  dateLabel: string;
}

// âœ… React.memo â€” propsê°€ ë°”ë€Œì§€ ì•Šìœ¼ë©´ ë¦¬ë Œë”ë§ ì™„ì „ ì°¨ë‹¨
// ìƒˆ ë©”ì‹œì§€ê°€ ì™€ë„ ê¸°ì¡´ ë©”ì‹œì§€ ë²„ë¸”ì€ ì „í˜€ ì¬ë Œë”ë§ë˜ì§€ ì•ŠìŒ
const MessageBubble = memo(function MessageBubble({
  msg,
  isMe,
  senderName,
  showDateDivider,
  dateLabel,
}: MessageBubbleProps) {
  const timeStr = (() => {
    if (!msg.createdAt) return "";
    const date = new Date(msg.createdAt);
    return isNaN(date.getTime())
      ? ""
      : date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
  })();

  return (
    <>
      {/* ë‚ ì§œ êµ¬ë¶„ì„  */}
      {showDateDivider && (
        <div className="flex items-center gap-2 my-4">
          <div className="flex-1 h-px bg-gray-200" />
          <span className="text-xs text-gray-400 px-2">{dateLabel}</span>
          <div className="flex-1 h-px bg-gray-200" />
        </div>
      )}

      <div className={`flex ${isMe ? "justify-end" : "justify-start"}`}>
        <div className={`flex flex-col ${isMe ? "items-end" : "items-start"}`}>
          {!isMe && (
            <span className="text-[10px] text-gray-400 mb-1 ml-1">{senderName}</span>
          )}
          <div
            className={`p-3 px-4 rounded-2xl max-w-[80vw] sm:max-w-[60%] text-[14px] shadow-sm ${
              isMe
                ? "bg-blue-600 text-white rounded-tr-none"
                : "bg-white border border-gray-200 text-black rounded-tl-none"
            }`}
          >
            {msg.type === "FILE" && msg.file ? (
              <a
                href={msg.file.url}
                target="_blank"
                rel="noopener noreferrer"
                className="underline"
              >
                ğŸ“ {msg.file.originalName || msg.file.name}
              </a>
            ) : (
              <p className="whitespace-pre-wrap break-words">{msg.content}</p>
            )}
            <div
              className={`text-[9px] mt-1 opacity-60 ${isMe ? "text-right" : "text-left"}`}
            >
              {timeStr}
            </div>
          </div>
        </div>
      </div>
    </>
  );
});

export default MessageBubble;
</file>

<file path="src/components/MobileBottomNav.tsx">
"use client";
// src/components/MobileBottomNav.tsx
// ëª¨ë°”ì¼ì—ì„œë§Œ ë³´ì´ëŠ” í•˜ë‹¨ íƒ­ ë„¤ë¹„ê²Œì´ì…˜
// layout.tsx ë˜ëŠ” dashboard layoutì— ì¶”ê°€

import Link from "next/link";
import { usePathname } from "next/navigation";
import { useEffect, useState } from "react";
import {
  LayoutDashboard, MessageCircle, Bell, Search, User,
} from "lucide-react";

const TABS = [
  { href: "/dashboard",   icon: LayoutDashboard, label: "í™ˆ",    tour: "dashboard" },
  { href: "/search",      icon: Search,          label: "ê²€ìƒ‰",  tour: "search" },
  { href: "/chat",        icon: MessageCircle,   label: "ì±„íŒ…",  tour: "chat" },
  { href: "/notifications", icon: Bell,          label: "ì•Œë¦¼",  tour: "notifications" },
  { href: "/profile",     icon: User,            label: "í”„ë¡œí•„", tour: "profile" },
];

export default function MobileBottomNav() {
  const pathname = usePathname();
  const [unread, setUnread] = useState(0);

  // ì•Œë¦¼ ë±ƒì§€
  useEffect(() => {
    fetch("/api/notifications?limit=1")
      .then((r) => r.json())
      .then((d) => setUnread(d.unreadCount ?? 0))
      .catch(() => {});
  }, [pathname]);

  // ë¡œê·¸ì¸/ê³µê°œ í˜ì´ì§€ì—ì„œëŠ” ìˆ¨ê¹€
  const hiddenPaths = ["/", "/login", "/register", "/share"];
  if (hiddenPaths.some((p) => pathname === p || pathname.startsWith("/share/"))) return null;

  return (
    <>
      {/* í•˜ë‹¨ ì—¬ë°± (ì½˜í…ì¸ ê°€ íƒ­ì— ê°€ë¦¬ì§€ ì•Šë„ë¡) */}
      <div className="h-20 md:hidden" aria-hidden />

      <nav className="fixed bottom-0 left-0 right-0 z-50 md:hidden
                      bg-white/95 dark:bg-slate-900/95 backdrop-blur-xl
                      border-t border-gray-200 dark:border-slate-700
                      safe-area-padding-bottom">
        <div className="flex items-center justify-around px-2 py-2 pb-safe">
          {TABS.map(({ href, icon: Icon, label, tour }) => {
            const isActive = pathname === href || pathname.startsWith(href + "/");
            const isBell   = href === "/notifications";
            return (
              <Link
                key={href}
                href={href}
                data-tour={tour}
                className={`relative flex flex-col items-center gap-1 px-3 py-2 rounded-xl transition-all min-w-0 flex-1 ${
                  isActive
                    ? "text-blue-600 dark:text-blue-400"
                    : "text-gray-500 dark:text-slate-400 hover:text-gray-700 dark:hover:text-slate-300"
                }`}
              >
                {/* í™œì„± ì¸ë””ì¼€ì´í„° */}
                {isActive && (
                  <div className="absolute top-0 left-1/2 -translate-x-1/2 w-8 h-0.5 bg-blue-600 dark:bg-blue-400 rounded-full" />
                )}
                {/* ì•„ì´ì½˜ */}
                <div className="relative">
                  <Icon
                    size={22}
                    strokeWidth={isActive ? 2.5 : 1.8}
                    className="transition-all"
                    fill={isActive ? "currentColor" : "none"}
                    style={{ fillOpacity: isActive ? 0.12 : 0 }}
                  />
                  {/* ì•Œë¦¼ ë±ƒì§€ */}
                  {isBell && unread > 0 && (
                    <span className="absolute -top-1 -right-1 min-w-[16px] h-4 bg-red-500 text-white text-[9px] font-bold rounded-full flex items-center justify-center px-1 leading-none">
                      {unread > 99 ? "99+" : unread}
                    </span>
                  )}
                </div>
                {/* ë ˆì´ë¸” */}
                <span className={`text-[10px] font-semibold leading-none truncate ${
                  isActive ? "text-blue-600 dark:text-blue-400" : "text-gray-500 dark:text-slate-400"
                }`}>
                  {label}
                </span>
              </Link>
            );
          })}
        </div>
      </nav>
    </>
  );
}
</file>

<file path="src/components/Notificationsettings.tsx">
"use client";

import { useState, useEffect } from "react";
import { registerFCMToken, unregisterFCMToken } from "@/lib/firebase";
import { toast } from "@/components/Toast";

export default function NotificationSettings() {
  const [notificationsEnabled, setNotificationsEnabled] = useState(false);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if ("Notification" in window) {
      setNotificationsEnabled(Notification.permission === "granted");
    }
  }, []);

  const handleToggle = async () => {
    setLoading(true);
    if (notificationsEnabled) {
      await unregisterFCMToken();
      setNotificationsEnabled(false);
    } else {
      const success = await registerFCMToken();
      setNotificationsEnabled(success);
      if (!success) {
        // âœ… alert() â†’ toast
        toast.error("ì•Œë¦¼ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”. ë¸Œë¼ìš°ì € ì„¤ì •ì—ì„œ ì•Œë¦¼ì„ í—ˆìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
      }
    }
    setLoading(false);
  };

  return (
    <div className="bg-white shadow rounded-lg p-6">
      <h3 className="text-lg font-semibold mb-4">ğŸ“¬ ì•Œë¦¼ ì„¤ì •</h3>

      <div className="flex items-center justify-between">
        <div>
          <p className="font-medium">í‘¸ì‹œ ì•Œë¦¼</p>
          <p className="text-sm text-gray-500">ìƒˆ ë©”ì‹œì§€ì™€ í†µí™” ìš”ì²­ì„ ì•Œë¦¼ìœ¼ë¡œ ë°›ìŠµë‹ˆë‹¤</p>
        </div>
        <button
          onClick={handleToggle}
          disabled={loading}
          className={`relative inline-flex h-8 w-14 items-center rounded-full transition ${
            notificationsEnabled ? "bg-blue-600" : "bg-gray-300"
          } ${loading ? "opacity-50 cursor-not-allowed" : "cursor-pointer"}`}
        >
          <span
            className={`inline-block h-6 w-6 transform rounded-full bg-white transition ${
              notificationsEnabled ? "translate-x-7" : "translate-x-1"
            }`}
          />
        </button>
      </div>

      {notificationsEnabled && (
        <div className="mt-4 p-3 bg-green-50 border border-green-200 rounded-md">
          <p className="text-sm text-green-800">
            âœ… ì•Œë¦¼ì´ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ì•±ì„ ë‹«ì•„ë„ ìƒˆ ë©”ì‹œì§€ ì•Œë¦¼ì„ ë°›ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
          </p>
        </div>
      )}

      {"Notification" in window && !notificationsEnabled && (
        <div className="mt-4 p-3 bg-yellow-50 border border-yellow-200 rounded-md">
          <p className="text-sm text-yellow-800">
            âš ï¸ ì•Œë¦¼ì´ ë¹„í™œì„±í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ì•±ì„ ë‹«ìœ¼ë©´ ë©”ì‹œì§€ ì•Œë¦¼ì„ ë°›ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
          </p>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/OnboardingTour.tsx">
"use client";
// src/components/OnboardingTour.tsx
// ì²« ë¡œê·¸ì¸ ì‹œ ìë™ í‘œì‹œë˜ëŠ” ë‹¨ê³„ë³„ ê°€ì´ë“œ
// providers.tsx ë˜ëŠ” dashboard layoutì— ì¶”ê°€

import { useState, useEffect, useRef } from "react";
import { useSession } from "next-auth/react";
import { X, ChevronRight, ChevronLeft, Check } from "lucide-react";

const STEPS = [
  {
    title: "ğŸ‰ ì´ìŒì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤!",
    desc: "ì´ìŒì€ íŒŒì¼ ê´€ë¦¬, ì‹¤ì‹œê°„ ì±„íŒ…, í˜‘ì—…ì„ í•˜ë‚˜ì˜ ê³µê°„ì—ì„œ ì œê³µí•˜ëŠ” í¼ìŠ¤ë„ í´ë¼ìš°ë“œì…ë‹ˆë‹¤.",
    target: null,
    position: "center" as const,
  },
  {
    title: "ğŸ“ íŒŒì¼ ì—…ë¡œë“œ",
    desc: "ëŒ€ì‹œë³´ë“œì—ì„œ íŒŒì¼ì„ ë“œë˜ê·¸ ì•¤ ë“œë¡­í•˜ê±°ë‚˜ í´ë¦­í•˜ì—¬ ì—…ë¡œë“œí•˜ì„¸ìš”. ì´ë¯¸ì§€, ì˜ìƒ, ë¬¸ì„œ ë“± ëª¨ë“  í˜•ì‹ì„ ì§€ì›í•©ë‹ˆë‹¤.",
    target: "[data-tour='upload']",
    position: "bottom" as const,
  },
  {
    title: "ğŸ’¬ ì‹¤ì‹œê°„ ì±„íŒ…",
    desc: "ë‹¤ë¥¸ ì‚¬ìš©ìì™€ ì±„íŒ…í•˜ê³  íŒŒì¼ì„ ê³µìœ í•˜ì„¸ìš”. ìŒì„±Â·ì˜ìƒ í†µí™”ë„ ì§€ì›í•©ë‹ˆë‹¤.",
    target: "[data-tour='chat']",
    position: "right" as const,
  },
  {
    title: "ğŸ”” ì•Œë¦¼ ì„¤ì •",
    desc: "ëŒ“ê¸€, ê³µìœ , ë©”ì‹œì§€ ë“± ì•Œë¦¼ì„ ì¢…ë¥˜ë³„ë¡œ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
    target: "[data-tour='notifications']",
    position: "bottom" as const,
  },
  {
    title: "ğŸ”’ ë³´ì•ˆ",
    desc: "2ë‹¨ê³„ ì¸ì¦(2FA)ì„ ì„¤ì •í•˜ê³ , ê°œë³„ íŒŒì¼ì— ë¹„ë°€ë²ˆí˜¸ë¥¼ ê±¸ì–´ ë” ì•ˆì „í•˜ê²Œ ë³´í˜¸í•˜ì„¸ìš”.",
    target: "[data-tour='profile']",
    position: "left" as const,
  },
  {
    title: "âœ… ì¤€ë¹„ ì™„ë£Œ!",
    desc: "ì´ìŒ ì‚¬ìš©ì„ ì‹œì‘í•  ì¤€ë¹„ê°€ ë˜ì—ˆìŠµë‹ˆë‹¤. ì–¸ì œë“ ì§€ í”„ë¡œí•„ â†’ ë„ì›€ë§ì—ì„œ ì´ ê°€ì´ë“œë¥¼ ë‹¤ì‹œ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
    target: null,
    position: "center" as const,
  },
];

function getTargetRect(selector: string | null): DOMRect | null {
  if (!selector) return null;
  return document.querySelector(selector)?.getBoundingClientRect() ?? null;
}

export default function OnboardingTour() {
  const { data: session } = useSession();
  const [step, setStep]   = useState(0);
  const [visible, setVisible] = useState(false);
  const [rect, setRect]   = useState<DOMRect | null>(null);
  const [done, setDone]   = useState(false);

  useEffect(() => {
    if (!session?.user) return;
    const key = `onboarding_done_${session.user.id}`;
    if (localStorage.getItem(key)) { setDone(true); return; }
    // ì²« ë¡œê·¸ì¸ì´ë©´ 0.8ì´ˆ í›„ íˆ¬ì–´ ì‹œì‘
    const t = setTimeout(() => setVisible(true), 800);
    return () => clearTimeout(t);
  }, [session]);

  useEffect(() => {
    if (!visible) return;
    const current = STEPS[step];
    setRect(getTargetRect(current.target));
  }, [step, visible]);

  const finish = () => {
    if (session?.user) {
      localStorage.setItem(`onboarding_done_${session.user.id}`, "1");
      // APIë¡œë„ ê¸°ë¡
      fetch("/api/users/me/onboarding", { method: "POST" }).catch(() => {});
    }
    setVisible(false);
    setDone(true);
  };

  if (!visible || done) return null;

  const current = STEPS[step];
  const isFirst = step === 0;
  const isLast  = step === STEPS.length - 1;

  // íƒ€ê¹ƒ ìš”ì†Œê°€ ìˆìœ¼ë©´ ìŠ¤í¬íŠ¸ë¼ì´íŠ¸, ì—†ìœ¼ë©´ ì¤‘ì•™ ëª¨ë‹¬
  const isCentered = current.position === "center" || !rect;

  return (
    <div className="fixed inset-0 z-[9998]">
      {/* ë°°ê²½ ì˜¤ë²„ë ˆì´ */}
      <div className="absolute inset-0 bg-black/60 backdrop-blur-[2px]" onClick={() => {}} />

      {/* ìŠ¤í¬íŠ¸ë¼ì´íŠ¸ ì»·ì•„ì›ƒ */}
      {rect && (
        <div
          className="absolute rounded-xl ring-4 ring-blue-400 ring-offset-2 bg-transparent z-[9999] pointer-events-none transition-all duration-300"
          style={{
            top:    rect.top    - 8,
            left:   rect.left   - 8,
            width:  rect.width  + 16,
            height: rect.height + 16,
          }}
        />
      )}

      {/* íˆ´íŒ/ëª¨ë‹¬ */}
      <div
        className={`absolute z-[9999] w-80 bg-white dark:bg-slate-800 rounded-2xl shadow-2xl border border-gray-100 dark:border-slate-700 p-5 transition-all duration-300 ${
          isCentered
            ? "top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2"
            : ""
        }`}
        style={
          !isCentered && rect
            ? current.position === "bottom"
              ? { top: rect.bottom + 16, left: Math.min(rect.left, window.innerWidth - 340) }
              : current.position === "right"
              ? { top: rect.top, left: rect.right + 16 }
              : { top: rect.top, right: window.innerWidth - rect.left + 16 }
            : {}
        }
      >
        {/* ë‹«ê¸° */}
        <button onClick={finish} className="absolute top-3 right-3 text-gray-400 hover:text-gray-600 dark:hover:text-slate-300 transition-colors">
          <X size={16} />
        </button>

        {/* ì§„í–‰ ë„íŠ¸ */}
        <div className="flex gap-1.5 mb-4">
          {STEPS.map((_, i) => (
            <div key={i} className={`h-1.5 rounded-full transition-all duration-300 ${
              i === step ? "w-6 bg-blue-600" : i < step ? "w-1.5 bg-blue-300" : "w-1.5 bg-gray-200 dark:bg-slate-700"
            }`} />
          ))}
        </div>

        <h3 className="text-base font-bold text-gray-900 dark:text-slate-100 mb-2 pr-5">{current.title}</h3>
        <p className="text-sm text-gray-500 dark:text-slate-400 leading-relaxed mb-5">{current.desc}</p>

        {/* ë²„íŠ¼ */}
        <div className="flex items-center gap-2">
          {!isFirst && (
            <button onClick={() => setStep((s) => s - 1)}
              className="flex items-center gap-1 px-3 py-2 text-xs font-medium text-gray-500 dark:text-slate-400 hover:bg-gray-100 dark:hover:bg-slate-700 rounded-xl transition">
              <ChevronLeft size={14} /> ì´ì „
            </button>
          )}
          <div className="flex-1" />
          <button
            onClick={() => isLast ? finish() : setStep((s) => s + 1)}
            className="flex items-center gap-1.5 px-4 py-2 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-xl transition"
          >
            {isLast ? <><Check size={14} /> ì‹œì‘í•˜ê¸°</> : <>ë‹¤ìŒ <ChevronRight size={14} /></>}
          </button>
        </div>

        <button onClick={finish} className="mt-3 w-full text-[10px] text-gray-400 hover:text-gray-600 dark:hover:text-slate-400 text-center">
          ê±´ë„ˆë›°ê¸°
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/PostShareModal.tsx">
"use client";

import { useState, useEffect } from "react";
import { toast } from "@/components/Toast";

interface Share {
  id: string;
  sharedWith: { id: string; email: string; name: string };
  permission: string;
  createdAt: string;
}

interface PostShareModalProps {
  postId: string | null;
  postTitle: string;
  onClose: () => void;
}

export default function PostShareModal({ postId, postTitle, onClose }: PostShareModalProps) {
  const [email, setEmail] = useState("");
  const [permission, setPermission] = useState("VIEW");
  const [shares, setShares] = useState<Share[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  // âœ… confirm() ëŒ€ì²´: ì‚­ì œ ëŒ€ê¸° ì¤‘ì¸ shareId
  const [pendingDeleteId, setPendingDeleteId] = useState<string | null>(null);

  useEffect(() => {
    if (postId) fetchShares();
  }, [postId]);

  const fetchShares = async () => {
    if (!postId) return;
    try {
      const res = await fetch(`/api/posts/${postId}/share`);
      if (res.ok) setShares((await res.json()).shares);
    } catch {}
  };

  const handleShare = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!postId || !email) return;
    setLoading(true);
    setError("");
    try {
      const res = await fetch(`/api/posts/${postId}/share`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ sharedWithEmail: email, permission }),
      });
      const data = await res.json();
      if (!res.ok) {
        setError(data.error || "ê³µìœ  ì‹¤íŒ¨");
        return;
      }
      // âœ… alert() â†’ toast
      toast.success("ê²Œì‹œê¸€ì´ ê³µìœ ë˜ì—ˆìŠµë‹ˆë‹¤");
      setEmail("");
      fetchShares();
    } catch {
      setError("ê³µìœ  ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  };

  const handleDeleteShare = async (shareId: string) => {
    if (!postId) return;
    try {
      const res = await fetch(`/api/posts/${postId}/share?shareId=${shareId}`, {
        method: "DELETE",
      });
      if (res.ok) {
        toast.success("ê³µìœ ê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤");
        fetchShares();
      } else {
        toast.error("ê³µìœ  ì·¨ì†Œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
      }
    } catch {
      toast.error("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setPendingDeleteId(null);
    }
  };

  if (!postId) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4" onClick={onClose}>
      <div className="bg-white rounded-xl shadow-xl max-w-2xl w-full max-h-[80vh] overflow-hidden" onClick={(e) => e.stopPropagation()}>
        <div className="flex items-center justify-between p-6 border-b">
          <h3 className="text-lg font-semibold text-gray-900">ê²Œì‹œê¸€ ê³µìœ : {postTitle}</h3>
          <button onClick={onClose} className="text-gray-400 hover:text-gray-600 text-2xl">Ã—</button>
        </div>

        <div className="p-6 overflow-y-auto max-h-[60vh]">
          <div className="mb-6 p-4 bg-blue-50 border border-blue-200 rounded-md">
            <p className="text-sm text-blue-800">
              ğŸ’¡ ì´ë©”ì¼ì„ ì…ë ¥í•˜ì—¬ íŠ¹ì • ì‚¬ìš©ìì—ê²Œë§Œ ê²Œì‹œê¸€ì„ ê³µìœ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
              <br />ê³µìœ ë°›ì€ ì‚¬ìš©ìëŠ” ìì‹ ì˜ ê²Œì‹œíŒì—ì„œ ì´ ê¸€ì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
            </p>
          </div>

          <form onSubmit={handleShare} className="mb-6">
            <label className="block text-sm font-medium text-gray-700 mb-2">ê³µìœ í•  ì‚¬ìš©ì ì´ë©”ì¼</label>
            {error && (
              <div className="mb-3 p-3 bg-red-50 border border-red-200 rounded-md">
                <p className="text-sm text-red-800">{error}</p>
              </div>
            )}
            <div className="flex gap-2">
              <input
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                placeholder="user@example.com"
                className="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-900"
                required
              />
              <select
                value={permission}
                onChange={(e) => setPermission(e.target.value)}
                className="px-3 py-2 border border-gray-300 rounded-md text-gray-900"
              >
                <option value="VIEW">ë³´ê¸°</option>
                <option value="EDIT">í¸ì§‘</option>
              </select>
              <button
                type="submit"
                disabled={loading}
                className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:opacity-50"
              >
                {loading ? "ê³µìœ  ì¤‘..." : "ê³µìœ "}
              </button>
            </div>
          </form>

          {shares.length > 0 && (
            <div>
              <h4 className="text-sm font-medium text-gray-700 mb-3">ê³µìœ ëœ ì‚¬ìš©ì</h4>
              <div className="space-y-2">
                {shares.map((share) => (
                  <div key={share.id} className="flex items-center justify-between p-3 bg-gray-50 rounded-md">
                    <div>
                      <p className="text-sm font-medium text-gray-900">{share.sharedWith.name}</p>
                      <p className="text-xs text-gray-500">{share.sharedWith.email}</p>
                    </div>
                    <div className="flex items-center gap-2">
                      <span className="px-2 py-1 text-xs bg-blue-100 text-blue-700 rounded">
                        {share.permission === "VIEW" ? "ë³´ê¸°" : "í¸ì§‘"}
                      </span>
                      {/* âœ… confirm() â†’ ì¸ë¼ì¸ í™•ì¸ UI */}
                      {pendingDeleteId === share.id ? (
                        <div className="flex items-center gap-1">
                          <span className="text-xs text-gray-500">ì·¨ì†Œí• ê¹Œìš”?</span>
                          <button
                            onClick={() => handleDeleteShare(share.id)}
                            className="text-xs px-2 py-1 bg-red-500 text-white rounded"
                          >
                            í™•ì¸
                          </button>
                          <button
                            onClick={() => setPendingDeleteId(null)}
                            className="text-xs px-2 py-1 bg-gray-200 rounded"
                          >
                            ì•„ë‹ˆì˜¤
                          </button>
                        </div>
                      ) : (
                        <button
                          onClick={() => setPendingDeleteId(share.id)}
                          className="text-red-500 hover:text-red-700 text-sm"
                        >
                          ì·¨ì†Œ
                        </button>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>

        <div className="flex justify-end p-6 border-t">
          <button
            onClick={onClose}
            className="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50"
          >
            ë‹«ê¸°
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/ProfileImageUpload.tsx">
"use client";
// src/components/ProfileImageUpload.tsx
// ì•„ë°”íƒ€ + ì»¤ë²„ ì´ë¯¸ì§€ ì—…ë¡œë“œ ì»´í¬ë„ŒíŠ¸

import { useState, useRef } from "react";
import { Camera, Upload, X } from "lucide-react";
import { toast } from "@/components/Toast";

type ImageType = "avatar" | "cover";

interface Props {
  currentAvatarUrl?: string | null;
  currentCoverUrl?:  string | null;
  userId: string;
  onUpdate?: (type: ImageType, url: string) => void;
  isOwnProfile?: boolean;
}

function ImageUploadButton({
  type, currentUrl, userId, onUpdate,
}: { type: ImageType; currentUrl?: string | null; userId: string; onUpdate?: (url: string) => void }) {
  const [preview, setPreview] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);
  const inputRef = useRef<HTMLInputElement>(null);

  const handleFile = async (file: File) => {
    if (!file.type.startsWith("image/")) { toast.error("ì´ë¯¸ì§€ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤"); return; }
    if (file.size > 5 * 1024 * 1024)    { toast.error("5MB ì´í•˜ ì´ë¯¸ì§€ë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤"); return; }

    // ë¯¸ë¦¬ë³´ê¸°
    const reader = new FileReader();
    reader.onload = (e) => setPreview(e.target?.result as string);
    reader.readAsDataURL(file);

    setLoading(true);
    try {
      const fd = new FormData();
      fd.append("file", file);
      fd.append("type", type);

      const res  = await fetch("/api/users/me/avatar", { method: "POST", body: fd });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error);

      onUpdate?.(data.publicUrl);
      toast.success(type === "avatar" ? "í”„ë¡œí•„ ì‚¬ì§„ì´ ë³€ê²½ëìŠµë‹ˆë‹¤" : "ì»¤ë²„ ì´ë¯¸ì§€ê°€ ë³€ê²½ëìŠµë‹ˆë‹¤");
    } catch (e: any) {
      toast.error(e.message ?? "ì—…ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
      setPreview(null);
    } finally {
      setLoading(false);
    }
  };

  return (
    <>
      <input ref={inputRef} type="file" accept="image/*" className="hidden"
        onChange={(e) => { const f = e.target.files?.[0]; if (f) handleFile(f); }} />
      <button
        onClick={() => inputRef.current?.click()}
        disabled={loading}
        className={`group relative overflow-hidden ${
          type === "avatar"
            ? "w-24 h-24 rounded-full ring-4 ring-white dark:ring-slate-800"
            : "w-full h-36 rounded-2xl"
        } bg-gray-200 dark:bg-slate-700 transition-all hover:brightness-90`}
      >
        {/* ì´ë¯¸ì§€ í‘œì‹œ */}
        {(preview ?? currentUrl) ? (
          <img
            src={preview ?? currentUrl!}
            alt={type}
            className="w-full h-full object-cover"
          />
        ) : (
          <div className="w-full h-full flex items-center justify-center">
            {type === "avatar"
              ? <span className="text-4xl text-gray-400">ğŸ‘¤</span>
              : <span className="text-gray-400 dark:text-slate-500 text-sm">ì»¤ë²„ ì´ë¯¸ì§€ ì—†ìŒ</span>}
          </div>
        )}

        {/* í˜¸ë²„ ì˜¤ë²„ë ˆì´ */}
        <div className="absolute inset-0 bg-black/40 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center gap-2 flex-col">
          <Camera size={type === "avatar" ? 20 : 24} className="text-white" />
          <span className="text-white text-xs font-medium">
            {loading ? "ì—…ë¡œë“œ ì¤‘..." : "ë³€ê²½"}
          </span>
        </div>

        {/* ë¡œë”© ìŠ¤í”¼ë„ˆ */}
        {loading && (
          <div className="absolute inset-0 flex items-center justify-center bg-black/50">
            <div className="w-6 h-6 border-3 border-white/30 border-t-white rounded-full animate-spin" />
          </div>
        )}
      </button>
    </>
  );
}

export default function ProfileImageUpload({
  currentAvatarUrl, currentCoverUrl, userId, onUpdate, isOwnProfile = false,
}: Props) {
  const [avatarUrl, setAvatarUrl] = useState(currentAvatarUrl ?? null);
  const [coverUrl,  setCoverUrl]  = useState(currentCoverUrl  ?? null);

  if (!isOwnProfile) {
    // ì½ê¸° ì „ìš© í‘œì‹œ
    return (
      <div>
        <div className="relative">
          <div className="h-32 rounded-2xl overflow-hidden bg-gradient-to-br from-blue-500 to-purple-600">
            {coverUrl && <img src={coverUrl} alt="cover" className="w-full h-full object-cover" />}
          </div>
          <div className="absolute -bottom-10 left-6">
            <div className="w-20 h-20 rounded-full ring-4 ring-white dark:ring-slate-800 bg-gradient-to-br from-blue-400 to-purple-500 overflow-hidden flex items-center justify-center text-white text-2xl font-bold">
              {avatarUrl ? <img src={avatarUrl} alt="avatar" className="w-full h-full object-cover" /> : "ğŸ‘¤"}
            </div>
          </div>
        </div>
        <div className="h-10" />
      </div>
    );
  }

  return (
    <div>
      {/* ì»¤ë²„ ì´ë¯¸ì§€ */}
      <ImageUploadButton
        type="cover"
        currentUrl={coverUrl}
        userId={userId}
        onUpdate={(url) => { setCoverUrl(url); onUpdate?.("cover", url); }}
      />

      {/* ì•„ë°”íƒ€ (ì»¤ë²„ ìœ„ì— ê²¹ì³ì„œ í‘œì‹œ) */}
      <div className="relative -mt-12 ml-6 inline-block">
        <ImageUploadButton
          type="avatar"
          currentUrl={avatarUrl}
          userId={userId}
          onUpdate={(url) => { setAvatarUrl(url); onUpdate?.("avatar", url); }}
        />
      </div>
      <p className="text-[10px] text-gray-400 dark:text-slate-500 mt-2 ml-2">
        í´ë¦­í•˜ì—¬ í”„ë¡œí•„ ì‚¬ì§„ ë˜ëŠ” ì»¤ë²„ ì´ë¯¸ì§€ ë³€ê²½ Â· ìµœëŒ€ 5MB
      </p>
    </div>
  );
}
</file>

<file path="src/components/PWAInstaller.tsx">
"use client";
// src/components/PWAInstaller.tsx
// layout.tsxì— ì¶”ê°€í•˜ë©´ SW ë“±ë¡ + ì„¤ì¹˜ ë°°ë„ˆ í‘œì‹œ

import { useEffect, useState } from "react";

interface BeforeInstallPromptEvent extends Event {
  prompt: () => Promise<void>;
  userChoice: Promise<{ outcome: "accepted" | "dismissed" }>;
}

export default function PWAInstaller() {
  const [installPrompt, setInstallPrompt] = useState<BeforeInstallPromptEvent | null>(null);
  const [showBanner, setShowBanner] = useState(false);
  const [dismissed, setDismissed] = useState(false);

  useEffect(() => {
    // ì„œë¹„ìŠ¤ ì›Œì»¤ ë“±ë¡
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker
        .register("/sw.js")
        .then((reg) => console.log("SW registered:", reg.scope))
        .catch((err) => console.warn("SW registration failed:", err));
    }

    // ì„¤ì¹˜ í”„ë¡¬í”„íŠ¸ ì´ë²¤íŠ¸ ìºì¹˜
    const handler = (e: Event) => {
      e.preventDefault();
      setInstallPrompt(e as BeforeInstallPromptEvent);
      // ì´ë¯¸ ì„¤ì¹˜ëê±°ë‚˜ ë°°ë„ˆ ë‹«ì€ ê²½ìš° ë¬´ì‹œ
      const wasDismissed = localStorage.getItem("pwa-dismissed");
      if (!wasDismissed) setShowBanner(true);
    };

    window.addEventListener("beforeinstallprompt", handler);
    return () => window.removeEventListener("beforeinstallprompt", handler);
  }, []);

  const install = async () => {
    if (!installPrompt) return;
    await installPrompt.prompt();
    const { outcome } = await installPrompt.userChoice;
    if (outcome === "accepted") {
      setShowBanner(false);
    }
    setInstallPrompt(null);
  };

  const dismiss = () => {
    setShowBanner(false);
    localStorage.setItem("pwa-dismissed", "true");
  };

  if (!showBanner || dismissed) return null;

  return (
    <div className="fixed bottom-20 md:bottom-6 left-4 right-4 md:left-auto md:right-6 md:w-80 z-50
                    bg-white dark:bg-slate-800 rounded-2xl shadow-2xl border border-gray-100 dark:border-slate-700
                    p-4 flex items-start gap-3 animate-slide-up">
      <div className="w-10 h-10 rounded-xl bg-gradient-to-br from-purple-500 to-blue-600 flex items-center justify-center text-white text-lg shrink-0">
        â˜ï¸
      </div>
      <div className="flex-1 min-w-0">
        <p className="text-sm font-semibold text-gray-900 dark:text-slate-100">ì•±ìœ¼ë¡œ ì„¤ì¹˜í•˜ê¸°</p>
        <p className="text-xs text-gray-500 dark:text-slate-400 mt-0.5">í™ˆ í™”ë©´ì— ì¶”ê°€í•˜ë©´ ë” ë¹ ë¥´ê²Œ ì´ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤</p>
        <div className="flex gap-2 mt-2.5">
          <button
            onClick={install}
            className="px-3 py-1.5 bg-blue-600 text-white text-xs font-semibold rounded-lg hover:bg-blue-700 transition-colors"
          >
            ì„¤ì¹˜
          </button>
          <button
            onClick={dismiss}
            className="px-3 py-1.5 text-gray-500 dark:text-slate-400 text-xs hover:text-gray-700 dark:hover:text-slate-200"
          >
            ë‚˜ì¤‘ì—
          </button>
        </div>
      </div>
      <button onClick={dismiss} className="text-gray-400 hover:text-gray-600 dark:hover:text-slate-300 text-lg leading-none shrink-0">Ã—</button>
    </div>
  );
}
</file>

<file path="src/components/SoundToggle.tsx">
"use client";
// src/components/SoundToggle.tsx
// ì•Œë¦¼ ì„¤ì • í˜ì´ì§€ ë˜ëŠ” í—¤ë”ì— ì¶”ê°€

import { useState, useEffect } from "react";
import { Volume2, VolumeX } from "lucide-react";
import { isSoundEnabled, setSoundEnabled, sound } from "@/lib/sound";

export default function SoundToggle({ compact = false }: { compact?: boolean }) {
  const [enabled, setEnabled] = useState(true);

  useEffect(() => { setEnabled(isSoundEnabled()); }, []);

  const toggle = () => {
    const next = !enabled;
    setSoundEnabled(next);
    setEnabled(next);
    if (next) sound.success(); // ì¼¤ ë•Œ ë¯¸ë¦¬ë³´ê¸°
  };

  if (compact) {
    return (
      <button onClick={toggle} title={enabled ? "ì•Œë¦¼ ì†Œë¦¬ ë„ê¸°" : "ì•Œë¦¼ ì†Œë¦¬ ì¼œê¸°"}
        className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
        {enabled
          ? <Volume2 size={18} className="text-blue-600 dark:text-blue-400" />
          : <VolumeX size={18} className="text-gray-400 dark:text-slate-500" />
        }
      </button>
    );
  }

  return (
    <div className="flex items-center justify-between py-3 px-4 bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700">
      <div className="flex items-center gap-3">
        {enabled
          ? <Volume2 size={18} className="text-blue-600 dark:text-blue-400" />
          : <VolumeX size={18} className="text-gray-400 dark:text-slate-500" />
        }
        <div>
          <p className="text-sm font-semibold text-gray-900 dark:text-slate-100">ì•Œë¦¼ ì‚¬ìš´ë“œ</p>
          <p className="text-xs text-gray-400 dark:text-slate-500">ë©”ì‹œì§€Â·ì•Œë¦¼Â·ì˜¤ë¥˜ ì†Œë¦¬</p>
        </div>
      </div>
      <button
        onClick={toggle}
        className={`w-11 h-6 rounded-full transition-colors ${enabled ? "bg-blue-600" : "bg-gray-200 dark:bg-slate-600"}`}
      >
        <span className={`block w-4.5 h-4.5 bg-white rounded-full shadow transition-transform mx-0.5 ${enabled ? "translate-x-5" : "translate-x-0"}`} />
      </button>
    </div>
  );
}
</file>

<file path="src/components/StorageQuotaBar.tsx">
"use client";
// src/components/StorageQuotaBar.tsx
// ëŒ€ì‹œë³´ë“œ ì‚¬ì´ë“œë°” ë˜ëŠ” í—¤ë”ì— ì‚½ì…

import { useState, useEffect } from "react";
import { HardDrive, AlertTriangle } from "lucide-react";

function formatBytes(bytes: string | bigint): string {
  const n = typeof bytes === "string" ? parseInt(bytes) : Number(bytes);
  if (n >= 1024 ** 3) return `${(n / 1024 ** 3).toFixed(1)}GB`;
  if (n >= 1024 ** 2) return `${(n / 1024 ** 2).toFixed(1)}MB`;
  if (n >= 1024)      return `${(n / 1024).toFixed(0)}KB`;
  return `${n}B`;
}

export default function StorageQuotaBar() {
  const [data, setData] = useState<{
    storageUsed: string; storageLimit: string; percentage: number;
  } | null>(null);

  useEffect(() => {
    fetch("/api/users/me/storage")
      .then((r) => r.json())
      .then(setData)
      .catch(() => {});
  }, []);

  if (!data) return null;

  const isWarning  = data.percentage >= 80;
  const isCritical = data.percentage >= 95;

  return (
    <div className="px-3 py-2.5 rounded-xl bg-gray-50 dark:bg-slate-800 border border-gray-100 dark:border-slate-700">
      <div className="flex items-center gap-2 mb-1.5">
        {isCritical
          ? <AlertTriangle size={13} className="text-red-500 shrink-0" />
          : <HardDrive size={13} className={`shrink-0 ${isWarning ? "text-amber-500" : "text-gray-500 dark:text-slate-400"}`} />
        }
        <span className="text-[11px] font-semibold text-gray-700 dark:text-slate-300 flex-1">ì €ì¥ ê³µê°„</span>
        <span className={`text-[10px] font-bold ${
          isCritical ? "text-red-500" : isWarning ? "text-amber-500" : "text-gray-500 dark:text-slate-400"
        }`}>
          {data.percentage}%
        </span>
      </div>

      {/* ë°” */}
      <div className="h-1.5 bg-gray-200 dark:bg-slate-700 rounded-full overflow-hidden">
        <div
          className={`h-full rounded-full transition-all ${
            isCritical ? "bg-red-500" : isWarning ? "bg-amber-500" : "bg-blue-500"
          }`}
          style={{ width: `${Math.min(data.percentage, 100)}%` }}
        />
      </div>

      <p className="text-[10px] text-gray-400 dark:text-slate-500 mt-1">
        {formatBytes(data.storageUsed)} / {formatBytes(data.storageLimit)}
      </p>

      {isCritical && (
        <p className="text-[9px] text-red-500 font-semibold mt-1">
          âš ï¸ ì €ì¥ ê³µê°„ì´ ê±°ì˜ ê°€ë“ ì°¼ìŠµë‹ˆë‹¤. íŒŒì¼ì„ ì •ë¦¬í•˜ì„¸ìš”.
        </p>
      )}
    </div>
  );
}
</file>

<file path="src/components/SystemNoticeBanner.tsx">
"use client";
// src/components/SystemNoticeBanner.tsx
// providers.tsxì— í¬í•¨ â€” í™œì„± ì‹œìŠ¤í…œ ê³µì§€ë¥¼ ìƒë‹¨ì— í‘œì‹œ

import { useState, useEffect } from "react";
import { X, AlertTriangle, Info, Wrench } from "lucide-react";

interface Notice {
  id: string; title: string; content: string; type: string;
}

const STYLES = {
  INFO:        "bg-blue-600 text-white",
  WARNING:     "bg-amber-500 text-white",
  MAINTENANCE: "bg-purple-700 text-white",
};
const ICONS = {
  INFO:        <Info size={14} className="shrink-0" />,
  WARNING:     <AlertTriangle size={14} className="shrink-0" />,
  MAINTENANCE: <Wrench size={14} className="shrink-0" />,
};

export default function SystemNoticeBanner() {
  const [notices, setNotices] = useState<Notice[]>([]);
  const [dismissed, setDismissed] = useState<Set<string>>(new Set());

  useEffect(() => {
    fetch("/api/admin/notices")
      .then((r) => r.json())
      .then((d) => setNotices(d.notices ?? []))
      .catch(() => {});
  }, []);

  const visible = notices.filter((n) => !dismissed.has(n.id));
  if (visible.length === 0) return null;

  const top = visible[0];
  const style = STYLES[top.type as keyof typeof STYLES] ?? STYLES.INFO;
  const icon  = ICONS[top.type  as keyof typeof ICONS]  ?? ICONS.INFO;

  return (
    <div className={`${style} px-4 py-2 flex items-center gap-2 text-sm font-medium z-[9990]`}>
      {icon}
      <span className="flex-1 text-center text-xs">{top.title}: {top.content}</span>
      <button onClick={() => setDismissed((s) => new Set([...s, top.id]))} className="opacity-70 hover:opacity-100 transition-opacity">
        <X size={14} />
      </button>
    </div>
  );
}
</file>

<file path="src/components/TagInput.tsx">
"use client";

import { useState, useEffect } from "react";
import { toast } from "@/components/Toast";

interface Tag { id: string; name: string; color?: string; }

interface TagInputProps {
  resourceId: string;
  resourceType: "file" | "post";
  onTagsChange?: () => void;
}

export default function TagInput({ resourceId, resourceType, onTagsChange }: TagInputProps) {
  const [tags, setTags] = useState<Tag[]>([]);
  const [allTags, setAllTags] = useState<Tag[]>([]);
  const [inputValue, setInputValue] = useState("");
  const [suggestions, setSuggestions] = useState<Tag[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    fetchTags();
    fetchAllTags();
  }, [resourceId]);

  const fetchTags = async () => {
    try {
      const res = await fetch(`/api/${resourceType}s/${resourceId}/tags`);
      if (res.ok) setTags((await res.json()).tags || []);
    } catch {}
  };

  const fetchAllTags = async () => {
    try {
      const res = await fetch("/api/tags");
      if (res.ok) setAllTags((await res.json()).tags || []);
    } catch {}
  };

  const handleAddTag = async (tagName: string) => {
    if (!tagName.trim()) return;
    setLoading(true);
    try {
      const res = await fetch(`/api/${resourceType}s/${resourceId}/tags`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ tagName: tagName.trim() }),
      });
      if (res.ok) {
        await fetchTags();
        setInputValue("");
        setSuggestions([]);
        onTagsChange?.();
      } else {
        const data = await res.json();
        // âœ… alert() â†’ toast
        toast.error(data.error || "íƒœê·¸ ì¶”ê°€ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
      }
    } catch {
      toast.error("íƒœê·¸ ì¶”ê°€ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  };

  const handleRemoveTag = async (tagId: string) => {
    setLoading(true);
    try {
      const res = await fetch(`/api/${resourceType}s/${resourceId}/tags?tagId=${tagId}`, {
        method: "DELETE",
      });
      if (res.ok) {
        await fetchTags();
        onTagsChange?.();
      } else {
        toast.error("íƒœê·¸ ì œê±°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
      }
    } catch {
      toast.error("íƒœê·¸ ì œê±° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  };

  const handleInputChange = (value: string) => {
    setInputValue(value);
    if (value.trim()) {
      const filtered = allTags.filter(
        (tag) =>
          tag.name.toLowerCase().includes(value.toLowerCase()) &&
          !tags.some((t) => t.id === tag.id)
      );
      setSuggestions(filtered.slice(0, 5));
    } else {
      setSuggestions([]);
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === "Enter") {
      e.preventDefault();
      handleAddTag(inputValue);
    }
  };

  return (
    <div className="space-y-3">
      <div className="flex flex-wrap gap-2">
        {tags.map((tag) => (
          <span
            key={tag.id}
            className="inline-flex items-center gap-1 px-3 py-1 bg-blue-100 text-blue-800 text-sm rounded-full"
          >
            #{tag.name}
            <button
              onClick={() => handleRemoveTag(tag.id)}
              disabled={loading}
              className="hover:text-blue-900 disabled:opacity-50"
            >
              Ã—
            </button>
          </span>
        ))}
      </div>

      <div className="relative">
        <input
          type="text"
          value={inputValue}
          onChange={(e) => handleInputChange(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder="íƒœê·¸ ì…ë ¥ í›„ Enter"
          className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-900"
          disabled={loading}
        />
        {suggestions.length > 0 && (
          <div className="absolute z-10 w-full mt-1 bg-white border border-gray-300 rounded-md shadow-lg">
            {suggestions.map((tag) => (
              <button
                key={tag.id}
                onClick={() => handleAddTag(tag.name)}
                className="w-full px-3 py-2 text-left hover:bg-gray-100 text-sm text-gray-900"
              >
                #{tag.name}
              </button>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/components/ThemeToggle.tsx">
"use client";

import { useTheme } from "next-themes";
import { useEffect, useState } from "react";
import { Sun, Moon, Monitor } from "lucide-react";

interface ThemeToggleProps {
  /** 'icon' = ì•„ì´ì½˜ë§Œ, 'full' = ì•„ì´ì½˜ + ë¼ë²¨ ë“œë¡­ë‹¤ìš´ */
  variant?: "icon" | "full";
  className?: string;
}

export default function ThemeToggle({ variant = "icon", className = "" }: ThemeToggleProps) {
  const { theme, setTheme, resolvedTheme } = useTheme();
  const [mounted, setMounted] = useState(false);

  // SSR hydration mismatch ë°©ì§€
  useEffect(() => setMounted(true), []);
  if (!mounted) return <div className="w-9 h-9" />;

  // ë‹¨ìˆœ ì•„ì´ì½˜ í† ê¸€ (light â†” dark)
  if (variant === "icon") {
    const isDark = resolvedTheme === "dark";
    return (
      <button
        onClick={() => setTheme(isDark ? "light" : "dark")}
        className={`relative w-9 h-9 flex items-center justify-center rounded-lg 
          hover:bg-slate-100 dark:hover:bg-slate-700 
          text-slate-500 dark:text-slate-400
          transition-colors ${className}`}
        title={isDark ? "ë¼ì´íŠ¸ ëª¨ë“œë¡œ ì „í™˜" : "ë‹¤í¬ ëª¨ë“œë¡œ ì „í™˜"}
        aria-label="í…Œë§ˆ ì „í™˜"
      >
        {/* Sun â€“ ë‹¤í¬ì¼ ë•Œ ë³´ì„ (í´ë¦­í•˜ë©´ ë¼ì´íŠ¸ë¡œ) */}
        <Sun
          size={18}
          className={`absolute transition-all duration-300 ${
            isDark ? "opacity-100 rotate-0 scale-100" : "opacity-0 rotate-90 scale-75"
          }`}
        />
        {/* Moon â€“ ë¼ì´íŠ¸ì¼ ë•Œ ë³´ì„ (í´ë¦­í•˜ë©´ ë‹¤í¬ë¡œ) */}
        <Moon
          size={18}
          className={`absolute transition-all duration-300 ${
            !isDark ? "opacity-100 rotate-0 scale-100" : "opacity-0 -rotate-90 scale-75"
          }`}
        />
      </button>
    );
  }

  // í’€ ë“œë¡­ë‹¤ìš´ (light / dark / system)
  const options = [
    { value: "light", label: "ë¼ì´íŠ¸", icon: Sun },
    { value: "dark",  label: "ë‹¤í¬",   icon: Moon },
    { value: "system",label: "ì‹œìŠ¤í…œ", icon: Monitor },
  ] as const;

  return (
    <div className={`flex items-center gap-1 p-1 rounded-xl bg-slate-100 dark:bg-slate-800 ${className}`}>
      {options.map(({ value, label, icon: Icon }) => (
        <button
          key={value}
          onClick={() => setTheme(value)}
          className={`flex items-center gap-1.5 px-3 py-1.5 rounded-lg text-xs font-medium transition-all ${
            theme === value
              ? "bg-white dark:bg-slate-700 text-slate-900 dark:text-slate-100 shadow-sm"
              : "text-slate-500 dark:text-slate-400 hover:text-slate-700 dark:hover:text-slate-200"
          }`}
        >
          <Icon size={13} />
          {label}
        </button>
      ))}
    </div>
  );
}
</file>

<file path="src/components/TypingIndicator.tsx">
"use client";
// src/components/TypingIndicator.tsx
// ì±„íŒ…ë°© í•˜ë‹¨ì— ë°°ì¹˜ â€” ìƒëŒ€ë°© íƒ€ì´í•‘ ì‹œ í‘œì‹œ

interface Props {
  typingUserNames: string[]; // useTypingIndicatorì—ì„œ userIdë¥¼ ì´ë¦„ìœ¼ë¡œ ë³€í™˜í•œ ë°°ì—´
}

export default function TypingIndicator({ typingUserNames }: Props) {
  if (typingUserNames.length === 0) return null;

  const label =
    typingUserNames.length === 1
      ? `${typingUserNames[0]}ë‹˜ì´ ì…ë ¥ ì¤‘`
      : `${typingUserNames.slice(0, 2).join(", ")}ë‹˜ì´ ì…ë ¥ ì¤‘`;

  return (
    <div className="flex items-center gap-2 px-4 py-1.5 animate-fade-in">
      {/* ì„¸ ì  ì• ë‹ˆë©”ì´ì…˜ */}
      <div className="flex items-center gap-0.5">
        {[0, 1, 2].map((i) => (
          <span
            key={i}
            className="w-1.5 h-1.5 rounded-full bg-gray-400 dark:bg-slate-500 animate-bounce"
            style={{ animationDelay: `${i * 0.15}s`, animationDuration: "0.9s" }}
          />
        ))}
      </div>
      <span className="text-xs text-gray-400 dark:text-slate-500 italic">{label}...</span>
    </div>
  );
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ì±„íŒ…ë°© í˜ì´ì§€ì—ì„œ ì‚¬ìš© ì˜ˆì‹œ
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//
// const { typingUserIds, startTyping, stopTyping } = useTypingIndicator(roomId);
//
// // roomMembers: { id, name }[] í˜•íƒœë¡œ ì±„íŒ…ë°© ë©¤ë²„ ëª©ë¡
// const typingNames = typingUserIds
//   .filter(id => id !== session.user.id)
//   .map(id => roomMembers.find(m => m.id === id)?.name ?? "ì‚¬ìš©ì");
//
// // ì¸í’‹ì— ì´ë²¤íŠ¸ ì—°ê²°
// <input
//   onChange={(e) => { setValue(e.target.value); startTyping(); }}
//   onBlur={stopTyping}
//   onKeyDown={(e) => { if (e.key === "Enter") stopTyping(); }}
// />
// <TypingIndicator typingUserNames={typingNames} />
</file>

<file path="src/components/UploadProgressOverlay.tsx">
"use client";
// src/components/UploadProgressOverlay.tsx
// ì—…ë¡œë“œ ì¤‘ì¸ íŒŒì¼ ì§„í–‰ë¥ ì„ í•˜ë‹¨ ê³ ì • ì˜¤ë²„ë ˆì´ë¡œ í‘œì‹œ
// providers.tsxì— ì¶”ê°€ (MobileBottomNav ìœ„ì—)

import { useUploadProgress } from "@/lib/socket-client";
import { X, Upload, CheckCircle } from "lucide-react";
import { useState } from "react";

export default function UploadProgressOverlay() {
  const { uploads } = useUploadProgress();
  const [dismissed, setDismissed] = useState<Set<string>>(new Set());

  const visible = uploads.filter((u) => !dismissed.has(u.fileId));
  if (visible.length === 0) return null;

  return (
    <div className="fixed bottom-20 right-4 z-[9990] space-y-2 max-w-xs w-full">
      {visible.map((u) => (
        <div
          key={u.fileId}
          className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 shadow-lg p-3"
        >
          <div className="flex items-center gap-2 mb-2">
            {u.progress >= 100
              ? <CheckCircle size={14} className="text-green-500 shrink-0" />
              : <Upload size={14} className="text-blue-500 shrink-0 animate-bounce" />
            }
            <p className="text-xs font-medium text-gray-800 dark:text-slate-200 flex-1 truncate">
              {u.filename}
            </p>
            <span className="text-[10px] font-bold text-gray-500 dark:text-slate-400">
              {u.progress}%
            </span>
            {u.progress >= 100 && (
              <button
                onClick={() => setDismissed((s) => new Set([...s, u.fileId]))}
                className="text-gray-400 hover:text-gray-600 dark:hover:text-slate-300"
              >
                <X size={12} />
              </button>
            )}
          </div>
          <div className="h-1.5 bg-gray-100 dark:bg-slate-700 rounded-full overflow-hidden">
            <div
              className={`h-full rounded-full transition-all duration-300 ${
                u.progress >= 100 ? "bg-green-500" : "bg-blue-500"
              }`}
              style={{ width: `${u.progress}%` }}
            />
          </div>
          {u.progress >= 100 && (
            <p className="text-[10px] text-green-600 dark:text-green-400 mt-1 font-medium">
              âœ“ ë‹¤ë¥¸ ê¸°ê¸°ì—ë„ ì—…ë¡œë“œ ì™„ë£Œë¨
            </p>
          )}
        </div>
      ))}
    </div>
  );
}
</file>

<file path="src/hooks/useInfiniteScroll.ts">
// src/hooks/useInfiniteScroll.ts
import { useState, useEffect, useRef, useCallback } from "react";

interface Options<T> {
  fetcher: (page: number) => Promise<{ items: T[]; hasMore: boolean }>;
  deps?: unknown[];
}

export function useInfiniteScroll<T>({ fetcher, deps = [] }: Options<T>) {
  const [items, setItems] = useState<T[]>([]);
  const [page, setPage] = useState(1);
  const [hasMore, setHasMore] = useState(true);
  const [loading, setLoading] = useState(false);
  const [initialLoading, setInitialLoading] = useState(true);
  const observerRef = useRef<IntersectionObserver | null>(null);
  const fetchingRef = useRef(false);
  const pageRef = useRef(1);

  const reset = useCallback(() => {
    setItems([]); setPage(1); setHasMore(true); setInitialLoading(true); pageRef.current = 1;
  }, []);

  // eslint-disable-next-line react-hooks/exhaustive-deps
  useEffect(() => { reset(); }, deps);

  const loadMore = useCallback(async (targetPage: number) => {
    if (fetchingRef.current) return;
    fetchingRef.current = true;
    setLoading(true);
    try {
      const result = await fetcher(targetPage);
      setItems((prev) => targetPage === 1 ? result.items : [...prev, ...result.items]);
      setHasMore(result.hasMore);
      pageRef.current = targetPage + 1;
      setPage(targetPage + 1);
    } catch {}
    finally { setLoading(false); setInitialLoading(false); fetchingRef.current = false; }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [fetcher]);

  // eslint-disable-next-line react-hooks/exhaustive-deps
  useEffect(() => { loadMore(1); }, deps);

  const setSentinel = useCallback((el: HTMLDivElement | null) => {
    if (observerRef.current) observerRef.current.disconnect();
    if (!el) return;
    observerRef.current = new IntersectionObserver(
      ([entry]) => { if (entry.isIntersecting && !fetchingRef.current) loadMore(pageRef.current); },
      { rootMargin: "200px" }
    );
    observerRef.current.observe(el);
  }, [loadMore]);

  return { items, loading, initialLoading, hasMore, setSentinel, reload: () => { reset(); loadMore(1); } };
}
</file>

<file path="src/lib/api-key-auth.ts">
// src/lib/api-key-auth.ts
// ì™¸ë¶€ API ìš”ì²­ ì‹œ Bearer API í‚¤ ê²€ì¦ ë¯¸ë“¤ì›¨ì–´

import { NextRequest } from "next/server";
import { prisma } from "@/lib/db";
import bcrypt from "bcryptjs";

interface AuthResult {
  ok: boolean;
  userId?: string;
  scopes?: string[];
  error?: string;
}

export async function verifyApiKey(
  request: NextRequest,
  requiredScopes: string[] = []
): Promise<AuthResult> {
  const authHeader = request.headers.get("authorization");
  if (!authHeader?.startsWith("Bearer eum_"))
    return { ok: false, error: "API í‚¤ê°€ í•„ìš”í•©ë‹ˆë‹¤" };

  const rawKey = authHeader.slice(7); // "Bearer " ì œê±°
  const prefix = rawKey.slice(0, 12);

  // prefixë¡œ í›„ë³´ í‚¤ ì¡°íšŒ (DB í’€ìŠ¤ìº” ë°©ì§€)
  const candidates = await prisma.apiKey.findMany({
    where: { keyPrefix: prefix },
  });

  for (const key of candidates) {
    const match = await bcrypt.compare(rawKey, key.keyHash);
    if (!match) continue;

    // ë§Œë£Œ í™•ì¸
    if (key.expiresAt && key.expiresAt < new Date())
      return { ok: false, error: "ë§Œë£Œëœ API í‚¤ì…ë‹ˆë‹¤" };

    // ìŠ¤ì½”í”„ í™•ì¸
    for (const scope of requiredScopes) {
      if (!key.scopes.includes(scope))
        return { ok: false, error: `'${scope}' ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤` };
    }

    // ë§ˆì§€ë§‰ ì‚¬ìš© ì‹œê° ì—…ë°ì´íŠ¸ (ë¹„ë™ê¸°, ì‘ë‹µ ëŒ€ê¸° ì•ˆ í•¨)
    prisma.apiKey.update({
      where: { id: key.id },
      data: { lastUsedAt: new Date() },
    }).catch(() => {});

    return { ok: true, userId: key.userId, scopes: key.scopes };
  }

  return { ok: false, error: "ìœ íš¨í•˜ì§€ ì•Šì€ API í‚¤ì…ë‹ˆë‹¤" };
}
</file>

<file path="src/lib/api-response.ts">
// src/lib/api-response.ts
// ì „ì²´ APIì—ì„œ ì‚¬ìš©í•  í‘œì¤€í™”ëœ ì‘ë‹µ í˜•ì‹
//
// ì„±ê³µ: { success: true,  data: T,      meta?: M }
// ì‹¤íŒ¨: { success: false, error: string, code: ErrorCode, details?: unknown }

import { NextResponse } from "next/server";

// â”€â”€ ì—ëŸ¬ ì½”ë“œ ì²´ê³„ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export const ErrorCode = {
  // ì¸ì¦
  UNAUTHORIZED:        "UNAUTHORIZED",
  FORBIDDEN:           "FORBIDDEN",
  SESSION_EXPIRED:     "SESSION_EXPIRED",
  ACCOUNT_BANNED:      "ACCOUNT_BANNED",

  // ì…ë ¥ê°’
  VALIDATION_ERROR:    "VALIDATION_ERROR",
  MISSING_FIELD:       "MISSING_FIELD",
  INVALID_FORMAT:      "INVALID_FORMAT",

  // ë¦¬ì†ŒìŠ¤
  NOT_FOUND:           "NOT_FOUND",
  ALREADY_EXISTS:      "ALREADY_EXISTS",
  CONFLICT:            "CONFLICT",

  // ì œí•œ
  RATE_LIMITED:        "RATE_LIMITED",
  STORAGE_QUOTA:       "STORAGE_QUOTA",
  FILE_TOO_LARGE:      "FILE_TOO_LARGE",
  MAX_LIMIT_REACHED:   "MAX_LIMIT_REACHED",

  // ì„œë²„
  INTERNAL_ERROR:      "INTERNAL_ERROR",
  SERVICE_UNAVAILABLE: "SERVICE_UNAVAILABLE",
  DATABASE_ERROR:      "DATABASE_ERROR",
} as const;

export type ErrorCode = typeof ErrorCode[keyof typeof ErrorCode];

// â”€â”€ íƒ€ì… ì •ì˜ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
interface SuccessResponse<T, M = undefined> {
  success: true;
  data:    T;
  meta?:   M;
}
interface ErrorResponse {
  success: false;
  error:   string;
  code:    ErrorCode;
  details?: unknown;
}
interface PaginatedMeta {
  page:     number;
  limit:    number;
  total:    number;
  hasMore:  boolean;
}

// â”€â”€ ì‘ë‹µ ë¹Œë” â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function ok<T>(data: T, status = 200): NextResponse {
  const body: SuccessResponse<T> = { success: true, data };
  return NextResponse.json(body, { status });
}

export function created<T>(data: T): NextResponse {
  return ok(data, 201);
}

export function paginated<T>(
  items:    T[],
  meta:     PaginatedMeta,
  status = 200
): NextResponse {
  const body: SuccessResponse<T[], PaginatedMeta> = { success: true, data: items, meta };
  return NextResponse.json(body, { status });
}

export function error(
  message: string,
  code:    ErrorCode,
  status:  number,
  details?: unknown
): NextResponse {
  const body: ErrorResponse = { success: false, error: message, code, details };
  return NextResponse.json(body, { status });
}

// â”€â”€ ìì£¼ ì“°ëŠ” ì—ëŸ¬ ë‹¨ì¶•í‚¤ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export const ApiError = {
  unauthorized:     (msg = "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤") =>
    error(msg, ErrorCode.UNAUTHORIZED, 401),

  forbidden:        (msg = "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤") =>
    error(msg, ErrorCode.FORBIDDEN, 403),

  notFound:         (resource = "ë¦¬ì†ŒìŠ¤") =>
    error(`${resource}ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤`, ErrorCode.NOT_FOUND, 404),

  conflict:         (msg: string) =>
    error(msg, ErrorCode.CONFLICT, 409),

  validation:       (msg: string, details?: unknown) =>
    error(msg, ErrorCode.VALIDATION_ERROR, 422, details),

  rateLimited:      () =>
    error("ë„ˆë¬´ ë§ì€ ìš”ì²­ì…ë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”", ErrorCode.RATE_LIMITED, 429),

  storageQuota:     () =>
    error("ì €ì¥ ìš©ëŸ‰ì´ ë¶€ì¡±í•©ë‹ˆë‹¤", ErrorCode.STORAGE_QUOTA, 413),

  internal:         (msg = "ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤") =>
    error(msg, ErrorCode.INTERNAL_ERROR, 500),
};

// â”€â”€ ì‚¬ìš© ì˜ˆì‹œ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// import { ok, created, paginated, ApiError } from "@/lib/api-response";
//
// // ì„±ê³µ
// return ok({ file });
// return created({ file });
// return paginated(files, { page, limit, total, hasMore });
//
// // ì—ëŸ¬
// return ApiError.unauthorized();
// return ApiError.notFound("íŒŒì¼");
// return ApiError.validation("ì´ë©”ì¼ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤", { field: "email" });
</file>

<file path="src/lib/cache.ts">
// src/lib/cache.ts
// Redis ì—†ì´ ë©”ëª¨ë¦¬ ê¸°ë°˜ TTL ìºì‹œ
// Next.js ì„œë²„ í”„ë¡œì„¸ìŠ¤ ë‚´ì—ì„œ ê³µìœ  (ë‹¨ì¼ ì„œë²„ í™˜ê²½ì— ì í•©)

interface CacheEntry<T> {
  value: T;
  expiresAt: number;
  tags: string[];
}

class MemoryCache {
  private store = new Map<string, CacheEntry<unknown>>();
  private maxSize: number;

  constructor(maxSize = 1000) {
    this.maxSize = maxSize;
    // 1ë¶„ë§ˆë‹¤ ë§Œë£Œ í•­ëª© ì •ë¦¬
    if (typeof setInterval !== "undefined") {
      setInterval(() => this.evictExpired(), 60_000);
    }
  }

  get<T>(key: string): T | null {
    const entry = this.store.get(key);
    if (!entry) return null;
    if (Date.now() > entry.expiresAt) {
      this.store.delete(key);
      return null;
    }
    return entry.value as T;
  }

  set<T>(key: string, value: T, ttlSeconds: number, tags: string[] = []): void {
    // LRU: ìµœëŒ€ í¬ê¸° ì´ˆê³¼ ì‹œ ê°€ì¥ ì˜¤ë˜ëœ í•­ëª© ì‚­ì œ
    if (this.store.size >= this.maxSize) {
      const firstKey = this.store.keys().next().value;
      if (firstKey) this.store.delete(firstKey);
    }
    this.store.set(key, {
      value,
      expiresAt: Date.now() + ttlSeconds * 1000,
      tags,
    });
  }

  delete(key: string): void {
    this.store.delete(key);
  }

  /** íƒœê·¸ë¡œ ê´€ë ¨ ìºì‹œ ì¼ê´„ ë¬´íš¨í™” */
  invalidateByTag(tag: string): void {
    for (const [key, entry] of this.store.entries()) {
      if (entry.tags.includes(tag)) this.store.delete(key);
    }
  }

  /** íŒ¨í„´ìœ¼ë¡œ ìºì‹œ ë¬´íš¨í™” */
  invalidateByPattern(prefix: string): void {
    for (const key of this.store.keys()) {
      if (key.startsWith(prefix)) this.store.delete(key);
    }
  }

  private evictExpired(): void {
    const now = Date.now();
    for (const [key, entry] of this.store.entries()) {
      if (now > entry.expiresAt) this.store.delete(key);
    }
  }

  get size() { return this.store.size; }
}

// ì „ì—­ ì‹±ê¸€í„´
const cache = new MemoryCache(2000);
export default cache;

// â”€â”€ í¸ì˜ ë˜í¼ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * ìºì‹œì—ì„œ ê°€ì ¸ì˜¤ê±°ë‚˜ fetcher ì‹¤í–‰ í›„ ìºì‹œì— ì €ì¥
 * @example
 *   const data = await withCache(
 *     `stats:${userId}`,
 *     () => prisma.file.count({ where: { userId } }),
 *     60,           // TTL: 60ì´ˆ
 *     ["user-stats"] // íƒœê·¸ (invalidateByTagë¡œ ì¼ê´„ ë¬´íš¨í™”)
 *   );
 */
export async function withCache<T>(
  key: string,
  fetcher: () => Promise<T>,
  ttlSeconds = 60,
  tags: string[] = []
): Promise<T> {
  const cached = cache.get<T>(key);
  if (cached !== null) return cached;

  const fresh = await fetcher();
  cache.set(key, fresh, ttlSeconds, tags);
  return fresh;
}

// â”€â”€ TTL ìƒìˆ˜ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export const TTL = {
  SHORT:    30,   // 30ì´ˆ - ìì£¼ ë³€í•˜ëŠ” ë°ì´í„° (ì•Œë¦¼ ìˆ˜)
  MEDIUM:   300,  // 5ë¶„  - ë³´í†µ (íŒŒì¼ ëª©ë¡)
  LONG:     3600, // 1ì‹œê°„ - ìì£¼ ì•ˆ ë³€í•˜ëŠ” ë°ì´í„° (í†µê³„)
  VERY_LONG: 86400, // 24ì‹œê°„ - ê±°ì˜ ì•ˆ ë³€í•˜ëŠ” ë°ì´í„° (íƒœê·¸ ëª©ë¡)
};

// â”€â”€ ì‚¬ìš© ì˜ˆì‹œ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// API routeì—ì„œ:
//
// import { withCache, cache, TTL } from "@/lib/cache";
//
// export async function GET() {
//   const stats = await withCache(
//     "admin:stats",
//     () => fetchExpensiveStats(),
//     TTL.LONG,
//     ["admin-stats"]
//   );
//   return NextResponse.json(stats);
// }
//
// // ë°ì´í„° ë³€ê²½ ì‹œ ë¬´íš¨í™”:
// cache.invalidateByTag("admin-stats");
// cache.invalidateByPattern(`user:${userId}:`);
</file>

<file path="src/lib/client-utils.ts">
/**
 * src/lib/client-utils.ts
 * í´ë¼ì´ì–¸íŠ¸ ê³µí†µ ìœ í‹¸ í•¨ìˆ˜ ëª¨ìŒ
 */

// â”€â”€ íŒŒì¼ í¬ê¸° â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function formatFileSize(bytes: number | string): string {
  const n = typeof bytes === "string" ? parseInt(bytes) : bytes;
  if (!n || isNaN(n)) return "0 B";
  if (n < 1024) return `${n} B`;
  if (n < 1024 ** 2) return `${(n / 1024).toFixed(1)} KB`;
  if (n < 1024 ** 3) return `${(n / 1024 ** 2).toFixed(2)} MB`;
  return `${(n / 1024 ** 3).toFixed(2)} GB`;
}

// â”€â”€ ìƒëŒ€ ì‹œê°„ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function relativeTime(dateStr: string | Date): string {
  const now = Date.now();
  const ts = typeof dateStr === "string" ? new Date(dateStr).getTime() : dateStr.getTime();
  const diff = now - ts;
  const mins = Math.floor(diff / 60000);
  const hours = Math.floor(diff / 3600000);
  const days = Math.floor(diff / 86400000);
  if (mins < 1) return "ë°©ê¸ˆ ì „";
  if (mins < 60) return `${mins}ë¶„ ì „`;
  if (hours < 24) return `${hours}ì‹œê°„ ì „`;
  if (days < 7) return `${days}ì¼ ì „`;
  return new Date(dateStr).toLocaleDateString("ko-KR");
}

// â”€â”€ ì ˆëŒ€ ë‚ ì§œ/ì‹œê°„ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function formatDate(dateStr: string | Date): string {
  const d = typeof dateStr === "string" ? new Date(dateStr) : dateStr;
  return d.toLocaleDateString("ko-KR", { year: "numeric", month: "long", day: "numeric" });
}

export function formatTime(dateStr: string | Date): string {
  const d = typeof dateStr === "string" ? new Date(dateStr) : dateStr;
  if (isNaN(d.getTime())) return "";
  return d.toLocaleTimeString("ko-KR", { hour: "2-digit", minute: "2-digit" });
}

// â”€â”€ íŒŒì¼ íƒ€ì… ì•„ì´ì½˜ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function getFileIcon(mimeType: string): string {
  if (!mimeType) return "ğŸ“";
  if (mimeType.startsWith("image/")) return "ğŸ–¼ï¸";
  if (mimeType.startsWith("video/")) return "ğŸ¬";
  if (mimeType.startsWith("audio/")) return "ğŸµ";
  if (mimeType.includes("pdf")) return "ğŸ“„";
  if (mimeType.includes("word") || mimeType.includes("document")) return "ğŸ“";
  if (mimeType.includes("sheet") || mimeType.includes("excel")) return "ğŸ“Š";
  if (mimeType.includes("presentation") || mimeType.includes("powerpoint")) return "ğŸ“‘";
  if (mimeType.includes("zip") || mimeType.includes("rar") || mimeType.includes("7z") || mimeType.includes("tar")) return "ğŸ—œï¸";
  if (mimeType.includes("text/plain")) return "ğŸ“ƒ";
  if (mimeType.includes("html")) return "ğŸŒ";
  if (mimeType.includes("json")) return "ğŸ”§";
  if (mimeType.includes("javascript") || mimeType.includes("typescript")) return "âš™ï¸";
  if (mimeType.includes("python")) return "ğŸ";
  return "ğŸ“";
}

// â”€â”€ íŒŒì¼ ìƒ‰ìƒ (ì¹´ë“œ ë°°ê²½) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function getFileColor(mimeType: string): string {
  if (!mimeType) return "bg-gray-50";
  if (mimeType.startsWith("image/")) return "bg-pink-50";
  if (mimeType.startsWith("video/")) return "bg-purple-50";
  if (mimeType.startsWith("audio/")) return "bg-yellow-50";
  if (mimeType.includes("pdf")) return "bg-red-50";
  if (mimeType.includes("word") || mimeType.includes("document")) return "bg-blue-50";
  if (mimeType.includes("sheet") || mimeType.includes("excel")) return "bg-green-50";
  if (mimeType.includes("presentation") || mimeType.includes("powerpoint")) return "bg-orange-50";
  if (mimeType.includes("zip") || mimeType.includes("rar")) return "bg-amber-50";
  return "bg-gray-50";
}

// â”€â”€ íŒŒì¼ í™•ì¥ì ì¶”ì¶œ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function getFileExtension(filename: string): string {
  const parts = filename.split(".");
  return parts.length > 1 ? parts[parts.length - 1].toUpperCase() : "";
}

// â”€â”€ í´ë¦½ë³´ë“œ ë³µì‚¬ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export async function copyToClipboard(text: string): Promise<boolean> {
  try {
    await navigator.clipboard.writeText(text);
    return true;
  } catch {
    // fallback
    const el = document.createElement("textarea");
    el.value = text;
    el.style.position = "fixed";
    el.style.opacity = "0";
    document.body.appendChild(el);
    el.focus();
    el.select();
    const ok = document.execCommand("copy");
    document.body.removeChild(el);
    return ok;
  }
}

// â”€â”€ ë°”ì´íŠ¸ â†’ í¼ì„¼íŠ¸ (ìš©ëŸ‰ ì œí•œ ê¸°ì¤€) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function storagePercent(usedBytes: number, limitBytes: number = 5 * 1024 ** 3): number {
  return Math.min((usedBytes / limitBytes) * 100, 100);
}
</file>

<file path="src/lib/email-templates.ts">
// src/lib/email-templates.ts
// ì´ìŒ ì´ë©”ì¼ í…œí”Œë¦¿ ëª¨ìŒ â€” ê¸°ì¡´ email.tsì™€ í•¨ê»˜ ì‚¬ìš©

const BASE_URL = process.env.NEXTAUTH_URL ?? "https://eum.app";

const baseLayout = (content: string, previewText = "") => `
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ì´ìŒ</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { background: #f4f4f7; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; color: #333; }
    .wrapper { max-width: 580px; margin: 40px auto; }
    .card { background: #fff; border-radius: 20px; overflow: hidden; box-shadow: 0 4px 24px rgba(0,0,0,.06); }
    .header { background: linear-gradient(135deg, #5b21b6 0%, #3730a3 100%); padding: 32px 40px; text-align: center; }
    .logo { display: inline-flex; align-items: center; gap: 10px; }
    .logo-icon { width: 36px; height: 36px; background: rgba(255,255,255,.15); border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 18px; }
    .logo-text { color: #fff; font-size: 20px; font-weight: 900; letter-spacing: -.5px; }
    .body { padding: 40px; }
    .title { font-size: 22px; font-weight: 800; color: #111; margin-bottom: 12px; line-height: 1.3; }
    .text { font-size: 15px; color: #555; line-height: 1.7; margin-bottom: 16px; }
    .btn { display: inline-block; padding: 14px 32px; background: #5b21b6; color: #fff !important; font-size: 15px; font-weight: 700; border-radius: 12px; text-decoration: none; margin: 16px 0; }
    .btn:hover { background: #4c1d95; }
    .divider { height: 1px; background: #f0f0f3; margin: 24px 0; }
    .notice { background: #faf9ff; border: 1px solid #e8e3ff; border-radius: 12px; padding: 16px; font-size: 13px; color: #7c3aed; margin: 20px 0; }
    .code { font-family: 'Courier New', monospace; font-size: 28px; font-weight: 900; letter-spacing: 6px; color: #5b21b6; text-align: center; padding: 20px; background: #faf9ff; border-radius: 12px; margin: 20px 0; }
    .footer { background: #f8f7ff; padding: 24px 40px; text-align: center; }
    .footer p { font-size: 12px; color: #999; line-height: 1.8; }
    .footer a { color: #7c3aed; text-decoration: none; }
  </style>
</head>
<body>
  <div style="display:none;max-height:0;overflow:hidden;">${previewText}</div>
  <div class="wrapper">
    <div class="card">
      <div class="header">
        <div class="logo">
          <div class="logo-icon">â˜ï¸</div>
          <div class="logo-text">ì´ìŒ</div>
        </div>
      </div>
      <div class="body">${content}</div>
    </div>
    <div class="footer">
      <p>ì´ ì´ë©”ì¼ì€ ì´ìŒ í¼ìŠ¤ë„ í´ë¼ìš°ë“œì—ì„œ ë°œì†¡ë˜ì—ˆìŠµë‹ˆë‹¤.</p>
      <p><a href="${BASE_URL}">ì´ìŒ ë°©ë¬¸í•˜ê¸°</a> Â· <a href="${BASE_URL}/settings">ì•Œë¦¼ ì„¤ì •</a></p>
      <p style="margin-top:8px;color:#bbb;">Â© 2026 EUM CLOUD SERVICE</p>
    </div>
  </div>
</body>
</html>`;

// â‘  ì´ë©”ì¼ ì¸ì¦
export function emailVerificationTemplate(name: string, code: string) {
  return baseLayout(`
    <h2 class="title">ì´ë©”ì¼ ì¸ì¦</h2>
    <p class="text">ì•ˆë…•í•˜ì„¸ìš”, <strong>${name}</strong>ë‹˜!<br/>
    ì•„ë˜ ì¸ì¦ ì½”ë“œë¥¼ ì…ë ¥í•´ ì´ìŒ ê³„ì •ì„ í™œì„±í™”í•˜ì„¸ìš”.</p>
    <div class="code">${code}</div>
    <p class="text" style="font-size:13px;color:#999;">ì´ ì½”ë“œëŠ” 10ë¶„ í›„ ë§Œë£Œë©ë‹ˆë‹¤. ë³¸ì¸ì´ ìš”ì²­í•˜ì§€ ì•Šì•˜ë‹¤ë©´ ë¬´ì‹œí•˜ì„¸ìš”.</p>
  `, `[ì´ìŒ] ì´ë©”ì¼ ì¸ì¦ ì½”ë“œ: ${code}`);
}

// â‘¡ ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì •
export function passwordResetTemplate(name: string, resetUrl: string) {
  return baseLayout(`
    <h2 class="title">ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì •</h2>
    <p class="text">ì•ˆë…•í•˜ì„¸ìš”, <strong>${name}</strong>ë‹˜!<br/>
    ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì • ìš”ì²­ì´ ì ‘ìˆ˜ë˜ì—ˆìŠµë‹ˆë‹¤. ì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ ìƒˆ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì„¤ì •í•˜ì„¸ìš”.</p>
    <div style="text-align:center;">
      <a href="${resetUrl}" class="btn">ğŸ”‘ ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì •</a>
    </div>
    <div class="notice">â± ì´ ë§í¬ëŠ” 1ì‹œê°„ í›„ ë§Œë£Œë©ë‹ˆë‹¤. ë³¸ì¸ì´ ìš”ì²­í•˜ì§€ ì•Šì•˜ë‹¤ë©´ ì¦‰ì‹œ ë¹„ë°€ë²ˆí˜¸ë¥¼ ë³€ê²½í•˜ì„¸ìš”.</div>
    <p class="text" style="font-size:13px;color:#999;">ë²„íŠ¼ì´ ì‘ë™í•˜ì§€ ì•Šìœ¼ë©´ ì•„ë˜ ë§í¬ë¥¼ ë³µì‚¬í•˜ì„¸ìš”:<br/>
    <a href="${resetUrl}" style="color:#7c3aed;word-break:break-all;">${resetUrl}</a></p>
  `, "ì´ìŒ ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì • ë§í¬ê°€ ë„ì°©í–ˆìŠµë‹ˆë‹¤");
}

// â‘¢ íŒŒì¼ ê³µìœ  ì•Œë¦¼
export function fileSharedTemplate(
  recipientName: string, senderName: string,
  fileName: string, shareUrl: string, permission: "VIEW" | "EDIT" | "ADMIN"
) {
  const permLabel = { VIEW: "ì½ê¸°", EDIT: "í¸ì§‘", ADMIN: "ê´€ë¦¬" }[permission];
  return baseLayout(`
    <h2 class="title">ğŸ“ íŒŒì¼ì´ ê³µìœ ë˜ì—ˆìŠµë‹ˆë‹¤</h2>
    <p class="text">ì•ˆë…•í•˜ì„¸ìš”, <strong>${recipientName}</strong>ë‹˜!<br/>
    <strong>${senderName}</strong>ë‹˜ì´ íŒŒì¼ì„ ê³µìœ í–ˆìŠµë‹ˆë‹¤.</p>
    <div class="notice">
      <strong>íŒŒì¼ëª…:</strong> ${fileName}<br/>
      <strong>ê¶Œí•œ:</strong> ${permLabel}
    </div>
    <div style="text-align:center;">
      <a href="${shareUrl}" class="btn">ğŸ“‚ íŒŒì¼ ë³´ê¸°</a>
    </div>
  `, `${senderName}ë‹˜ì´ "${fileName}"ì„ ê³µìœ í–ˆìŠµë‹ˆë‹¤`);
}

// â‘£ íŒ”ë¡œìš° ì•Œë¦¼
export function followNotificationTemplate(
  recipientName: string, followerName: string, followerProfileUrl: string
) {
  return baseLayout(`
    <h2 class="title">ğŸ‘¤ ìƒˆ íŒ”ë¡œì›Œ</h2>
    <p class="text">ì•ˆë…•í•˜ì„¸ìš”, <strong>${recipientName}</strong>ë‹˜!<br/>
    <strong>${followerName}</strong>ë‹˜ì´ íšŒì›ë‹˜ì„ íŒ”ë¡œìš°í•˜ê¸° ì‹œì‘í–ˆìŠµë‹ˆë‹¤.</p>
    <div style="text-align:center;">
      <a href="${followerProfileUrl}" class="btn">í”„ë¡œí•„ ë³´ê¸°</a>
    </div>
  `, `${followerName}ë‹˜ì´ íŒ”ë¡œìš°í–ˆìŠµë‹ˆë‹¤`);
}

// â‘¤ ì£¼ê°„ ìš”ì•½ ë‹¤ì´ì œìŠ¤íŠ¸
export function weeklyDigestTemplate(
  name: string,
  stats: { newFiles: number; newComments: number; newFollowers: number; storageUsed: string }
) {
  return baseLayout(`
    <h2 class="title">ğŸ“Š ì£¼ê°„ í™œë™ ìš”ì•½</h2>
    <p class="text">ì•ˆë…•í•˜ì„¸ìš”, <strong>${name}</strong>ë‹˜! ì´ë²ˆ ì£¼ ì´ìŒ í™œë™ì„ í™•ì¸í•˜ì„¸ìš”.</p>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin:20px 0;">
      ${[
        { label: "ğŸ“ ìƒˆ íŒŒì¼", value: stats.newFiles },
        { label: "ğŸ’¬ ìƒˆ ëŒ“ê¸€", value: stats.newComments },
        { label: "ğŸ‘¥ ìƒˆ íŒ”ë¡œì›Œ", value: stats.newFollowers },
        { label: "ğŸ’¾ ì €ì¥ ì‚¬ìš©ëŸ‰", value: stats.storageUsed },
      ].map(({ label, value }) => `
        <div style="background:#faf9ff;border:1px solid #e8e3ff;border-radius:12px;padding:16px;text-align:center;">
          <p style="font-size:13px;color:#7c3aed;font-weight:600;">${label}</p>
          <p style="font-size:22px;font-weight:900;color:#111;margin-top:4px;">${value}</p>
        </div>
      `).join("")}
    </div>
    <div style="text-align:center;">
      <a href="${BASE_URL}/dashboard" class="btn">ëŒ€ì‹œë³´ë“œ ë³´ê¸°</a>
    </div>
  `, `${name}ë‹˜ì˜ ì´ë²ˆ ì£¼ ì´ìŒ í™œë™ ìš”ì•½`);
}

// â‘¥ ê³„ì • ì •ì§€ ì•Œë¦¼
export function accountBannedTemplate(name: string, reason: string) {
  return baseLayout(`
    <h2 class="title" style="color:#dc2626;">ğŸš« ê³„ì •ì´ ì •ì§€ë˜ì—ˆìŠµë‹ˆë‹¤</h2>
    <p class="text">ì•ˆë…•í•˜ì„¸ìš”, <strong>${name}</strong>ë‹˜.<br/>
    ì´ìŒ ì´ìš© ì •ì±… ìœ„ë°˜ìœ¼ë¡œ ê³„ì •ì´ ì¼ì‹œ ì •ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.</p>
    <div class="notice" style="background:#fff5f5;border-color:#fecaca;color:#dc2626;">
      <strong>ì‚¬ìœ :</strong> ${reason}
    </div>
    <p class="text">ë¬¸ì˜ì‚¬í•­ì´ ìˆìœ¼ì‹œë©´ <a href="mailto:support@eum.app" style="color:#7c3aed;">support@eum.app</a>ìœ¼ë¡œ ì—°ë½í•´ ì£¼ì„¸ìš”.</p>
  `, "ì´ìŒ ê³„ì • ì •ì§€ ì•ˆë‚´");
}
</file>

<file path="src/lib/emit-notification.ts">
// src/lib/emit-notification.ts
import { emitToUser } from "@/lib/socket-server";
import { prisma } from "@/lib/db";

type NotificationType = "COMMENT" | "SHARE" | "CHAT" | "SYSTEM" | "FILE_UPLOAD" | "CALL";

interface CreateNotificationOptions {
  userId:  string;
  type:    NotificationType;
  title:   string;   // âš ï¸ êµ¬ "message" â†’ "title" (Notification ìŠ¤í‚¤ë§ˆ ì¼ì¹˜)
  body?:   string;
  link?:   string;
}

export async function createNotification(opts: CreateNotificationOptions) {
  const notification = await prisma.notification.create({
    data: { userId: opts.userId, type: opts.type, title: opts.title, body: opts.body ?? null, link: opts.link ?? null, isRead: false },
  }).catch(() => null);

  try {
    emitToUser(opts.userId, "notification:new", {
      id: notification?.id, type: opts.type, title: opts.title,
      body: opts.body, link: opts.link, createdAt: new Date().toISOString(), isRead: false,
    });
  } catch {}

  return notification;
}

export function broadcastChatMessage(roomId: string, message: unknown) {
  try { const { getIO } = require("@/lib/socket-server"); getIO().to(`room:${roomId}`).emit("chat:message:new", message); } catch {}
}
</file>

<file path="src/lib/image-optimizer.ts">
// src/lib/image-optimizer.ts
// sharp ê¸°ë°˜ ì´ë¯¸ì§€ ìµœì í™” íŒŒì´í”„ë¼ì¸
// npm install sharp && npm install --save-dev @types/sharp

import sharp from "sharp";
import path from "path";
import { writeFile, mkdir } from "fs/promises";
import { existsSync } from "fs";

const STORAGE_PATH = process.env.STORAGE_PATH ?? "./storage";
const OPTIMIZED_DIR = path.join(STORAGE_PATH, "optimized");
const THUMBNAIL_DIR = path.join(STORAGE_PATH, "thumbnails");

// ì§€ì› ì…ë ¥ í˜•ì‹
const IMAGE_TYPES = new Set([
  "image/jpeg", "image/jpg", "image/png",
  "image/webp", "image/gif", "image/avif", "image/tiff",
]);

export function isImage(mimeType: string): boolean {
  return IMAGE_TYPES.has(mimeType);
}

export interface OptimizeResult {
  optimizedPath: string;
  thumbnailPath: string;
  originalSize:  number;
  optimizedSize: number;
  width:         number;
  height:        number;
  format:        string;
}

interface OptimizeOptions {
  maxWidth?:    number;   // ê¸°ë³¸ 2048px
  maxHeight?:   number;   // ê¸°ë³¸ 2048px
  quality?:     number;   // WebP í’ˆì§ˆ (ê¸°ë³¸ 82)
  thumbSize?:   number;   // ì¸ë„¤ì¼ í¬ê¸° (ê¸°ë³¸ 320px)
  keepOriginal?: boolean; // ì›ë³¸ ë³´ì¡´ ì—¬ë¶€
}

export async function optimizeImage(
  inputPath: string,
  filename:  string,
  opts: OptimizeOptions = {}
): Promise<OptimizeResult> {
  const {
    maxWidth    = 2048,
    maxHeight   = 2048,
    quality     = 82,
    thumbSize   = 320,
  } = opts;

  // ë””ë ‰í† ë¦¬ ìƒì„±
  if (!existsSync(OPTIMIZED_DIR)) await mkdir(OPTIMIZED_DIR, { recursive: true });
  if (!existsSync(THUMBNAIL_DIR)) await mkdir(THUMBNAIL_DIR, { recursive: true });

  const baseName     = path.basename(filename, path.extname(filename));
  const optimizedPath = path.join(OPTIMIZED_DIR, `${baseName}.webp`);
  const thumbnailPath = path.join(THUMBNAIL_DIR, `${baseName}_thumb.webp`);

  // ì›ë³¸ ë©”íƒ€ë°ì´í„°
  const metadata = await sharp(inputPath).metadata();
  const originalSize = (await import("fs")).statSync(inputPath).size;

  // ìµœì í™” (WebP ë³€í™˜ + ë¦¬ì‚¬ì´ì¦ˆ)
  await sharp(inputPath)
    .rotate()                        // EXIF orientation ìë™ ë³´ì •
    .resize(maxWidth, maxHeight, {
      fit:           "inside",
      withoutEnlargement: true,      // ì›ë³¸ë³´ë‹¤ í¬ê²Œ í™•ëŒ€ ì•ˆ í•¨
    })
    .webp({ quality, effort: 4 })   // effort: 0(ë¹ ë¦„) ~ 6(ë†’ì€ ì••ì¶•)
    .toFile(optimizedPath);

  // ì¸ë„¤ì¼ ìƒì„±
  await sharp(inputPath)
    .rotate()
    .resize(thumbSize, thumbSize, { fit: "cover", position: "attention" })
    .webp({ quality: 75, effort: 3 })
    .toFile(thumbnailPath);

  const optimizedSize = (await import("fs")).statSync(optimizedPath).size;

  return {
    optimizedPath,
    thumbnailPath,
    originalSize,
    optimizedSize,
    width:  metadata.width  ?? 0,
    height: metadata.height ?? 0,
    format: "webp",
  };
}

/**
 * ì—…ë¡œë“œ routeì— í†µí•© ì˜ˆì‹œ:
 *
 * import { isImage, optimizeImage } from "@/lib/image-optimizer";
 *
 * if (isImage(file.type)) {
 *   const result = await optimizeImage(savedPath, file.name);
 *   // DBì— thumbnailUrl = result.thumbnailPath ì €ì¥
 *   // filepath = result.optimizedPath (WebPë¡œ êµì²´)
 *   console.log(`ì••ì¶•ë¥ : ${Math.round((1 - result.optimizedSize / result.originalSize) * 100)}%`);
 * }
 */

// â”€â”€ ë°°ì¹˜ ì¬ë³€í™˜ (ê¸°ì¡´ ì´ë¯¸ì§€ ì¼ê´„ ì²˜ë¦¬) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export async function batchOptimizeExistingImages(
  userId?: string
): Promise<{ processed: number; skipped: number; savedBytes: bigint }> {
  const { prisma } = await import("@/lib/db");

  const files = await prisma.file.findMany({
    where: {
      ...(userId ? { userId } : {}),
      mimeType: { in: [...IMAGE_TYPES] },
      deletedAt: null,
    },
    select: { id: true, filepath: true, originalName: true, mimeType: true },
    take: 100, // ë°°ì¹˜ í¬ê¸°
  });

  let processed = 0, skipped = 0;
  let savedBytes = BigInt(0);

  for (const file of files) {
    if (!existsSync(file.filepath)) { skipped++; continue; }
    try {
      const result = await optimizeImage(file.filepath, file.originalName);
      const saved  = BigInt(result.originalSize - result.optimizedSize);
      savedBytes  += saved > 0 ? saved : BigInt(0);

      await prisma.file.update({
        where: { id: file.id },
        data: {
          filepath:     result.optimizedPath,
          thumbnailUrl: result.thumbnailPath,
          size:         BigInt(result.optimizedSize),
        },
      });
      processed++;
    } catch { skipped++; }
  }

  return { processed, skipped, savedBytes };
}
</file>

<file path="src/lib/logger.ts">
// src/lib/logger.ts
// Winston ê¸°ë°˜ êµ¬ì¡°í™” ë¡œê¹… ì‹œìŠ¤í…œ
// npm install winston winston-daily-rotate-file

import winston from "winston";
import DailyRotateFile from "winston-daily-rotate-file";
import path from "path";

const LOG_DIR  = process.env.LOG_DIR  ?? "./logs";
const LOG_LEVEL = process.env.LOG_LEVEL ?? (process.env.NODE_ENV === "production" ? "info" : "debug");

// â”€â”€ ì»¤ìŠ¤í…€ í¬ë§· â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const prettyFormat = winston.format.combine(
  winston.format.timestamp({ format: "YYYY-MM-DD HH:mm:ss.SSS" }),
  winston.format.errors({ stack: true }),
  winston.format.colorize(),
  winston.format.printf(({ timestamp, level, message, stack, ...meta }) => {
    const metaStr = Object.keys(meta).length ? `\n  ${JSON.stringify(meta, null, 2)}` : "";
    return `${timestamp} [${level}] ${message}${stack ? `\n${stack}` : ""}${metaStr}`;
  })
);

const jsonFormat = winston.format.combine(
  winston.format.timestamp(),
  winston.format.errors({ stack: true }),
  winston.format.json()
);

// â”€â”€ íŠ¸ëœìŠ¤í¬íŠ¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const transports: winston.transport[] = [];

// ì½˜ì†” (ê°œë°œ í™˜ê²½)
if (process.env.NODE_ENV !== "production") {
  transports.push(new winston.transports.Console({ format: prettyFormat }));
} else {
  transports.push(new winston.transports.Console({
    format: jsonFormat,
    level: "warn",
  }));
}

// ì¼ë³„ ë¡œí…Œì´ì…˜ íŒŒì¼
transports.push(
  new DailyRotateFile({
    dirname:      path.join(LOG_DIR, "app"),
    filename:     "%DATE%.log",
    datePattern:  "YYYY-MM-DD",
    maxSize:      "20m",
    maxFiles:     "14d",  // 14ì¼ ë³´ê´€
    format:       jsonFormat,
    level:        LOG_LEVEL,
  }),
  new DailyRotateFile({
    dirname:      path.join(LOG_DIR, "errors"),
    filename:     "%DATE%-error.log",
    datePattern:  "YYYY-MM-DD",
    maxSize:      "20m",
    maxFiles:     "30d",
    format:       jsonFormat,
    level:        "error",
  })
);

// â”€â”€ ë¡œê±° ìƒì„± â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const logger = winston.createLogger({
  level:      LOG_LEVEL,
  transports,
  exceptionHandlers: [
    new DailyRotateFile({
      dirname:     path.join(LOG_DIR, "exceptions"),
      filename:    "%DATE%-exception.log",
      datePattern: "YYYY-MM-DD",
      maxFiles:    "30d",
      format:      jsonFormat,
    }),
  ],
  rejectionHandlers: [
    new DailyRotateFile({
      dirname:     path.join(LOG_DIR, "rejections"),
      filename:    "%DATE%-rejection.log",
      datePattern: "YYYY-MM-DD",
      maxFiles:    "30d",
      format:      jsonFormat,
    }),
  ],
});

export default logger;

// â”€â”€ ì»¨í…ìŠ¤íŠ¸ ë¡œê±° (ëª¨ë“ˆë³„ prefix) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function createLogger(module: string) {
  return {
    debug: (msg: string, meta?: object) => logger.debug(msg, { module, ...meta }),
    info:  (msg: string, meta?: object) => logger.info(msg,  { module, ...meta }),
    warn:  (msg: string, meta?: object) => logger.warn(msg,  { module, ...meta }),
    error: (msg: string, meta?: object) => logger.error(msg, { module, ...meta }),
  };
}

// â”€â”€ ì‚¬ìš© ì˜ˆì‹œ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// import { createLogger } from "@/lib/logger";
// const log = createLogger("FileUpload");
// log.info("íŒŒì¼ ì—…ë¡œë“œ ì‹œì‘", { userId, filename, size });
// log.error("ì—…ë¡œë“œ ì‹¤íŒ¨", { error: err.message, stack: err.stack });
</file>

<file path="src/lib/notification-prefs.ts">
// src/lib/notification-prefs.ts
// NotificationPreferences íƒ€ì…ê³¼ ê¸°ë³¸ê°’ì„ route íŒŒì¼ ë°–ìœ¼ë¡œ ë¶„ë¦¬
// route.tsì—ì„œ export const/interfaceë¥¼ ì‚¬ìš©í•˜ë©´ Next.js ë¹Œë“œ ì˜¤ë¥˜ ë°œìƒ

export interface NotificationPreferences {
  pushEnabled: boolean;
  comment:     boolean;
  share:       boolean;
  chat:        boolean;
  call:        boolean;
  system:      boolean;
  fileUpload:  boolean;
  emailDigest: boolean;
}

export const DEFAULT_PREFS: NotificationPreferences = {
  pushEnabled: true,
  comment:     true,
  share:       true,
  chat:        true,
  call:        true,
  system:      true,
  fileUpload:  false,
  emailDigest: false,
};
</file>

<file path="src/lib/notification.ts">
// src/lib/notification.ts
// ë‹¤ë¥¸ API routeì—ì„œ importí•´ì„œ ì‚¬ìš©í•˜ì„¸ìš”.
// ì˜ˆ: ëŒ“ê¸€ ì‘ì„± â†’ createNotification({ userId: post.authorId, type: "COMMENT", ... })

import { prisma } from "@/lib/db";

type NotificationType =
  | "COMMENT"
  | "SHARE"
  | "CHAT"
  | "SYSTEM"
  | "FILE_UPLOAD"
  | "CALL";

interface CreateNotificationInput {
  userId: string;      // ìˆ˜ì‹ ì
  type: NotificationType;
  title: string;
  body?: string;
  link?: string;       // í´ë¦­ ì‹œ ì´ë™í•  URL (ì˜ˆ: "/posts/abc123")
}

export async function createNotification(input: CreateNotificationInput) {
  try {
    return await prisma.notification.create({
      data: {
        userId: input.userId,
        type: input.type,
        title: input.title,
        body: input.body,
        link: input.link,
      },
    });
  } catch (error) {
    // ì•Œë¦¼ ìƒì„± ì‹¤íŒ¨ëŠ” ì¡°ìš©íˆ ì²˜ë¦¬ (ì£¼ìš” ê¸°ëŠ¥ì— ì˜í–¥ ì—†ì–´ì•¼ í•¨)
    console.error("createNotification error:", error);
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ì‚¬ìš© ì˜ˆì‹œ
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//
// [ëŒ“ê¸€ ì•Œë¦¼] src/app/api/posts/[id]/comments/route.ts
// await createNotification({
//   userId: post.userId,
//   type: "COMMENT",
//   title: `${commenterName}ë‹˜ì´ ëŒ“ê¸€ì„ ë‚¨ê²¼ìŠµë‹ˆë‹¤`,
//   body: comment.content.slice(0, 80),
//   link: `/posts/${post.id}`,
// });
//
// [ê³µìœ  ì•Œë¦¼] src/app/api/files/[id]/share/route.ts
// await createNotification({
//   userId: targetUserId,
//   type: "SHARE",
//   title: `${ownerName}ë‹˜ì´ íŒŒì¼ì„ ê³µìœ í–ˆìŠµë‹ˆë‹¤`,
//   body: file.originalName,
//   link: `/dashboard`,
// });
//
// [ì±„íŒ… ì•Œë¦¼] src/app/api/chat/rooms/[id]/messages ë“±
// await createNotification({
//   userId: recipientId,
//   type: "CHAT",
//   title: `${senderName}ë‹˜ì˜ ìƒˆ ë©”ì‹œì§€`,
//   body: message.content?.slice(0, 80),
//   link: `/chat/${chatRoomId}`,
// });
</file>

<file path="src/lib/optimized-queries.ts">
// src/lib/optimized-queries.ts
import { prisma } from "@/lib/db";
import { withCache, TTL } from "@/lib/cache";

export async function getFileList(userId: string, folderId: string | null = null, page = 1, limit = 20) {
  const [files, total] = await Promise.all([
    prisma.file.findMany({
      where: { userId, folderId, deletedAt: null },
      select: { id: true, originalName: true, mimeType: true, size: true, thumbnailUrl: true, createdAt: true, isEncrypted: true, publicToken: true, isStarred: true, isPinned: true, _count: { select: { fileTags: true } } },
      orderBy: { createdAt: "desc" },
      skip: (page - 1) * limit, take: limit,
    }),
    prisma.file.count({ where: { userId, folderId, deletedAt: null } }),
  ]);
  return { files, total, hasMore: page * limit < total };
}

export async function getPinnedFiles(userId: string) {
  return prisma.file.findMany({
    where: { userId, isPinned: true, deletedAt: null },
    select: { id: true, originalName: true, mimeType: true, size: true, thumbnailUrl: true },
    orderBy: { updatedAt: "desc" }, take: 10,
  });
}

export async function getPostList(viewerId: string, page = 1, limit = 20) {
  const [posts, total] = await Promise.all([
    prisma.post.findMany({
      where: { visibility: { in: ["PUBLIC", "SHARED"] } },
      select: {
        id: true, title: true, content: true, createdAt: true,
        user: { select: { id: true, name: true } },
        _count: { select: { comments: true, likes: true } },
        likes:     { where: { userId: viewerId }, select: { id: true } },
        bookmarks: { where: { userId: viewerId }, select: { id: true } },
      },
      orderBy: { createdAt: "desc" }, skip: (page - 1) * limit, take: limit,
    }),
    prisma.post.count({ where: { visibility: { in: ["PUBLIC", "SHARED"] } } }),
  ]);
  return {
    posts: posts.map((p) => ({ ...p, liked: p.likes.length > 0, bookmarked: p.bookmarks.length > 0, likes: undefined, bookmarks: undefined })),
    total, hasMore: page * limit < total,
  };
}

// âš ï¸ Notification ìŠ¤í‚¤ë§ˆ: title/body (message í•„ë“œ ì—†ìŒ)
export async function getNotifications(userId: string, limit = 20) {
  return withCache(`notifications:${userId}:${limit}`,
    () => prisma.notification.findMany({
      where: { userId }, orderBy: { createdAt: "desc" }, take: limit,
      select: { id: true, type: true, title: true, body: true, link: true, isRead: true, createdAt: true },
    }),
    TTL.SHORT, [`user:${userId}:notifications`]
  );
}

export async function globalSearch(userId: string, q: string, limit = 30) {
  if (!q.trim()) return { files: [], posts: [], users: [] };
  const chunk = Math.floor(limit / 3);
  const [files, posts, users] = await Promise.all([
    prisma.file.findMany({ where: { userId, deletedAt: null, originalName: { contains: q, mode: "insensitive" } }, select: { id: true, originalName: true, mimeType: true, size: true, thumbnailUrl: true }, take: chunk }),
    prisma.post.findMany({ where: { visibility: { in: ["PUBLIC", "SHARED"] }, OR: [{ title: { contains: q, mode: "insensitive" } }, { content: { contains: q, mode: "insensitive" } }] }, select: { id: true, title: true, content: true, user: { select: { id: true, name: true } } }, take: chunk }),
    prisma.user.findMany({ where: { id: { not: userId }, name: { contains: q, mode: "insensitive" } }, select: { id: true, name: true, isOnline: true }, take: chunk }),
  ]);
  return { files, posts, users };
}

export async function getAdminStats() {
  return withCache("admin:stats:summary", async () => {
    const [totalUsers, totalFiles, storage] = await Promise.all([
      prisma.user.count(),
      prisma.file.count({ where: { deletedAt: null } }),
      prisma.file.aggregate({ _sum: { size: true }, where: { deletedAt: null } }),
    ]);
    return { totalUsers, totalFiles, totalStorage: storage._sum.size?.toString() ?? "0" };
  }, TTL.LONG, ["admin-stats"]);
}
</file>

<file path="src/lib/request-logger.ts">
// src/lib/request-logger.ts
// API route ìš”ì²­/ì‘ë‹µ ë¡œê¹… + ìŠ¬ë¡œìš° ì¿¼ë¦¬ ê°ì§€ ë¯¸ë“¤ì›¨ì–´

import { NextRequest, NextResponse } from "next/server";
import logger from "@/lib/logger";

const SLOW_THRESHOLD_MS = 1000; // 1ì´ˆ ì´ìƒì€ ê²½ê³ 

interface RequestLogMeta {
  method:     string;
  url:        string;
  status:     number;
  durationMs: number;
  userId?:    string;
  ip?:        string;
  userAgent?: string;
}

/**
 * API Route í•¸ë“¤ëŸ¬ë¥¼ ê°ì‹¸ëŠ” ë¡œê¹… ë˜í¼
 *
 * ì‚¬ìš©ë²•:
 * export const GET = withRequestLog(async (req) => {
 *   ...
 *   return NextResponse.json({ ... });
 * });
 */
export function withRequestLog<T extends unknown[]>(
  handler: (req: NextRequest, ...args: T) => Promise<NextResponse>
) {
  return async (req: NextRequest, ...args: T): Promise<NextResponse> => {
    const start  = Date.now();
    const method = req.method;
    const url    = req.nextUrl.pathname + req.nextUrl.search;
    const ip     = req.headers.get("x-forwarded-for") ?? req.headers.get("x-real-ip") ?? "unknown";
    const ua     = req.headers.get("user-agent") ?? "";

    let response: NextResponse;
    let status = 500;

    try {
      response = await handler(req, ...args);
      status   = response.status;
    } catch (err: any) {
      const durationMs = Date.now() - start;
      logger.error("API í•¸ë“¤ëŸ¬ ì˜ˆì™¸", {
        method, url, durationMs, ip,
        error: err?.message,
        stack: err?.stack,
      });
      // í‘œì¤€ ì—ëŸ¬ ì‘ë‹µ ë°˜í™˜
      return NextResponse.json(
        { success: false, error: "ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤", code: "INTERNAL_ERROR" },
        { status: 500 }
      );
    }

    const durationMs = Date.now() - start;
    const meta: RequestLogMeta = { method, url, status, durationMs, ip, userAgent: ua };

    if (durationMs >= SLOW_THRESHOLD_MS) {
      logger.warn(`ğŸ¢ ìŠ¬ë¡œìš° ì‘ë‹µ [${durationMs}ms]`, meta);
    } else if (status >= 500) {
      logger.error(`âŒ ì„œë²„ ì—ëŸ¬ [${status}]`, meta);
    } else if (status >= 400) {
      logger.warn(`âš ï¸  í´ë¼ì´ì–¸íŠ¸ ì—ëŸ¬ [${status}]`, meta);
    } else {
      logger.debug(`âœ… ${method} ${url} [${status}] ${durationMs}ms`, meta);
    }

    return response;
  };
}

/**
 * ìŠ¬ë¡œìš° DB ì¿¼ë¦¬ ê°ì§€ìš© Prisma ë¯¸ë“¤ì›¨ì–´
 * prisma/client.ts ë˜ëŠ” src/lib/db.tsì— ì¶”ê°€
 *
 * prisma.$use(async (params, next) => {
 *   const before = Date.now();
 *   const result = await next(params);
 *   const after  = Date.now();
 *   const ms     = after - before;
 *   if (ms > 500) {
 *     logger.warn("ğŸ¢ ìŠ¬ë¡œìš° DB ì¿¼ë¦¬", {
 *       model:  params.model,
 *       action: params.action,
 *       ms,
 *     });
 *   }
 *   return result;
 * });
 */
</file>

<file path="src/lib/socket-client.ts">
// src/lib/socket-client.ts
// í´ë¼ì´ì–¸íŠ¸ ì‚¬ì´ë“œ ì†Œì¼“ ì‹±ê¸€í„´ + React í›…

import { useEffect, useRef, useState, useCallback } from "react";
import { io, type Socket } from "socket.io-client";
import { useSession } from "next-auth/react";

// â”€â”€ ì‹±ê¸€í„´ ì†Œì¼“ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _socket: Socket | null = null;

export function getSocket(): Socket {
  if (!_socket) {
    _socket = io({ path: "/api/socket", transports: ["websocket", "polling"], autoConnect: false });
  }
  return _socket;
}

// â”€â”€ ì „ì—­ ì†Œì¼“ ì—°ê²° í›… (providersì—ì„œ í•œ ë²ˆë§Œ ì‚¬ìš©) â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function useSocketConnection() {
  const { data: session, status } = useSession();
  const [connected, setConnected] = useState(false);

  useEffect(() => {
    if (status !== "authenticated") return;
    const socket = getSocket();

    if (!socket.connected) socket.connect();

    const onConnect    = () => setConnected(true);
    const onDisconnect = () => setConnected(false);

    socket.on("connect",    onConnect);
    socket.on("disconnect", onDisconnect);
    if (socket.connected) setConnected(true);

    return () => {
      socket.off("connect",    onConnect);
      socket.off("disconnect", onDisconnect);
    };
  }, [status]);

  return connected;
}

// â”€â”€ ì‹¤ì‹œê°„ ì•Œë¦¼ í›… â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function useSocketNotifications(
  onNew: (n: { type: string; message: string; createdAt: string }) => void
) {
  useEffect(() => {
    const socket = getSocket();
    socket.on("notification:new", onNew);
    return () => { socket.off("notification:new", onNew); };
  }, [onNew]);
}

// â”€â”€ ì±„íŒ… íƒ€ì´í•‘ ì¸ë””ì¼€ì´í„° í›… â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
interface TypingState {
  [userId: string]: boolean;
}
export function useTypingIndicator(roomId: string | null) {
  const [typingUsers, setTypingUsers] = useState<TypingState>({});
  const typingTimer = useRef<Record<string, NodeJS.Timeout>>({});

  useEffect(() => {
    if (!roomId) return;
    const socket = getSocket();
    socket.emit("chat:join", roomId);

    const handler = ({ userId, isTyping }: { userId: string; roomId: string; isTyping: boolean }) => {
      setTypingUsers((prev) => ({ ...prev, [userId]: isTyping }));
      // 5ì´ˆ í›„ ìë™ìœ¼ë¡œ íƒ€ì´í•‘ í•´ì œ
      if (isTyping) {
        clearTimeout(typingTimer.current[userId]);
        typingTimer.current[userId] = setTimeout(() => {
          setTypingUsers((prev) => ({ ...prev, [userId]: false }));
        }, 5000);
      }
    };

    socket.on("chat:typing:update", handler);
    return () => {
      socket.emit("chat:leave", roomId);
      socket.off("chat:typing:update", handler);
    };
  }, [roomId]);

  const startTyping = useCallback(() => {
    if (!roomId) return;
    getSocket().emit("chat:typing:start", { roomId });
  }, [roomId]);

  const stopTyping = useCallback(() => {
    if (!roomId) return;
    getSocket().emit("chat:typing:stop", { roomId });
  }, [roomId]);

  const typingUserIds = Object.entries(typingUsers)
    .filter(([, v]) => v)
    .map(([k]) => k);

  return { typingUserIds, startTyping, stopTyping };
}

// â”€â”€ ì—…ë¡œë“œ ì§„í–‰ë¥  í›… â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
interface UploadProgress {
  fileId: string;
  filename: string;
  progress: number;
}
export function useUploadProgress() {
  const [uploads, setUploads] = useState<Record<string, UploadProgress>>({});

  useEffect(() => {
    const socket = getSocket();
    const onProgress = ({ fileId, filename, progress }: UploadProgress) => {
      setUploads((prev) => ({ ...prev, [fileId]: { fileId, filename, progress } }));
    };
    const onDone = ({ fileId }: { fileId: string }) => {
      setUploads((prev) => {
        const next = { ...prev };
        delete next[fileId];
        return next;
      });
    };
    socket.on("upload:progress:update", onProgress);
    socket.on("upload:done:update",     onDone);
    return () => {
      socket.off("upload:progress:update", onProgress);
      socket.off("upload:done:update",     onDone);
    };
  }, []);

  const broadcastProgress = useCallback((fileId: string, filename: string, progress: number) => {
    getSocket().emit("upload:progress", { fileId, progress, filename });
    if (progress >= 100) getSocket().emit("upload:done", { fileId, filename });
  }, []);

  return { uploads: Object.values(uploads), broadcastProgress };
}

// â”€â”€ í”„ë ˆì¦ŒìŠ¤ í›… â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function usePresence(userIds: string[]) {
  const [onlineUsers, setOnlineUsers] = useState<Set<string>>(new Set());

  useEffect(() => {
    const socket = getSocket();
    const handler = ({ userId, isOnline }: { userId: string; isOnline: boolean }) => {
      setOnlineUsers((prev) => {
        const next = new Set(prev);
        isOnline ? next.add(userId) : next.delete(userId);
        return next;
      });
    };
    socket.on("presence:update", handler);
    return () => { socket.off("presence:update", handler); };
  }, []);

  return { isOnline: (userId: string) => onlineUsers.has(userId) };
}
</file>

<file path="src/lib/sound.ts">
// src/lib/sound.ts
// Web Audio API ê¸°ë°˜ ì•Œë¦¼ ì‚¬ìš´ë“œ â€” ì™¸ë¶€ íŒŒì¼ ë¶ˆí•„ìš”
// ë¸Œë¼ìš°ì € ë‚´ì—ì„œ ì§ì ‘ ì†Œë¦¬ í•©ì„±

type SoundType = "message" | "notification" | "success" | "error" | "call";

let ctx: AudioContext | null = null;

function getCtx(): AudioContext {
  if (!ctx || ctx.state === "closed") {
    ctx = new (window.AudioContext || (window as any).webkitAudioContext)();
  }
  if (ctx.state === "suspended") ctx.resume();
  return ctx;
}

function playTone(
  frequency: number,
  duration: number,
  type: OscillatorType = "sine",
  volume = 0.3,
  delay = 0
): void {
  const ac  = getCtx();
  const osc = ac.createOscillator();
  const gain = ac.createGain();

  osc.connect(gain);
  gain.connect(ac.destination);

  osc.type = type;
  osc.frequency.setValueAtTime(frequency, ac.currentTime + delay);

  gain.gain.setValueAtTime(0, ac.currentTime + delay);
  gain.gain.linearRampToValueAtTime(volume, ac.currentTime + delay + 0.01);
  gain.gain.exponentialRampToValueAtTime(0.001, ac.currentTime + delay + duration);

  osc.start(ac.currentTime + delay);
  osc.stop(ac.currentTime + delay + duration + 0.01);
}

const SOUNDS: Record<SoundType, () => void> = {
  // ì±„íŒ… ë©”ì‹œì§€: ë§‘ì€ ë‘ ìŒ
  message: () => {
    playTone(880, 0.08, "sine", 0.2);
    playTone(1200, 0.1, "sine", 0.15, 0.09);
  },
  // ì•Œë¦¼: ë¶€ë“œëŸ¬ìš´ í•‘
  notification: () => {
    playTone(660, 0.15, "sine", 0.25);
    playTone(880, 0.12, "sine", 0.2, 0.1);
  },
  // ì„±ê³µ: ìƒìŠ¹ 3ìŒ
  success: () => {
    playTone(523, 0.1, "sine", 0.2);
    playTone(659, 0.1, "sine", 0.2, 0.1);
    playTone(784, 0.15, "sine", 0.2, 0.2);
  },
  // ì—ëŸ¬: ë‚®ì€ ë‘ ìŒ
  error: () => {
    playTone(220, 0.15, "sawtooth", 0.15);
    playTone(180, 0.2, "sawtooth", 0.12, 0.12);
  },
  // í†µí™” ìˆ˜ì‹ : ë°˜ë³µ ë§ (3íšŒ)
  call: () => {
    [0, 0.6, 1.2].forEach((delay) => {
      playTone(480, 0.3, "sine", 0.3, delay);
      playTone(380, 0.3, "sine", 0.25, delay + 0.02);
    });
  },
};

// â”€â”€ ì„¤ì • â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const PREF_KEY = "eum_sound_enabled";

export function isSoundEnabled(): boolean {
  try { return localStorage.getItem(PREF_KEY) !== "false"; } catch { return true; }
}
export function setSoundEnabled(on: boolean) {
  try { localStorage.setItem(PREF_KEY, on ? "true" : "false"); } catch {}
}

// â”€â”€ ê³µê°œ API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function playSound(type: SoundType) {
  if (typeof window === "undefined") return;
  if (!isSoundEnabled()) return;
  try { SOUNDS[type]?.(); } catch {}
}

export const sound = {
  message:      () => playSound("message"),
  notification: () => playSound("notification"),
  success:      () => playSound("success"),
  error:        () => playSound("error"),
  call:         () => playSound("call"),
};
</file>

<file path="src/lib/storage-guard.ts">
// src/lib/storage-guard.ts
// íŒŒì¼ ì—…ë¡œë“œ ì „ ìš©ëŸ‰ ì œí•œ í™•ì¸ ìœ í‹¸ë¦¬í‹°
// upload routeì—ì„œ í˜¸ì¶œí•´ ì‚¬ìš©

import { prisma } from "@/lib/db";

const DEFAULT_LIMIT = BigInt(5 * 1024 * 1024 * 1024); // 5GB

export async function checkStorageQuota(
  userId: string,
  newFileSize: number
): Promise<{ allowed: boolean; used: bigint; limit: bigint; remaining: bigint }> {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { storageUsed: true, storageLimit: true },
  });

  const used  = user?.storageUsed  ?? BigInt(0);
  const limit = user?.storageLimit ?? DEFAULT_LIMIT;
  const remaining = limit - used;

  return {
    allowed: remaining >= BigInt(newFileSize),
    used, limit, remaining,
  };
}

/** íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ í›„ ì‚¬ìš©ëŸ‰ ì¦ê°€ */
export async function incrementStorage(userId: string, bytes: number) {
  await prisma.user.update({
    where: { id: userId },
    data: { storageUsed: { increment: BigInt(bytes) } },
  });
}

/** íŒŒì¼ ì‚­ì œ í›„ ì‚¬ìš©ëŸ‰ ê°ì†Œ */
export async function decrementStorage(userId: string, bytes: bigint | number) {
  await prisma.user.update({
    where: { id: userId },
    data: { storageUsed: { decrement: BigInt(bytes) } },
  }).catch(() => {}); // ìŒìˆ˜ ë°©ì§€ë¥¼ ìœ„í•´ ì—ëŸ¬ ë¬´ì‹œ
}
</file>

<file path="src/lib/validators.ts">
// src/lib/validators.ts
// Zod ê¸°ë°˜ API ì…ë ¥ê°’ ìŠ¤í‚¤ë§ˆ ì •ì˜
// npm install zod

import { z } from "zod";
import { NextRequest } from "next/server";
import { ApiError } from "@/lib/api-response";
import type { NextResponse } from "next/server";

// â”€â”€ ê³µí†µ ìŠ¤í‚¤ë§ˆ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export const paginationSchema = z.object({
  page:  z.coerce.number().int().min(1).default(1),
  limit: z.coerce.number().int().min(1).max(100).default(20),
});

export const idSchema = z.string().cuid({ message: "ìœ íš¨í•˜ì§€ ì•Šì€ IDì…ë‹ˆë‹¤" });

// â”€â”€ ì¸ì¦ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export const registerSchema = z.object({
  name:     z.string().min(2, "ì´ë¦„ì€ 2ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤").max(50),
  email:    z.string().email("ì˜¬ë°”ë¥¸ ì´ë©”ì¼ í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤"),
  password: z.string()
    .min(8,  "ë¹„ë°€ë²ˆí˜¸ëŠ” 8ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤")
    .max(100)
    .regex(/[A-Z]/,  "ëŒ€ë¬¸ìë¥¼ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤")
    .regex(/[0-9]/,  "ìˆ«ìë¥¼ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤")
    .regex(/[^A-Za-z0-9]/, "íŠ¹ìˆ˜ë¬¸ìë¥¼ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤"),
});

export const loginSchema = z.object({
  email:    z.string().email(),
  password: z.string().min(1),
});

export const changePasswordSchema = z.object({
  currentPassword: z.string().min(1, "í˜„ì¬ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”"),
  newPassword:     z.string().min(8, "ìƒˆ ë¹„ë°€ë²ˆí˜¸ëŠ” 8ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤"),
}).refine((d) => d.currentPassword !== d.newPassword, {
  message: "ìƒˆ ë¹„ë°€ë²ˆí˜¸ëŠ” í˜„ì¬ ë¹„ë°€ë²ˆí˜¸ì™€ ë‹¬ë¼ì•¼ í•©ë‹ˆë‹¤",
  path:    ["newPassword"],
});

// â”€â”€ íŒŒì¼ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export const fileUploadSchema = z.object({
  folderId: z.string().cuid().optional().nullable(),
});

export const fileEncryptSchema = z.object({
  password: z.string().min(4, "ë¹„ë°€ë²ˆí˜¸ëŠ” 4ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤").max(100),
});

export const fileVersionSchema = z.object({
  comment: z.string().max(200).optional(),
});

// â”€â”€ ê²Œì‹œê¸€ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export const createPostSchema = z.object({
  title:      z.string().min(1, "ì œëª©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”").max(200),
  content:    z.string().min(1, "ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”").max(50_000),
  visibility: z.enum(["PUBLIC", "PRIVATE", "SHARED"]).default("PUBLIC"),
  tags:       z.array(z.string().max(30)).max(10).optional(),
});

export const createCommentSchema = z.object({
  content:    z.string().min(1, "ëŒ“ê¸€ì„ ì…ë ¥í•´ì£¼ì„¸ìš”").max(2000),
  mentionIds: z.array(z.string().cuid()).max(20).optional(),
});

// â”€â”€ ì±„íŒ… â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export const createRoomSchema = z.object({
  name:        z.string().min(1).max(100).optional(),
  memberIds:   z.array(z.string().cuid()).min(1).max(50),
  type:        z.enum(["DIRECT", "GROUP"]).default("DIRECT"),
});

export const sendMessageSchema = z.object({
  type:     z.enum(["TEXT", "FILE", "SYSTEM"]).default("TEXT"),
  content:  z.string().max(10_000).optional(),
  fileId:   z.string().cuid().optional(),
}).refine((d) => d.content || d.fileId, {
  message: "ë©”ì‹œì§€ ë‚´ìš© ë˜ëŠ” íŒŒì¼ì´ í•„ìš”í•©ë‹ˆë‹¤",
});

// â”€â”€ ì•Œë¦¼ ì„¤ì • â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export const notificationSettingsSchema = z.object({
  emailNotifications:  z.boolean().optional(),
  pushNotifications:   z.boolean().optional(),
  chatNotifications:   z.boolean().optional(),
  mentionNotifications: z.boolean().optional(),
});

// â”€â”€ API í‚¤ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export const createApiKeySchema = z.object({
  name:           z.string().min(1, "ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”").max(100),
  scopes:         z.array(z.string()).min(1, "ê¶Œí•œì„ í•˜ë‚˜ ì´ìƒ ì„ íƒí•´ì£¼ì„¸ìš”"),
  expiresInDays:  z.number().int().min(0).max(365).optional(),
});

// â”€â”€ ì‹œìŠ¤í…œ ê³µì§€ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export const createNoticeSchema = z.object({
  title:    z.string().min(1).max(200),
  content:  z.string().min(1).max(5000),
  type:     z.enum(["INFO", "WARNING", "MAINTENANCE"]).default("INFO"),
  startsAt: z.string().datetime().optional(),
  endsAt:   z.string().datetime().optional(),
});

// â”€â”€ ìœ íš¨ì„± ê²€ì‚¬ í—¬í¼ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/**
 * request bodyë¥¼ íŒŒì‹±í•˜ê³  Zod ìŠ¤í‚¤ë§ˆë¡œ ê²€ì¦
 * ì‹¤íŒ¨ ì‹œ 422 ì‘ë‹µ ë°˜í™˜ (NextResponse)
 */
export async function parseBody<T>(
  request:  NextRequest,
  schema:   z.ZodSchema<T>
): Promise<{ data: T; error: null } | { data: null; error: NextResponse }> {
  let raw: unknown;
  try {
    raw = await request.json();
  } catch {
    return { data: null, error: ApiError.validation("ìš”ì²­ ë³¸ë¬¸ì´ ìœ íš¨í•œ JSONì´ ì•„ë‹™ë‹ˆë‹¤") };
  }

  const result = schema.safeParse(raw);
  if (!result.success) {
    const details = result.error.errors.map((e) => ({
      field:   e.path.join("."),
      message: e.message,
    }));
    return {
      data:  null,
      error: ApiError.validation(details[0]?.message ?? "ì…ë ¥ê°’ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤", details),
    };
  }

  return { data: result.data, error: null };
}

/**
 * URL ì¿¼ë¦¬ íŒŒë¼ë¯¸í„° ê²€ì¦
 */
export function parseQuery<T>(
  request: NextRequest,
  schema:  z.ZodSchema<T>
): { data: T; error: null } | { data: null; error: NextResponse } {
  const params = Object.fromEntries(new URL(request.url).searchParams);
  const result = schema.safeParse(params);
  if (!result.success) {
    const details = result.error.errors.map((e) => ({
      field:   e.path.join("."),
      message: e.message,
    }));
    return { data: null, error: ApiError.validation("ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤", details) };
  }
  return { data: result.data, error: null };
}
</file>

<file path="src/middleware.ts">
// src/middleware.ts (ë˜ëŠ” ë£¨íŠ¸ì˜ middleware.ts)
// ë¡œê·¸ì¸ì´ í•„ìš”í•œ ëª¨ë“  í˜ì´ì§€ë¥¼ ì¼ê´„ ë³´í˜¸
// NextAuth JWT ê¸°ë°˜ â€” ë³„ë„ DB ì¡°íšŒ ì—†ì´ ì—£ì§€ì—ì„œ ì²˜ë¦¬

import { getToken } from "next-auth/jwt";
import { NextRequest, NextResponse } from "next/server";

// â”€â”€ ë³´í˜¸ê°€ í•„ìš”í•œ ê²½ë¡œ íŒ¨í„´ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const PROTECTED_PATHS = [
  "/dashboard",
  "/chat",
  "/files",
  "/profile",
  "/settings",
  "/notifications",
  "/trash",
  "/search",
  "/posts",
  "/users",
  "/admin",
  "/shared",
];

// â”€â”€ ê´€ë¦¬ì ì „ìš© ê²½ë¡œ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const ADMIN_PATHS = ["/admin"];

// â”€â”€ ê³µê°œ ê²½ë¡œ (ë¡œê·¸ì¸ ìƒíƒœì—ì„œ ì ‘ê·¼ ì‹œ ëŒ€ì‹œë³´ë“œ ë¦¬ë””ë ‰ì…˜) â”€
const PUBLIC_ONLY_PATHS = ["/login", "/register"];

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;

  // ì •ì  íŒŒì¼, API ì¸ì¦ ì—”ë“œí¬ì¸íŠ¸ëŠ” ìŠ¤í‚µ
  if (
    pathname.startsWith("/_next") ||
    pathname.startsWith("/api/auth") ||
    pathname.startsWith("/api/share") ||   // ê³µê°œ íŒŒì¼ ê³µìœ 
    pathname.startsWith("/share") ||
    pathname.startsWith("/offline") ||
    pathname === "/" ||
    pathname === "/favicon.ico"
  ) {
    return NextResponse.next();
  }

  const token = await getToken({
    req: request,
    secret: process.env.NEXTAUTH_SECRET,
  });

  const isAuthenticated = !!token;
  const isAdmin = token?.role === "ADMIN";

  // â”€â”€ ë¡œê·¸ì¸ ìƒíƒœì—ì„œ ê³µê°œ ì „ìš© í˜ì´ì§€ ì ‘ê·¼ â†’ ëŒ€ì‹œë³´ë“œë¡œ â”€
  if (isAuthenticated && PUBLIC_ONLY_PATHS.some((p) => pathname.startsWith(p))) {
    return NextResponse.redirect(new URL("/dashboard", request.url));
  }

  // â”€â”€ ë³´í˜¸ëœ í˜ì´ì§€ ì ‘ê·¼ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const isProtected = PROTECTED_PATHS.some((p) => pathname.startsWith(p));
  if (isProtected && !isAuthenticated) {
    const loginUrl = new URL("/login", request.url);
    loginUrl.searchParams.set("callbackUrl", pathname);
    return NextResponse.redirect(loginUrl);
  }

  // â”€â”€ ê´€ë¦¬ì í˜ì´ì§€ ì ‘ê·¼ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const isAdminPath = ADMIN_PATHS.some((p) => pathname.startsWith(p));
  if (isAdminPath && !isAdmin) {
    return NextResponse.redirect(new URL("/dashboard?error=unauthorized", request.url));
  }

  // â”€â”€ ì •ì§€ëœ ì‚¬ìš©ì ì°¨ë‹¨ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // tokenì— isBanned ì»¤ìŠ¤í…€ í´ë ˆì„ì„ í¬í•¨ì‹œì¼œì•¼ í•¨ (authOptionsì˜ jwt callbackì—ì„œ ì²˜ë¦¬)
  if (token?.isBanned && isProtected) {
    const bannedUrl = new URL("/banned", request.url);
    return NextResponse.redirect(bannedUrl);
  }

  return NextResponse.next();
}

export const config = {
  matcher: [
    /*
     * ë‹¤ìŒ ê²½ë¡œë¥¼ ì œì™¸í•œ ëª¨ë“  ìš”ì²­ì— ì ìš©:
     * - api/auth (NextAuth ìì²´ ë¼ìš°íŠ¸)
     * - _next/static, _next/image (ì •ì  íŒŒì¼)
     * - favicon.ico
     */
    "/((?!api/auth|_next/static|_next/image|favicon.ico).*)",
  ],
};
</file>

<file path="src/types/next-auth.d.ts">
// src/types/next-auth.d.ts
import { DefaultSession } from "next-auth";

declare module "next-auth" {
  interface Session {
    user: {
      id:       string;
      role:     string;
      isBanned: boolean;
    } & DefaultSession["user"];
  }

  interface User {
    id:       string;
    email:    string;
    name:     string;
    role:     string;
    isBanned: boolean;
  }
}

declare module "next-auth/jwt" {
  interface JWT {
    id:       string;
    role:     string;
    isBanned: boolean;
  }
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/app/api/auth/[...nextauth]/route": ["./src/lib/auth"],
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules", "e2e"]
}
</file>

<file path="src/app/api/admin/stats/route.ts">
// src/app/api/admin/stats/route.ts
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function GET() {
  const session = await getServerSession(authOptions);
  if (!session?.user || session.user.role !== "ADMIN")
    return NextResponse.json({ error: "ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 403 });

  const thirtyDaysAgo = new Date(Date.now() - 30 * 86400000);

  const [
    totalUsers, activeUsers, bannedUsers,
    totalFiles, totalStorage,
    totalPosts, totalComments,
    newUsersLast30, newFilesLast30,
    storageByUser, filesByType, dailySignups, dailyUploads,
  ] = await Promise.all([
    prisma.user.count(),
    prisma.user.count({ where: { isOnline: true } }),
    prisma.user.count({ where: { isBanned: true } }),
    prisma.file.count({ where: { deletedAt: null } }),
    prisma.file.aggregate({ _sum: { size: true }, where: { deletedAt: null } }),
    prisma.post.count(),
    prisma.comment.count(),
    prisma.user.count({ where: { createdAt: { gte: thirtyDaysAgo } } }),
    prisma.file.count({ where: { createdAt: { gte: thirtyDaysAgo }, deletedAt: null } }),
    prisma.file.groupBy({ by: ["userId"], _sum: { size: true }, orderBy: { _sum: { size: "desc" } }, take: 10 }),
    prisma.$queryRaw<{ type: string; count: bigint; size: bigint }[]>`
      SELECT CASE WHEN "mime_type" LIKE 'image/%' THEN 'ì´ë¯¸ì§€' WHEN "mime_type" LIKE 'video/%' THEN 'ì˜ìƒ' WHEN "mime_type" LIKE 'audio/%' THEN 'ì˜¤ë””ì˜¤' WHEN "mime_type" = 'application/pdf' THEN 'PDF' ELSE 'ê¸°íƒ€' END AS type, COUNT(*) AS count, SUM(size) AS size FROM files WHERE deleted_at IS NULL GROUP BY type ORDER BY count DESC`,
    prisma.$queryRaw<{ date: string; count: bigint }[]>`SELECT DATE("created_at") AS date, COUNT(*) AS count FROM users WHERE "created_at" >= NOW() - INTERVAL '14 days' GROUP BY DATE("created_at") ORDER BY date`,
    prisma.$queryRaw<{ date: string; count: bigint }[]>`SELECT DATE("created_at") AS date, COUNT(*) AS count FROM files WHERE "created_at" >= NOW() - INTERVAL '14 days' AND "deleted_at" IS NULL GROUP BY DATE("created_at") ORDER BY date`,
  ]);

  const userIds = storageByUser.map((x) => x.userId);
  const users = await prisma.user.findMany({ where: { id: { in: userIds } }, select: { id: true, name: true, email: true } });
  const userMap = Object.fromEntries(users.map((u) => [u.id, u]));

  return NextResponse.json({
    summary: { totalUsers, activeUsers, bannedUsers, totalFiles, totalStorage: totalStorage._sum.size?.toString() ?? "0", totalPosts, totalComments, newUsersLast30, newFilesLast30 },
    topStorageUsers: storageByUser.map((x) => ({ ...userMap[x.userId], storageUsed: x._sum.size?.toString() ?? "0" })),
    filesByType: filesByType.map((x) => ({ type: x.type, count: Number(x.count), size: x.size.toString() })),
    dailySignups: dailySignups.map((x) => ({ date: x.date, count: Number(x.count) })),
    dailyUploads: dailyUploads.map((x) => ({ date: x.date, count: Number(x.count) })),
  });
}
</file>

<file path="src/app/api/notifications/preferences/route.ts">
// src/app/api/notifications/preferences/route.ts
// âš ï¸ ìˆ˜ì •: export const/interface â†’ @/lib/notification-prefs ë¡œ ë¶„ë¦¬

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";
import { NotificationPreferences, DEFAULT_PREFS } from "@/lib/notification-prefs";

export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { notificationPrefs: true },
    });

    const prefs = (user?.notificationPrefs as NotificationPreferences | null) ?? DEFAULT_PREFS;
    return NextResponse.json({ prefs: { ...DEFAULT_PREFS, ...prefs } });
  } catch (error) {
    console.error("GET /api/notifications/preferences error:", error);
    return NextResponse.json({ error: "ì„œë²„ ì˜¤ë¥˜" }, { status: 500 });
  }
}

export async function PATCH(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });

    const body = await request.json();
    const allowed = Object.keys(DEFAULT_PREFS) as (keyof NotificationPreferences)[];
    const prefs: Partial<NotificationPreferences> = {};
    for (const key of allowed) {
      if (typeof body[key] === "boolean") prefs[key] = body[key];
    }

    await prisma.user.update({
      where: { id: session.user.id },
      data:  { notificationPrefs: prefs },
    });

    return NextResponse.json({ prefs: { ...DEFAULT_PREFS, ...prefs } });
  } catch (error) {
    console.error("PATCH /api/notifications/preferences error:", error);
    return NextResponse.json({ error: "ì„œë²„ ì˜¤ë¥˜" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/users/me/export/route.ts">
// src/app/api/users/me/export/route.ts
// âœ… ìˆ˜ì •: export const dynamic = 'force-dynamic' ì¶”ê°€

export const dynamic = 'force-dynamic';

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { prisma } from "@/lib/db";

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const userId = session.user.id;

    const [user, files, folders, posts, comments, notifications, activityLogs] =
      await Promise.all([
        prisma.user.findUnique({
          where: { id: userId },
          select: {
            id: true, name: true, email: true, role: true,
            emailVerified: true, createdAt: true, updatedAt: true,
            isOnline: true, lastSeenAt: true,
          },
        }),
        prisma.file.findMany({
          where: { userId },
          select: {
            id: true, originalName: true, mimeType: true,
            size: true, createdAt: true, folderId: true,
          },
          orderBy: { createdAt: "desc" },
        }),
        prisma.folder.findMany({
          where: { userId },
          select: { id: true, name: true, parentId: true, createdAt: true },
        }),
        prisma.post.findMany({
          where: { userId },
          select: {
            id: true, title: true, content: true,
            visibility: true, createdAt: true,
            comments: { select: { id: true, content: true, createdAt: true } },
          },
          orderBy: { createdAt: "desc" },
        }),
        prisma.comment.findMany({
          where: { userId },
          select: {
            id: true, content: true, createdAt: true,
            post: { select: { id: true, title: true } },
          },
          orderBy: { createdAt: "desc" },
        }),
        prisma.notification.findMany({
          where: { userId },
          select: { id: true, type: true, title: true, body: true, isRead: true, createdAt: true },
          orderBy: { createdAt: "desc" },
          take: 200,
        }),
        prisma.activityLog.findMany({
          where: { userId },
          select: { id: true, action: true, target: true, createdAt: true },
          orderBy: { createdAt: "desc" },
          take: 500,
        }).catch(() => []),
      ]);

    const exportData = {
      exportedAt: new Date().toISOString(),
      exportVersion: "1.0",
      user,
      summary: {
        fileCount: files.length,
        folderCount: folders.length,
        postCount: posts.length,
        commentCount: comments.length,
        notificationCount: notifications.length,
        activityLogCount: activityLogs.length,
      },
      files, folders, posts, comments, notifications, activityLogs,
    };

    const filename = `eum-data-export-${new Date().toISOString().split("T")[0]}.json`;

    return new NextResponse(JSON.stringify(exportData, null, 2), {
      headers: {
        "Content-Type": "application/json; charset=utf-8",
        "Content-Disposition": `attachment; filename="${filename}"`,
      },
    });
  } catch (error) {
    console.error("GET /api/users/me/export error:", error);
    return NextResponse.json({ error: "ë‚´ë³´ë‚´ê¸° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/users/me/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { prisma } from "@/lib/db";
import bcrypt from "bcryptjs";

// GET /api/users/me â€” í˜„ì¬ ì‚¬ìš©ì ì •ë³´ + ìŠ¤í† ë¦¬ì§€ í†µê³„
export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
        emailVerified: true,
        createdAt: true,
        isOnline: true,
        _count: {
          select: {
            files: true,
            posts: true,
            comments: true,
          },
        },
      },
    });

    if (!user) {
      return NextResponse.json({ error: "ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 404 });
    }

    // ìŠ¤í† ë¦¬ì§€ í•©ê³„ ê³„ì‚°
    const storageAgg = await prisma.file.aggregate({
      where: { userId: session.user.id },
      _sum: { size: true },
    });

    const totalBytes = Number(storageAgg._sum.size ?? 0);

    return NextResponse.json({
      user,
      stats: {
        totalFiles: user._count.files,
        totalPosts: user._count.posts,
        totalComments: user._count.comments,
        storageUsedBytes: totalBytes,
        storageUsedMB: (totalBytes / 1024 / 1024).toFixed(2),
      },
    });
  } catch (error) {
    console.error("GET /api/users/me error:", error);
    return NextResponse.json({ error: "ì„œë²„ ì˜¤ë¥˜" }, { status: 500 });
  }
}

// PATCH /api/users/me â€” ì´ë¦„ ë³€ê²½ ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ ë³€ê²½
export async function PATCH(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const body = await request.json();
    const { name, currentPassword, newPassword } = body;

    const user = await prisma.user.findUnique({ where: { id: session.user.id } });
    if (!user) {
      return NextResponse.json({ error: "ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" }, { status: 404 });
    }

    const updateData: Record<string, unknown> = {};

    // ì´ë¦„ ë³€ê²½
    if (name !== undefined) {
      const trimmed = name.trim();
      if (!trimmed) {
        return NextResponse.json({ error: "ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”" }, { status: 400 });
      }
      if (trimmed.length > 20) {
        return NextResponse.json({ error: "ì´ë¦„ì€ 20ì ì´í•˜ì—¬ì•¼ í•©ë‹ˆë‹¤" }, { status: 400 });
      }
      updateData.name = trimmed;
    }

    // ë¹„ë°€ë²ˆí˜¸ ë³€ê²½
    if (newPassword !== undefined) {
      if (!currentPassword) {
        return NextResponse.json({ error: "í˜„ì¬ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”" }, { status: 400 });
      }
      const valid = await bcrypt.compare(currentPassword, user.passwordHash);
      if (!valid) {
        return NextResponse.json({ error: "í˜„ì¬ ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤" }, { status: 400 });
      }
      if (newPassword.length < 8) {
        return NextResponse.json({ error: "ìƒˆ ë¹„ë°€ë²ˆí˜¸ëŠ” 8ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤" }, { status: 400 });
      }
      updateData.passwordHash = await bcrypt.hash(newPassword, 12);
    }

    if (Object.keys(updateData).length === 0) {
      return NextResponse.json({ error: "ë³€ê²½í•  ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤" }, { status: 400 });
    }

    const updated = await prisma.user.update({
      where: { id: session.user.id },
      data: updateData,
      select: { id: true, name: true, email: true },
    });

    return NextResponse.json({ user: updated });
  } catch (error) {
    console.error("PATCH /api/users/me error:", error);
    return NextResponse.json({ error: "ì„œë²„ ì˜¤ë¥˜" }, { status: 500 });
  }
}

// DELETE /api/users/me â€” ê³„ì • ì˜êµ¬ ì‚­ì œ (ë³¸ì¸)
export async function DELETE() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    // ê´€ë¦¬ì ê³„ì •ì€ ì‚­ì œ ë¶ˆê°€ (ìµœí›„ì˜ ë³´ë£¨)
    const user = await prisma.user.findUnique({ where: { id: session.user.id } });
    if (user?.role === "ADMIN") {
      const adminCount = await prisma.user.count({ where: { role: "ADMIN" } });
      if (adminCount <= 1) {
        return NextResponse.json(
          { error: "ë§ˆì§€ë§‰ ê´€ë¦¬ì ê³„ì •ì€ ì‚­ì œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤" },
          { status: 400 }
        );
      }
    }

    // CASCADEë¡œ íŒŒì¼, ê²Œì‹œê¸€, ëŒ“ê¸€ ë“± ëª¨ë‘ ì‚­ì œë¨
    await prisma.user.delete({ where: { id: session.user.id } });

    return NextResponse.json({ message: "ê³„ì •ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤" });
  } catch (error) {
    console.error("DELETE /api/users/me error:", error);
    return NextResponse.json({ error: "ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" }, { status: 500 });
  }
}
</file>

<file path="src/app/chat/page.tsx">
"use client";

import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import { useEffect, useState, useCallback } from "react";
import Link from "next/link";
import { useSocket } from "@/hooks/useSocket";
import { toast } from "@/components/Toast";

interface ChatRoom {
  id: string;
  name: string | null;
  type: "DIRECT" | "GROUP";
  members: any[];
  messages: any[];
  unreadCount: number;
  updatedAt: string;
}

export default function ChatPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const { socket, isConnected } = useSocket();

  const [chatRooms, setChatRooms] = useState<ChatRoom[]>([]);
  const [loading, setLoading] = useState(true);
  const [showNewChatModal, setShowNewChatModal] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [searchResults, setSearchResults] = useState<any[]>([]);
  const [isSearching, setIsSearching] = useState(false);
  const [isCreating, setIsCreating] = useState(false);

  useEffect(() => {
    if (status === "unauthenticated") router.push("/login");
  }, [status, router]);

  const fetchChatRooms = useCallback(async () => {
    try {
      const res = await fetch("/api/chat/rooms");
      if (res.ok) {
        const data = await res.json();
        setChatRooms(data.chatRooms || []);
      }
    } catch (err) {
      console.error("ì±„íŒ…ë°© ëª©ë¡ ë¡œë“œ ì‹¤íŒ¨:", err);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    if (session) fetchChatRooms();
  }, [session, fetchChatRooms]);

  // âœ… ì‹¤ì‹œê°„: ë‹¤ë¥¸ ì±„íŒ…ë°©ì—ì„œ ìƒˆ ë©”ì‹œì§€ ì˜¤ë©´ ëª©ë¡ ìˆœì„œ/ë¯¸ë¦¬ë³´ê¸° ê°±ì‹ 
  useEffect(() => {
    if (!socket) return;

    const handleNewMessage = (data: any) => {
      setChatRooms((prev) => {
        const roomIndex = prev.findIndex((r) => r.id === data.chatRoomId);
        if (roomIndex === -1) return prev;

        const updated = [...prev];
        const room = { ...updated[roomIndex] };

        // ë§ˆì§€ë§‰ ë©”ì‹œì§€ ì—…ë°ì´íŠ¸
        room.messages = [data];
        room.updatedAt = data.createdAt || new Date().toISOString();

        // ë‚´ê°€ ë³´ë‚¸ ë©”ì‹œì§€ê°€ ì•„ë‹ˆë©´ unread ì¦ê°€
        if (data.senderId !== session?.user?.id) {
          room.unreadCount = (room.unreadCount || 0) + 1;
        }

        // í•´ë‹¹ ë°©ì„ ë§¨ ìœ„ë¡œ ì˜¬ë¦¬ê¸°
        updated.splice(roomIndex, 1);
        return [room, ...updated];
      });
    };

    socket.on("message:receive", handleNewMessage);
    socket.on("message:new", handleNewMessage);

    return () => {
      socket.off("message:receive", handleNewMessage);
      socket.off("message:new", handleNewMessage);
    };
  }, [socket, session?.user?.id]);

  const searchUsers = async () => {
    if (!searchQuery.trim()) return;
    setIsSearching(true);
    try {
      const res = await fetch(
        `/api/users/search?q=${encodeURIComponent(searchQuery)}`
      );
      if (res.ok) {
        const data = await res.json();
        setSearchResults(data.users || []);
        if ((data.users || []).length === 0) {
          toast.info("ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤");
        }
      }
    } catch {
      toast.error("ì‚¬ìš©ì ê²€ìƒ‰ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
    } finally {
      setIsSearching(false);
    }
  };

  const createChatRoom = async (otherUserId: string) => {
    setIsCreating(true);
    try {
      const res = await fetch("/api/chat/rooms", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ type: "DIRECT", memberIds: [otherUserId] }),
      });

      if (res.ok) {
        const data = await res.json();
        router.push(`/chat/${data.chatRoom.id}`);
      } else {
        // âœ… alert() â†’ toast.error()
        toast.error("ì±„íŒ…ë°© ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
      }
    } catch {
      toast.error("ì±„íŒ…ë°© ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setIsCreating(false);
    }
  };

  const closeModal = () => {
    setShowNewChatModal(false);
    setSearchResults([]);
    setSearchQuery("");
  };

  const getChatRoomName = (chatRoom: ChatRoom) => {
    if (chatRoom.type === "GROUP") return chatRoom.name || "ê·¸ë£¹ ì±„íŒ…";
    const other = chatRoom.members.find(
      (m) => m.user.id !== session?.user?.id
    );
    return other?.user.name || "ì•Œ ìˆ˜ ì—†ìŒ";
  };

  const getChatRoomInitial = (chatRoom: ChatRoom) => {
    return getChatRoomName(chatRoom)[0]?.toUpperCase() || "?";
  };

  const getLastMessage = (chatRoom: ChatRoom) => {
    if (!chatRoom.messages?.length) return "ë©”ì‹œì§€ê°€ ì—†ìŠµë‹ˆë‹¤";
    const last = chatRoom.messages[0];
    if (last.type === "FILE") return "ğŸ“ íŒŒì¼";
    if (last.type === "CALL_LOG") return "ğŸ“ í†µí™”";
    return last.content || "ë©”ì‹œì§€ê°€ ì—†ìŠµë‹ˆë‹¤";
  };

  const formatDate = (dateStr: string) => {
    const date = new Date(dateStr);
    if (isNaN(date.getTime())) return "";
    const now = new Date();
    const isToday = date.toDateString() === now.toDateString();
    if (isToday) {
      return date.toLocaleTimeString("ko-KR", {
        hour: "2-digit",
        minute: "2-digit",
      });
    }
    return date.toLocaleDateString("ko-KR", { month: "short", day: "numeric" });
  };

  if (status === "loading") {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="text-gray-400">ë¡œë”© ì¤‘...</div>
      </div>
    );
  }

  if (!session) return null;

  return (
    <div className="min-h-screen bg-gray-50">
      {/* â”€â”€ í—¤ë” â”€â”€ */}
      <header className="bg-white border-b sticky top-0 z-10">
        <div className="max-w-2xl mx-auto px-4 py-4 flex justify-between items-center">
          <div className="flex items-center gap-3">
            <h1 className="text-xl font-bold text-gray-900">ğŸ’¬ ì±„íŒ…</h1>
            {/* âœ… isConnected ì´ì œ ì‹¤ì œë¡œ ì‘ë™ */}
            <span
              className={`w-2 h-2 rounded-full ${
                isConnected ? "bg-green-500" : "bg-gray-300"
              }`}
              title={isConnected ? "ì—°ê²°ë¨" : "ì—°ê²° ì¤‘..."}
            />
          </div>
          <div className="flex items-center gap-2">
            <Link
              href="/dashboard"
              className="text-sm text-gray-500 hover:text-gray-700"
            >
              â† ëŒ€ì‹œë³´ë“œ
            </Link>
            <button
              onClick={() => setShowNewChatModal(true)}
              className="px-3 py-1.5 bg-blue-600 text-white text-sm rounded-lg hover:bg-blue-700 font-medium"
            >
              + ìƒˆ ì±„íŒ…
            </button>
          </div>
        </div>
      </header>

      {/* â”€â”€ ì±„íŒ…ë°© ëª©ë¡ â”€â”€ */}
      <main className="max-w-2xl mx-auto px-4 py-4">
        {loading ? (
          // ìŠ¤ì¼ˆë ˆí†¤ UI
          <div className="space-y-1">
            {[1, 2, 3].map((i) => (
              <div
                key={i}
                className="bg-white rounded-xl p-4 flex gap-3 animate-pulse"
              >
                <div className="w-12 h-12 rounded-full bg-gray-200 flex-shrink-0" />
                <div className="flex-1 space-y-2 py-1">
                  <div className="h-4 bg-gray-200 rounded w-1/3" />
                  <div className="h-3 bg-gray-100 rounded w-2/3" />
                </div>
              </div>
            ))}
          </div>
        ) : chatRooms.length === 0 ? (
          <div className="text-center py-16">
            <p className="text-4xl mb-4">ğŸ’¬</p>
            <p className="text-gray-500 mb-4">ì•„ì§ ëŒ€í™”ê°€ ì—†ì–´ìš”</p>
            <button
              onClick={() => setShowNewChatModal(true)}
              className="px-4 py-2 bg-blue-600 text-white rounded-lg text-sm font-medium"
            >
              ì²« ì±„íŒ… ì‹œì‘í•˜ê¸°
            </button>
          </div>
        ) : (
          <div className="space-y-1">
            {chatRooms.map((chatRoom) => (
              <Link
                key={chatRoom.id}
                href={`/chat/${chatRoom.id}`}
                className="flex items-center gap-3 bg-white hover:bg-gray-50 rounded-xl p-4 transition"
              >
                {/* ì•„ë°”íƒ€ */}
                <div className="w-12 h-12 rounded-full bg-blue-100 flex items-center justify-center text-blue-600 font-bold text-lg flex-shrink-0">
                  {getChatRoomInitial(chatRoom)}
                </div>

                {/* ë‚´ìš© */}
                <div className="flex-1 min-w-0">
                  <div className="flex items-center justify-between mb-0.5">
                    <span className="font-semibold text-gray-900 text-sm">
                      {getChatRoomName(chatRoom)}
                    </span>
                    <span className="text-xs text-gray-400 flex-shrink-0 ml-2">
                      {formatDate(chatRoom.updatedAt)}
                    </span>
                  </div>
                  <div className="flex items-center justify-between">
                    <p className="text-sm text-gray-500 truncate">
                      {getLastMessage(chatRoom)}
                    </p>
                    {chatRoom.unreadCount > 0 && (
                      <span className="ml-2 min-w-[20px] h-5 px-1.5 bg-blue-600 text-white text-xs rounded-full flex items-center justify-center flex-shrink-0">
                        {chatRoom.unreadCount > 99 ? "99+" : chatRoom.unreadCount}
                      </span>
                    )}
                  </div>
                </div>
              </Link>
            ))}
          </div>
        )}
      </main>

      {/* â”€â”€ ìƒˆ ì±„íŒ… ëª¨ë‹¬ â”€â”€ */}
      {showNewChatModal && (
        <div
          className="fixed inset-0 z-50 flex items-end sm:items-center justify-center bg-black/50 backdrop-blur-sm p-4"
          onClick={closeModal}
        >
          <div
            className="bg-white rounded-2xl shadow-2xl w-full max-w-md p-6"
            onClick={(e) => e.stopPropagation()}
          >
            <h3 className="text-lg font-bold mb-4 text-gray-900">
              ìƒˆ ì±„íŒ… ì‹œì‘
            </h3>

            <div className="flex gap-2 mb-4">
              <input
                type="text"
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                onKeyDown={(e) => e.key === "Enter" && searchUsers()}
                placeholder="ì´ë¦„ ë˜ëŠ” ì´ë©”ì¼ë¡œ ê²€ìƒ‰"
                className="flex-1 px-4 py-2.5 border border-gray-200 rounded-xl outline-none focus:border-blue-500 text-gray-900 bg-gray-50 text-sm"
                autoFocus
              />
              <button
                onClick={searchUsers}
                disabled={isSearching}
                className="px-4 py-2.5 bg-blue-600 text-white rounded-xl font-medium text-sm disabled:opacity-50"
              >
                {isSearching ? "..." : "ê²€ìƒ‰"}
              </button>
            </div>

            {searchResults.length > 0 && (
              <div className="space-y-2 max-h-60 overflow-y-auto mb-4">
                {searchResults.map((user) => (
                  <button
                    key={user.id}
                    onClick={() => createChatRoom(user.id)}
                    disabled={isCreating}
                    className="w-full p-3 text-left border border-gray-100 rounded-xl hover:bg-blue-50 hover:border-blue-200 transition disabled:opacity-50"
                  >
                    <div className="flex items-center gap-3">
                      <div className="w-9 h-9 rounded-full bg-blue-100 flex items-center justify-center text-blue-600 font-bold text-sm flex-shrink-0">
                        {user.name?.[0]?.toUpperCase() || "?"}
                      </div>
                      <div className="flex-1 min-w-0">
                        <p className="font-medium text-gray-900 text-sm">
                          {user.name}
                        </p>
                        <p className="text-xs text-gray-500 truncate">
                          {user.email}
                        </p>
                      </div>
                      {user.isOnline && (
                        <span className="w-2 h-2 bg-green-500 rounded-full flex-shrink-0" />
                      )}
                    </div>
                  </button>
                ))}
              </div>
            )}

            <div className="flex justify-end">
              <button
                onClick={closeModal}
                className="px-4 py-2 text-gray-500 hover:bg-gray-100 rounded-xl text-sm font-medium"
              >
                ë‹«ê¸°
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/app/error.tsx">
"use client";

import { useEffect } from "react";
import { AlertTriangle, RefreshCw, Home } from "lucide-react";

export default function ErrorPage({
  error, reset,
}: { error: Error & { digest?: string }; reset: () => void }) {
  useEffect(() => {
    // í´ë¼ì´ì–¸íŠ¸ ì—ëŸ¬ ë¡œê¹…
    fetch("/api/errors/report", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        message: error.message,
        stack:   error.stack,
        digest:  error.digest,
        url:     window.location.href,
        ts:      new Date().toISOString(),
      }),
    }).catch(() => {});
  }, [error]);

  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gray-50 dark:bg-slate-900 px-4">
      <div className="max-w-md w-full text-center space-y-6">
        <div className="w-20 h-20 rounded-2xl bg-red-50 dark:bg-red-900/30 flex items-center justify-center mx-auto">
          <AlertTriangle size={36} className="text-red-500" />
        </div>
        <div>
          <h1 className="text-2xl font-black text-gray-900 dark:text-slate-100 mb-2">í˜ì´ì§€ ì˜¤ë¥˜</h1>
          <p className="text-gray-500 dark:text-slate-400">
            ì´ í˜ì´ì§€ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.
          </p>
          {process.env.NODE_ENV === "development" && (
            <pre className="mt-3 text-left text-[10px] bg-gray-900 text-red-300 rounded-xl p-4 overflow-auto max-h-32">
              {error.message}
            </pre>
          )}
        </div>
        <div className="flex gap-3">
          <button onClick={reset}
            className="flex-1 flex items-center justify-center gap-2 py-3 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-xl transition">
            <RefreshCw size={15} /> ë‹¤ì‹œ ì‹œë„
          </button>
          <a href="/dashboard"
            className="flex-1 flex items-center justify-center gap-2 py-3 text-sm font-semibold text-gray-700 dark:text-slate-300 bg-white dark:bg-slate-800 border border-gray-200 dark:border-slate-700 rounded-xl transition hover:bg-gray-50 dark:hover:bg-slate-700">
            <Home size={15} /> í™ˆìœ¼ë¡œ
          </a>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/not-found.tsx">
// src/app/not-found.tsx
// Next.js 14 App Router ê¸€ë¡œë²Œ 404 í˜ì´ì§€

import Link from "next/link";

export default function NotFound() {
  return (
    <div className="min-h-screen bg-[#0f0c29] flex items-center justify-center px-4">
      {/* ë°°ê²½ ë¸”ë¡­ */}
      <div className="fixed inset-0 overflow-hidden pointer-events-none -z-10">
        <div className="absolute top-1/4 left-1/4 w-96 h-96 bg-purple-700/20 rounded-full blur-3xl" />
        <div className="absolute bottom-1/4 right-1/4 w-80 h-80 bg-blue-700/15 rounded-full blur-3xl" />
      </div>

      <div className="text-center max-w-md">
        {/* 404 */}
        <div className="relative mb-6 inline-block">
          <p className="text-[120px] md:text-[160px] font-black leading-none tracking-tighter
                        bg-clip-text text-transparent
                        bg-gradient-to-b from-white/80 to-white/10
                        select-none">
            404
          </p>
          <div className="absolute inset-0 flex items-center justify-center">
            <div className="w-24 h-24 rounded-full bg-purple-500/10 border border-purple-500/20 flex items-center justify-center animate-pulse">
              <span className="text-4xl">ğŸ”</span>
            </div>
          </div>
        </div>

        <h1 className="text-2xl font-bold text-white mb-3">
          í˜ì´ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤
        </h1>
        <p className="text-white/40 text-sm leading-relaxed mb-10">
          ìš”ì²­í•˜ì‹  í˜ì´ì§€ê°€ ì‚­ì œë˜ì—ˆê±°ë‚˜ ì£¼ì†Œê°€ ë³€ê²½ë˜ì—ˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
          ì…ë ¥í•œ ì£¼ì†Œë¥¼ ë‹¤ì‹œ í™•ì¸í•´ ì£¼ì„¸ìš”.
        </p>

        <div className="flex flex-col sm:flex-row items-center justify-center gap-3">
          <Link
            href="/dashboard"
            className="w-full sm:w-auto px-6 py-3 bg-white text-black font-bold rounded-xl hover:bg-purple-50 transition-all text-sm"
          >
            ğŸ  ëŒ€ì‹œë³´ë“œë¡œ ì´ë™
          </Link>
          <Link
            href="javascript:history.back()"
            className="w-full sm:w-auto px-6 py-3 bg-white/5 text-white font-semibold rounded-xl border border-white/10 hover:bg-white/10 transition-all text-sm"
          >
            â† ì´ì „ í˜ì´ì§€
          </Link>
        </div>

        <p className="mt-10 text-white/10 text-[10px] font-medium tracking-[0.3em] uppercase">
          Â© 2026 EUM CLOUD SERVICE
        </p>
      </div>
    </div>
  );
}

// export default function NotFoundPage() {
//   return (
//     <div className="min-h-screen flex flex-col items-center justify-center bg-gray-50 dark:bg-slate-900 px-4">
//       <div className="text-center space-y-6 max-w-sm">
//         <p className="text-7xl font-black text-gray-200 dark:text-slate-700">404</p>
//         <div>
//           <h1 className="text-xl font-bold text-gray-900 dark:text-slate-100 mb-2">
//             í˜ì´ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤
//           </h1>
//           <p className="text-sm text-gray-500 dark:text-slate-400">
//             ì£¼ì†Œê°€ ì˜ëª»ë˜ì—ˆê±°ë‚˜ ì‚­ì œëœ í˜ì´ì§€ì…ë‹ˆë‹¤.
//           </p>
//         </div>
//         <a href="/dashboard"
//           className="inline-flex items-center gap-2 px-6 py-3 text-sm font-semibold text-white bg-blue-600 hover:bg-blue-700 rounded-xl transition">
//           <Home size={15} /> ëŒ€ì‹œë³´ë“œë¡œ
//         </a>
//       </div>
//     </div>
//   );
// }
</file>

<file path="src/app/offline/page.tsx">
"use client";
// src/app/offline/page.tsx
// âœ… ìˆ˜ì •: "use client" ì¶”ê°€ â€” onClick í•¸ë“¤ëŸ¬ê°€ ìˆì–´ Server Componentë¡œ ë Œë”ë§ ë¶ˆê°€

export default function OfflinePage() {
  return (
    <div className="min-h-screen bg-[#0f0c29] flex items-center justify-center px-4">
      <div className="fixed inset-0 overflow-hidden pointer-events-none -z-10">
        <div className="absolute top-1/3 left-1/4 w-80 h-80 bg-slate-700/30 rounded-full blur-3xl" />
      </div>

      <div className="text-center max-w-sm">
        <div className="text-7xl mb-6 animate-pulse">ğŸ“¡</div>
        <h1 className="text-2xl font-bold text-white mb-3">ì˜¤í”„ë¼ì¸ ìƒíƒœì…ë‹ˆë‹¤</h1>
        <p className="text-white/40 text-sm leading-relaxed mb-8">
          ì¸í„°ë„· ì—°ê²°ì„ í™•ì¸í•´ì£¼ì„¸ìš”.<br />
          ì—°ê²°ì´ ë³µêµ¬ë˜ë©´ ìë™ìœ¼ë¡œ ìƒˆë¡œê³ ì¹¨ë©ë‹ˆë‹¤.
        </p>
        <button
          onClick={() => window.location.reload()}
          className="px-6 py-3 bg-white/10 text-white font-semibold rounded-xl border border-white/10 hover:bg-white/20 transition-all text-sm"
        >
          ğŸ”„ ë‹¤ì‹œ ì‹œë„
        </button>
        <p className="mt-8 text-white/10 text-[10px] font-medium tracking-[0.3em] uppercase">
          Â© 2026 EUM CLOUD SERVICE
        </p>
      </div>
    </div>
  );
}
</file>

<file path="src/app/users/search/page.tsx">
"use client";
// src/app/users/search/page.tsx
// âœ… ìˆ˜ì •: useSearchParamsë¥¼ Suspenseë¡œ ê°ì‹¸ëŠ” íŒ¨í„´ ì ìš©

import { Suspense, useState, useEffect, useCallback, useRef } from "react";
import Link from "next/link";
import { useRouter, useSearchParams } from "next/navigation";
import { ChevronLeft, Search, Users, UserPlus, UserCheck } from "lucide-react";
import { toast } from "@/components/Toast";

interface SearchUser {
  id: string;
  name: string;
  email: string;
  role: "USER" | "ADMIN";
  isOnline: boolean;
  createdAt: string;
  isFollowing: boolean;
  _count: { files: number; posts: number };
}

// âœ… useSearchParamsë¥¼ ì‚¬ìš©í•˜ëŠ” ë¶€ë¶„ì„ ë³„ë„ ì»´í¬ë„ŒíŠ¸ë¡œ ë¶„ë¦¬
function UserSearchContent() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [query, setQuery] = useState(searchParams.get("q") ?? "");
  const [users, setUsers] = useState<SearchUser[]>([]);
  const [total, setTotal] = useState(0);
  const [loading, setLoading] = useState(false);
  const [following, setFollowing] = useState<Set<string>>(new Set());
  const debounceRef = useRef<NodeJS.Timeout>();

  const search = useCallback(async (q: string) => {
    if (!q.trim()) { setUsers([]); setTotal(0); return; }
    setLoading(true);
    try {
      const res = await fetch(`/api/users/search?q=${encodeURIComponent(q)}`);
      const data = await res.json();
      setUsers(data.users ?? []);
      setTotal(data.total ?? 0);
      const init = new Set<string>(data.users.filter((u: SearchUser) => u.isFollowing).map((u: SearchUser) => u.id));
      setFollowing(init);
    } catch {
      toast.error("ê²€ìƒ‰ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    clearTimeout(debounceRef.current);
    debounceRef.current = setTimeout(() => {
      search(query);
      if (query) router.replace(`/users/search?q=${encodeURIComponent(query)}`, { scroll: false });
    }, 300);
  }, [query, search, router]);

  const toggleFollow = async (userId: string) => {
    const isNowFollowing = following.has(userId);
    const method = isNowFollowing ? "DELETE" : "POST";
    setFollowing((s) => { const n = new Set(s); isNowFollowing ? n.delete(userId) : n.add(userId); return n; });
    try {
      const res = await fetch(`/api/users/${userId}/follow`, { method });
      if (!res.ok) throw new Error();
      toast.success(isNowFollowing ? "íŒ”ë¡œìš°ë¥¼ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤" : "íŒ”ë¡œìš°í–ˆìŠµë‹ˆë‹¤");
    } catch {
      setFollowing((s) => { const n = new Set(s); isNowFollowing ? n.add(userId) : n.delete(userId); return n; });
      toast.error("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    }
  };

  return (
    <>
      {/* í—¤ë” */}
      <div className="bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700 sticky top-0 z-10">
        <div className="max-w-2xl mx-auto px-4 py-3 flex items-center gap-3">
          <Link href="/dashboard" className="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-slate-700 transition-colors">
            <ChevronLeft size={20} className="text-gray-600 dark:text-slate-400" />
          </Link>
          <div className="flex-1 relative">
            <Search size={16} className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400" />
            <input
              type="text"
              autoFocus
              value={query}
              onChange={(e) => setQuery(e.target.value)}
              placeholder="ì´ë¦„ ë˜ëŠ” ì´ë©”ì¼ë¡œ ê²€ìƒ‰"
              className="w-full pl-9 pr-4 py-2 text-sm border border-gray-200 dark:border-slate-600 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-slate-700 dark:text-slate-100"
            />
          </div>
        </div>
      </div>

      <div className="max-w-2xl mx-auto px-4 py-4">
        {query && !loading && (
          <p className="text-xs text-gray-500 dark:text-slate-400 mb-3 px-1">
            {total > 0 ? `"${query}" ê²€ìƒ‰ ê²°ê³¼ ${total}ëª…` : `"${query}"ì— í•´ë‹¹í•˜ëŠ” ì‚¬ìš©ìê°€ ì—†ìŠµë‹ˆë‹¤`}
          </p>
        )}

        {loading && (
          <div className="space-y-2">
            {[...Array(4)].map((_, i) => (
              <div key={i} className="bg-white dark:bg-slate-800 rounded-xl p-4 animate-pulse flex items-center gap-3">
                <div className="w-12 h-12 rounded-full bg-gray-200 dark:bg-slate-700" />
                <div className="flex-1 space-y-2">
                  <div className="h-3.5 bg-gray-200 dark:bg-slate-700 rounded w-1/3" />
                  <div className="h-3 bg-gray-100 dark:bg-slate-700/50 rounded w-1/2" />
                </div>
              </div>
            ))}
          </div>
        )}

        {!query && !loading && (
          <div className="flex flex-col items-center justify-center py-24 text-center">
            <div className="w-16 h-16 rounded-full bg-gray-100 dark:bg-slate-800 flex items-center justify-center mb-4">
              <Users size={28} className="text-gray-400 dark:text-slate-500" />
            </div>
            <p className="text-gray-500 dark:text-slate-400 font-medium">ì‚¬ìš©ìë¥¼ ê²€ìƒ‰í•˜ì„¸ìš”</p>
            <p className="text-xs text-gray-400 dark:text-slate-500 mt-1">ì´ë¦„ì´ë‚˜ ì´ë©”ì¼ë¡œ ê²€ìƒ‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤</p>
          </div>
        )}

        {!loading && users.length > 0 && (
          <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 overflow-hidden">
            <div className="divide-y divide-gray-100 dark:divide-slate-700">
              {users.map((u) => (
                <div key={u.id} className="flex items-center gap-3 px-4 py-3 hover:bg-gray-50 dark:hover:bg-slate-700/50 transition-colors">
                  <Link href={`/users/${u.id}`} className="relative shrink-0">
                    <div className="w-11 h-11 rounded-full bg-gradient-to-br from-blue-400 to-purple-500 flex items-center justify-center text-white font-bold">
                      {u.name[0]}
                    </div>
                    {u.isOnline && (
                      <span className="absolute bottom-0 right-0 w-3 h-3 bg-green-500 rounded-full border-2 border-white dark:border-slate-800" />
                    )}
                  </Link>
                  <Link href={`/users/${u.id}`} className="flex-1 min-w-0">
                    <div className="flex items-center gap-1.5">
                      <p className="text-sm font-semibold text-gray-900 dark:text-slate-100 truncate">{u.name}</p>
                      {u.role === "ADMIN" && (
                        <span className="text-[9px] font-bold bg-yellow-100 dark:bg-yellow-900/30 text-yellow-700 dark:text-yellow-400 px-1.5 py-0.5 rounded-full">ê´€ë¦¬ì</span>
                      )}
                    </div>
                    <p className="text-xs text-gray-400 dark:text-slate-500 truncate">{u.email}</p>
                    <p className="text-[10px] text-gray-400 dark:text-slate-500 mt-0.5">
                      íŒŒì¼ {u._count.files} Â· ê²Œì‹œê¸€ {u._count.posts}
                    </p>
                  </Link>
                  <button
                    onClick={() => toggleFollow(u.id)}
                    className={`flex items-center gap-1.5 px-3 py-1.5 rounded-xl text-xs font-semibold transition shrink-0 ${
                      following.has(u.id)
                        ? "bg-gray-100 dark:bg-slate-700 text-gray-700 dark:text-slate-300 hover:bg-red-50 dark:hover:bg-red-900/20 hover:text-red-600"
                        : "bg-blue-600 text-white hover:bg-blue-700"
                    }`}
                  >
                    {following.has(u.id) ? <><UserCheck size={12} /> íŒ”ë¡œì‰</> : <><UserPlus size={12} /> íŒ”ë¡œìš°</>}
                  </button>
                </div>
              ))}
            </div>
          </div>
        )}
      </div>
    </>
  );
}

// âœ… í˜ì´ì§€ ì§„ì…ì  â€” Suspenseë¡œ ê°ì‹¸ì„œ useSearchParams í—ˆìš©
export default function UserSearchPage() {
  return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900">
      <Suspense fallback={
        <div className="flex items-center justify-center min-h-screen">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600" />
        </div>
      }>
        <UserSearchContent />
      </Suspense>
    </div>
  );
}
</file>

<file path="src/components/ConfirmDialog.tsx">
"use client";
// src/components/ConfirmDialog.tsx
// âœ… ìˆ˜ì •ì‚¬í•­:
// 1. openConfirmì´ Promise<boolean> ë°˜í™˜ â†’ await íŒ¨í„´ ì§€ì›
// 2. confirmText / confirmLabel ë‘˜ ë‹¤ í—ˆìš© (í•˜ìœ„ í˜¸í™˜)
// 3. confirmVariant / variant ë‘˜ ë‹¤ í—ˆìš© (í•˜ìœ„ í˜¸í™˜)

import { useEffect, useRef, useState, useCallback } from "react";

// â”€â”€ UI ì»´í¬ë„ŒíŠ¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

interface ConfirmDialogProps {
  isOpen:         boolean;
  title:          string;
  message:        string;
  confirmLabel?:  string;
  cancelLabel?:   string;
  variant?:       "danger" | "default" | "primary";
  onConfirm:      () => void;
  onCancel:       () => void;
}

export function ConfirmDialog({
  isOpen,
  title,
  message,
  confirmLabel = "í™•ì¸",
  cancelLabel  = "ì·¨ì†Œ",
  variant      = "default",
  onConfirm,
  onCancel,
}: ConfirmDialogProps) {
  const confirmBtnRef = useRef<HTMLButtonElement>(null);

  useEffect(() => {
    if (isOpen) setTimeout(() => confirmBtnRef.current?.focus(), 50);
  }, [isOpen]);

  useEffect(() => {
    if (!isOpen) return;
    const handle = (e: KeyboardEvent) => { if (e.key === "Escape") onCancel(); };
    window.addEventListener("keydown", handle);
    return () => window.removeEventListener("keydown", handle);
  }, [isOpen, onCancel]);

  if (!isOpen) return null;

  return (
    <div
      className="fixed inset-0 z-[200] flex items-center justify-center p-4 bg-black/50 backdrop-blur-sm"
      onClick={onCancel}
    >
      <div
        className="bg-white dark:bg-slate-800 rounded-2xl shadow-2xl w-full max-w-sm p-6 animate-in zoom-in-95 duration-150"
        onClick={(e) => e.stopPropagation()}
      >
        <h3 className="font-bold text-gray-900 dark:text-slate-100 text-base mb-2">{title}</h3>
        <p className="text-sm text-gray-500 dark:text-slate-400 mb-6">{message}</p>
        <div className="flex gap-3">
          <button
            onClick={onCancel}
            className="flex-1 py-2.5 rounded-xl border border-gray-200 dark:border-slate-600 text-gray-600 dark:text-slate-300 text-sm font-medium hover:bg-gray-50 dark:hover:bg-slate-700 transition"
          >
            {cancelLabel}
          </button>
          <button
            ref={confirmBtnRef}
            onClick={onConfirm}
            className={`flex-1 py-2.5 rounded-xl text-white text-sm font-bold transition ${
              variant === "danger"
                ? "bg-red-500 hover:bg-red-600"
                : variant === "primary"
                ? "bg-violet-600 hover:bg-violet-700"
                : "bg-blue-600 hover:bg-blue-700"
            }`}
          >
            {confirmLabel}
          </button>
        </div>
      </div>
    </div>
  );
}

// â”€â”€ Hook â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

interface OpenConfirmOptions {
  title:           string;
  message:         string;
  // confirmText / confirmLabel ë‘˜ ë‹¤ í—ˆìš©
  confirmText?:    string;
  confirmLabel?:   string;
  cancelLabel?:    string;
  // confirmVariant / variant ë‘˜ ë‹¤ í—ˆìš©
  confirmVariant?: "danger" | "default" | "primary";
  variant?:        "danger" | "default" | "primary";
  // ì½œë°± íŒ¨í„´ (ì„ íƒ)
  onConfirm?:      () => void;
}

export function useConfirm() {
  const [state, setState] = useState<{
    isOpen:       boolean;
    title:        string;
    message:      string;
    confirmLabel: string;
    cancelLabel:  string;
    variant:      "danger" | "default" | "primary";
  }>({
    isOpen:       false,
    title:        "",
    message:      "",
    confirmLabel: "í™•ì¸",
    cancelLabel:  "ì·¨ì†Œ",
    variant:      "default",
  });

  // Promise resolveë¥¼ ì™¸ë¶€ì—ì„œ ì €ì¥
  const resolveRef = useRef<((value: boolean) => void) | null>(null);

  // â”€â”€ Promise ë°˜í™˜ íŒ¨í„´ ì§€ì› â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // await openConfirm({ ... }) â†’ true(í™•ì¸) / false(ì·¨ì†Œ)
  const openConfirm = useCallback((opts: OpenConfirmOptions): Promise<boolean> => {
    return new Promise((resolve) => {
      resolveRef.current = resolve;
      setState({
        isOpen:       true,
        title:        opts.title,
        message:      opts.message,
        confirmLabel: opts.confirmText ?? opts.confirmLabel ?? "í™•ì¸",
        cancelLabel:  opts.cancelLabel ?? "ì·¨ì†Œ",
        variant:      opts.confirmVariant ?? opts.variant ?? "default",
      });
    });
  }, []);

  const handleConfirm = useCallback(() => {
    setState((s) => ({ ...s, isOpen: false }));
    resolveRef.current?.(true);
    resolveRef.current = null;
  }, []);

  const handleCancel = useCallback(() => {
    setState((s) => ({ ...s, isOpen: false }));
    resolveRef.current?.(false);
    resolveRef.current = null;
  }, []);

  const confirmDialog = (
    <ConfirmDialog
      isOpen={state.isOpen}
      title={state.title}
      message={state.message}
      confirmLabel={state.confirmLabel}
      cancelLabel={state.cancelLabel}
      variant={state.variant}
      onConfirm={handleConfirm}
      onCancel={handleCancel}
    />
  );

  return { confirmDialog, openConfirm };
}
</file>

<file path="src/components/Toast.tsx">
"use client";
// src/components/Toast.tsx (ê°œì„ íŒ â€” ì‚¬ìš´ë“œ í†µí•©)
// ê¸°ì¡´ Toast.tsxë¥¼ ì´ íŒŒì¼ë¡œ êµì²´í•˜ì„¸ìš”

import { useState, useEffect, useCallback, createContext, useContext } from "react";
import { CheckCircle, AlertCircle, Info, X, AlertTriangle } from "lucide-react";
import { sound } from "@/lib/sound";

type ToastType = "success" | "error" | "info" | "warning";

interface ToastItem {
  id: string;
  type: ToastType;
  message: string;
  duration?: number;
}

interface ToastContextValue {
  addToast: (type: ToastType, message: string, duration?: number) => void;
}

const ToastContext = createContext<ToastContextValue>({ addToast: () => {} });

const ICONS = {
  success: <CheckCircle   size={16} className="text-green-500 shrink-0" />,
  error:   <AlertCircle   size={16} className="text-red-500   shrink-0" />,
  info:    <Info           size={16} className="text-blue-500  shrink-0" />,
  warning: <AlertTriangle  size={16} className="text-amber-500 shrink-0" />,
};

const STYLES: Record<ToastType, string> = {
  success: "border-green-200 dark:border-green-800 bg-green-50 dark:bg-green-900/30",
  error:   "border-red-200   dark:border-red-800   bg-red-50   dark:bg-red-900/30",
  info:    "border-blue-200  dark:border-blue-800  bg-blue-50  dark:bg-blue-900/30",
  warning: "border-amber-200 dark:border-amber-800 bg-amber-50 dark:bg-amber-900/30",
};

let globalAddToast: ToastContextValue["addToast"] | null = null;

// â”€â”€ Provider â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function ToastProvider({ children }: { children: React.ReactNode }) {
  const [toasts, setToasts] = useState<ToastItem[]>([]);

  const addToast = useCallback((type: ToastType, message: string, duration = 3500) => {
    const id = Math.random().toString(36).slice(2);
    setToasts((t) => [...t.slice(-4), { id, type, message, duration }]);

    // ì‚¬ìš´ë“œ ì¬ìƒ
    if (type === "success") sound.success();
    else if (type === "error") sound.error();
    else sound.notification();

    setTimeout(() => setToasts((t) => t.filter((x) => x.id !== id)), duration);
  }, []);

  useEffect(() => { globalAddToast = addToast; return () => { globalAddToast = null; }; }, [addToast]);

  return (
    <ToastContext.Provider value={{ addToast }}>
      {children}
      {/* í† ìŠ¤íŠ¸ ì»¨í…Œì´ë„ˆ */}
      <div className="fixed top-4 right-4 z-[9997] flex flex-col gap-2 pointer-events-none max-w-sm w-full">
        {toasts.map((t) => (
          <div key={t.id}
            className={`pointer-events-auto flex items-start gap-2.5 px-4 py-3 rounded-xl border shadow-lg backdrop-blur-sm ${STYLES[t.type]} animate-slide-in`}>
            {ICONS[t.type]}
            <p className="text-sm font-medium text-gray-800 dark:text-slate-200 flex-1 leading-snug">{t.message}</p>
            <button onClick={() => setToasts((t2) => t2.filter((x) => x.id !== t.id))}
              className="text-gray-400 hover:text-gray-600 dark:hover:text-slate-300 shrink-0 mt-0.5">
              <X size={14} />
            </button>
          </div>
        ))}
      </div>
    </ToastContext.Provider>
  );
}

// â”€â”€ ì •ì  API (ì»´í¬ë„ŒíŠ¸ ë°–ì—ì„œë„ ì‚¬ìš© ê°€ëŠ¥) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export const toast = {
  success: (msg: string, dur?: number) => globalAddToast?.("success", msg, dur),
  error:   (msg: string, dur?: number) => globalAddToast?.("error",   msg, dur),
  info:    (msg: string, dur?: number) => globalAddToast?.("info",    msg, dur),
  warning: (msg: string, dur?: number) => globalAddToast?.("warning", msg, dur),
};

export function useToast() {
  return useContext(ToastContext);
}
</file>

<file path="src/lib/activity-log.ts">
// src/lib/activity-log.ts
import { prisma } from "@/lib/db";
import { NextRequest } from "next/server";
import { Prisma } from "@prisma/client";

type ActivityAction =
  | "FILE_UPLOAD" | "FILE_DELETE" | "FILE_DOWNLOAD" | "FILE_SHARE"
  | "FOLDER_CREATE" | "FOLDER_DELETE"
  | "POST_CREATE" | "POST_DELETE"
  | "COMMENT_CREATE" | "COMMENT_DELETE"
  | "PROFILE_UPDATE" | "PASSWORD_CHANGE"
  | "LOGIN" | "LOGOUT"
  | "CHAT_MESSAGE" | "CALL_START" | "CALL_END";

interface LogActivityInput {
  userId:   string;
  action:   ActivityAction;
  target?:  string;
  targetId?: string;
  request?: NextRequest;
  extra?:   Record<string, unknown>;
}

export async function logActivity(input: LogActivityInput) {
  try {
    const meta: Record<string, unknown> = { ...(input.extra ?? {}) };
    if (input.request) {
      meta.ip = input.request.headers.get("x-forwarded-for")
             ?? input.request.headers.get("x-real-ip")
             ?? "unknown";
      meta.ua = input.request.headers.get("user-agent")?.slice(0, 120);
    }

    await prisma.activityLog.create({
      data: {
        userId:   input.userId,
        action:   input.action,
        target:   input.target,
        targetId: input.targetId,
        // âœ… Prisma Json íƒ€ì… ìºìŠ¤íŒ…
        meta: Object.keys(meta).length
          ? (meta as Prisma.InputJsonValue)
          : undefined,
      },
    });
  } catch (err) {
    console.error("logActivity error:", err);
  }
}
</file>

<file path="src/lib/auth.ts">
// src/lib/auth.ts
import NextAuth, { AuthOptions } from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";
import { compare } from "bcryptjs";
import { prisma } from "@/lib/db";

export const authOptions: AuthOptions = {
  providers: [
    CredentialsProvider({
      name: "Credentials",
      credentials: {
        email:    { label: "Email",    type: "email" },
        password: { label: "Password", type: "password" },
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) return null;

        const user = await prisma.user.findUnique({
          where: { email: credentials.email },
        });
        if (!user) return null;

        const isValid = await compare(credentials.password, user.passwordHash);
        if (!isValid) return null;

        return {
          id:       user.id,
          email:    user.email,
          name:     user.name,
          role:     user.role,
          isBanned: user.isBanned,  // â† ì¶”ê°€
        };
      },
    }),
  ],
  session: { strategy: "jwt", maxAge: 30 * 24 * 60 * 60 },
  pages:   { signIn: "/login", signOut: "/", error: "/login" },
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.id       = user.id;
        token.role     = user.role;
        token.isBanned = user.isBanned;  // â† ì¶”ê°€
      }
      return token;
    },
    async session({ session, token }) {
      if (session.user) {
        session.user.id       = token.id       as string;
        session.user.role     = token.role     as string;
        session.user.isBanned = token.isBanned as boolean;  // â† ì¶”ê°€
      }
      return session;
    },
  },
  secret: process.env.NEXTAUTH_SECRET,
};

const handler = NextAuth(authOptions);
export { handler as GET, handler as POST };
</file>

<file path="src/lib/socket-server.ts">
import { Server as NetServer } from "http";
import { Server as SocketIOServer } from "socket.io";
import { prisma } from "@/lib/db";

// ì „ì—­ ë³€ìˆ˜ë¡œ IO ì¸ìŠ¤í„´ìŠ¤ ê´€ë¦¬
let globalIo: SocketIOServer | null = null;

export const initSocketServer = (httpServer: NetServer) => {
  const io = new SocketIOServer(httpServer, {
    path: "/api/socket/io",
    addTrailingSlash: false,
    cors: { origin: "*", methods: ["GET", "POST"] },
  });

  globalIo = io;

  io.on("connection", (socket: any) => {
    const userId = socket.handshake.query.userId;
    if (!userId) return;
    
    socket.join(`user:${userId}`);

    // í†µí™” ìš”ì²­
    socket.on("call:initiate", async ({ chatRoomId, receiverId, callType, offer }: any) => {
      try {
        const call = await prisma.call.create({
          data: {
            chatRoomId,
            initiatorId: userId,
            receiverId,
            type: callType,
            // âœ… statusë¥¼ "RINGING" ëŒ€ì‹  Prisma Enum í‘œì¤€ì¸ "PENDING"ìœ¼ë¡œ ìˆ˜ì •
            status: "PENDING", 
          },
        });
        
        io.to(`user:${receiverId}`).emit("call:incoming", {
          callId: call.id,
          from: userId,
          callerName: socket.user?.name || "ìƒëŒ€ë°©",
          callType,
          offer,
        });
      } catch (error) { 
        console.error("Call creation error:", error); 
      }
    });

    socket.on("call:accept", ({ callerId, answer }: any) => {
      io.to(`user:${callerId}`).emit("call:accepted", { answer });
    });

    socket.on("call:ice-candidate", ({ otherUserId, candidate }: any) => {
      io.to(`user:${otherUserId}`).emit("call:ice-candidate", { candidate });
    });

    socket.on("call:reject", async ({ callerId }: any) => {
      try {
        await prisma.call.updateMany({
          where: { 
            initiatorId: callerId, 
            receiverId: userId, 
            status: "PENDING" // âœ… ì—¬ê¸°ë„ PENDINGìœ¼ë¡œ ìˆ˜ì •
          },
          data: { status: "REJECTED" },
        });
        io.to(`user:${callerId}`).emit("call:rejected");
      } catch (error) {
        console.error("Call reject error:", error);
      }
    });

    socket.on("call:end", ({ otherUserId }: any) => {
      io.to(`user:${otherUserId}`).emit("call:ended");
    });

    socket.on("disconnect", () => { 
      socket.leave(`user:${userId}`); 
    });
  });

  return io;
};

// ì•Œë¦¼ ì „ì†¡ìš© í•¨ìˆ˜
export const emitToUser = (userId: string, event: string, data: any) => {
  if (globalIo) {
    globalIo.to(`user:${userId}`).emit(event, data);
  } else {
    console.warn("Socket.io server is not initialized yet.");
  }
};
</file>

<file path="src/app/api/chat/rooms/[id]/messages/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { prisma } from "@/lib/db";
import { sendChatMessageNotification, sendFileSharedNotification } from "@/lib/fcm";

// BigInt ì§ë ¬í™” ìœ í‹¸
function serialize(data: any) {
  return JSON.parse(
    JSON.stringify(data, (key, value) =>
      typeof value === "bigint" ? value.toString() : value
    )
  );
}

// â”€â”€â”€ GET: ë©”ì‹œì§€ ëª©ë¡ ì¡°íšŒ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const chatRoomId = params.id;
    const { searchParams } = new URL(request.url);
    const limit = parseInt(searchParams.get("limit") || "50");
    const before = searchParams.get("before");

    // ë©¤ë²„ì‹­ í™•ì¸
    const membership = await prisma.chatRoomMember.findFirst({
      where: { chatRoomId, userId: session.user.id },
    });

    if (!membership) {
      return NextResponse.json(
        { error: "ì±„íŒ…ë°©ì— ì°¸ì—¬í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤" },
        { status: 403 }
      );
    }

    const messages = await prisma.chatMessage.findMany({
      where: {
        chatRoomId,
        ...(before && { createdAt: { lt: new Date(before) } }),
      },
      include: {
        sender: { select: { id: true, name: true, email: true } },
        file: { select: { id: true, originalName: true, size: true, mimeType: true } },
      },
      orderBy: { createdAt: "desc" },
      take: limit,
    });

    return NextResponse.json(serialize({ messages: messages.reverse() }));
  } catch (error) {
    console.error("GET Messages Error:", error);
    return NextResponse.json({ error: "ë©”ì‹œì§€ ì¡°íšŒ ì‹¤íŒ¨" }, { status: 500 });
  }
}

// â”€â”€â”€ POST: ë©”ì‹œì§€ ì „ì†¡ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" }, { status: 401 });
    }

    const chatRoomId = params.id;
    const { type, content, fileId, callId } = await request.json();

    // ë©”ì‹œì§€ ìƒì„±
    const message = await prisma.chatMessage.create({
      data: {
        chatRoomId,
        senderId: session.user.id,
        type,
        content:
          type === "TEXT" || type === "CALL_LOG" || type === "SYSTEM"
            ? content
            : null,
        fileId: type === "FILE" ? fileId : null,
        callId: callId || null,
      },
      include: {
        sender: { select: { id: true, name: true, email: true } },
        file: true,
      },
    });

    const serializedMessage = serialize(message);

    // âœ… ì´ë²¤íŠ¸ëª… í†µì¼: "message:new" â†’ "message:receive"
    // (í´ë¼ì´ì–¸íŠ¸ useSocket.tsì˜ listen ì´ë²¤íŠ¸ì™€ ì¼ì¹˜)
    const io = (global as any).io;
    if (io) {
      io.to(`chat:${chatRoomId}`).emit("message:receive", serializedMessage);
      console.log(`ğŸ“¡ ì†Œì¼“ ë¸Œë¡œë“œìºìŠ¤íŠ¸: chat:${chatRoomId}`);
    } else {
      console.warn("âš ï¸ global.io ì—†ìŒ â€” ì†Œì¼“ ì„œë²„ ìƒíƒœ í™•ì¸ í•„ìš”");
    }

    // ì±„íŒ…ë°© ë©¤ë²„ ì¡°íšŒ (íŒŒì¼ ê¶Œí•œ + FCMìš©)
    const members = await prisma.chatRoomMember.findMany({
      where: { chatRoomId },
      include: { user: { select: { id: true, name: true, fcmToken: true } } },
    });

    // íŒŒì¼ ê³µìœ  ì‹œ ë©¤ë²„ë“¤ì—ê²Œ ê¶Œí•œ ë¶€ì—¬
    if (type === "FILE" && fileId) {
      for (const member of members) {
        if (member.userId !== session.user.id) {
          await prisma.sharedResource.upsert({
            where: {
              resourceType_resourceId_sharedWithId: {
                resourceType: "FILE",
                resourceId: fileId,
                sharedWithId: member.userId,
              },
            },
            update: {},
            create: {
              resourceType: "FILE",
              resourceId: fileId,
              ownerId: session.user.id,
              sharedWithId: member.userId,
              permission: "VIEW",
            },
          });
        }
      }
    }

    // ì±„íŒ…ë°© updatedAt ê°±ì‹ 
    await prisma.chatRoom.update({
      where: { id: chatRoomId },
      data: { updatedAt: new Date() },
    });

    // FCM í‘¸ì‹œ ì•Œë¦¼ (ë‚˜ ì œì™¸í•œ ë©¤ë²„ë“¤)
    for (const member of members) {
      if (member.userId !== session.user.id && member.user.fcmToken) {
        try {
          if (type === "TEXT") {
            await sendChatMessageNotification(
              member.user.fcmToken,
              session.user.name || "ì‚¬ìš©ì",
              content,
              chatRoomId
            );
          } else if (type === "FILE" && message.file) {
            await sendFileSharedNotification(
              member.user.fcmToken,
              session.user.name || "ì‚¬ìš©ì",
              (message.file as any).originalName,
              chatRoomId
            );
          }
        } catch (error) {
          console.error(`âŒ FCM ì‹¤íŒ¨ (${member.user.name}):`, error);
        }
      }
    }

    return NextResponse.json({ data: serializedMessage }, { status: 201 });
  } catch (error) {
    console.error("POST Message Error:", error);
    return NextResponse.json({ error: "ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨" }, { status: 500 });
  }
}
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from "next";
import { Providers } from "./providers";
import PWAInstaller from "@/components/PWAInstaller";
import "./globals.css";

export const metadata: Metadata = {
  title: "ì´ìŒ (Eum)",
  description: "ì‚¬ëŒê³¼ íŒŒì¼ì„ ì‡ë‹¤ - ë‚˜ë§Œì˜ í¼ìŠ¤ë„ í´ë¼ìš°ë“œ",
  manifest: "/manifest.json",
  appleWebApp: {
    capable: true,
    statusBarStyle: "black-translucent",
    title: "ì´ìŒ",
  },
  other: {
    "mobile-web-app-capable": "yes",
    "apple-mobile-web-app-capable": "yes",
    "apple-mobile-web-app-status-bar-style": "black-translucent",
  },
};

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="ko" suppressHydrationWarning>
      <head>
        <link
          rel="stylesheet"
          href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css"
        />
        <link rel="manifest" href="/manifest.json" />
        <link rel="apple-touch-icon" href="/icons/icon-192.png" />
        <meta name="theme-color" content="#7c3aed" />
        <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
      </head>
      <body suppressHydrationWarning>
        <Providers>
          {children}
          <PWAInstaller />
        </Providers>
      </body>
    </html>
  );
}
</file>

<file path="src/app/providers.tsx">
"use client";
// src/app/providers.tsx â€” ìµœì¢… í†µí•©ë³¸ (ì†Œì¼“ í¬í•¨)

import { SessionProvider } from "next-auth/react";
import { ThemeProvider } from "next-themes";
import { ToastProvider } from "@/components/Toast";
import KeyboardShortcuts from "@/components/KeyboardShortcuts";
import OnboardingTour from "@/components/OnboardingTour";
import MobileBottomNav from "@/components/MobileBottomNav";
import SystemNoticeBanner from "@/components/SystemNoticeBanner";
import UploadProgressOverlay from "@/components/UploadProgressOverlay";
import { useSocketConnection, useSocketNotifications } from "@/lib/socket-client";
import { useCallback } from "react";
import { useToast } from "@/components/Toast";
import { sound } from "@/lib/sound";

// ì†Œì¼“ ì•Œë¦¼ ë¸Œë¦¿ì§€ (ë‚´ë¶€ ì»´í¬ë„ŒíŠ¸)
function SocketBridge() {
  const connected = useSocketConnection();
  const { addToast } = useToast();

  const onNotification = useCallback((n: { type: string; message: string }) => {
    sound.notification();
    addToast("info", n.message);
  }, [addToast]);

  useSocketNotifications(onNotification);
  return null;
}

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <SessionProvider>
      <ThemeProvider attribute="class" defaultTheme="system" enableSystem>
        <ToastProvider>
          <SocketBridge />
          <SystemNoticeBanner />
          {children}
          <UploadProgressOverlay />
          <MobileBottomNav />
          <OnboardingTour />
          <KeyboardShortcuts />
        </ToastProvider>
      </ThemeProvider>
    </SessionProvider>
  );
}
</file>

<file path="package.json">
{
  "name": "personal-cloud",  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "node server.js",
    "build": "next build",
    "start": "cross-env NODE_ENV=production tsx server.js",
    "lint": "next lint",
    "db:generate": "prisma generate",
    "db:migrate": "prisma migrate dev",
    "db:push": "prisma db push",
    "db:studio": "prisma studio",
    "ai:update": "npx repomix && git add . && git commit -m \"Update code and AI context\" && git push origin master"
  },
  "dependencies": {
    "@prisma/client": "^5.22.0",
    "archiver": "^7.0.1",
    "bcryptjs": "^3.0.3",
    "date-fns": "^4.1.0",
    "firebase": "^12.9.0",
    "firebase-admin": "^13.6.1",
    "lucide-react": "^0.575.0",
    "next": "14.2.35",
    "next-auth": "^4.24.10",
    "next-themes": "^0.4.6",
    "nodemailer": "^7.0.13",
    "otpauth": "^9.5.0",
    "qrcode": "^1.5.4",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "sharp": "^0.33.5",
    "socket.io": "^4.8.3",
    "socket.io-client": "^4.8.3",
    "tsx": "^4.21.0",
    "winston": "^3.19.0",
    "winston-daily-rotate-file": "^5.0.0",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@playwright/test": "^1.58.2",
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.2",
    "@types/archiver": "^7.0.0",
    "@types/bcrypt": "^5.0.2",
    "@types/bcryptjs": "^2.4.6",
    "@types/jest": "^30.0.0",
    "@types/multer": "^1.4.12",
    "@types/node": "^20",
    "@types/nodemailer": "^7.0.9",
    "@types/qrcode": "^1.5.6",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "autoprefixer": "^10.4.20",
    "cross-env": "^10.1.0",
    "eslint": "^8",
    "eslint-config-next": "14.2.18",
    "jest": "^30.2.0",
    "jest-environment-jsdom": "^30.2.0",
    "postcss": "^8",
    "prisma": "^5.22.0",
    "tailwindcss": "^3.4.1",
    "ts-jest": "^29.4.6",
    "typescript": "^5"
  }
}
</file>

<file path="src/app/dashboard/page.tsx">
"use client";

import { useSession, signOut } from "next-auth/react";
import { useRouter, usePathname } from "next/navigation";
import { useEffect, useState, useCallback, useMemo } from "react";
import Link from "next/link";
import { Bell } from "lucide-react";
import ThemeToggle from "@/components/ThemeToggle";
import { toast } from "@/components/Toast";
import { useConfirm } from "@/components/ConfirmDialog";
import { getFileIcon, getFileColor, formatFileSize } from "@/lib/client-utils";
import FilePreviewModal from "@/components/FilePreviewModal";

// ğŸ”” ì•Œë¦¼ ë²¨ ì»´í¬ë„ŒíŠ¸ (í—¤ë”ìš©)
function NotificationBell() {
  const [unread, setUnread] = useState(0);

  useEffect(() => {
    fetch("/api/notifications?unread=true")
      .then((r) => r.json())
      .then((d) => setUnread(d.unreadCount ?? 0))
      .catch(() => {});

    // 30ì´ˆë§ˆë‹¤ í´ë§
    const timer = setInterval(() => {
      fetch("/api/notifications?unread=true")
        .then((r) => r.json())
        .then((d) => setUnread(d.unreadCount ?? 0))
        .catch(() => {});
    }, 30000);
    return () => clearInterval(timer);
  }, []);

  return (
    <Link
      href="/notifications"
      className="relative p-2 rounded-lg hover:bg-slate-100 transition-colors"
      title="ì•Œë¦¼"
    >
      <Bell size={18} className="text-slate-600" />
      {unread > 0 && (
        <span className="absolute -top-0.5 -right-0.5 min-w-[16px] h-4 px-1 bg-red-500 text-white text-[9px] font-bold rounded-full flex items-center justify-center">
          {unread > 99 ? "99+" : unread}
        </span>
      )}
    </Link>
  );
}

interface Folder {
  id: string;
  name: string;
  userId: string;
  _count: { files: number };
}

interface Tag { id: string; name: string; color: string | null; }

interface FileItem {
  id: string;
  filename: string;
  originalName: string;
  size: string;
  mimeType: string;
  thumbnailUrl: string | null;
  createdAt: string;
  folderId: string | null;
  userId: string;
  fileTags?: { tag: Tag }[];
}

interface BreadcrumbItem { id: string | null; name: string; }

export default function DashboardPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const pathname = usePathname();
  // âœ… confirm() ëŒ€ì²´
  const { confirmDialog, openConfirm } = useConfirm();

  const [currentFolderId, setCurrentFolderId] = useState<string | null>(null);
  const [folders, setFolders] = useState<Folder[]>([]);
  const [files, setFiles] = useState<FileItem[]>([]);
  const [breadcrumb, setBreadcrumb] = useState<BreadcrumbItem[]>([{ id: null, name: "í™ˆ" }]);
  const [loading, setLoading] = useState(true);
  const [searchQuery, setSearchQuery] = useState("");

  const [showFolderModal, setShowFolderModal] = useState(false);
  const [showFileDetail, setShowFileDetail] = useState(false);
  const [showShareModal, setShowShareModal] = useState(false);
  const [selectedFile, setSelectedFile] = useState<FileItem | null>(null);
  const [selectedFolder, setSelectedFolder] = useState<Folder | null>(null);
  const [shareType, setShareType] = useState<"FILE" | "FOLDER">("FILE");

  const [newFolderName, setNewFolderName] = useState("");
  const [shareEmail, setShareEmail] = useState("");
  const [sharePermission, setSharePermission] = useState<"VIEW" | "EDIT">("VIEW");
  const [newTagName, setNewTagName] = useState("");
  const [isSharing, setIsSharing] = useState(false);

  const [uploading, setUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);

  const fetchData = useCallback(async () => {
    setLoading(true);
    try {
      const folderUrl = currentFolderId ? `/api/folders?parentId=${currentFolderId}` : `/api/folders`;
      const fileUrl = currentFolderId ? `/api/files?folderId=${currentFolderId}` : `/api/files?folderId=null`;
      const [fRes, fileRes] = await Promise.all([fetch(folderUrl), fetch(fileUrl)]);
      if (fRes.ok) setFolders((await fRes.json()).folders || []);
      if (fileRes.ok) setFiles((await fileRes.json()).files || []);
    } catch (err) {
      console.error(err);
      toast.error("ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  }, [currentFolderId]);

  useEffect(() => {
    if (status === "unauthenticated") router.push("/login");
    if (session) fetchData();
  }, [status, session, fetchData, router]);

  const displayedFiles = useMemo(
    () => files.filter((f) => f.originalName.toLowerCase().includes(searchQuery.toLowerCase())),
    [files, searchQuery]
  );

  const handleFolderClick = (f: Folder) => {
    setCurrentFolderId(f.id);
    setBreadcrumb([...breadcrumb, { id: f.id, name: f.name }]);
  };

  const handleBreadcrumbClick = (idx: number) => {
    const next = breadcrumb.slice(0, idx + 1);
    setBreadcrumb(next);
    setCurrentFolderId(next[next.length - 1].id);
  };

  const handleCreateFolder = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newFolderName.trim()) return;
    const res = await fetch("/api/folders", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ name: newFolderName, parentId: currentFolderId }),
    });
    if (res.ok) {
      setNewFolderName("");
      setShowFolderModal(false);
      fetchData();
      // âœ… alert() â†’ toast
      toast.success("í´ë”ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤");
    } else {
      toast.error("í´ë” ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
    }
  };

  const handleFileUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;
    setUploading(true);
    const fd = new FormData();
    fd.append("file", file);
    if (currentFolderId) fd.append("folderId", currentFolderId);

    const xhr = new XMLHttpRequest();
    xhr.upload.onprogress = (ev) => setUploadProgress((ev.loaded / ev.total) * 100);
    xhr.onload = () => {
      fetchData();
      setUploading(false);
      setUploadProgress(0);
      if (xhr.status >= 200 && xhr.status < 300) {
        toast.success("íŒŒì¼ì´ ì—…ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤");
      } else {
        toast.error("ì—…ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
      }
    };
    xhr.onerror = () => {
      setUploading(false);
      toast.error("ì—…ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    };
    xhr.open("POST", "/api/files/upload");
    xhr.send(fd);
    // input ì´ˆê¸°í™” (ê°™ì€ íŒŒì¼ ì¬ì—…ë¡œë“œ ê°€ëŠ¥í•˜ë„ë¡)
    e.target.value = "";
  };

  const handleDeleteFolder = (id: string) => {
    // âœ… confirm() â†’ ConfirmDialog
    openConfirm({
      title: "í´ë” ì‚­ì œ",
      message: "í´ë”ë¥¼ ì‚­ì œí•˜ë©´ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
      confirmLabel: "ì‚­ì œ",
      variant: "danger",
      onConfirm: async () => {
        const res = await fetch(`/api/folders/${id}`, { method: "DELETE" });
        if (res.ok) {
          fetchData();
          toast.success("í´ë”ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤");
        } else {
          toast.error("ì‚­ì œ ê¶Œí•œì´ ì—†ê±°ë‚˜ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
        }
      },
    });
  };

  const handleDeleteFile = (id: string) => {
    // âœ… confirm() â†’ ConfirmDialog
    openConfirm({
      title: "íŒŒì¼ ì‚­ì œ",
      message: "íŒŒì¼ì„ ì‚­ì œí•˜ë©´ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
      confirmLabel: "ì‚­ì œ",
      variant: "danger",
      onConfirm: async () => {
        const res = await fetch(`/api/files/${id}`, { method: "DELETE" });
        if (res.ok) {
          setShowFileDetail(false);
          fetchData();
          toast.success("íŒŒì¼ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤");
        } else {
          toast.error("íŒŒì¼ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
        }
      },
    });
  };

  const handleAddTag = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!selectedFile || !newTagName.trim()) return;
    const res = await fetch(`/api/files/${selectedFile.id}/tags`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ tagName: newTagName }),
    });
    if (res.ok) {
      const tagData = await res.json();
      setSelectedFile({ ...selectedFile, fileTags: [...(selectedFile.fileTags || []), { tag: tagData }] });
      setNewTagName("");
      fetchData();
    } else {
      toast.error("íƒœê·¸ ì¶”ê°€ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
    }
  };

  const handleShare = async (e: React.FormEvent) => {
    e.preventDefault();
    const resourceId = shareType === "FILE" ? selectedFile?.id : selectedFolder?.id;
    if (!resourceId) return;
    setIsSharing(true);
    try {
      const res = await fetch("/api/share", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          resourceType: shareType,
          resourceId,
          sharedWithEmail: shareEmail,
          permission: sharePermission,
        }),
      });
      if (res.ok) {
        toast.success("ê³µìœ ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤");
        setShowShareModal(false);
        setShareEmail("");
      } else {
        const data = await res.json();
        toast.error(data.error || "ê³µìœ ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
      }
    } catch {
      toast.error("ê³µìœ  ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setIsSharing(false);
    }
  };

  if (status === "loading") {
    return <div className="h-screen flex items-center justify-center font-bold">ë¡œë”© ì¤‘...</div>;
  }
  if (!session) return null;

  return (
    <div className="min-h-screen bg-[#F8F9FA] dark:bg-slate-900 flex flex-col text-slate-900 dark:text-slate-100 pb-20 md:pb-0">
      {/* ConfirmDialog ë Œë”ë§ */}
      {confirmDialog}

      {/* í—¤ë” */}
      <header className="bg-white dark:bg-slate-800 border-b border-gray-200 dark:border-slate-700 dark:border-slate-700 sticky top-0 z-40 px-6 h-16 flex items-center justify-between shadow-sm">
        <div className="flex items-center gap-6">
          <h1 className="text-xl font-black text-blue-600 dark:text-blue-400">ì´ìŒ</h1>
          <nav className="flex items-center gap-4 text-xs font-bold text-slate-400 dark:text-slate-500 dark:text-slate-400 dark:text-slate-500 dark:text-slate-400">
            <Link href="/dashboard" className={pathname === "/dashboard" ? "text-blue-600" : ""}>íŒŒì¼</Link>
            <Link href="/posts" className={pathname === "/posts" ? "text-blue-600" : ""}>ê²Œì‹œíŒ</Link>
            <Link href="/chat" className={pathname === "/chat" ? "text-blue-600" : ""}>ì±„íŒ…</Link>
          </nav>
        </div>
        <div className="flex items-center gap-2">
          {/* ğŸ”” ì•Œë¦¼ ë²¨ */}
          <NotificationBell />
          <ThemeToggle />
          {/* âœ… ì´ë¦„ í´ë¦­ â†’ ë§ˆì´í˜ì´ì§€ */}
          <Link
            href="/profile"
            className="text-[12px] font-black text-slate-600 dark:text-slate-300 bg-slate-100 dark:bg-slate-700 px-3 py-1.5 rounded-full hover:bg-slate-200 dark:hover:bg-slate-600 transition"
          >
            {session.user?.name}ë‹˜
          </Link>
          <button
            onClick={() => signOut()}
            className="text-[11px] font-black bg-slate-900 dark:bg-slate-700 text-white px-3 py-2 rounded-lg hover:bg-slate-700 dark:hover:bg-slate-600 transition"
          >
            ë¡œê·¸ì•„ì›ƒ
          </button>
        </div>
      </header>

      {/* ëª¨ë°”ì¼ í•˜ë‹¨ë°” */}
      <div className="md:hidden fixed bottom-0 left-0 right-0 bg-white dark:bg-slate-800 border-t dark:border-slate-700 px-6 py-2 z-50 flex justify-around items-center shadow-lg">
        <Link href="/dashboard" className={`flex flex-col items-center gap-0.5 ${pathname === "/dashboard" ? "text-blue-600" : "text-gray-400"}`}>
          <span className="text-xl">ğŸ“</span>
          <span className="text-[9px] font-medium">íŒŒì¼</span>
        </Link>
        <Link href="/posts" className={`flex flex-col items-center gap-0.5 ${pathname === "/posts" ? "text-blue-600" : "text-gray-400"}`}>
          <span className="text-xl">ğŸ“</span>
          <span className="text-[9px] font-medium">ê²Œì‹œíŒ</span>
        </Link>
        <button
          onClick={() => setShowFolderModal(true)}
          className="w-12 h-12 bg-blue-600 text-white rounded-full flex items-center justify-center text-2xl -mt-6 border-4 border-white shadow-xl"
        >+</button>
        <Link href="/chat" className={`flex flex-col items-center gap-0.5 ${pathname === "/chat" ? "text-blue-600" : "text-gray-400"}`}>
          <span className="text-xl">ğŸ’¬</span>
          <span className="text-[9px] font-medium">ì±„íŒ…</span>
        </Link>
        <Link href="/profile" className={`flex flex-col items-center gap-0.5 ${pathname === "/profile" ? "text-blue-600" : "text-gray-400"}`}>
          <span className="text-xl">ğŸ‘¤</span>
          <span className="text-[9px] font-medium">í”„ë¡œí•„</span>
        </Link>
      </div>

      {/* ê²½ë¡œ ì•ˆë‚´ */}
      <div className="bg-white border-b py-2.5 px-6 text-[10px] font-black text-slate-300">
        {breadcrumb.map((c, i) => (
          <span key={i}>
            {i > 0 && <span className="mx-2">/</span>}
            <button
              onClick={() => handleBreadcrumbClick(i)}
              className={i === breadcrumb.length - 1 ? "text-slate-800" : "hover:text-slate-600"}
            >
              {c.name}
            </button>
          </span>
        ))}
      </div>

      <main className="max-w-7xl w-full mx-auto p-4 md:p-10 flex-1">
        {/* ê²€ìƒ‰ & ì•¡ì…˜ */}
        <div className="mb-8 flex flex-wrap gap-4">
          <input
            type="text"
            placeholder="íŒŒì¼ ê²€ìƒ‰..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="flex-1 min-w-[200px] bg-white border rounded-xl py-3 px-4 text-sm outline-none shadow-sm focus:border-blue-500"
          />
          <button
            onClick={() => setShowFolderModal(true)}
            className="bg-white border px-5 py-3 rounded-xl font-bold text-sm"
          >
            ğŸ“ ìƒˆ í´ë”
          </button>
          <label className="bg-blue-600 text-white px-5 py-3 rounded-xl font-bold text-sm cursor-pointer shadow-lg shadow-blue-500/20">
            ğŸ“¤ ì—…ë¡œë“œ
            <input type="file" onChange={handleFileUpload} className="hidden" />
          </label>
        </div>

        {/* ì—…ë¡œë“œ ì§„í–‰ë°” */}
        {uploading && (
          <div className="mb-8 p-4 bg-blue-50 rounded-xl border border-blue-100">
            <div className="flex justify-between text-[10px] font-black text-blue-600 mb-1">
              <span>íŒŒì¼ ì „ì†¡ ì¤‘...</span>
              <span>{uploadProgress.toFixed(0)}%</span>
            </div>
            <div className="w-full bg-blue-100 h-1.5 rounded-full overflow-hidden">
              <div className="bg-blue-600 h-full transition-all" style={{ width: `${uploadProgress}%` }} />
            </div>
          </div>
        )}

        {/* í´ë” ì„¹ì…˜ */}
        {!searchQuery && folders.length > 0 && (
          <div className="mb-10">
            <h2 className="text-[11px] font-black text-slate-300 uppercase mb-4 px-1">í´ë”</h2>
            <div className="grid grid-cols-1 sm:grid-cols-3 lg:grid-cols-4 gap-4">
              {folders.map((f) => (
                <div
                  key={f.id}
                  className="group bg-white border p-4 rounded-2xl flex items-center justify-between hover:border-blue-500 transition-all shadow-sm"
                >
                  <div
                    className="flex items-center gap-3 truncate cursor-pointer flex-1"
                    onClick={() => handleFolderClick(f)}
                  >
                    <span className="text-2xl">ğŸ“‚</span>
                    <div className="truncate">
                      <p className="text-sm font-bold truncate">{f.name}</p>
                      <p className="text-[10px] font-bold text-slate-400 dark:text-slate-500 dark:text-slate-400">{f._count.files} items</p>
                    </div>
                  </div>
                  <div className="flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                    <button
                      onClick={() => { setSelectedFolder(f); setShareType("FOLDER"); setShowShareModal(true); }}
                      className="p-1.5 hover:bg-slate-50 dark:bg-slate-900 rounded-lg"
                      title="ê³µìœ "
                    >ğŸ”—</button>
                    {f.userId === session.user?.id && (
                      <button
                        onClick={() => handleDeleteFolder(f.id)}
                        className="p-1.5 hover:bg-red-50 text-red-500 rounded-lg"
                        title="ì‚­ì œ"
                      >ğŸ—‘ï¸</button>
                    )}
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}

        {/* íŒŒì¼ ì„¹ì…˜ */}
        <div>
          <h2 className="text-[11px] font-black text-slate-300 uppercase mb-4 px-1">íŒŒì¼</h2>
          {loading ? (
            <div className="grid grid-cols-2 xs:grid-cols-3 md:grid-cols-5 lg:grid-cols-7 gap-6">
              {[...Array(7)].map((_, i) => (
                <div key={i} className="animate-pulse">
                  <div className="aspect-square bg-gray-200 rounded-[2rem]" />
                  <div className="h-3 bg-gray-200 rounded mt-2 mx-2" />
                </div>
              ))}
            </div>
          ) : displayedFiles.length === 0 ? (
            <div className="text-center py-16 text-slate-300">
              <p className="text-4xl mb-3">ğŸ“‚</p>
              <p className="font-bold text-sm">
                {searchQuery ? "ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤" : "íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤"}
              </p>
            </div>
          ) : (
            <div className="grid grid-cols-2 xs:grid-cols-3 md:grid-cols-5 lg:grid-cols-7 gap-6">
              {displayedFiles.map((file) => (
                <div
                  key={file.id}
                  className="group cursor-pointer"
                  onClick={() => { setSelectedFile(file); setShowFileDetail(true); }}
                >
                  <div className={`aspect-square border rounded-[2rem] flex items-center justify-center overflow-hidden group-hover:shadow-xl transition-all relative ${
                    file.thumbnailUrl ? "bg-white" : getFileColor(file.mimeType)
                  }`}>
                    {file.thumbnailUrl ? (
                      <img src={file.thumbnailUrl} className="w-full h-full object-cover" alt={file.originalName} />
                    ) : (
                      <span className="text-4xl select-none">{getFileIcon(file.mimeType)}</span>
                    )}
                    {file.userId !== session.user?.id && (
                      <span className="absolute top-2 right-2 bg-blue-600 text-white text-[8px] px-1.5 py-0.5 rounded-full">
                        ê³µìœ 
                      </span>
                    )}
                  </div>
                  <p className="mt-2 text-[10px] font-bold text-center truncate px-2">{file.originalName}</p>
                  <div className="flex flex-wrap justify-center gap-1 mt-1">
                    {file.fileTags?.map((ft) => (
                      <span key={ft.tag.id} className="text-[8px] bg-slate-100 text-slate-500 dark:text-slate-400 px-1.5 py-0.5 rounded">
                        #{ft.tag.name}
                      </span>
                    ))}
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      </main>

      {/* ëª¨ë‹¬: í´ë” ìƒì„± */}
      {showFolderModal && (
        <div className="fixed inset-0 z-[100] bg-black/50 flex items-center justify-center p-4">
          <form
            onSubmit={handleCreateFolder}
            className="bg-white p-6 rounded-[2rem] w-full max-w-xs shadow-2xl animate-in fade-in zoom-in duration-200"
          >
            <h3 className="font-black mb-4">ìƒˆ í´ë” ìƒì„±</h3>
            <input
              type="text"
              value={newFolderName}
              onChange={(e) => setNewFolderName(e.target.value)}
              autoFocus
              className="w-full border-2 rounded-xl p-3 mb-6 outline-none focus:border-blue-500 font-bold"
              placeholder="í´ë” ì´ë¦„ ì…ë ¥"
            />
            <div className="flex gap-2">
              <button
                type="button"
                onClick={() => setShowFolderModal(false)}
                className="flex-1 font-bold text-slate-400 dark:text-slate-500 dark:text-slate-400"
              >
                ì·¨ì†Œ
              </button>
              <button
                type="submit"
                className="flex-[2] py-3 bg-blue-600 text-white rounded-xl font-bold shadow-lg"
              >
                í´ë” ë§Œë“¤ê¸°
              </button>
            </div>
          </form>
        </div>
      )}

      {/* ëª¨ë‹¬: íŒŒì¼ ë¯¸ë¦¬ë³´ê¸° (FilePreviewModal ì»´í¬ë„ŒíŠ¸ ì‚¬ìš©) */}
      <FilePreviewModal
        file={showFileDetail && selectedFile ? {
          id: selectedFile.id,
          originalName: selectedFile.originalName,
          mimeType: selectedFile.mimeType,
          size: selectedFile.size,
        } : null}
        onClose={() => setShowFileDetail(false)}
      />

      {/* ëª¨ë‹¬: ê³µìœ  */}
      {showShareModal && (
        <div
          className="fixed inset-0 z-[110] bg-black/50 flex items-center justify-center p-4"
          onClick={() => setShowShareModal(false)}
        >
          <div
            className="bg-white p-8 rounded-[2.5rem] w-full max-w-sm"
            onClick={(e) => e.stopPropagation()}
          >
            <h3 className="font-black text-lg mb-6">í•­ëª© ê³µìœ </h3>
            <form onSubmit={handleShare} className="space-y-4">
              <input
                type="email"
                value={shareEmail}
                onChange={(e) => setShareEmail(e.target.value)}
                required
                className="w-full border-2 rounded-xl p-3 text-sm outline-none focus:border-blue-500"
                placeholder="ìƒëŒ€ë°© ì´ë©”ì¼"
              />
              <select
                value={sharePermission}
                onChange={(e) => setSharePermission(e.target.value as "VIEW" | "EDIT")}
                className="w-full border-2 rounded-xl p-3 text-sm font-bold"
              >
                <option value="VIEW">ì½ê¸° ê°€ëŠ¥</option>
                <option value="EDIT">í¸ì§‘ ê°€ëŠ¥</option>
              </select>
              <div className="flex gap-2 pt-2">
                <button
                  type="button"
                  onClick={() => setShowShareModal(false)}
                  className="flex-1 font-bold text-slate-400 dark:text-slate-500 dark:text-slate-400 text-sm"
                >
                  ì·¨ì†Œ
                </button>
                <button
                  type="submit"
                  disabled={isSharing}
                  className="flex-[2] py-3 bg-blue-600 text-white rounded-xl font-bold shadow-lg disabled:opacity-50"
                >
                  {isSharing ? "ê³µìœ  ì¤‘..." : "ë³´ë‚´ê¸°"}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/hooks/useSocket.ts">
import { useEffect, useState, useCallback, useRef } from "react";
import { io, Socket } from "socket.io-client";
import { toast } from "@/components/Toast";

export const useSocket = (chatRoomId?: string) => {
  const [socket, setSocket] = useState<Socket | null>(null);
  const [isConnected, setIsConnected] = useState(false); // âœ… ì¶”ê°€: ì—°ê²° ìƒíƒœ í™•ì¸ìš©
  const [socketMessages, setSocketMessages] = useState<any[]>([]);
  const [typingUsers, setTypingUsers] = useState<Set<string>>(new Set());
  
  const [callStatus, setCallStatus] = useState<"idle" | "calling" | "incoming" | "connected">("idle");
  const [incomingCall, setIncomingCall] = useState<any>(null);
  const [localStream, setLocalStream] = useState<MediaStream | null>(null);
  const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);
  
  const peerConnection = useRef<RTCPeerConnection | null>(null);

  useEffect(() => {
    const s = io(process.env.NEXT_PUBLIC_SITE_URL || "http://localhost:3000", {
      path: "/api/socket/io",
    });

    s.on("connect", () => {
      setIsConnected(true); // âœ… ì—°ê²°ë¨
      if (chatRoomId) {
        s.emit("room:join", { chatRoomId });
      }
    });

    s.on("disconnect", () => {
      setIsConnected(false); // âœ… ì—°ê²° ëŠê¹€
    });

    s.on("message:received", (msg) => {
      setSocketMessages((prev) => [...prev, msg]);
    });

    s.on("call:incoming", (data) => {
      setIncomingCall(data);
      setCallStatus("incoming");
    });

    s.on("call:accepted", async ({ answer }) => {
      if (peerConnection.current) {
        await peerConnection.current.setRemoteDescription(new RTCSessionDescription(answer));
        setCallStatus("connected");
      }
    });

    s.on("call:ice-candidate", async ({ candidate }) => {
      if (peerConnection.current) {
        await peerConnection.current.addIceCandidate(new RTCIceCandidate(candidate));
      }
    });

    s.on("call:rejected", () => {
      toast.error("í†µí™”ê°€ ê±°ì ˆë˜ì—ˆìŠµë‹ˆë‹¤.");
      resetCallState();
    });

    s.on("call:ended", () => {
      toast.info("í†µí™”ê°€ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.");
      resetCallState();
    });

    setSocket(s);
    return () => { s.disconnect(); };
  }, [chatRoomId]);

  const resetCallState = useCallback(() => {
    if (localStream) localStream.getTracks().forEach(t => t.stop());
    setLocalStream(null);
    setRemoteStream(null);
    setCallStatus("idle");
    setIncomingCall(null);
    if (peerConnection.current) {
      peerConnection.current.close();
      peerConnection.current = null;
    }
  }, [localStream]);

  const initiateCall = useCallback(async (type: "VOICE" | "VIDEO", otherUserId: string) => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: type === "VIDEO" });
      setLocalStream(stream);
      setCallStatus("calling");

      const pc = new RTCPeerConnection({ iceServers: [{ urls: "stun:stun.l.google.com:19302" }] });
      stream.getTracks().forEach(track => pc.addTrack(track, stream));

      pc.onicecandidate = (e) => {
        if (e.candidate) socket?.emit("call:ice-candidate", { otherUserId, candidate: e.candidate });
      };
      pc.ontrack = (e) => setRemoteStream(e.streams[0]);

      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      peerConnection.current = pc;

      socket?.emit("call:initiate", { chatRoomId, receiverId: otherUserId, callType: type, offer });
    } catch (err) {
      toast.error("ë¯¸ë””ì–´ ì¥ì¹˜ ì ‘ê·¼ ì‹¤íŒ¨");
    }
  }, [socket, chatRoomId]);

  const acceptCall = useCallback(async () => {
    if (!incomingCall || !socket) return;
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: incomingCall.callType === "VIDEO" });
      setLocalStream(stream);
      const pc = new RTCPeerConnection({ iceServers: [{ urls: "stun:stun.l.google.com:19302" }] });
      stream.getTracks().forEach(track => pc.addTrack(track, stream));

      pc.onicecandidate = (e) => {
        if (e.candidate) socket.emit("call:ice-candidate", { otherUserId: incomingCall.from, candidate: e.candidate });
      };
      pc.ontrack = (e) => setRemoteStream(e.streams[0]);

      await pc.setRemoteDescription(new RTCSessionDescription(incomingCall.offer));
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      peerConnection.current = pc;

      socket.emit("call:accept", { callerId: incomingCall.from, answer });
      setCallStatus("connected");
    } catch (err) {
      toast.error("í†µí™” ì—°ê²° ì‹¤íŒ¨");
    }
  }, [incomingCall, socket]);

  const rejectCall = useCallback(() => {
    if (incomingCall && socket) {
      socket.emit("call:reject", { callerId: incomingCall.from });
      resetCallState();
    }
  }, [incomingCall, socket, resetCallState]);

  const endCall = useCallback((otherUserId?: string) => {
    if (socket && otherUserId) socket.emit("call:end", { otherUserId });
    resetCallState();
  }, [socket, resetCallState]);

  const toggleMute = () => {
    if (localStream) {
      const track = localStream.getAudioTracks()[0];
      track.enabled = !track.enabled;
      return !track.enabled; 
    }
    return false;
  };

  return { 
    socketMessages, 
    typingUsers, 
    socket, 
    isConnected, // âœ… ì¶”ê°€: ì´ì œ page.tsxì—ì„œ ì´ ê°’ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    incomingCall, 
    localStream, 
    remoteStream, 
    callStatus, 
    initiateCall, 
    acceptCall, 
    rejectCall, 
    endCall, 
    toggleMute 
  };
};
</file>

<file path="prisma/schema.prisma">
// prisma/schema.prisma
// ì „ì²´ ì™„ì„±ë³¸ â€” ê¸°ì¡´ íŒŒì¼ì„ ì´ê²ƒìœ¼ë¡œ êµì²´í•˜ì„¸ìš”

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// â”€â”€ Enums â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

enum Role {
  USER
  ADMIN
}

enum ResourceType {
  FILE
  FOLDER
  POST
  CHATROOM   // ê¸°ì¡´ ë°ì´í„° ë³´ì¡´
}

enum Permission {
  VIEW
  EDIT
  ADMIN      // ê¸°ì¡´ ë°ì´í„° ë³´ì¡´
}

enum Visibility {
  PUBLIC
  PRIVATE
  SHARED
}

enum ChatRoomType {
  DIRECT
  GROUP
}

enum MessageType {
  TEXT
  FILE
  SYSTEM
  CALL
  CALL_LOG   // ê¸°ì¡´ ë°ì´í„° ë³´ì¡´
}

enum CallStatus {
  PENDING
  ACTIVE
  ENDED
  MISSED
  ACCEPTED   // ê¸°ì¡´ ë°ì´í„° ë³´ì¡´
  REJECTED   // ê¸°ì¡´ ë°ì´í„° ë³´ì¡´
}

enum CallType {
  VOICE
  VIDEO
}

enum NetworkType {
  OFFLINE
  WIFI
  CELLULAR
}

enum NotificationType {
  COMMENT
  SHARE
  CHAT
  SYSTEM
  FILE_UPLOAD
  CALL
}

enum ActivityAction {
  FILE_UPLOAD
  FILE_DELETE
  FILE_DOWNLOAD
  FILE_SHARE
  FOLDER_CREATE
  FOLDER_DELETE
  POST_CREATE
  POST_DELETE
  COMMENT_CREATE
  COMMENT_DELETE
  PROFILE_UPDATE
  PASSWORD_CHANGE
  LOGIN
  LOGOUT
  CHAT_MESSAGE
  CALL_START
  CALL_END
}

// â”€â”€ Models â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  passwordHash  String    @map("password_hash")
  name          String
  role          Role      @default(USER)
  emailVerified Boolean   @default(false) @map("email_verified")
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  isOnline      Boolean     @default(false) @map("is_online")
  lastSeenAt    DateTime?   @map("last_seen_at")
  fcmToken      String?     @map("fcm_token")
  notificationPrefs Json?   @map("notification_prefs")
  twoFactorEnabled  Boolean @default(false) @map("two_factor_enabled")
  twoFactorSecret   String? @map("two_factor_secret")
  twoFactorBackups  String[] @map("two_factor_backups")
  networkType   NetworkType @default(OFFLINE) @map("network_type")

  // ìŠ¤í† ë¦¬ì§€
  storageUsed   BigInt  @default(0)          @map("storage_used")
  storageLimit  BigInt  @default(5368709120) @map("storage_limit")

  // ê³„ì • ìƒíƒœ
  isBanned      Boolean   @default(false) @map("is_banned")
  banReason     String?   @map("ban_reason")
  bannedAt      DateTime? @map("banned_at")

  // ì˜¨ë³´ë”©
  onboardingDone Boolean @default(false) @map("onboarding_done")

  // í”„ë¡œí•„ ì´ë¯¸ì§€
  avatarUrl     String? @map("avatar_url")
  coverUrl      String? @map("cover_url")

  // ê´€ê³„
  files                File[]
  folders              Folder[]
  posts                Post[]
  comments             Comment[]
  sharedResources      SharedResource[] @relation("SharedWith")
  ownedSharedResources SharedResource[] @relation("Owner")
  savedSearches        SavedSearch[]
  chatRoomMembers      ChatRoomMember[]
  sentMessages         ChatMessage[]
  callsInitiated       Call[] @relation("CallInitiator")
  callsReceived        Call[] @relation("CallReceiver")
  passwordResetTokens  PasswordResetToken[]
  notifications        Notification[]
  emailVerificationTokens EmailVerificationToken[]
  activityLogs         ActivityLog[]
  following            Follow[] @relation("Follower")
  followers            Follow[] @relation("Following")
  postLikes            PostLike[]
  postBookmarks        PostBookmark[]
  sessions             UserSession[]
  apiKeys              ApiKey[]
  fileVersions         FileVersion[]

  @@map("users")
}

model ChatRoom {
  id        String       @id @default(cuid())
  name      String?
  type      ChatRoomType @default(DIRECT)
  createdAt DateTime     @default(now()) @map("created_at")
  updatedAt DateTime     @updatedAt @map("updated_at")

  members  ChatRoomMember[]
  messages ChatMessage[]
  calls    Call[]

  @@map("chat_rooms")
}

model ChatRoomMember {
  id         String    @id @default(cuid())
  chatRoomId String    @map("chat_room_id")
  userId     String    @map("user_id")
  joinedAt   DateTime  @default(now()) @map("joined_at")
  lastReadAt DateTime? @map("last_read_at")

  chatRoom ChatRoom @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([chatRoomId, userId])
  @@index([chatRoomId])
  @@index([userId])
  @@map("chat_room_members")
}

model ChatMessage {
  id         String      @id @default(cuid())
  chatRoomId String      @map("chat_room_id")
  senderId   String      @map("sender_id")
  type       MessageType @default(TEXT)
  content    String?
  fileId     String?     @map("file_id")
  callId     String?     @map("call_id")
  createdAt  DateTime    @default(now()) @map("created_at")

  chatRoom ChatRoom @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)
  sender   User     @relation(fields: [senderId], references: [id], onDelete: Cascade)
  file     File?    @relation(fields: [fileId], references: [id], onDelete: SetNull)

  @@index([chatRoomId])
  @@index([senderId])
  @@index([createdAt])
  @@index([chatRoomId, createdAt(sort: Desc)])
  @@map("chat_messages")
}

model Call {
  id          String     @id @default(cuid())
  chatRoomId  String     @map("chat_room_id")
  initiatorId String     @map("initiator_id")
  receiverId  String     @map("receiver_id")
  type        CallType   @default(VOICE)
  status      CallStatus @default(PENDING)
  startedAt   DateTime?  @map("started_at")
  endedAt     DateTime?  @map("ended_at")
  duration    Int?
  createdAt   DateTime   @default(now()) @map("created_at")

  chatRoom  ChatRoom @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)
  initiator User     @relation("CallInitiator", fields: [initiatorId], references: [id], onDelete: Cascade)
  receiver  User     @relation("CallReceiver",  fields: [receiverId],  references: [id], onDelete: Cascade)

  @@index([chatRoomId])
  @@index([initiatorId])
  @@index([receiverId])
  @@index([status])
  @@map("calls")
}

model Folder {
  id        String   @id @default(cuid())
  name      String
  parentId  String?  @map("parent_id")
  userId    String   @map("user_id")
  color     String?
  icon      String?
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  parent   Folder?  @relation("FolderHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children Folder[] @relation("FolderHierarchy")
  files    File[]

  @@index([userId])
  @@index([parentId])
  @@map("folders")
}

model File {
  id              String    @id @default(cuid())
  filename        String
  originalName    String    @map("original_name")
  filepath        String
  size            BigInt
  mimeType        String    @map("mime_type")
  hash            String?   @unique
  thumbnailUrl    String?   @map("thumbnail_url")
  transcodeStatus String?   @default("PENDING") @map("transcode_status")
  transcodeJobId  String?   @map("transcode_job_id")
  transcodedPaths Json?     @map("transcoded_paths")
  userId          String    @map("user_id")
  folderId        String?   @map("folder_id")
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  // ê³µê°œ ê³µìœ 
  publicToken   String?  @unique @map("public_token")

  // íœ´ì§€í†µ
  deletedAt     DateTime? @map("deleted_at")

  // ì•”í˜¸í™”
  encryptedKey  String?  @map("encrypted_key")
  isEncrypted   Boolean  @default(false) @map("is_encrypted")

  // ì¦ê²¨ì°¾ê¸° / í•€
  isStarred     Boolean  @default(false) @map("is_starred")
  isPinned      Boolean  @default(false) @map("is_pinned")

  // ê´€ê³„
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  folder       Folder?      @relation(fields: [folderId], references: [id], onDelete: SetNull)
  fileTags     FileTag[]
  chatMessages ChatMessage[]
  fileVersions FileVersion[]

  @@index([userId])
  @@index([folderId])
  @@index([userId, deletedAt])
  @@index([userId, createdAt(sort: Desc)])
  @@index([userId, isStarred])
  @@index([userId, isPinned])
  @@index([publicToken])
  @@index([hash])
  @@map("files")
}

model Tag {
  id        String   @id @default(cuid())
  name      String   @unique
  color     String?
  createdAt DateTime @default(now()) @map("created_at")

  fileTags FileTag[]
  postTags PostTag[]

  @@map("tags")
}

model FileTag {
  id        String   @id @default(cuid())
  fileId    String   @map("file_id")
  tagId     String   @map("tag_id")
  createdAt DateTime @default(now()) @map("created_at")

  file File @relation(fields: [fileId], references: [id], onDelete: Cascade)
  tag  Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([fileId, tagId])
  @@index([fileId])
  @@index([tagId])
  @@map("file_tags")
}

model PostTag {
  id        String   @id @default(cuid())
  postId    String   @map("post_id")
  tagId     String   @map("tag_id")
  createdAt DateTime @default(now()) @map("created_at")

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  tag  Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([postId, tagId])
  @@index([postId])
  @@index([tagId])
  @@map("post_tags")
}

model SavedSearch {
  id        String   @id @default(cuid())
  name      String
  query     Json
  userId    String   @map("user_id")
  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("saved_searches")
}

model Post {
  id         String     @id @default(cuid())
  title      String
  content    String
  visibility Visibility @default(PRIVATE)
  userId     String     @map("user_id")
  createdAt  DateTime   @default(now()) @map("created_at")
  updatedAt  DateTime   @updatedAt @map("updated_at")

  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  comments  Comment[]
  postTags  PostTag[]
  likes     PostLike[]
  bookmarks PostBookmark[]

  @@index([userId])
  @@index([userId, createdAt(sort: Desc)])
  @@index([visibility, createdAt(sort: Desc)])
  @@map("posts")
}

model Comment {
  id        String   @id @default(cuid())
  content   String
  postId    String   @map("post_id")
  userId    String   @map("user_id")
  createdAt DateTime @default(now()) @map("created_at")

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([postId])
  @@index([userId])
  @@map("comments")
}

model SharedResource {
  id           String       @id @default(cuid())
  resourceType ResourceType
  resourceId   String       @map("resource_id")
  ownerId      String       @map("owner_id")
  sharedWithId String       @map("shared_with_id")
  permission   Permission   @default(VIEW)
  createdAt    DateTime     @default(now()) @map("created_at")

  owner      User @relation("Owner",      fields: [ownerId],      references: [id], onDelete: Cascade)
  sharedWith User @relation("SharedWith", fields: [sharedWithId], references: [id], onDelete: Cascade)

  @@unique([resourceType, resourceId, sharedWithId])
  @@index([ownerId])
  @@index([sharedWithId])
  @@index([resourceType, resourceId])
  @@map("shared_resources")
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  userId    String   @unique
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("password_reset_tokens")
}

model Notification {
  id        String           @id @default(cuid())
  userId    String           @map("user_id")
  type      NotificationType @default(SYSTEM)
  title     String
  body      String?
  link      String?
  isRead    Boolean          @default(false) @map("is_read")
  createdAt DateTime         @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([isRead])
  @@index([createdAt])
  @@index([userId, isRead])
  @@index([userId, createdAt(sort: Desc)])
  @@map("notifications")
}

model EmailVerificationToken {
  id        String   @id @default(cuid())
  userId    String   @map("user_id")
  token     String   @unique
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@map("email_verification_tokens")
}

model ActivityLog {
  id        String         @id @default(cuid())
  userId    String         @map("user_id")
  action    ActivityAction
  target    String?
  targetId  String?        @map("target_id")
  meta      Json?
  createdAt DateTime       @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt(sort: Desc)])
  @@index([action])
  @@map("activity_logs")
}

model Follow {
  id          String   @id @default(cuid())
  followerId  String   @map("follower_id")
  followingId String   @map("following_id")
  createdAt   DateTime @default(now()) @map("created_at")

  follower  User @relation("Follower",  fields: [followerId],  references: [id], onDelete: Cascade)
  following User @relation("Following", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@map("follows")
}

model PostLike {
  id        String   @id @default(cuid())
  postId    String   @map("post_id")
  userId    String   @map("user_id")
  createdAt DateTime @default(now()) @map("created_at")

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId])
  @@index([postId])
  @@index([userId])
  @@map("post_likes")
}

model PostBookmark {
  id        String   @id @default(cuid())
  postId    String   @map("post_id")
  userId    String   @map("user_id")
  createdAt DateTime @default(now()) @map("created_at")

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId])
  @@index([postId])
  @@index([userId])
  @@map("post_bookmarks")
}

model UserSession {
  id         String   @id @default(cuid())
  userId     String   @map("user_id")
  token      String   @unique
  userAgent  String?  @map("user_agent")
  ip         String?
  lastActive DateTime @default(now()) @map("last_active")
  createdAt  DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@map("user_sessions")
}

model FileVersion {
  id         String   @id @default(cuid())
  fileId     String   @map("file_id")
  versionNum Int      @map("version_num")
  filepath   String
  size       BigInt
  createdBy  String   @map("created_by")
  comment    String?
  createdAt  DateTime @default(now()) @map("created_at")

  file File @relation(fields: [fileId], references: [id], onDelete: Cascade)
  user User @relation(fields: [createdBy], references: [id], onDelete: Cascade)

  @@index([fileId])
  @@index([fileId, versionNum(sort: Desc)])
  @@map("file_versions")
}

model ApiKey {
  id         String    @id @default(cuid())
  userId     String    @map("user_id")
  name       String
  keyHash    String    @unique @map("key_hash")
  keyPrefix  String    @map("key_prefix")
  scopes     String[]
  lastUsedAt DateTime? @map("last_used_at")
  expiresAt  DateTime? @map("expires_at")
  createdAt  DateTime  @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("api_keys")
}

model SystemNotice {
  id        String    @id @default(cuid())
  title     String
  content   String
  type      String    @default("INFO")
  isActive  Boolean   @default(true) @map("is_active")
  startsAt  DateTime? @map("starts_at")
  endsAt    DateTime? @map("ends_at")
  createdBy String    @map("created_by")
  createdAt DateTime  @default(now()) @map("created_at")

  @@index([isActive])
  @@map("system_notices")
}
</file>

<file path="src/app/profile/page.tsx">
"use client";
export const dynamic = 'force-dynamic';
// src/app/profile/page.tsx
// âœ… ìˆ˜ì •: useSearchParams ì œê±°(ë¯¸ì‚¬ìš©), Suspense ë¶ˆí•„ìš”í•˜ê²Œ ë¨

import { useSession, signOut } from "next-auth/react";
import { useRouter } from "next/navigation";
import { useEffect, useState } from "react";
import Link from "next/link";
import ThemeToggle from "@/components/ThemeToggle";
import { toast } from "@/components/Toast";
import { useConfirm } from "@/components/ConfirmDialog";
import { formatFileSize, storagePercent } from "@/lib/client-utils";

interface UserStats {
  totalFiles: number;
  totalPosts: number;
  totalComments: number;
  storageUsedBytes: number;
  storageUsedMB: string;
}

interface UserInfo {
  id: string;
  name: string;
  email: string;
  role: string;
  emailVerified: boolean;
  createdAt: string;
  isOnline: boolean;
}

export default function ProfilePage() {
  const { data: session, status, update: updateSession } = useSession();
  const router = useRouter();
  const { confirmDialog, openConfirm } = useConfirm();

  const [user, setUser] = useState<UserInfo | null>(null);
  const [stats, setStats] = useState<UserStats | null>(null);
  const [loading, setLoading] = useState(true);
  const [deleteConfirmText, setDeleteConfirmText] = useState("");
  const [sendingVerification, setSendingVerification] = useState(false);
  const [verificationSent, setVerificationSent] = useState(false);
  const [showDeleteSection, setShowDeleteSection] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);

  // ì´ë¦„ ë³€ê²½ í¼
  const [nameEdit, setNameEdit] = useState(false);
  const [newName, setNewName] = useState("");
  const [nameLoading, setNameLoading] = useState(false);

  // ë¹„ë°€ë²ˆí˜¸ ë³€ê²½ í¼
  const [pwEdit, setPwEdit] = useState(false);
  const [currentPw, setCurrentPw] = useState("");
  const [newPw, setNewPw] = useState("");
  const [confirmPw, setConfirmPw] = useState("");
  const [pwLoading, setPwLoading] = useState(false);

  useEffect(() => {
    if (status === "unauthenticated") router.push("/login");
  }, [status, router]);

  useEffect(() => {
    if (session) fetchProfile();
  }, [session]);

  const fetchProfile = async () => {
    try {
      const res = await fetch("/api/users/me");
      if (res.ok) {
        const data = await res.json();
        setUser(data.user);
        setStats(data.stats);
        setNewName(data.user.name);
      }
    } catch {
      toast.error("í”„ë¡œí•„ ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
    } finally {
      setLoading(false);
    }
  };

  const handleNameSave = async () => {
    if (!newName.trim() || newName.trim() === user?.name) {
      setNameEdit(false);
      return;
    }
    setNameLoading(true);
    try {
      const res = await fetch("/api/users/me", {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name: newName.trim() }),
      });
      const data = await res.json();
      if (res.ok) {
        setUser((prev) => prev ? { ...prev, name: data.user.name } : prev);
        await updateSession({ name: data.user.name });
        toast.success("ì´ë¦„ì´ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤");
        setNameEdit(false);
      } else {
        toast.error(data.error || "ì´ë¦„ ë³€ê²½ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
      }
    } catch {
      toast.error("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setNameLoading(false);
    }
  };

  const handlePasswordSave = async () => {
    if (!currentPw || !newPw || !confirmPw) {
      toast.warning("ëª¨ë“  í•„ë“œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”");
      return;
    }
    if (newPw !== confirmPw) {
      toast.warning("ìƒˆ ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤");
      return;
    }
    if (newPw.length < 8) {
      toast.warning("ìƒˆ ë¹„ë°€ë²ˆí˜¸ëŠ” 8ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤");
      return;
    }
    setPwLoading(true);
    try {
      const res = await fetch("/api/users/me", {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ currentPassword: currentPw, newPassword: newPw }),
      });
      const data = await res.json();
      if (res.ok) {
        toast.success("ë¹„ë°€ë²ˆí˜¸ê°€ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤");
        setPwEdit(false);
        setCurrentPw(""); setNewPw(""); setConfirmPw("");
      } else {
        toast.error(data.error || "ë¹„ë°€ë²ˆí˜¸ ë³€ê²½ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
      }
    } catch {
      toast.error("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤");
    } finally {
      setPwLoading(false);
    }
  };

  const sendVerificationEmail = async () => {
    setSendingVerification(true);
    try {
      const res = await fetch("/api/auth/verify-email", { method: "POST" });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error);
      setVerificationSent(true);
      toast.success("ì¸ì¦ ì´ë©”ì¼ì„ ë°œì†¡í–ˆìŠµë‹ˆë‹¤. ë°›ì€í¸ì§€í•¨ì„ í™•ì¸í•´ì£¼ì„¸ìš”.");
    } catch (e: any) {
      toast.error(e.message || "ì´ë©”ì¼ ë°œì†¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤");
    } finally {
      setSendingVerification(false);
    }
  };

  const handleDeleteAccount = async () => {
    if (deleteConfirmText !== "ê³„ì •ì‚­ì œ") return;
    setIsDeleting(true);
    try {
      const res = await fetch("/api/users/me", { method: "DELETE" });
      if (!res.ok) throw new Error();
      await signOut({ callbackUrl: "/" });
    } catch {
      toast.error("ê³„ì • ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.");
      setIsDeleting(false);
    }
  };

  const handleLogout = () => {
    openConfirm({
      title: "ë¡œê·¸ì•„ì›ƒ",
      message: "ë¡œê·¸ì•„ì›ƒ í•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
      confirmLabel: "ë¡œê·¸ì•„ì›ƒ",
      onConfirm: () => signOut({ callbackUrl: "/login" }),
    });
  };

  if (status === "loading" || loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50 dark:bg-slate-900">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600" />
      </div>
    );
  }

  if (!session || !user) return null;

  const usagePercent = stats ? storagePercent(stats.storageUsedBytes) : 0;
  const storageColor =
    usagePercent > 90 ? "bg-red-500" : usagePercent > 70 ? "bg-yellow-500" : "bg-blue-500";

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-slate-900">
      {confirmDialog}

      {/* í—¤ë” */}
      <header className="bg-white dark:bg-slate-800 shadow dark:shadow-slate-700/30 sticky top-0 z-10 border-b border-gray-100 dark:border-slate-700">
        <div className="max-w-3xl mx-auto px-4 py-4 flex items-center justify-between">
          <Link href="/dashboard" className="text-gray-500 dark:text-slate-400 hover:text-gray-900 dark:hover:text-slate-100 flex items-center gap-2 text-sm">
            â† ëŒ€ì‹œë³´ë“œ
          </Link>
          <h1 className="text-lg font-bold text-gray-900 dark:text-slate-100">ë§ˆì´í˜ì´ì§€</h1>
          <div className="flex items-center gap-2">
            <ThemeToggle />
            <button
              onClick={handleLogout}
              className="text-sm text-red-500 hover:text-red-700 font-medium"
            >
              ë¡œê·¸ì•„ì›ƒ
            </button>
          </div>
        </div>
      </header>

      <main className="max-w-3xl mx-auto px-4 py-6 space-y-4">

        {/* í”„ë¡œí•„ ì¹´ë“œ */}
        <div className="bg-white dark:bg-slate-800 rounded-xl shadow p-6">
          <div className="flex items-center gap-4 mb-6">
            <div className="w-16 h-16 rounded-full bg-gradient-to-br from-blue-500 to-purple-600 flex items-center justify-center text-white text-2xl font-bold flex-shrink-0">
              {user.name.charAt(0).toUpperCase()}
            </div>
            <div>
              <h2 className="text-xl font-bold text-gray-900 dark:text-slate-100">{user.name}</h2>
              <p className="text-gray-500 dark:text-slate-400 text-sm">{user.email}</p>
              <span className={`inline-block mt-1 px-2 py-0.5 text-xs rounded-full font-medium ${
                user.role === "ADMIN"
                  ? "bg-purple-100 text-purple-700"
                  : "bg-gray-100 dark:bg-slate-700 text-gray-600 dark:text-slate-400"
              }`}>
                {user.role === "ADMIN" ? "ê´€ë¦¬ì" : "ì¼ë°˜ ì‚¬ìš©ì"}
              </span>
            </div>
          </div>

          {stats && (
            <div className="grid grid-cols-3 gap-4 pt-4 border-t">
              {[
                { label: "íŒŒì¼", value: stats.totalFiles.toLocaleString() },
                { label: "ê²Œì‹œê¸€", value: stats.totalPosts.toLocaleString() },
                { label: "ëŒ“ê¸€", value: stats.totalComments.toLocaleString() },
              ].map(({ label, value }) => (
                <div key={label} className="text-center">
                  <p className="text-xl font-bold text-gray-900 dark:text-slate-100">{value}</p>
                  <p className="text-xs text-gray-500 dark:text-slate-400">{label}</p>
                </div>
              ))}
            </div>
          )}
        </div>

        {/* ìŠ¤í† ë¦¬ì§€ */}
        {stats && (
          <div className="bg-white dark:bg-slate-800 rounded-xl shadow p-6">
            <h3 className="text-sm font-semibold text-gray-700 dark:text-slate-300 mb-3">â˜ï¸ ìŠ¤í† ë¦¬ì§€ ì‚¬ìš©ëŸ‰</h3>
            <div className="flex justify-between text-sm text-gray-600 dark:text-slate-400 mb-2">
              <span>{formatFileSize(stats.storageUsedBytes)} ì‚¬ìš© ì¤‘</span>
              <span className="text-gray-400 dark:text-slate-500">/ 5 GB</span>
            </div>
            <div className="w-full bg-gray-100 dark:bg-slate-700 rounded-full h-2.5">
              <div
                className={`h-2.5 rounded-full transition-all ${storageColor}`}
                style={{ width: `${usagePercent}%` }}
              />
            </div>
            <p className="text-xs text-gray-400 dark:text-slate-500 mt-1.5">{usagePercent.toFixed(1)}% ì‚¬ìš©</p>
          </div>
        )}

        {/* ì´ë¦„ ë³€ê²½ */}
        <div className="bg-white dark:bg-slate-800 rounded-xl shadow p-6">
          <div className="flex items-center justify-between mb-4">
            <h3 className="text-sm font-semibold text-gray-700 dark:text-slate-300">âœï¸ ì´ë¦„ ë³€ê²½</h3>
            {!nameEdit && (
              <button
                onClick={() => { setNameEdit(true); setNewName(user.name); }}
                className="text-xs text-blue-600 hover:text-blue-800 font-medium"
              >
                ë³€ê²½
              </button>
            )}
          </div>
          {nameEdit ? (
            <div className="space-y-3">
              <input
                type="text"
                value={newName}
                onChange={(e) => setNewName(e.target.value)}
                maxLength={20}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-900 dark:text-slate-100 text-sm"
                placeholder="ìƒˆ ì´ë¦„ ì…ë ¥"
                autoFocus
                onKeyDown={(e) => e.key === "Enter" && handleNameSave()}
              />
              <div className="flex justify-end gap-2">
                <button
                  onClick={() => { setNameEdit(false); setNewName(user.name); }}
                  className="px-4 py-1.5 text-sm text-gray-600 dark:text-slate-400 hover:bg-gray-100 dark:hover:bg-slate-700 rounded-lg"
                >ì·¨ì†Œ</button>
                <button
                  onClick={handleNameSave}
                  disabled={nameLoading || !newName.trim()}
                  className="px-4 py-1.5 text-sm bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50"
                >
                  {nameLoading ? "ì €ì¥ ì¤‘..." : "ì €ì¥"}
                </button>
              </div>
            </div>
          ) : (
            <p className="text-gray-900 dark:text-slate-100 font-medium">{user.name}</p>
          )}
        </div>

        {/* ë¹„ë°€ë²ˆí˜¸ ë³€ê²½ */}
        <div className="bg-white dark:bg-slate-800 rounded-xl shadow p-6">
          <div className="flex items-center justify-between mb-4">
            <h3 className="text-sm font-semibold text-gray-700 dark:text-slate-300">ğŸ”’ ë¹„ë°€ë²ˆí˜¸ ë³€ê²½</h3>
            {!pwEdit && (
              <button onClick={() => setPwEdit(true)} className="text-xs text-blue-600 hover:text-blue-800 font-medium">
                ë³€ê²½
              </button>
            )}
          </div>
          {pwEdit ? (
            <div className="space-y-3">
              <div>
                <label className="text-xs text-gray-500 dark:text-slate-400 mb-1 block">í˜„ì¬ ë¹„ë°€ë²ˆí˜¸</label>
                <input type="password" value={currentPw} onChange={(e) => setCurrentPw(e.target.value)}
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-900 dark:text-slate-100 text-sm"
                  placeholder="í˜„ì¬ ë¹„ë°€ë²ˆí˜¸" autoFocus />
              </div>
              <div>
                <label className="text-xs text-gray-500 dark:text-slate-400 mb-1 block">ìƒˆ ë¹„ë°€ë²ˆí˜¸</label>
                <input type="password" value={newPw} onChange={(e) => setNewPw(e.target.value)}
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-900 dark:text-slate-100 text-sm"
                  placeholder="ìƒˆ ë¹„ë°€ë²ˆí˜¸ (ìµœì†Œ 8ì)" />
              </div>
              <div>
                <label className="text-xs text-gray-500 dark:text-slate-400 mb-1 block">ìƒˆ ë¹„ë°€ë²ˆí˜¸ í™•ì¸</label>
                <input type="password" value={confirmPw} onChange={(e) => setConfirmPw(e.target.value)}
                  className={`w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-900 dark:text-slate-100 text-sm ${
                    confirmPw && newPw !== confirmPw ? "border-red-400" : "border-gray-300"
                  }`}
                  placeholder="ìƒˆ ë¹„ë°€ë²ˆí˜¸ ì¬ì…ë ¥" />
                {confirmPw && newPw !== confirmPw && (
                  <p className="text-xs text-red-500 mt-1">ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤</p>
                )}
              </div>
              <div className="flex justify-end gap-2">
                <button
                  onClick={() => { setPwEdit(false); setCurrentPw(""); setNewPw(""); setConfirmPw(""); }}
                  className="px-4 py-1.5 text-sm text-gray-600 dark:text-slate-400 hover:bg-gray-100 dark:hover:bg-slate-700 rounded-lg"
                >ì·¨ì†Œ</button>
                <button onClick={handlePasswordSave} disabled={pwLoading}
                  className="px-4 py-1.5 text-sm bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50">
                  {pwLoading ? "ë³€ê²½ ì¤‘..." : "ë³€ê²½í•˜ê¸°"}
                </button>
              </div>
            </div>
          ) : (
            <p className="text-gray-400 dark:text-slate-500 text-sm">â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢</p>
          )}
        </div>

        {/* ê³„ì • ì •ë³´ */}
        <div className="bg-white dark:bg-slate-800 rounded-xl shadow p-6">
          <h3 className="text-sm font-semibold text-gray-700 dark:text-slate-300 mb-4">ğŸ“‹ ê³„ì • ì •ë³´</h3>
          <dl className="space-y-3 text-sm">
            <div className="flex justify-between">
              <dt className="text-gray-500 dark:text-slate-400">ì´ë©”ì¼</dt>
              <dd className="font-medium text-gray-900 dark:text-slate-100">{user.email}</dd>
            </div>
            <div className="flex flex-col gap-1">
              <div className="flex justify-between">
                <dt className="text-gray-500 dark:text-slate-400">ì´ë©”ì¼ ì¸ì¦</dt>
                <dd className="font-medium text-gray-900 dark:text-slate-100">
                  {user.emailVerified ? "âœ… ì¸ì¦ ì™„ë£Œ" : "âš ï¸ ë¯¸ì¸ì¦"}
                </dd>
              </div>
              {!user.emailVerified && (
                <button
                  onClick={sendVerificationEmail}
                  disabled={sendingVerification || verificationSent}
                  className="text-xs text-blue-600 dark:text-blue-400 hover:underline disabled:opacity-50 text-right"
                >
                  {verificationSent ? "ë°œì†¡ë¨ âœ“" : sendingVerification ? "ë°œì†¡ ì¤‘..." : "ì¸ì¦ ì´ë©”ì¼ ì¬ë°œì†¡"}
                </button>
              )}
            </div>
            <div className="flex justify-between">
              <dt className="text-gray-500 dark:text-slate-400">ê°€ì…ì¼</dt>
              <dd className="font-medium text-gray-900 dark:text-slate-100">
                {new Date(user.createdAt).toLocaleDateString("ko-KR", { year: "numeric", month: "long", day: "numeric" })}
              </dd>
            </div>
          </dl>
        </div>

        {/* ë°”ë¡œê°€ê¸° */}
        <div className="bg-white dark:bg-slate-800 rounded-xl shadow p-6">
          <h3 className="text-sm font-semibold text-gray-700 dark:text-slate-300 mb-3">ğŸ”— ë°”ë¡œê°€ê¸°</h3>
          <div className="grid grid-cols-2 gap-2">
            {[
              { href: "/dashboard", label: "ğŸ“ íŒŒì¼ ê´€ë¦¬", color: "bg-blue-50 text-blue-700 hover:bg-blue-100" },
              { href: "/posts", label: "ğŸ“ ê²Œì‹œê¸€", color: "bg-green-50 text-green-700 hover:bg-green-100" },
              { href: "/chat", label: "ğŸ’¬ ì±„íŒ…", color: "bg-purple-50 text-purple-700 hover:bg-purple-100" },
              { href: "/search", label: "ğŸ” ê²€ìƒ‰", color: "bg-orange-50 text-orange-700 hover:bg-orange-100" },
              { href: "/notifications", label: "ğŸ”” ì•Œë¦¼", color: "bg-gray-50 dark:bg-slate-700 text-gray-700 dark:text-slate-300 hover:bg-gray-100" },
              { href: "/settings/sessions", label: "ğŸ’» ë¡œê·¸ì¸ ê¸°ê¸°", color: "bg-gray-50 dark:bg-slate-700 text-gray-700 dark:text-slate-300 hover:bg-gray-100" },
              { href: "/trash", label: "ğŸ—‘ï¸ íœ´ì§€í†µ", color: "bg-gray-50 dark:bg-slate-700 text-gray-700 dark:text-slate-300 hover:bg-gray-100" },
              { href: "/users/search", label: "ğŸ‘¥ ì‚¬ìš©ì ê²€ìƒ‰", color: "bg-gray-50 dark:bg-slate-700 text-gray-700 dark:text-slate-300 hover:bg-gray-100" },
              { href: "/settings/2fa", label: "ğŸ” 2ë‹¨ê³„ ì¸ì¦", color: "bg-gray-50 dark:bg-slate-700 text-gray-700 dark:text-slate-300 hover:bg-gray-100" },
              ...(user.role === "ADMIN"
                ? [{ href: "/admin", label: "ğŸ›¡ï¸ ê´€ë¦¬ì", color: "bg-red-50 text-red-700 hover:bg-red-100" }]
                : []),
            ].map(({ href, label, color }) => (
              <Link key={href} href={href}
                className={`flex items-center justify-center py-3 px-4 rounded-lg text-sm font-medium transition ${color}`}>
                {label}
              </Link>
            ))}
          </div>
        </div>

        {/* ë°ì´í„° ë‚´ë³´ë‚´ê¸° */}
        <div className="bg-white dark:bg-slate-800 rounded-xl border border-gray-100 dark:border-slate-700 p-5">
          <h3 className="text-sm font-semibold text-gray-700 dark:text-slate-300 mb-3">ğŸ“¦ ë‚´ ë°ì´í„°</h3>
          <p className="text-xs text-gray-500 dark:text-slate-400 mb-3">
            íŒŒì¼ ëª©ë¡, ê²Œì‹œê¸€, ëŒ“ê¸€, í™œë™ ë‚´ì—­ ë“± ë‚´ ëª¨ë“  ë°ì´í„°ë¥¼ JSON íŒŒì¼ë¡œ ë‚´ë ¤ë°›ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
          </p>
          <a href="/api/users/me/export" download
            className="flex items-center justify-center gap-2 w-full py-2.5 text-sm font-medium text-blue-700 dark:text-blue-400 bg-blue-50 dark:bg-blue-900/20 hover:bg-blue-100 dark:hover:bg-blue-900/30 rounded-xl border border-blue-200 dark:border-blue-800 transition">
            â¬‡ï¸ ë°ì´í„° ë‚´ë³´ë‚´ê¸° (JSON)
          </a>
        </div>

        {/* ë¡œê·¸ì•„ì›ƒ */}
        <div>
          <button onClick={handleLogout}
            className="w-full py-3 text-sm font-medium text-red-600 bg-red-50 dark:bg-red-900/20 hover:bg-red-100 dark:hover:bg-red-900/30 rounded-xl border border-red-200 dark:border-red-800 transition">
            ë¡œê·¸ì•„ì›ƒ
          </button>
        </div>

        {/* ê³„ì • ì‚­ì œ */}
        <div className="pb-8">
          <button
            onClick={() => setShowDeleteSection(!showDeleteSection)}
            className="w-full py-2 text-xs text-gray-400 dark:text-slate-500 hover:text-red-500 dark:hover:text-red-400 transition">
            {showDeleteSection ? "â–² ì ‘ê¸°" : "ê³„ì • ì‚­ì œ..."}
          </button>
          {showDeleteSection && (
            <div className="mt-3 p-4 rounded-xl border border-red-200 dark:border-red-800 bg-red-50 dark:bg-red-900/10 space-y-3">
              <p className="text-sm font-semibold text-red-700 dark:text-red-400">âš ï¸ ê³„ì • ì˜êµ¬ ì‚­ì œ</p>
              <p className="text-xs text-red-600 dark:text-red-400">
                ê³„ì •ì„ ì‚­ì œí•˜ë©´ ëª¨ë“  íŒŒì¼, ê²Œì‹œê¸€, ëŒ“ê¸€, ì±„íŒ… ë‚´ì—­ì´ <strong>ì˜êµ¬ì ìœ¼ë¡œ ì‚­ì œ</strong>ë˜ë©° ë³µêµ¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
              </p>
              <p className="text-xs text-gray-600 dark:text-slate-400">
                í™•ì¸ì„ ìœ„í•´ ì•„ë˜ì— <strong className="text-red-600">&quot;ê³„ì •ì‚­ì œ&quot;</strong> ë¥¼ ì…ë ¥í•˜ì„¸ìš”.
              </p>
              <input
                type="text"
                value={deleteConfirmText}
                onChange={(e) => setDeleteConfirmText(e.target.value)}
                placeholder="ê³„ì •ì‚­ì œ"
                className="w-full border border-red-300 dark:border-red-700 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-red-400 bg-white dark:bg-slate-800 dark:text-slate-100"
              />
              <button
                onClick={handleDeleteAccount}
                disabled={deleteConfirmText !== "ê³„ì •ì‚­ì œ" || isDeleting}
                className="w-full py-2.5 text-sm font-bold text-white bg-red-500 hover:bg-red-600 disabled:bg-gray-300 dark:disabled:bg-slate-600 disabled:cursor-not-allowed rounded-lg transition">
                {isDeleting ? "ì‚­ì œ ì¤‘..." : "ê³„ì • ì˜êµ¬ ì‚­ì œ"}
              </button>
            </div>
          )}
        </div>
      </main>
    </div>
  );
}
</file>

<file path="src/app/chat/[id]/page.tsx">
"use client";

import { useSession } from "next-auth/react";
import { useParams, useRouter } from "next/navigation";
import { useEffect, useState, useRef, useCallback } from "react";
import { useSocket } from "@/hooks/useSocket"; // useChatRoom -> useSocketìœ¼ë¡œ ë³µêµ¬
import { useInfiniteScroll } from "@/hooks/useInfiniteScroll";
import { toast } from "@/components/Toast";

const MESSAGE_LIMIT = 30;

export default function ChatRoomPage() {
  const { data: session } = useSession();
  const params = useParams();
  const router = useRouter();
  const chatRoomId = params.id as string;

  const [allMessages, setAllMessages] = useState<any[]>([]);
  const [input, setInput] = useState("");
  const [isSending, setIsSending] = useState(false);
  const [chatRoom, setChatRoom] = useState<any>(null);
  const [audioMuted, setAudioMuted] = useState(false);

  const [hasMore, setHasMore] = useState(true);
  const [isLoadingMore, setIsLoadingMore] = useState(false);
  const [isInitialLoading, setIsInitialLoading] = useState(true);
  const oldestMessageDateRef = useRef<string | null>(null);

  const scrollContainerRef = useRef<HTMLDivElement>(null);
  const bottomRef = useRef<HTMLDivElement>(null);
  const shouldScrollToBottomRef = useRef(true);

  const localVideoRef = useRef<HTMLVideoElement>(null);
  const remoteVideoRef = useRef<HTMLVideoElement>(null);

  // useSocket ì‚¬ìš©
  const {
    socketMessages,
    socket,
    incomingCall,
    localStream,
    remoteStream,
    callStatus,
    initiateCall,
    acceptCall,
    rejectCall,
    endCall,
    toggleMute,
  } = useSocket(chatRoomId);

  useEffect(() => {
    if (!chatRoomId) return;
    Promise.all([
      fetch(`/api/chat/rooms/${chatRoomId}/messages?limit=${MESSAGE_LIMIT}`),
      fetch(`/api/chat/rooms/${chatRoomId}`),
    ]).then(async ([msgRes, roomRes]) => {
      if (msgRes.ok) {
        const data = await msgRes.json();
        const messages = data.messages || [];
        setAllMessages(messages);
        if (messages.length > 0) oldestMessageDateRef.current = messages[0].createdAt;
        setHasMore(messages.length === MESSAGE_LIMIT);
      }
      if (roomRes.ok) {
        const data = await roomRes.json();
        setChatRoom(data.chatRoom);
      }
    }).finally(() => setIsInitialLoading(false));
  }, [chatRoomId]);

  const fetchMoreMessages = useCallback(async () => {
    if (!oldestMessageDateRef.current || isLoadingMore) return;
    setIsLoadingMore(true);
    const container = scrollContainerRef.current;
    const prevScrollHeight = container?.scrollHeight || 0;
    try {
      const res = await fetch(`/api/chat/rooms/${chatRoomId}/messages?limit=${MESSAGE_LIMIT}&before=${encodeURIComponent(oldestMessageDateRef.current)}`);
      if (res.ok) {
        const data = await res.json();
        const older = data.messages || [];
        if (older.length === 0) { setHasMore(false); return; }
        setAllMessages((prev) => [...older, ...prev]);
        setHasMore(older.length === MESSAGE_LIMIT);
        oldestMessageDateRef.current = older[0].createdAt;
        requestAnimationFrame(() => { if (container) container.scrollTop = container.scrollHeight - prevScrollHeight; });
      }
    } finally { setIsLoadingMore(false); }
  }, [chatRoomId, isLoadingMore]);

  const { setSentinel: topObserverRef } = useInfiniteScroll({
    fetcher: async (page) => {
      if (page > 1) await fetchMoreMessages();
      return { items: [], hasMore };
    },
    deps: [chatRoomId],
  });

  useEffect(() => {
    if (socketMessages.length === 0) return;
    const newMsg = socketMessages[socketMessages.length - 1];
    setAllMessages((prev) => prev.some((m) => m.id === newMsg.id) ? prev : [...prev, newMsg]);
    shouldScrollToBottomRef.current = true;
  }, [socketMessages]);

  useEffect(() => {
    if (shouldScrollToBottomRef.current) {
      bottomRef.current?.scrollIntoView({ behavior: "smooth" });
      shouldScrollToBottomRef.current = false;
    }
  }, [allMessages]);

  useEffect(() => {
    if (localStream && localVideoRef.current) localVideoRef.current.srcObject = localStream;
  }, [localStream]);

  useEffect(() => {
    if (remoteStream && remoteVideoRef.current) {
      remoteVideoRef.current.srcObject = remoteStream;
      remoteVideoRef.current.play().catch(console.warn);
    }
  }, [remoteStream]);

  const onSend = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!input.trim() || isSending) return;
    const content = input;
    setInput("");
    setIsSending(true);
    try {
      const res = await fetch(`/api/chat/rooms/${chatRoomId}/messages`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ type: "TEXT", content }),
      });
      const result = await res.json();
      if (result.data) {
        setAllMessages((prev) => [...prev, result.data]);
        socket?.emit("message:send", { chatRoomId, ...result.data });
      }
    } finally { setIsSending(false); }
  };

  const getOtherMember = () => chatRoom?.members?.find((m: any) => m.user.id !== session?.user?.id);

  const callStatusLabel: Record<string, string> = {
    calling: "ì—°ê²° ì¤‘...",
    incoming: "í†µí™” ìˆ˜ì‹  ì¤‘",
    connected: "í†µí™” ì¤‘",
  };

  return (
    <div className="flex flex-col h-screen bg-[#F8F9FA] text-black overflow-hidden">
      <div className="p-4 border-b flex justify-between items-center bg-white sticky top-0 z-20 shadow-sm">
        <div className="flex items-center gap-3">
          <button onClick={() => router.back()} className="p-1 rounded-full hover:bg-gray-100">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="m15 18-6-6 6-6"/></svg>
          </button>
          <div>
            <p className="font-bold">{getOtherMember()?.user?.name || "ëŒ€í™”ë°©"}</p>
            {callStatus !== "idle" && <p className="text-xs text-green-500 animate-pulse">{callStatusLabel[callStatus]}</p>}
          </div>
        </div>
        {callStatus === "idle" && (
          <div className="flex gap-2">
            <button onClick={() => initiateCall("VOICE", getOtherMember()?.user.id)} className="w-10 h-10 rounded-full bg-green-500 flex items-center justify-center text-white">ğŸ“</button>
            <button onClick={() => initiateCall("VIDEO", getOtherMember()?.user.id)} className="w-10 h-10 rounded-full bg-blue-500 flex items-center justify-center text-white">ğŸ“¹</button>
          </div>
        )}
      </div>

      <div ref={scrollContainerRef} className="flex-1 overflow-y-auto px-4 py-2 pb-28">
        <div ref={topObserverRef} className="h-1" />
        <div className="space-y-4 mt-2">
          {allMessages.map((msg, idx) => {
            const isMe = msg.senderId === session?.user?.id;
            return (
              <div key={idx} className={`flex ${isMe ? "justify-end" : "justify-start"}`}>
                <div className={`p-3 px-4 rounded-2xl max-w-[70%] text-sm shadow-sm ${isMe ? "bg-blue-600 text-white rounded-tr-none" : "bg-white border text-black rounded-tl-none"}`}>
                  <p className="whitespace-pre-wrap">{msg.content}</p>
                </div>
              </div>
            );
          })}
        </div>
        <div ref={bottomRef} />
      </div>

      <div className="fixed bottom-0 left-0 right-0 p-3 bg-white border-t z-30">
        <form onSubmit={onSend} className="flex items-center gap-2 max-w-2xl mx-auto">
          <input value={input} onChange={(e) => setInput(e.target.value)} className="flex-1 border rounded-full px-5 py-3 bg-gray-100 outline-none focus:bg-white" placeholder="ë©”ì‹œì§€ ì…ë ¥..." />
          <button type="submit" disabled={!input.trim() || isSending} className="bg-blue-600 text-white w-12 h-12 flex items-center justify-center rounded-full shadow-lg disabled:bg-gray-300">
             <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><path d="m22 2-7 20-4-9-9-4Z"/><path d="M22 2 11 13"/></svg>
          </button>
        </form>
      </div>

      {callStatus !== "idle" && (
        <div className="fixed inset-0 z-[100] bg-black/95 flex flex-col items-center justify-center p-6 backdrop-blur-md text-white">
          <div className="text-center mb-8">
            <h2 className="text-2xl font-bold">{getOtherMember()?.user?.name}</h2>
            <p className="text-white/50">{callStatusLabel[callStatus]}</p>
          </div>
          {callStatus === "connected" && (
            <div className="relative w-full max-w-sm aspect-[3/4] bg-gray-900 rounded-[2rem] overflow-hidden mb-8 border border-white/10">
              <video ref={remoteVideoRef} autoPlay playsInline className="w-full h-full object-cover" />
              <div className="absolute top-4 right-4 w-24 aspect-[3/4] bg-black rounded-xl overflow-hidden border-2 border-white/20">
                <video ref={localVideoRef} autoPlay playsInline muted className="w-full h-full object-cover" />
              </div>
            </div>
          )}
          <div className="flex gap-6 items-center">
            {callStatus === "incoming" ? (
              <>
                <button onClick={rejectCall} className="w-16 h-16 bg-red-500 rounded-full text-2xl">âœ•</button>
                <button onClick={acceptCall} className="w-16 h-16 bg-green-500 rounded-full text-2xl">âœ“</button>
              </>
            ) : (
              <>
                <button onClick={() => setAudioMuted(toggleMute())} className={`w-14 h-14 rounded-full flex items-center justify-center ${audioMuted ? "bg-red-500" : "bg-white/20"}`}>
                  {audioMuted ? "ğŸ”‡" : "ğŸ¤"}
                </button>
                <button onClick={() => endCall(getOtherMember()?.user.id)} className="w-20 h-20 bg-red-500 rounded-full flex items-center justify-center rotate-[135deg]">
                  ğŸ“
                </button>
              </>
            )}
          </div>
        </div>
      )}
    </div>
  );
}
</file>

</files>
